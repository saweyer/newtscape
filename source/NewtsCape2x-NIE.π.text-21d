// Text of project NewtsCape2x-NIE.¹ written on 8/31/00 at 1:15 PM// Beginning of text file Language DataSetLocalizationFrame({ // use with LocObj(defaultStr, 'symbol)/*insert your translation in front of the English version,then include a , comma after your string, and // to keep English (for documentation)if you don't want to translate everything at first that's ok;just do the important ones (and those that you understand what they are) now;and over time you could make corrections/additions;skip old commands (preceded with // e.g., "Open Personal Media".To include special (non-ascii) characters, best if you can embed unicode character sequences with \u at beginning and end, e.g.,  saveHTMLNotes:  "HTML\u3092\uNotes\u30784FDD5B58\u", //"Save HTML to Notes",(each char is a 4-digit sequence)you may be able to include literal codes, but if so,only after testing to make sure they map correctly(and sent as .sit or .zip to avoid email gateway problems)user interface commands are grouped approximately by menu and view(though some may appear in more than one place).  I've left in some // commentsto indicate where commands can be found, or where else they're used.You'll probably want to go thru the English version of Newt's Cape andsee where things are to understand context (and possibly look at the documentationsuch as exists, e.g., in userintf.htm, for more description of function.In some cases (see *** items), you should try to keep length of stringsapproximately the same as the English version so that labels fit inside buttonsor in front of input fields, for example.You could abbreviate a string, or if some are a little longer andsome are a little shorter, I may be able to adjust a few sizes.so that I make you famous, please give me a web address thatI can include so that others can look at your work/products.*//*English: {// File menufileLabel:				"File",				//***openLocationItem:		"Open Location",openNotesItem:			"Open Notes",openInboxItem:			"Open Inbox",openPaperbackItem:		"Open Paperback",paperbackItem:			"Paperback",WabumiUniItem:			"WabumiUni",openWabumiUniItem:		"Open WabumiUni",//openPersonalMediaItem:"Open Personal Media",//personalMediaItem:	"Personal Media",//workspacesItem:		"Workspaces",//docsItem:				"Docs",//storesItem:			"Stores",openNewtWorksItem:		"Open NewtWorks",newtworksItem:			"NewtWorks",openHTMLCacheItem:		"Open HTML Cache",openImageCacheItem:		"Open Image Cache",OpenNetHopperCacheItem:	"Open NetHopper Cache",openDesktopItem:		"Open Desktop",serial9600:				"Serial(9600)",serial57600:			"Serial(57600)",chooseMsg:				"Choose",connectToMsg:			"connect to",ADSPlabel:				"ADSP",				// AppleTalk ***ADSPslabel:				"ADSPs",			//***closeDesktopItem:		"Close Desktop",//openDemoURLsItem:		"Open Demo URLs",savePackageItem:		"Save as Package",	// also i, overview:ProcesssaveHTMLNotes:			"Save HTML to Notes",saveImageNotes:			"Save Image to Notes",saveHTMLNewtworksItem:	"Save HTML to NewtWorks",saveImageNewtworksItem:	"Save Image to NewtWorks",saveBookNewtworksItem:	"Save Book to NewtWorks",//saveTextDesktopItem:	"Save as Text to Desktop",removeCurrentBookItem:	"Remove Current Book",removeFromCacheItem:	"Remove from Cache",resetHTTPlabel:			"Reset HTTP",		// also in Other Options// View menuviewLabel:				"View",			//***currentBookItem:		"Current Book",closeOverViewItem:		"Close Overview",reloadItem:				"Reload",loadWithImagesItem:		"Load with Images",//allImagesItem:		"All Images",loadLinksItem:			"Load Links",loadFramesItem:			"Load Frames",documentSourceItem:		"Document Source",//overviewsHTMLlabel:				"HTML",			// *** (also in i:General)imagesLabel:			"Images",		// *** (also in i:General)//HTMLCacheLabel:		"HTML Cache",//ImageCacheLabel:		"Image Cache",linksItem:				"Links",framesItem:				"Frames",allLabel:				"All",			//***loadItem:				"Load",openItem:				"Open",			// also in NotesprocessItem:			"Process",		// also About,idisplayURLitem:			"Display URL",	// also HREF popupsaveOutlineItem:		"Save as Outline",addBookmarkItem:		"Add Bookmark",	// also Bookmarks, HREF popuplockItem:				"Lock",unlockItem:				"Unlock",deleteItem:				"Delete",bookmarkLabelL:			"bookmark",bookmarksLabelL:		"bookmarks",	// same as bookmarksLabel but lowercaseitemItem:				"item",			// also i:General cachesitemsItem:				"items",// SchedulescheduleLabel:			"Schedule",		//***CancelSchedLabel:		"Cancel Schedule",startDateLabel:			"Start Date",	// ***autoLinkLabel:			"AutoLink",		// ***frequencyLabel:			"Frequency",	//***immedItem:				"immediately",onceItem:				"once",hourlyItem:				"hourly",twiceDailyItem:			"twice daily",dailyItem:				"daily",daily5Item:				"daily (except weekend)",weeklyItem:				"weekly",monthlyItem:			"monthly",// Go menugoLabel:				"Go",			// ***backItem:				"Back",forwardItem:			"Forward",clearHistoryItem:		"Clear History", // (book menu)homeItem:				"Home",		// i.e., startup URLnewerHTMLitem:			"Newer HTML Cache Item",newerImageItem:			"Newer Image Cache Item",setHTMLitem:			"Set HTML Cache Item",setImageItem:			"Set Image Cache Item",// Bookmarks menubookmarksLabel:			"Bookmarks",	// ***openBookmarksItem:		"Browse/Schedule",removeBookmarkItem:		"Remove Bookmark",newtscapeBookmarkItem:	"Newt's Cape Example Page",//removeAllItem:		"Remove All",// info buttonaboutItem: 				"About",helpItem:				"Help",prefsItem:				"Prefs",registerItem:			"Register",	// open Register application// about box/textintroductionText:		"Introduction",aboutCreate:			"CreateNewton books with text, graphics, tables andforms from HTML",	//***rightsReserved:			"All Rights Reserved Worldwide",moreInfo:				"For More Information",webInfo:				"web info",thanksRegister:			"Thanks for registering",//bookLabel:			"Book",//optionsLabel:			"Options",generalItem:			"General",appearanceItem:			"Appearance",encodingItem:			"Encoding",//(Process)displayItemItem:		"Display Item",displayPageItem:		"Display Page",displayPage1Item:		"Display Page1",displayAllItem:			"Display All",cacheOnlyItem:			"Cache Only",	// also HREF popupsaveNewtworksItem:		"Save to NewtWorks",//i:GeneralnoCacheItem:			"no cache",maxLabel:				"Max.",			// after 10 items -- MaximumtrustCacheItem:			"trust cache?",storeItem:				"Store",ignoreExpirationItem: 	"Ignore Expiration",emptyQuitItem:			"empty upon quit?",showItemOverview:		"show items in overviews",autoloadFramesItem:		"autoload Frames?",	// HTMLmergeFramesItem:		"merge Frame source?",	// HTMLremoveItem:				"remove?",		// <!-- HTML comments-->includeDesktopItem:		"desktop?",			// HTMLfixISOItem:				"Fix ISO Chars?",	// HTML//openURLitem:			"open URL immediately?",defaultItem:			"default",			// Store (also Schedule:NIE setup)autoLoadItem:			"autoLoad?",		// imagesfirstOneItem:			"first 1",			// Images autoload #rawImageItem:			"original (unconverted)?", // imagesanimatedItem:			"animated?",		// imagesscaleImage:				"scale to fit?",	// images//"Scale bitmaps to fit?"	// 1.xresolutionLabel:		"Res.",				// resolution ***bwItem:					"b&w(threshold)",gray4Item:				"4-gray",gray16Item:				"16-gray",unfiledBkMenuItem:		"Unfiled bookmarks in menu",cookiesLabel:			"Cookies",		//***skipItem:				"Skip",askItem:				"Ask",keepItem:				"Keep",			//*** also AuthenticateNSlabel:				"NewtonScript",compileItem:			"Compile",noneItem:				"none",			// also Schedule:Frequency, Authenticate:HostsdocDoneLabel:			"Doc Done",		//*** soundspageSizeLabel:			"Page Size",	//***phelpItem:				"help",portraitItem:			"portrait",landscapeItem:			"landscape",fullitem:				"full",pkgLabel:				"Pkg",			// package ***standaloneLabel:		"Standalone book pkg?",		// ***compressedItem:			"Compressed",autoHideLabel:			"Auto hide?",//inetSetupLabel:		"Inet Setup",		NIEsetupLabel:			"NIE Setup",		//*** also ScheduleIPaidLabel:				"I Paid?",			//***//AuthenticatehostsItem:				"Hosts",	//***hostLabel:				"Host",		//***tempItem:				"Temp.", 	// temporary (only for session) vs. "Keep"proxyLabel:				"Proxy",nameLabel:				"Name",		//***passwordLabel:			"Password",	//***authenticateLabel:		"Authenticate",	// *** also SchedulerequireUserMsg:			"requires user authentication",unauthErr:				"Unauthorized; request requires user authentication",//i:General:Other OptionsotherOptionsLabel: 		"Other Options",	// ***startupURLItem:			"Startup URL",proxyURLitem:			"Proxy URL",proxyHostItem:			"Proxy Host",		// 1.xproxyOnlyItem: 			"Proxy Only",proxyExItem:			"Proxy Exceptions",findTitleItem:			"Find.Title",findURLitem:			"Find.URL",findMethodItem:			"Find.Method",findDataItem:			"Find.Data",findCheckItem:			"Find:CheckData",UserAgentItem:			"Agent Prefix",AgentSizeItem:			"Agent Size&Res.",acceptItem:				"Accept",acceptLangItem:			"Accept Language",helpISBNitem:			"Help ISBN",autoLoginItem:			"Auto Login",dontShowNCItem: 		"Don't Show Newt's Cape",dontCloseBookItem:		"Don't Close Book",ignoreMETArefresh:		"Ignore META Refresh",ignoreTablesItem:		"Ignore Tables",includeFramesItem:		"Include Frames",tagFrameItem:			"map FRAME to tag",ignoreFontFaceItem:		"Ignore FONT FACE",missingImgItem:			"IMG: no ALT",displayUnkTagItem:		"Display unknown <tags>",NCmenuItem:				"Newt's Cape button",//bkoverItem:			"Bookmarks in overview only",overfloatItem:			"Overview not floating",changeKbdItem:			"Change keyboard keys",nwSummaryItem:			"NewtWorks HTML via Summary",mailtoBodyItem:			"mailto: body",autoLinkExcItem:		"AutoLink Exceptions",bookWidthItem:			"Book Page Width",bookHeightItem:			"Book Page Height",bookBaseItem:			"Book BASE",bookISBNitem:			"Book ISBN",booksTitleItem:			"Book ShortTitle",bookTitleItem:			"Book Title",bookContentsTitle:		"Contents",//PrefSetsmainPrefSetLabel:		"Main PrefSet",prefSetItem:			"PrefSet",renameItem:				"Rename",duplicateItem:			"Duplicate",resetAllitem:			"Reset All",// i:AppearancetagLabel:				"Tag",			// ***missingErr:				"missing",		// missing Hx tagdefaultsLabel:			"Defaults",		// ***indentsLabel:			"Indents",		// ***aboveLabel:				"Above",		// ***leftLabel:				"Left",			// ***belowLabel:				"Below",		// ***splitLabel:				"Split",		// ***alignLabel:				"Align",		// ***rightItem:				"Right",centerItem:				"Center",justifyItem:			"Justify",fontLabel:				"Font",			// ***familyLabel:			"Family",		// ***sizeLabel:				"Size",			// ***faceLabel:				"Face",			// ***plainItem:				"Plain",boldItem:				"Bold",italicItem:				"Italic",boldItalicItem:			"BoldItalic",underlineItem:			"Underline",sampleLabel:			"Sample",		// ***// Directory menu (if applicable)//directoryLabel:		"Directory",// status fields/msgs//urlLabel:				"URL",//titleLabel:			"Title",//isbnLabel:			"ISBN",//shortTitleLabel:		"Short Title",linesLabel:				"Lines",itemsLabel:				"Items",pagesLabel:				"Pages",// HREF popuploadImageItem:			"Load Image",// Notes menugetURLItem:				"getURL",findItem:				"Find",// keyboard (labels) [holding down cmd-]//"General"//quitItem:				"Quit",stopLabel:				"Stop",//"Hide/Show"//"History"//saveLabel:			"Save",// FORM button defaultssubmitLabel:			"Submit",resetLabel:				"Reset",// parsing status, general errorsnoHeapStoreErr:			"out of heap/store?",errorOccurred:			"An error occured in",errorLabel:				"Error",parsingMsg:				"Parsing",lengthMsg:				"Length",untitledLabel:			"Untitled",compileErr:				"compile err",evalErr:				"eval err",unknownTagErr:			"UNKNOWN TAG",noNameErr:				"no NAME",missingNameValErr:		"missing NAME or VALUE",screenSmallErr:			"Screen smaller than",unknownValErr:			"unknown val",notFormErr:				"not inside FORM",processErr:				"process",nameValErr:				"name or val err",notArrayOddErr:			"not an array (or odd length)",okMsg:					"OK",// graphicsImageConvertErr:		"Image conversion err?",notGIFerr:				"not a real GIF",graphicHeading:			"non-text object",noBinaryLenErr:			"no binary len?", // no binary length// packagesnotPkgErr:				"not a package",installPackage:			"Do you want to install package?",replacePackage:			"Replace existing package?",installingPackage:		"Installing Package",installErr:				"Installation Failed",noPackageErr:			"no package",//prefSetsnameExistsErr:			"name already exists",nameEmptyErr:			"name empty",// comm (http/serial) status messages and errors.  FSM abort, wait, etc.?openingLinkMsg:			"Opening link",lookupHostMsg:			"Looking up host",cancelOpenMsg:			"Cancelling Open Link Request",instantiatingMsg:		"Instantiating",instantiateErr:			"Instantiate Err",IPaddressMsg:			"IP Address",bindPortMsg:			"Binding to port",connectingPortMsg:		"Connecting to port",connectingMsg:			"connecting",connectedMsg:			"connected",connectErr:				"Connect Err",disconnectingPortMsg:	"Disconnecting port",disconnectingMsg:		"disconnecting",unbindingMsg:			"UnBinding",disposingMsg:			"Disposing",closingLinkMsg:			"Closing link",sendingHTTPMsg:			"HTTP Command",binaryLabel:			"Binary",textLabel:				"Text",waitMsg:				"Please wait",terminalMsg:			"HTTP FSM is executing toward terminal state",goAwayLabel:			"Go Away",redirectionMsg:			"redirection",badRequestErr:			"Bad request",forbiddenErr:			"Forbidden for unspecified reason",notFoundErr:			"Not found",internalErr:			"Internal server",notImplementedErr:		"Not implemented",badGatewayErr:			"Bad gateway; invalid response from gateway or upstream server",noServiceErr:			"Service temporarily unavailable",addCookiesMsg:			"Add Cookies?",yesLabel:				"Yes",noLabel:				"No",inboxItem:				"Inbox",		// destination for packageinboxErr:				"Inbox Error",clientErr:				"client",serverErr:				"server",unknownHelperErr:		"unknown helper for",noHelperErr:			"no helper for",notHTMLimageErr:		"cache: not HTML or Image?",helperItem:			"Helpers",		// View:Helpers -> list helper AppsoldVersionLabel:	"old version",	// in Install package dialognewVersionLabel:	"new version",createdLabel:		"created", 	// ...followed by date},*/// -----Japanese: { // Shinobu Yamada <yamada@shinobu.com>// File menufileLabel:				"File",	//***openLocationItem:		"Location\u3092958B304F\u",		//"Open Location",openNotesItem:			"Notes\u3092958B304F\u",		//"Open Notes",openInboxItem:			"\u53D74FE17BB13092958B304F\u",	//"Open Inbox",openPaperbackItem:		"Paperback\u3092958B304F\u",	//"Open Paperback",openWabumiUniItem:		"WabumiUni\u3092958B304F\u",	//"Open WabumiUni",openNewtWorksItem:		"NewtWorks\u3092958B304F\u",	//"Open NewtWorks",openHTMLCacheItem:		"\u30AD30E330C330B730E53092958B304F\u",	//"Open HTML Cache",openImageCacheItem:		"\u753B50CF752830AD30E330C330B730E53092958B304F\u",	//"Open Image Cache",OpenNetHopperCacheItem:	"Open NetHopper Cache",openDesktopItem:		"PC\u306863A57D9A\u",			//"Open Desktop",serial9600:				"\u30B730EA30A230EB\u(9600)",	//"Serial(9600)",serial57600:			"\u30B730EA30A230EB\u(57600)",	//"Serial(57600)",chooseMsg:				"\u9078629E\u",					//"Choose",connectToMsg:			"\u63A57D9A5148\u",				//"connect to",ADSPlabel:				"ADSP",				// AppleTalk ***ADSPslabel:				"ADSPs",			//***closeDesktopItem:		"PC\u3068306E63A57D9A30925207308B\u",		//"Close Desktop",savePackageItem:		"\u30D130C330B130FC30B83068305730664FDD5B58\u",	//"Save as Package",	// also i, overview:ProcesssaveHTMLNotes:			"HTML\u3092\uNotes\u30784FDD5B58\u",		//"Save HTML to Notes",saveImageNotes:			"\u753B50CF3092\uNotes\u30784FDD5B58\u",	//"Save Image to Notes",saveHTMLNewtworksItem:	"HTML\u3092\uNewtWorks\u30784FDD5B58\u",	//"Save HTML to NewtWorks"saveImageNewtworksItem:	"\u753B50CF3092\uNewtWorks\u30784FDD5B58\u",//"Save Image to NewtWorks",saveBookNewtworksItem:	"Book NewtWorks\u30784FDD5B58\u",			//"Save Book to NewtWorks",removeCurrentBookItem:	"\u4F5C696D4E2D306E\uBook\u3092524A9664\u",	//"Remove Current Book",removeFromCacheItem:	"\u30AD30E330C330B730E5304B3089524A9664\u",	//"Remove from Cache",resetHTTPlabel:			"\u6A196E968A2D5B9A\u",						//"Reset HTTP",		// also in Other Options// View menuviewLabel:				"View",			//***currentBookItem:		"\u4F5C696D4E2D306E\uBook",			//"Current Book",closeOverViewItem:		"\u76EE6B21309295893058308B\u",		//"Close Overview",reloadItem:				"\u518D8AAD307F8FBC307F\u",			//"Reload",loadWithImagesItem:		"\u753B50CF306E8AAD307F8FBC307F\u",	//"Load with Images",loadLinksItem:			"\u30EA30F330AF3092958B304F\u",		//"Load Links",loadFramesItem:			"\u30D530EC30FC30E03092958B304F\u",	//"Load Frames",documentSourceItem:		"\u65877AE0306E30BD30FC30B9\u",		//"Document Source",//overviewsHTMLlabel:				"HTML",			// *** (also in i:General)imagesLabel:			"\u753B50CF\u",			// "Images",		// *** (also in i:General)linksItem:				"\u30EA30F330AF\u",		//"Links",framesItem:				"\u30D530EC30FC30E0\u",		//"Frames",allLabel:				"\u51683066\u",			//"All",			//***loadItem:				"\u30ED30FC30C9\u",		//"Load",openItem:				"\u8D7752D5\u",			//"Open",			// also in NotesprocessItem:			"\u51E67406306E8A2D5B9A\u",	//"Process",		// also About,idisplayURLitem:			"URL\u30928868793A\u",	//"Display URL",	// also HREF popupsaveOutlineItem:		"\u30A230A630C830E930A430F33068305730664FDD5B58\u",	//"Save as Outline",addBookmarkItem:		"\u30D630C330AF30DE30FC30AF30928FFD52A0\u",	//"Add Bookmark",	// also Bookmarks, HREF popuplockItem:				"\u524A96644FDD8B77\u",	//"Lock",unlockItem:				"\u4FDD8B7789E39664\u",	//"Unlock",deleteItem:				"\u524A9664\u",			//"Delete",bookmarkLabelL:			"bookmark",bookmarksLabelL:		"bookmarks",	// same as bookmarksLabel but lowercaseitemItem:				"\u30A230A430C630E0\u",	//"item",			// also i:General cachesitemsItem:				"\u30A230A430C630E0\u",	//"items",// SchedulescheduleLabel:			"\u30B930B130B830E530FC30EB\u",	//"Schedule",		//***CancelSchedLabel:		"\u30B930B130B830E530FC30EB309230AD30E330F330BB30EB\u",	//"Cancel Schedule",startDateLabel:			"Start Date",	// ***frequencyLabel:			"\u983B5EA6\u",			//"Frequency",	//***immedItem:				"\u30593050306B\u",		//"immediately",onceItem:				"\u4E005EA630603051\u",	//"once",hourlyItem:				"\u4E006642959330543068\u",	//"hourly",twiceDailyItem:			"\u65E5306B4E8C56DE\u",	//"twice daily",dailyItem:				"\u6BCE65E5\u",			//"daily",daily5Item:				"\u6BCE65E5FF089031672B30929664304FFF09\u",	//"daily (except weekend)",weeklyItem:				"\u6BCE9031\u",			//"weekly",// Go menugoLabel:				"Go",			// ***backItem:				"Back",forwardItem:			"Forward",clearHistoryItem:		"\u5C656B7430926D8853BB\u",	//"Clear History", // (also book menu)homeItem:				"\u30DB30FC30E0\u",			//"Home",		// i.e., startup URL// Bookmarks menubookmarksLabel:			"Bookmarks",	// ***openBookmarksItem:		"\u30D630E930A630BA\u/\u30B930B130B830E530FC30EB\u",	//"Browse/Schedule",removeBookmarkItem:		"\u30D630C330AF30DE30FC30AF3092524A9664\u",				//"Remove Bookmark",newtscapeBookmarkItem:	"Newt's Cape \u30B530F330D730EB30DA30FC30B8\u",			//"Newt's Cape Example Page",// info buttonaboutItem: 				"About",helpItem:				"\u30D830EB30D7\u",		//"Help",prefsItem:				"\u8A2D5B9A\u",			//"Prefs",registerItem:			"\u767B93323059308B\u",	//"Register",	// open Register application// about box/textintroductionText:		"\u305468485185\u",		//"Introduction",aboutCreate:			"HTML\u30924F7F752830573066300130C630AD30B930C83001753B50CF300130C630FC30D630EB300130D530A930FC30E030924F7F75283057305F\uNewtonBook\u309252364F5C3059308B30533068304C3067304D307E30593002\u",/*"CreateNewton books with text, graphics, tables andforms from HTML",*/	//***rightsReserved:			"All Rights Reserved Worldwide",moreInfo:				"\u3088308A8A733057304F77E5308B306B306F\u",	//"For More Information",webInfo:				"WWW\u4E0A306E30A430F330D530A930E130FC30B730E730F3\u",	//"web info",thanksRegister:			"\u767B93323042308A304C30683046305430563044307E3057305F\u",	//"Thanks for registering",generalItem:			"\u5168822C306E8A2D5B9A\u",	//"General",appearanceItem:			"\u8868793A306E8A2D5B9A\u",	//"Appearance",encodingItem:			"\u30A830F330B330FC30C730A330F330B08A2D5B9A\u",	//"Encoding",//(Process)displayItemItem:		"\u30A230A430C630E053584F4D30678868793A\u",	//"Display Item",displayPageItem:		"\u30DA30FC30B853584F4D30678868793A\u",		//"Display Page",displayPage1Item:		"\uFF1130DA30FC30B8306E307F8868793A\u",		//"Display Page1",displayAllItem:			"\u516830DA30FC30B851E674065F8C8868793A\u",	//"Display All",cacheOnlyItem:			"\u30AD30E330C330B730E5306E307FFF0871218868793AFF09\u",	//"Cache Only",	// also HREF popupsaveNewtworksItem:		"NewtWorks\u30784FDD5B58\u",				//"Save to NewtWorks",//i:GeneralnoCacheItem:			"\u30AD30E330C330B730E53057306A3044\u",	//"no cache",maxLabel:				"\u67005927\u",			//"Max.",			// after 10 items -- MaximumtrustCacheItem:			"\u30AD30E330C330B730E5309253C27167\u",	//"trust cache?",storeItem:				"Store",ignoreExpirationItem: 	"\u671F9650309271218996\u",	//"Ignore Expiration",emptyQuitItem:			"\u7D424E866642306B30AD30E330C330B730E5309230AF30EA30A2\u",	//"empty upon quit?",showItemOverview:		"show items in overviews",autoloadFramesItem:		"\u30D530EC30FC30E0309281EA52D57684306B958B304F\u",	//"autoload Frames?",	// HTMLmergeFramesItem:		"merge Frame source?",	// HTMLremoveItem:				"\u524A9664\u",		// <!-- HTML comments-->includeDesktopItem:		"PC?",	//"desktop?",			// HTMLfixISOItem:				"ISO\u65875B5730924FEE6B633059308B\u",	//"Fix ISO Chars?",	// HTMLdefaultItem:			"\u6A196E96\u",						//"default",		// Store (also Schedule:NIE setup)autoLoadItem:			"\u81EA52D58AAD307F8FBC307F\u",		//"autoLoad?",		// imagesfirstOneItem:			"\u6700521D306E\u1",				//"first 1",			// Images autoload #rawImageItem:			"\u753B50CF5F625F0F3092590963DB3057306A3044\u",	//"original (unconverted)?", // imagesanimatedItem:			"\u30A230CB30E130FC30B730E730F3\u",	//"animated?",		// imagesscaleImage:				"\u30B530A430BA3092753B9762306B906954083055305B308B\u",	//"scale to fit?",	// imagesresolutionLabel:		"\u968E8ABF\u",			//"Res.",				// resolution ***bwItem:					"\u30E230CE30AF30ED\u",	//"b&w(threshold)",gray4Item:				"4\u968E8ABF\u",		//"4-gray",gray16Item:				"16\u968E8ABF\u",		//"16-gray",unfiledBkMenuItem:		"Unfiled bookmarks in menu",cookiesLabel:			"Cookies",		//***skipItem:				"\u712152B9\u",			//"Skip",askItem:				"\u78BA8A8D\u",			//"Ask",keepItem:				"\u7DAD6301\u",			//"Keep",			//*** also AuthenticateNSlabel:				"NewtonScript",compileItem:			"\u30B330F330D130A430EB\u",		//"Compile",noneItem:				"\u71213057\u",					//"none",	// also Schedule:Frequency, Authenticate:HostsdocDoneLabel:			"\u51E674067D424E8697F3\u",		//"Doc Done",		//*** soundspageSizeLabel:			"\u753B976230B530A430BA\u",		//"Page Size",	//***phelpItem:				"\u30AA30F330E930A430F330D830EB30D7\u",	//"help",portraitItem:			"\u7E26753B9762\u",				//"portrait",landscapeItem:			"\u6A2A753B9762\u",				//"landscape",fullitem:				"\u5168753B9762\u",				//"full",pkgLabel:				"Pkg",			// package ***standaloneLabel:		"\u535872EC306E\uBook\u3068305730664F5C6210\u",	//"Standalone book pkg?",		// ***compressedItem:			"Compressed",autoHideLabel:			"\u81EA52D57684306B96A03059\u",	//"Auto hide?",NIEsetupLabel:			"NIE\u8A2D5B9A\u",				//"NIE Setup",		//*** also ScheduleIPaidLabel:				"\u767B93326E08\u",				//"I Paid?",			//***//AuthenticatehostsItem:				"Hosts",	//***hostLabel:				"Host",		//***tempItem:				"\u30C630F330DD30E930EA\u",		//"Temp.", 	// temporary (only for session) vs. "Keep"proxyLabel:				"Proxy",nameLabel:				"Name",		//***passwordLabel:			"Password",	//***authenticateLabel:		"\u8A8D8A3C\u",					//"Authenticate",	// *** also SchedulerequireUserMsg:			"\u30E630FC30B68A8D8A3C304C5FC5898130673059\u",	//"requires user authentication",unauthErr:				"\u8A8D8A3C306B593165573057307E3057305F\u",		//"Unauthorized; request requires user authentication",//i:General:Other OptionsotherOptionsLabel: 		"\u305D306E4ED6306E8A2D5B9A\u",	//"Other Options",	// ***startupURLItem:			"\u8D7752D56642306B8868793A3059308B\uURL",	//"Startup URL",proxyURLitem:			"Proxy URL",proxyOnlyItem: 			"Proxy Only",proxyExItem:			"Proxy Exceptions",findTitleItem:			"Find.Title",findURLitem:			"Find.URL",findMethodItem:			"Find.Method",findDataItem:			"Find.Data",findCheckItem:			"Find:CheckData",UserAgentItem:			"Agent Prefix",AgentSizeItem:			"Agent Size&Res.",helpISBNitem:			"Help ISBN",autoLoginItem:			"Auto Login",dontShowNCItem: 		"Newt'sCape\u30928868793A3057306A3044\u",	//"Don't Show Newt's Cape",dontCloseBookItem:		"Book\u309295893058306A3044\u",				//"Don't Close Book",ignoreMETArefresh:		"META\u30BF30B0306E\uRefresh\u309271218996\u",	//"Ignore META Refresh",ignoreTablesItem:		"Table\u309271218996\u",					//"Ignore Tables",includeFramesItem:		"\u30D530EC30FC30E03092542B307E305B308B\u",	//"Include Frames",tagFrameItem:			"map FRAME to tag",missingImgItem:			"IMG: no ALT",NCmenuItem:				"Newt'sCape\u30E130CB30E530FC\u",			//"Newt's Cape button",//bkoverItem:			"\u4E0089A730D330E530FC3067306E307F30D630C330AF30DE30FC30AF30928868793A\u",	//"Bookmarks in overview only",overfloatItem:			"\u4E0089A730D330E530FC309230D530ED30FC30C630A330F330B03057306A3044\u",	//"Overview not floating",changeKbdItem:			"\u30AD30FC30DC30FC30C9309230AB30B930BF30DE30A430BA\u",	//"Change keyboard keys",nwSummaryItem:			"NewtWorks\u306E\uHTML\u309230B530DE30EA30FC30924F7F30633066691C7D22\u",	//"NewtWorks HTML via Summary",mailtoBodyItem:			"mailto: body",bookWidthItem:			"Book Page Width",bookHeightItem:			"Book Page Height",bookBaseItem:			"Book BASE",bookISBNitem:			"Book ISBN",booksTitleItem:			"Book ShortTitle",bookTitleItem:			"Book Title",bookContentsTitle:		"Contents",//PrefSetsmainPrefSetLabel:		"Main PrefSet",prefSetItem:			"PrefSet",renameItem:				"Rename",duplicateItem:			"Duplicate",resetAllitem:			"\u521D671F8A2D5B9A306B623B3059\u",	//"Reset All",// i:AppearancetagLabel:				"\u30BF30B0\u",					//"Tag",			// ***missingErr:				"\u5B5857283057307E305B3093\u",	//"missing",		// missing Hx tagdefaultsLabel:			"\u6A196E968A2D5B9A\u",			//"Defaults",		// ***indentsLabel:			"\u30A430F330C730F330C8\u",		//"Indents",		// ***aboveLabel:				"\u4E0A65B9\u",					//"Above",		// ***leftLabel:				"\u5DE665B9\u",					//"Left",			// ***belowLabel:				"\u4E0B65B9\u",					//"Below",		// ***splitLabel:				"\u52065272\u",					//"Split",		// ***alignLabel:				"\u4F4D7F6E\u",					//"Align",		// ***rightItem:				"\u53F365B9\u",					//"Right",centerItem:				"\u4E2D592E\u",					//"Center",justifyItem:			"\u57477B49\u",					//"Justify",fontLabel:				"\u30D530A930F330C8\u",			//"Font",			// ***familyLabel:			"\u7A2E985E\u",					//"Family",		// ***sizeLabel:				"\u30B530A430BA\u",				//"Size",			// ***faceLabel:				"\u88C598FE\u",					//"Face",			// ***plainItem:				"Plain",boldItem:				"Bold",italicItem:				"Italic",boldItalicItem:			"BoldItalic",underlineItem:			"Underline",sampleLabel:			"\u30B530F330D730EB\u",		//"Sample",		// ***// HREF popuploadImageItem:			"\u753B50CF30928868793A\u",	//"Load Image",// Notes menugetURLItem:				"URL\u3092958B304F\u",		//"getURL",findItem:				"\u691C7D22\u",				//"Find",// FORM button defaultssubmitLabel:			"Submit",resetLabel:				"Reset",stopLabel:				"\u4E2D6B62\u",		//"Stop"  (progress box/keyboard label)// parsing status, general errorslinesLabel:				"Lines",itemsLabel:				"Items",pagesLabel:				"Pages",noHeapStoreErr:		"\u4F5C696D752830E130E230EA304C8DB3308A307E305B3093\u",							//"out of heap/store"errorOccurred:		"\u4F55304B554F984C304C767A751F3057307E3057305F\u",							//"An error occured in"errorLabel:			"\u30A830E930FC\u",							//"Error"parsingMsg:			"\u51E674064E2D\u",							//"Parsing"lengthMsg:			"\u30D530A130A430EB9577\u",							//"Length",untitledLabel:		"\u540D79F0672A8A2D5B9A\u",							//"Untitled"compileErr:			"\u30B330F330D130A430EB30A830E930FC\u",							//"compile err"evalErr:			"\u8A554FA130A830E930FC\u",							//"eval err"unknownTagErr:		"\u5B5857283057306A3044\uTag\u30673059\u",							//"UNKNOWN TAG"noNameErr:			"NAME\u304C8A2D5B9A3055308C30663044307E305B3093\u",							//"no NAME"missingNameValErr:	"NAME\u307E305F306F\uVALUE\u304C5B5857283057307E305B3093\u",							//"missing NAME or VALUE"screenSmallErr:		"\u753B9762304C5C0F30553059304E307E3059\u",						 	//"Screen smaller than"unknownValErr:		"\u5B5857283057306A3044502430673059\u",					 		//"unknown val"notFormErr:			"FORM\u5185306B3042308A307E305B3093\u",							//"not inside FORM"processErr:			"\u51E67406\u",							//"process"nameValErr:			"NAME\u307E305F306F\uVAL\u306B554F984C304C3042308A307E3059\u",							//"name or val err",notArrayOddErr:		"\u914D52173067306F306A3044304B300159476570500B306E914D521730673059\u",							//"not an array (or odd length)",okMsg:					"OK",// graphicsImageConvertErr:		"\u753B50CF30B330F330D030FC30C830A830E930FC\u",	//"Image conversion err?",notGIFerr:				"GIF\u30D530A930FC30DE30C330C83067306F3042308A307E305B3093\u",	//"not a real GIF",graphicHeading:			"\u753B50CF\u",	//"non-text object",noBinaryLenErr:			"\u30D030A430CA30EA30EC30F330B030B9304C4E0D660E\u",	//"no binary len?", // no binary length// packagesnotPkgErr:				"\u30D130C330B130FC30B83067306F3042308A307E305B3093\u",							//"not a package",installPackage:			"\u30D130C330B130FC30B8309230A430F330B930C830FC30EB3057307E3059304B\u",							//"Do you want to install package?"replacePackage:			"\u30D130C330B130FC30B830927F6E304D63DB3048307E3059FF1A\u",							//"Replace existing package?"installingPackage:		"\u30A430F330B930C830FC30EB4E2D\u",							//"Installing Package"installErr:				"\u30A430F330B930C830FC30EB306B593165573057307E3057305F\u",							//"Installation Failed"noPackageErr:			"\u30D130C330B130FC30B8304C3042308A307E305B3093\u",							//"no package"//prefSetsnameExistsErr:			"name already exists",nameEmptyErr:			"name empty",// comm (http/serial) status messages and errors.  FSM abort, wait, etc.?openingLinkMsg:			"\u30EA30F330AF3092958B304430663044307E3059\u",							//"Opening link"lookupHostMsg:			"\u30DB30B930C8309263A2305730663044307E3059\u",							//"Looking up host"cancelOpenMsg:			"\u30EA30F330AF30924E2D6B62305730663044307E3059\u",							//"Cancelling Open Link Request"instantiatingMsg:		"\u63A57D9A6E9650994E2D\u",							//"Instantiating"instantiateErr:			"\u63A57D9A6E965099306B593165573057307E3057305F\u",							//"Instantiate Err"IPaddressMsg:			"IP\u30A230C930EC30B9\u",							//"IP Address"bindPortMsg:			"\u30DD30FC30C8307863A57D9A305730663044307E3059\u",							//"Binding to port"connectingPortMsg:		"\u30DD30FC30C8307863A57D9A4E2D\u",							//"Connecting to port"connectingMsg:			"\u63A57D9A4E2D\u",							//"connecting"connectedMsg:			"\u63A57D9A3057307E3057305F\u",							//"connected"connectErr:				"\u63A57D9A306B593165573057307E3057305F\u",							//"Connect Err"disconnectingPortMsg:	"\u63A57D9A3092520765AD305730663044307E3059\u",							//"Disconnecting port"disconnectingMsg:		"\u520765AD4E2D\u",							//"disconnecting"unbindingMsg:			"\u30DD30FC30C83068306E63A57D9A3092520765AD305730663044307E3059\u",							//"UnBinding"disposingMsg:			"\u63A57D9A30927D424E864E2D\u",							//"Disposing"closingLinkMsg:			"\u30EA30F330AF3092520765AD4E2D\u",							//"Closing link"sendingHTTPMsg:			"HTTP\u30EA30AF30A830B930C8309290014FE14E2D\u",							//"HTTP Command"binaryLabel:			"\u30D030A430CA30EA\u",							//"Binary"textLabel:				"\u30C630AD30B930C8\u",							//"Text"waitMsg:				"\u304A5F8530614E0B30553044\u",							//"Please wait"terminalMsg:			"HTTP FSM\u306F30BF30FC30DF30CA30EB72B6614B30925B9F884C4E2D\u",							//"HTTP FSM is executing toward terminal state"goAwayLabel:			"\u4E2D6B62\u",							//"Go Away"redirectionMsg:			"\u30EA30C030A430EC30AF30C8\u",							//"redirection"badRequestErr:			"\u4E0D6B63306A30EA30AF30A830B930C830673059\u",							//"Bad request"forbiddenErr:			"\u30A230AF30BB30B96A29304C3042308A307E305B3093\u",							//"Forbidden for unspecified reason"notFoundErr:			"\u307F3064304B308A307E305B3093\u",							//"Not found"internalErr:			"\u518590E830B530FC30D0\u",							//"Internal server"notImplementedErr:		"\u5B9F88C53055308C30663044307E305B3093\u",							//"Not implemented"badGatewayErr:			"\u30B230FC30C830A630A730A430B530FC30D0304B3089306E30EC30B930DD30F330B9304C4E0D6B6330673059\u",							//"Bad gateway; invalid response from gateway or upstream server"noServiceErr:			"\u73FE572830B530FC30D330B930924F116B62305730663044307E3059\u",							//"Service temporarily unavailable"addCookiesMsg:			"Cookie\u30924F7F7528\u",							//"Add Cookies?"yesLabel:				"\u306F3044\u",							//"Yes",noLabel:				"\u304430443048\u",							//"No",inboxItem:				"\u53D74FE17BB1\u",					//"Inbox",		// destination for packageinboxErr:				"\u53D74FE17BB130A830E930FC\u",		//"Inbox Error",clientErr:				"\u30AF30E930A430A230F330C8\u",							//"client"serverErr:				"\u30B530FC30D0\u",							//"server"unknownHelperErr:		"\u30D830EB30D130FC30A230D730EA30B130FC30B730E730F3304C4E0D660EFF1A\u",							//"unknown helper for"noHelperErr:			"\u30D830EB30D130FC30A230D730EA30B130FC30B730E730F3304C5B5857283057307E305B3093FF1A\u",							//"no helper for"notHTMLimageErr:		"cache: not HTML or Image?",helperItem:			"Helpers",		// View:Helpers -> list helper AppsoldVersionLabel:	"old version",	// in Install package dialognewVersionLabel:	"new version",createdLabel:		"created", 	// ...followed by date// !!!a1//Other OptionsacceptItem:				"Accept",acceptLangItem:			"Accept Language",ignoreFontFaceItem:		"Ignore FONT FACE",displayUnkTagItem:		"Display unknown <tags>",autoLinkExcItem:		"AutoLink Exceptions",//overview:ScheduleautoLinkLabel:			"AutoLink",		// ***monthlyItem:			"monthly",//GonewerHTMLitem:			"Newer HTML Cache Item",newerImageItem:			"Newer Image Cache Item",setHTMLitem:			"Set HTML Cache Item",setImageItem:			"Set Image Cache Item",}, // end Japanese// -----German: { // Reinhold Schoeb <schoeba@str.daimler-benz.com>// File menufileLabel:				"Datei",				//"File"	//***openLocationItem:		"ffne URL",			//"Open Location"openNotesItem:			"ffne Notizen",		//"Open Notes"openInboxItem:			"ffne Eingang",		//"Open Inbox"openPaperbackItem:		"ffne Taschenbuch",	//"Open Paperback"paperbackItem:			"Taschenbuch",			//"Paperback"WabumiUniItem:			"WabumiUni",openWabumiUniItem:		"ffne WabumiUni",//openPersonalMediaItem:"ffne Personal Media",	//"Open Personal Media"//personalMediaItem:	"Personal Media",		//"Personal Media"//workspacesItem:		"Arbeitsumgebung",			//"Workspaces"//docsItem:				"Dokumente",				//"Docs"//storesItem:			"Speicher",				//"Stores"openNewtWorksItem:		"ffne NewtWorks",		//"Open NewtWorks"newtworksItem:			"NewtWorks",			//"NewtWorks"openHTMLCacheItem:		"ffne HTML Cache",		//"Open HTML Cache"openImageCacheItem:		"ffne Bilder Cache",	//"Open Image Cache"OpenNetHopperCacheItem:	"ffne NetHopper Cache",openDesktopItem:		"ffne Desktop",		//"Open Desktop"serial9600:				"Seriell(9600)",		//"Serial(9600)",serial57600:			"Seriell(57600)",		//"Serial(57600)",chooseMsg:				"Whle",				//"Choose"connectToMsg:			"verbinde zu",			//"connect to"ADSPlabel:				"ADSP",ADSPslabel:				"ADSPs",closeDesktopItem:		"Schlie§e Desktop",		//"Close Desktop"//openDemoURLsItem:		"ffne Demo URL's",		//"Open Demo URLs"savePackageItem:		"Speicher als Package",			//"Save as Package"saveHTMLNotes:			"Speicher HTML in Notizen",		//"Save HTML to Notes"saveImageNotes:			"Speicher Bild in Notizen",		//"Save Image to Notes"saveHTMLNewtworksItem:	"Speicher HTML in NewtWorks",	//"Save HTML to NewtWorks"saveImageNewtworksItem:	"Speicher Bild in NewtWorks",	//"Save Image to NewtWorks"saveBookNewtworksItem:	"Speicher Buch in NewtWorks",	//"Save Book to NewtWorks"//saveTextDesktopItem:	"Speicher als Text auf Desktop",//"Save as Text to Desktop"removeCurrentBookItem:	"Lsche aktuelles Buch",		//"Remove Current Book"removeFromCacheItem:	"Lsche aus Cache", 			//"Remove from Cache"resetHTTPlabel:			"HTTP Reset",			//"Reset HTTP"// View menuviewLabel:				"Anzeig.",				//"View"	//***currentBookItem:		"Aktuelles Buch",			//"Current Book"//closeOverViewItem:	"berblick schlie§en",	//"Close Overview",reloadItem:				"Neu laden",			//"Reload"loadWithImagesItem:		"Lade mit Bilder",		//"Load with Images"//allImagesItem:		"Alle Bilder",			//"All Images",loadLinksItem:			"Lade Links",			//"Load Links",loadFramesItem:			"Lade Rahmen",			//"Load Frames",documentSourceItem:		"Dokument-Quelle", 		//"Document Source"//overviewsHTMLlabel:				"HTML",					// *** (also in i:General)imagesLabel:			"Bilder",				//"Images"	// *** (also in i:General)//HTMLCacheLabel:			"HTML Cache",//ImageCacheLabel:		"Bilder Cache",			//"Image Cache"linksItem:				"Links",				//"Links"framesItem:				"Rahmen",				//"Frames",allLabel:				"Alle",					//***loadItem:				"Lade",openItem:				"ffne",				//"Open". // also in NotesprocessItem:			"Ausfhren",			//"Process"		// also About,idisplayURLitem:			"Zeige URL",			//"Display URL"	// also HREF popupsaveOutlineItem:		"Sichern als bers.",	//"Save as Outline",//outlineLabel:			"bers.",addBookmarkItem:		"Lesez. zufgen",		//"Add Bookmark"	// also Bookmarks, HREF popuplockItem:				"Sperren",				//"Lock",unlockItem:				"Entsperren",			//"Unlock",deleteItem:				"Lsche",bookmarkLabelL:			"Lesezeichen",bookmarksLabelL:		"Lesezeichen",itemItem:				"Eintrag",				//"item",	// also i:General cachesitemsItem:				"Eintrge",				//"items"//SchedulescheduleLabel:			"Plan",CancelSchedLabel:		"Plan abbrechen",startDateLabel:			"Start Datum",			// ***frequencyLabel:			"Hufigkeit",			//"Frequency",immedItem:				"sofort",				//"immediately",onceItem:				"einmal",				//"once",hourlyItem:				"stndlich",			//"hourly",twiceDailyItem:			"zweimal tglich",		//"twice daily",dailyItem:				"tglich",				//"daily",daily5Item:				"tglich (au§er Wochenende)",	//"daily (except weekend)",weeklyItem:				"wchentlich",			//"weekly",???// Go menugoLabel:				"Gehe",					//"Go"backItem:				"Zurck",				//"Back"clearHistoryItem:		"Lsche Historie",		//"Clear History"forwardItem:			"Vorwrts",				//"Forward",homeItem:				"Home", 	// i.e., startup URL// Bookmarks menubookmarksLabel:			"Lesez.",				//"Bookmarks"openBookmarksItem:		"Liste anzeigen",		//"Browse/Schedule"removeBookmarkItem:		"Lesezeichen entfernen", 	//"Remove Bookmark"newtscapeBookmarkItem:	"Newt's Cape Beispiel-Seiten",	//"Newt's Cape Example Page",//removeAllItem:		"Alles lschen",		//"Remove All",// info buttonaboutItem: 				"ber",					//"About"helpItem:				"Hilfe",				//"Help"prefsItem:				"Einstellungen",		//"Prefs"registerItem:			"Registrieren",			//"Register",   // open Register application (if installed)// about box/textintroductionText:		"Einfhrung",			//"Introduction"aboutCreate:			"Erzeuge Newton-Bcher mit Text, Grafik, Tabellen und Formularen aus HTML",//"Create Newton books with text, graphics, tables and forms from HTML"rightsReserved:			"Alle Rechte weltweit reserviert",	//"All Rights Reserved Worldwide"moreInfo:				"Fr mehr Informationen",			//"For More Information"webInfo:				"Web-Info",				//"web info"thanksRegister:			"Vielen Dank fr die Registrierung",//"Thanks for registering"//bookLabel:				"Buch",					//"Book"//i:Prefs//optionsLabel:			"Optionen",				//"Options"generalItem:			"Allgemein",			//"General"appearanceItem:			"Aussehen",				//"Appearance"encodingItem:			"Kodierung",			//"Encoding"//(Process)displayItemItem:		"Zeige Eintrag",		//"Display Item"displayPageItem:		"Zeige Seite",			//"Display Page"displayPage1Item:		"Zeige Seite 1",		//"Display Page1"displayAllItem:			"Zeige alles",			//"Display All"cacheOnlyItem:			"Nur Cache",			//"Cache Only"saveNewtworksItem:		"Speicher in NewtWorks",	//"Save to NewtWorks"//i:GeneralnoCacheItem:			"kein Cache",			//"no cache"maxLabel:				"Max.",trustCacheItem:			"Cache benutzen?",		//"trust cache?"storeItem:				"Speicher",		//"Store",ignoreExpirationItem:	"Verfall ignorieren",	//"Ignore Expiration",emptyQuitItem:			"nach Beenden leeren?",	//"empty upon quit?"showItemOverview:		"Eintrge im berblick zeigen",	//"show items in overviews",autoloadFramesItem:		"Rahmen autom. laden?",	//"autoload Frames?",mergeFramesItem:		"Rahmen Quellen mischen?",	//"merge Frame source?",removeItem:				"lsche?",				//"remove",includeDesktopItem:		"Bildschirm?",			//"desktop?"fixISOItem:				"ISO Zeichen einst.?",	//"Fix ISO Chars?",//openURLitem:			"ffne URL sofort?",	//"open URL immediately?",defaultItem:			"Grundeinstellungen",	//"default",autoLoadItem:			"Autom. laden?",		//"autoLoad?"firstOneItem:			"erst 1",				//"first 1",      Images autoload #rawImageItem:			"Original (nicht konv.)?",	//"original (unconverted)?"animatedItem:			"Animiert?",			//"animated?",scaleImage:				"Gr§e anpa§en?",		//"scale to fit?",resolutionLabel:		"Aufls.",				//"Res."bwItem:					"S&W",					//"b&w(threshold)"gray4Item:				"4-Grau",				//"4-gray"gray16Item:				"16-Grau",				//"16-gray"unfiledBkMenuItem:		"Nicht abgelegte Lesezeichen im Menu",	//"Unfiled bookmarks in menu",cookiesLabel:			"Cookies",skipItem:				"berspringen",			//"Skip"askItem:				"Fragen",				//"Ask"keepItem:				"Behalten",				//"Keep"NSlabel:				"NewtonScript",compileItem:			"bersetzen",			//"compile",noneItem:				"ohne",					//"none"docDoneLabel:			"Dok fertig",			//"Doc Done"pageSizeLabel:			"Seitengr§e",			//"Page Size"phelpItem:				"Hilfeformat",			//"help"portraitItem:			"Hochformat",			//"portrait"landscapeItem:			"Querformat",			//"landscape"fullitem:				"Bildschirm",			//"full" was "Alles"pkgLabel:				"Pkg",          // Pkg (package) menu options	// ***standaloneLabel:		"Eigenst. Buch-Pkg?",	//"Standalone book pkg?"	// ***compressedItem:			"Komprimiert",			//"Compressed",autoHideLabel:			"Autom. verbergen?",	//"Auto hide?",//inetSetupLabel:		"INET Einst.",			//"Inet Setup" ***NIEsetupLabel:			"NIE Einst.",	//Einstellungen "NIE Setup", //*** also ScheduleIPaidLabel:				"Bezahlt?",				//"I Paid?",//AuthenticatehostsItem:            	"Rechner",		//"Hosts"	//***hostLabel:				"Rechner",		//"Host",	//***tempItem:				"vorlufig",	//"Temp.", temporary (new password category) vs. "Keep"proxyLabel:				"Proxy",nameLabel:				"Name",					//***passwordLabel:			"Pa§wort",				//"Password"	//***authenticateLabel:		"Authentifizierung",	//"Authenticate"	// *** also SchedulerequireUserMsg:			"erfordert Benutzer-Authentifizierung",	//"requires user authentication"unauthErr:				"Nicht authentifiziert; Anfrage erfordert Benutzer-Authentifizierung",	//"Unauthorized; request requires user authentication"//i:General:Other Options//Other OptionsotherOptionsLabel:		"Weitere Optionen",		//"Other Options",	// ***startupURLItem:			"Start URL",proxyURLitem:			"Proxy URL",//proxyHostItem:		"Proxy Host",proxyOnlyItem:			"Nur Proxy",			// "Proxy Only",proxyExItem:			"Proxy Ausnahmen",		//"Proxy Exceptions"findTitleItem:			"Finde Titel",			//"Find.Title"findURLitem:			"Finde URL",			//"Find.URL"findMethodItem:			"Finde Methode",		//"Find.Method"findDataItem:			"Finde Daten",			//"Find.Data"findCheckItem:			"Finde:CheckData",		//"Find:CheckData"UserAgentItem:			"Agent Prefix",AgentSizeItem:			"Gr§e durch Agent",	//"Agent Size&Res.",helpISBNitem:			"Hilfe ISBN",			//"Help ISBN",autoLoginItem:			"Autom. Login",			//"Auto Login",dontShowNCItem: 		"Newt's Cape nicht anzeigen",	//"Don't Show Newt's Cape",dontCloseBookItem:		"Buch nicht schlie§en",	//"Don't Close Book",ignoreMETArefresh:		"META Refresh ignorieren",	//"Ignore META Refresh",ignoreTablesItem:		"Ignor. Tabellen",		//"Ignore Tables",includeFramesItem:		"Mit Rahmen",			//"Include Frames?",tagFrameItem:			"FRAME nach TAG wandeln",	//"map FRAME to tag",missingImgItem:			"IMG: kein ALT",		//"IMG: no ALT",NCmenuItem:				"Newt's Cape button",	// "Newt's Cape button"//bkoverItem:			"Lesezeichen nur im berblick",	//"Bookmarks in overview only",overfloatItem:			"Lesezeichen nicht verschieben",	//"Overview not floating",changeKbdItem:			"Andere Tastatur",		//"Change keyboard keys",nwSummaryItem:			"NewtWorks HTML ber Zusammenf.",	//"NewtWorks HTML via Summary",mailtoBodyItem:			"mailto: body",bookWidthItem:			"Buch Seitenbreite",	//"Book Page Width",bookHeightItem:			"Buch Seitenhhe",		//"Book Page Height",bookBaseItem:			"Buch BASE",			//"Book BASE",bookISBNitem: 			"Buch ISBN",			//"Book ISBN",booksTitleItem:			"Buch Kurztitel",		//"Book ShortTitle",bookTitleItem:			"Buch Titel",			//"Book Title",bookContentsTitle:		"Inhalt",				//"Contents",//PrefSetsmainPrefSetLabel:		"Haupt-Einstellungen",	//"Main PrefSet",prefSetItem:			"Einstellungen",		//"PrefSet",renameItem:				"Umbenennen",			//"Rename",duplicateItem:			"Kopieren",				//"Duplicate",resetAllItem:			"Alles zurcksetzen",	//"Reset All"// Options:AppearancetagLabel:				"Tag",					// ***missingErr:				"fehlt",				//"missing"defaultsLabel:			"Voreinst.",			//"Defaults"	// ***indentsLabel:			"Einrcken",			//"Indents",	// ***aboveLabel:				"Oben",					//"Above"	// ***leftLabel:				"Links",				//"Left"	// ***belowLabel:				"Unten",				//"Below"	// ***splitLabel:				"Teilen",				//"Split"	// ***alignLabel:				"Ausrichten",			//"Align"	// ***rightItem:				"Rechts",				//"Right"centerItem:				"Mitte",				//"Center"justifyItem:			"Anpassen",				//"Justify"fontLabel:				"Schrift",				//"Font"	// ***familyLabel:			"Familie",				//"Family"	// ***sizeLabel:				"Gr§e",				//"Size"	// ***faceLabel:				"Aussehen",				//"Face"	// ***plainItem:				"Normal",				//"Plain"boldItem:				"Fett",					//"Bold"italicItem:				"Kursiv",				//"Italic"boldItalicItem:			"Fett+Kursiv",			//"BoldItalic"underlineItem:			"Unterstr.",			//"Underline"sampleLabel:			"Beispiel",				//"Sample"	// ***// Directory menu (if applicable)//directoryLabel:			"Verzeichnis",			//"Directory"// status fields//urlLabel:				"URL",//titleLabel:			"Titel",				//"Title"//isbnLabel:			"ISBN",//shortTitleLabel:		"Kurztitel",			//"STitle"linesLabel:				"Zeilen",				//"Lines"itemsLabel:				"Punkt",				//"Items"pagesLabel:				"Seiten",				//"Pages"// HREF popuploadImageItem:			"Lade Bilder",// Notes menugetURLItem:				"URL laden",			//"getURL",findItem:				"Suchen",				//"Find"// keyboard (labels) [holding down cmd-]//"General"//quitItem:				"Ende",stopLabel:				"Stop",//"Hide/Show"//"History"//saveLabel:			"Speich.",// FORM button defaultssubmitLabel:			"Eintragen",			//"Submit",resetLabel:				"Reset",// parsing status, general errorsnoHeapStoreErr:			"zu wenig Speicher?",	//"out of heap/store"errorOccurred:			"Ein Fehler ist aufgetreten in",	//"An error occured in"errorLabel:				"Fehler",				//"Error"parsingMsg:				"Parsing",lengthMsg:				"Lnge",				//"Length"untitledLabel:			"Ohne Titel",			//"Untitled"compileErr:				"bersetzungs-Fehler",	//"compile err"evalErr:				"Eval-Fehler",			//"eval err"unknownTagErr:			"TAG UNBEKANNT",		//"UNKNOWN TAG"noNameErr:				"kein NAME",			//"no NAME"missingNameValErr:		"NAME oder VALUE fehlt",//"missing NAME or VALUE"screenSmallErr:			"Bildschirm kleiner als",//"Screen smaller than"unknownValErr:			"Val unbekannt",		//"unknown val"notFormErr:				"nicht innerhalb FORM",	//"not inside FORM"processErr:				"ausfhren",			//"process"nameValErr:				"Fehler: Name od. Wert",//"name or val err"notArrayOddErr:			"kein Array (oder ung. Lnge)",	//"not an array (or odd length)"okMsg:					"OK",// graphicsImageConvertErr:		"Fehler Bildumwandl.",	//"Image conversion err?",//GIFconvertErr:		"GIF bersetzungs-Fehler?",		//"GIF conversion err?"notGIFerr:				"GIF ungltig",			//"not a real GIF"graphicHeading:			"eine Grafik",			//"non-text object"noBinaryLenErr:			"keine Binary-Lnge",	//"no binary len?", no binary length from serve// packagesnotPkgErr:				"kein Package",			//"not a package"installPackage:			"Package installieren?",//"Do you want to install package?"replacePackage:			"Existierendes Package berschreiben?",	//"Replace existing package?"installingPackage:		"Installiere Package",	//"Installing Package"installErr:				"Fehler beim Installieren",	//"Installation Failed"noPackageErr:			"kein Package",			//"no package"//prefSetsnameExistsErr:			"Name existiert bereits",	//"name already exists",nameEmptyErr:			"Name leer",				//"name empty",// comm (http/serial) status messages and errors. FSM abort, wait, etc.???openingLinkMsg:			"ffne link",			//"Opening link"lookupHostMsg:			"Suche nach Host",		//"Looking up host"cancelOpenMsg:			"Stoppe ffne-Verbindungs-Anfrage",	//"Cancelling Open Link Request"instantiatingMsg:		"Instantinating",		//"Instantiating",instantiateErr:			"Instantinating Fehler",//"Instantiate Err",IPaddressMsg:			"IP Adresse",			//"IP Address"bindPortMsg:			"Verbinde zu Port",		//"Binding to port"connectingPortMsg:		"Verbinde zu Port",		//"Connecting to port"connectingMsg:			"verbinde",				//"connecting"connectedMsg:			"verbunden",			//"connected"connectErr:				"Verbindungs-Fehler",	//"Connect Err"disconnectingPortMsg:	"Unterbreche Port", 	//"Disconnecting port"disconnectingMsg:		"unterbreche",			//"disconnecting"unbindingMsg:			"UnBinding",disposingMsg:			"Disposing",closingLinkMsg:			"Schlie§e Verbindung",	//"Closing link"sendingHTTPMsg:			"HTTP Kommando",		//"HTTP Command"binaryLabel:			"Binr",				//"Binary"textLabel:				"Text",waitMsg:				"Bitte warten",			//"Please wait"terminalMsg:			"HTTP FSM is executing toward terminal state",goAwayLabel:			"Verlasse",				//"Go Away"redirectionMsg:			"Umleitung",			//"redirection"badRequestErr:			"Anfrage falsch",		//"Bad request"forbiddenErr:			"Verboten aus unbekanntem Grund",	//"Forbidden for unspecified reason"notFoundErr:			"Nicht gefunden",		//"Not found"internalErr:			"Interner Server",		//"Internal server"notImplementedErr:		"Nicht implementiert", 	//"Not implemented"badGatewayErr:			"Gateway Problem: ungltige Antwort vom Gateway oder Upstream Server", //"Bad gateway; invalid response from gateway or upstream server",noServiceErr:			"Service z.Z. nicht verfgbar",	//"Service temporarily unavailable"addCookiesMsg:			"Cookies hinzufgen?",	//"Add Cookies?"yesLabel:				"Ja",					//"Yes",noLabel:				"Nein",					//"No",inboxItem:				"Eingang",				// "Inbox"inboxErr:				"Eingang Fehler",		// "Inbox Error"clientErr:				"client",serverErr:				"server",unknownHelperErr:		"Unbekannter Helper fr",	//"unknown helper for"noHelperErr:			"kein Helper fr",		//"no helper for"notHTMLimageErr:		"Cache kein HTML oder Bild?",	//"cache: not HTML or Image?",helperItem:			"Helpers",		// View:Helpers -> list helper AppsoldVersionLabel:	"old version",	// in Install package dialognewVersionLabel:	"new version",createdLabel:		"created", 	// ...followed by date//!!!a1acceptItem:			"Akzeptieren",	//"Accept",acceptLangItem: 	"Language akzeptieren",	//"Accept Language",ignoreFontFaceItem:	"FONT FACE ignorieren",	//"Ignore FONT FACE",displayUnkTagItem: 	"Unbekannte <tags> anzeigen",	//"Display unknown <tags>",autoLinkExcItem:	"Auto Link Ausnahmen",	//"AutoLink Exceptions",autoLinkLabel: 		"Auto Link",	//"AutoLink",             // ***monthlyItem:		"monatlich",	//"monthly",newerHTMLitem:		"HTML Cache Eintrag erneuern",	//"Newer HTML Cache Item",newerImageItem: 	"Bilder Cache Eintrag erneuern",	//"Newer Image Cache Item",setHTMLitem:		"HTML Cache Eintrag setzen",	//"Set HTML Cache Item",setImageItem: 		"Bilder Cache Eintrag setzen",	//"Set Image Cache Item",}, // end German// -----Chinese: {	// Joseph Chen <joseph@nats.informatik.uni-hamburg.de>// File menufileLabel:	"\u6A946848\u",	//"File",	//***openLocationItem:	"\u6253958B7DB25740\u",	//"Open Location",openNotesItem:	"\u6253958B8A184E8B7C3F\u",	//"Open Notes",openInboxItem:	"\u6253958B65364EF67BB1\u",	//"Open Inbox",openPaperbackItem:	"\u6253958B002000500061007000650072006200610063006B\u",	//"Open Paperback",paperbackItem:	"Paperback",WabumiUniItem:			"WabumiUni",openWabumiUniItem:		"Open WabumiUni",//openPersonalMediaItem:	"\u6253958B00200050006500720073006F006E0061006C0020004D0065006400690061\u",	//"Open Personal Media",//personalMediaItem:	"Personal Media",//storesItem:	"\u51325B585340\u",	//"Stores",//workspacesItem:	"\u5DE54F5C5340\u",	//"Workspaces",//docsItem:	"\u65874EF6\u",	//"Docs",openNewtWorksItem:	"\u6253958B0020004E0065007700740057006F0072006B0073\u",	//"Open NewtWorks",newtworksItem:	"NewtWorks",openHTMLCacheItem:	"\u6253958B002000480054004D004C002000430061006300680065\u",	//"Open HTML Cache",openImageCacheItem:	"\u6253958B571650CF002000430061006300680065\u",	//"Open Image Cache",OpenNetHopperCacheItem:	"Open NetHopper Cache",openDesktopItem:	"\u6253958B684C4E0A96FB8166\u",	//"Open Desktop",serial9600:	"\u5E8F5217002800390036003000300029\u",	//"Serial(9600)",serial57600:	"\u5E8F52170028003500370036003000300029\u",	//"Serial(57600)",chooseMsg:	"\u907864C7\u",	//"Choose",connectToMsg:	"\u902363A581F3\u",	//"connect to",ADSPlabel:	"ADSP",		// AppleTalk ***ADSPslabel:	"ADSPs",	//***closeDesktopItem:	"\u95DC9589684C4E0A96FB8166\u",	//"Close Desktop",//openDemoURLsItem:	"\u6253958B002000440065006D006F002000550052004C0073\u",	//"Open Demo URLs",savePackageItem:		"\u51325B5870BA0020005000610063006B006100670065\u",	//"Save as Package",saveHTMLNotes:	"\u51325B58002000480054004D004C002081F38A184E8B7C3F\u",	//"Save HTML to Notes",saveImageNotes:	"\u51325B58571650CF81F38A184E8B7C3F\u",	//"Save Image to Notes",saveHTMLNewtworksItem:	"\u51325B58002000480054004D004C002081F30020004E0065007700740057006F0072006B0073\u",	//"Save HTML to NewtWorks"saveImageNewtworksItem:	"\u51325B585F7150CF81F30020004E0065007700740057006F0072006B0073\u",	//"Save Image to NewtWorks",saveBookNewtworksItem:	"\u51325B58725B981366F881F30020004E0065007700740057006F0072006B0073\u",	//"Save Book to NewtWorks",//saveTextDesktopItem:	"\u51325B5865875B576A9481F3684C4E0A96FB8166\u",	//"Save as Text to Desktop",removeCurrentBookItem:	"\u79FB966476EE524D7684725B981366F8\u",	//"Remove Current Book",removeFromCacheItem:	"\u81EA00200043006100630068006500204E2D6E059664\u",	//"Remove from Cache",resetHTTPlabel:	"\u91CD8A2D00200048005400540050\u",	//"Reset HTTP",// View menuviewLabel:	"\u666F89C0\u",	//"View",	//***currentBookItem:	"\u76EE524D7684725B981366F8\u",	//"Current Book",//closeOverViewItem:	"\u95DC95890020004F0076006500720076006900650077\u",	//"Close Overview",reloadItem:	"\u91CD65B08F095165\u",	//"Reload",loadWithImagesItem:	"\u540C66428F095165571650CF\u",	//"Load with Images",//allImagesItem:			"All Images",loadLinksItem:		"Load Links",loadFramesItem:		"Load Frames",documentSourceItem:	"\u65874EF6539F59CB6A94\u",	//"Document Source",//overviewHTMLlabel:		"HTML",imagesLabel:	"\u571650CF\u",	//"Images",//HTMLCacheLabel:	"HTML Cache",//ImageCacheLabel:	"\u571650CF002000430061006300680065\u",	//"Image Cache",linksItem:		"Links",		// in title line of Links overviewframesItem:		"Frames",allLabel:				"All",loadItem:				"Load",openItem:		"\u6253958B\u",	//"Open",processItem:	"\u7A0B5E8F8A2D5B9A\u",	//"Process",displayURLitem:		"Display URL",saveOutlineItem:		"\u5B5870BA59277DB1\u",		//"Save as Outline",addBookmarkItem:	"\u52A0516566F87C64\u",	//"Add Bookmark",lockItem:		"Lock",unlockItem:		"Unlock",deleteItem:				"Delete",bookmarkLabelL:			"bookmark",bookmarksLabelL:		"bookmarks",itemItem:		"item",itemsItem:	"\u55AE5143\u",	//"items",// SchedulescheduleLabel:			"Schedule",	// ***CancelSchedLabel:		"Cancel Schedule",startDateLabel:			"Start Date",	// ***frequencyLabel:		"Frequency",	// ***immedItem:			"immediately",onceItem:			"once",hourlyItem:			"hourly",twiceDailyItem:		"twice daily",dailyItem:			"daily",daily5Item:			"daily (except weekend)",weeklyItem:			"weekly",// Go menugoLabel:			"\u524D5F80\u",	//"Go",	// ***backItem:			"\u8FD456DE\u",	//"Back",forwardItem:		"\u4E0B4E009805\u",			//"Forward",clearHistoryItem:	"\u6E0596646B7753F26A94\u",	//"Clear History", // (book menu)homeItem:			"Home",		// i.e., startup URL// Bookmarks menubookmarksLabel:		"\u66F87C64\u",	//"Bookmarks", //***openBookmarksItem:		"Browse/Schedule",removeBookmarkItem:	"\u81EA66F87C644E2D6E059664\u",	//"Remove Bookmark",newtscapeBookmarkItem:	"Newt's Cape Example Page",//removeAllItem:			"\u516890E8966453BB\u",		//"Remove All",// info buttonaboutItem:	"\u95DC65BC\u",	//"About",helpItem:	"\u8AAA660E\u",	//"Help",prefsItem:	"\u8A2D5B9A\u",	//"Prefs",registerItem:		"Register",	// open Register application// about box/textintroductionText:	"\u7C214ECB\u",	//"Introduction",aboutCreate:	"\u5229752800480054004D004C768457165F62548C8868683C7522751F725B981366F8\u",	//"Create Newton books with text, graphics, tables and forms from HTML",rightsReserved:	"\u5168740372486B0A62406709\u",	//"All Rights Reserved Worldwide",moreInfo:	"\u95DC65BC90324E006B6576848CC78A0A\u",	//"For More Information",webInfo:	"\u00570045004200208CC78A0A\u",	//"web info",thanksRegister:	"\u8B1D8B1D60A88A3B518A\u",	//"Thanks for registering",//bookLabel:	"Book",// Options//optionsLabel:	"\u8A2D5B9A\u",	//"Options",generalItem:	"\u4E00822C8A2D5B9A\u",	//"General",appearanceItem:	"\u986F793A8A2D5B9A\u",	//"Appearance",encodingItem:	"\u7DE878BC65B95F0F\u",	//"Encoding",//(Process)displayItemItem:	"\u986F793A55AE9805\u",	//"Display Item",displayPageItem:	"\u986F793A98019762\u",	//"Display Page",displayPage1Item:	"\u986F793A7B2C4E009801\u",	//"Display Page1",displayAllItem:		"\u986F793A516890E8\u",	//"Display All",cacheOnlyItem:		"\u50C55B585165002000430061006300680065\u",	//"Cache Only",	// also HREF popupsaveNewtworksItem:	"Save to NewtWorks",	//??//i:GeneralnoCacheItem:	"\u4E0D4F7F7528002000430061006300680065\u",	//"no cache",maxLabel:		"Max.",		// after 10 items -- Max.  short for overview titletrustCacheItem:	"\u4FE14EFB002000430061006300680065003F\u",	//"trust cache?",storeItem:			"Store",ignoreExpirationItem: "Ignore Expiration",emptyQuitItem:	"\u900051FA66426E059664003F\u",	//"empty upon quit?",showItemOverview:		"show items in overviews",autoloadFramesItem:		"autoload Frames?",	// HTMLmergeFramesItem:	"merge Frame source?",removeItem:		"\u6E059664003F\u",	//"remove?",includeDesktopItem:	"\u684C976296FB8166003F\u",	//"desktop?",fixISOItem:			"Fix ISO Chars?",//openURLitem: 	"\u7ACB523B6253958B002000550052004C\u",	// "open URL immediately?",defaultItem:	"default",autoLoadItem:	"\u81EA52D58F095165003F\u",	//"autoLoad?",firstOneItem:		"first 1",	// Images autoload #rawImageItem:	"\u539F59CB0028672A7D938F4963DB0029003F\u",	//"original (unconverted)?",animatedItem:	"\u52D5756B003F\u",	//"animated?",scaleImage:		"\u81EA52D57E2E653E\u",		//"scale to fit?",resolutionLabel:	"\u89E367905EA6\u",	//"Res.",bwItem:	"\u9ED1767D0028007400680072006500730068006F006C00640029\u",	//"b&w(threshold)",gray4Item:	"\u56DB7070968E\u",	//"4-gray",gray16Item:	"\u5341516D7070968E\u",	//"16-gray",unfiledBkMenuItem:		"Unfiled bookmarks in menu",cookiesLabel:	"Cookies",skipItem:	"\u8DF3904E\u",	//"Skip",askItem:	"\u8A62554F\u",	//"Ask",keepItem:	"\u4FDD5B58\u",	//"Keep",NSlabel:	"NewtonScript",compileItem:	"\u7DE88B6F\u",	//"Compile",noneItem:	"\u7121\u",	//"none",docDoneLabel:	"\u5B8C621097F36548\u",	//"Doc Done",pageSizeLabel:	"\u980197625C3A5BF8\u",	//"Page Size",	// ***phelpItem:	"\u8AAA660E\u",	//"help",portraitItem:	"\u76F47ACB98019762\u",	//"portrait",landscapeItem:	"\u6A6B8EBA98019762\u",	//"landscape",fullitem:	"\u5B8C5168\u",	//"full",pkgLabel:			"Pkg",		// Pkg (package) menu options	//***standaloneLabel:	"\u73687ACB00200042006F006F006B00200050006B0067003F\u",	//"Standalone book pkg?",// ***compressedItem:			"Compressed",autoHideLabel:			"Auto hide?",//inetSetupLabel:	"\u0049006E0065007400208A2D5B9A\u",	//"Inet Setup",NIEsetupLabel:		"NIE Setup",	// ***IPaidLabel:		"\u4EE54ED88CBB003F\u",		//"I Paid?",	// ***//AuthenticatehostsItem:			"Hosts",	// ***hostLabel:	"\u4E3B6A5F\u",	//"Host",	// ***tempItem:			"Temp.", //temporary (new password category) vs. "Keep"	proxyLabel:	"Proxy",nameLabel:	"\u5E33865F\u",	//"Name",	// ***passwordLabel:	"\u5BC678BC\u",	//"Password",	// ***authenticateLabel:	"\u5BC678BC63886B0A\u",	//"Authenticate",	// ***requireUserMsg:	"\u970089815BC678BC63886B0A\u",	//"requires user authentication",unauthErr:	"\u5BC678BC63886B0A932F8AA4\u",	//"Unauthorized; request requires user authentication",//i:General:Other OptionsotherOptionsLabel: "Other Options",	// ***startupURLItem:	"\u8D7759CB002000550052004C\u",	//"Startup URL",proxyURLitem:	"Proxy URL",//proxyHostItem:	"Proxy Host",proxyOnlyItem: 	"Proxy Only",proxyExItem:	"Proxy Exceptions",findTitleItem:	"\u627E5C0B6A19984C\u",	//"Find.Title",findURLitem:	"\u627E5C0B002000550052004C\u",	//"Find.URL",findMethodItem:	"\u627E5C0B0020004D006500740068006F0064\u",	//"Find.Method",findDataItem:	"\u627E5C0B00200044006100740061\u",	//"Find.Data",findCheckItem:	"\u627E5C0B00200043006800650063006B0044006100740061\u",	//"Find:CheckData",UserAgentItem:	"Agent Prefix",AgentSizeItem:	"Agent Size&Res.",helpISBNitem:	"Help ISBN",autoLoginItem: 	"\u81EA52D57C3D5165\u",		//  "Auto Login",dontShowNCItem: 		"Don't Show Newt's Cape",dontCloseBookItem:		"Don't Close Book",ignoreMETArefresh:	"Ignore META Refresh",ignoreTablesItem:		"Ignore Tables",includeFramesItem:	"Include Frames",tagFrameItem:		"map FRAME to tag",missingImgItem:		"IMG: no ALT",NCmenuItem:				"Newt's Cape button",//bkoverItem:		"Bookmarks in overview only",overfloatItem:	"Overview not floating",changeKbdItem:	"Change keyboard keys",nwSummaryItem:	"NewtWorks HTML via Summary",mailtoBodyItem:			"mailto: body",bookWidthItem:	"Book Page Width",bookHeightItem:	"Book Page Height",bookBaseItem:	"Book BASE",bookISBNitem:	"Book ISBN",booksTitleItem:	"Book ShortTitle",bookTitleItem:	"Book Title",bookContentsTitle:		"Contents",//PrefSetsmainPrefSetLabel:		"Main PrefSet",prefSetItem:			"PrefSet",renameItem:				"Rename",duplicateItem:			"Duplicate",resetAllitem:	"\u516890E891CD8A2D\u",	//"Reset All",// i:AppearancetagLabel:	"\u6A197C64\u",	//"Tag",	// ***missingErr:	"\u4E0D5B585728\u",	//"missing",	// missing Hx tagdefaultsLabel:	"\u98108A2D503C\u",	//"Defaults",	// ***indentsLabel:	"\u7E2E6392\u",	//"Indents",	// ***aboveLabel:	"\u62AC982D\u",	//"Above",	// ***leftLabel:	"\u5DE6\u",	//"Left",		// ***belowLabel:	"\u843D8173\u",	//"Below",	// ***splitLabel:	"\u52069694\u",	//"Split",	// ***alignLabel:	"\u5C0D9F4A\u",	//"Align",	// ***rightItem:	"\u53F3\u",	//"Right",centerItem:	"\u4E2D\u",	//"Center",justifyItem:	"\u9F4A6392\u",	//"Justify",fontLabel:	"\u5B579AD4\u",	//"Font",	// ***familyLabel:	"\u5B5765CF\u",	//"Family",	// ***sizeLabel:	"\u5C3A5BF8\u",	//"Size",	// ***faceLabel:	"\u5B575F62\u",	//"Face",	// ***plainItem:	"\u6B635E38\u",	//"Plain",boldItem:	"\u7C979AD4\u",	//"Bold",italicItem:	"\u659C9AD4\u",	//"Italic",boldItalicItem:	"\u7C97659C9AD4\u",	//"BoldItalic",underlineItem:	"\u52A05E957DDA\u",	//"Underline",sampleLabel:	"\u6A23672C\u",	//"Sample",	// ***// Directory menu (if applicable)//directoryLabel:	"\u76EE9304\u",	//"Directory",// status fields/msgs//urlLabel:	"URL",//titleLabel:	"\u6A19984C\u",	//"Title",//isbnLabel:	"ISBN",//shortTitleLabel:	"\u77ED6A19984C\u",	//"Short Title",linesLabel:	"\u884C6578\u",	//"Lines",itemsLabel:	"\u55AE9805\u",	//"Items",pagesLabel:	"\u98019762\u",	//"Pages",// HREF popuploadImageItem:			"Load Image",// Notes menugetURLItem:		"\u629353D6002000550052004C\u",	//"getURL",findItem:		"\u5C0B627E\u",	//"Find",// keyboard (labels) [holding down cmd-]//"General"//quitItem:				"\u7D50675F\u",		//"Quit",stopLabel:				"\u505C6B62\u",		//"Stop",	// also in Progress Box//"Hide/Show"//"History"//saveLabel:			"Save",// FORM button defaultssubmitLabel:			"Submit",resetLabel:				"Reset",// parsing status, general errorsnoHeapStoreErr:	"\u8A1861B69AD44E0D8DB3\u",	//"out of heap/store?",errorOccurred:	"\u932F8AA4003A\u",	//"An error occured in",errorLabel:	"\u932F8AA4\u",	//"Error",parsingMsg:	"\u52566790\u",	//"Parsing",lengthMsg:	"\u95775EA6\u",	//"Length",untitledLabel:	"\u71216A19984C\u",	//"Untitled",compileErr:	"\u7DE88B6F932F8AA4\u",	//"compile err",evalErr:	"\u6C42503C932F8AA4\u",	//"eval err",unknownTagErr:	"UNKNOWN TAG",noNameErr:	"no NAME",missingNameValErr:	"missing NAME or VALUE",screenSmallErr:	"Screen smaller than",unknownValErr:	"unknown val",notFormErr:	"not inside FORM",processErr:	"\u86557406\u",	//"process",nameValErr:	"name or val err",notArrayOddErr:	"not an array (or odd length)",okMsg:	"OK",// graphicsImageConvertErr:	"\u571650CF8F4963DB932F8AA4003F\u",	//"Image conversion err?",notGIFerr:	"\u975E771F5BE60020004700490046\u",	//"not a real GIF",graphicHeading:	"\u975E65875B5772694EF6\u",	//"non-text object",noBinaryLenErr:		"no binary len?", // no binary length// packagesnotPkgErr:	"\u975E0020005000610063006B006100670065\u",	//"not a package",installPackage:	"\u88DD8A2D0020005000610063006B006100670065003F\u",	//"Do you want to install package?",replacePackage:	"\u53D64EE35DF25B5857284E4B0020005000610063006B006100670065003F\u",	//"Replace existing package?",installingPackage:	"\u6B63572888DD8A2D0020005000610063006B006100670065\u",	//"Installing Package",installErr:	"\u88DD8A2D932F8AA4\u",	//"Installation Failed",noPackageErr:	"\u71210020005000610063006B006100670065\u",	//"no package",//prefSetsnameExistsErr:			"name already exists",nameEmptyErr:			"name empty",// comm (http/serial) status messages and errors.  FSM abort, wait, etc.?openingLinkMsg:	"\u6253958B902363A5\u",	//"Opening link",lookupHostMsg:	"\u67E595B14E3B6A5F57305740\u",	//"Looking up host",cancelOpenMsg:	"\u53D66D8800226253958B902363A5002263074EE4\u",	//"Cancelling Open Link Request",instantiatingMsg:	"\u8D7759CB\u",	//"Instantiating",instantiateErr:	"\u8D7759CB932F8AA4\u",	//"Instantiate Err",IPaddressMsg:	"\u00490050002057305740\u",	//"IP Address",bindPortMsg:	"\u5EFA7ACB00200050006F00720074002000420069006E00640069006E0067\u",	//"Binding to port",connectingPortMsg:	"\u902363A581F357E0\u",	//"Connecting to port",connectingMsg:	"\u6B635728902363A5\u",	//"connecting",connectedMsg:	"\u5DF2902363A5\u",	//"connected",connectErr:	"\u902363A5932F8AA4\u",	//"Connect Err",disconnectingPortMsg:	"\u89E3966457E0902363A5\u",	//"Disconnecting port",disconnectingMsg:	"\u89E39664902363A5\u",	//"disconnecting",unbindingMsg:	"\u89E39664002000420069006E00640069006E0067\u",	//"UnBinding",disposingMsg:	"\u4E1F7F6E\u",	//"Disposing",closingLinkMsg:	"\u95DC95890020004C0069006E006B\u",	//"Closing link",sendingHTTPMsg:	"\u00480054005400500020547D4EE4\u",	//"HTTP Command",binaryLabel:	"\u4E8C90324F4D\u",	//"Binary",textLabel:	"\u65875B57\u",	//"Text",waitMsg:	"\u8ACB7A0D5019\u",	//"Please wait",terminalMsg:	"HTTP FSM is executing toward terminal state",goAwayLabel:	"\u96E2958B\u",	//"Go Away",redirectionMsg:	"\u91CD5C0E5411\u",	//"redirection",badRequestErr:	"\u932F8AA489816C42\u",	//"Bad request",forbiddenErr:	"Forbidden for unspecified reason",notFoundErr:	"\u627E4E0D5230\u",	//"Not found",internalErr:	"\u51675EFA4F3A670D6A5F\u",	//"Internal server",notImplementedErr:	"\u5C1A672A5B8C6210\u",	//"Not implemented",badGatewayErr:	"\u932F8AA400200047006100740065007700610079003B00200047006100740065007700610079002056DE61C971216548\u",	//"Bad gateway; invalid response from gateway or upstream server",noServiceErr:	"\u66AB664271216CD563D04F9B670D52D9\u",	//"Service temporarily unavailable",addCookiesMsg:	"\u52A0516500200043006F006F006B006900650073003F\u",	//"Add Cookies?",yesLabel:	"\u662F\u",	//"Yes",noLabel:	"\u4E0D662F\u",	//"No",inboxItem: 		"\u65364EF67BB1980576EE\u",	// "Inbox",inboxErr: 		"\u65364EF67BB1932F8AA4\u",	// "Inbox Error",clientErr:	"\u75286236\u",	//"client",serverErr:	"\u4F3A670D6A5F\u",	//"server",unknownHelperErr:	"\u535452A97A0B5F0F672A8A73003A\u",	//"unknown helper for",noHelperErr:	"\u7121535452A97A0B5F0F003A\u",	//"no helper for",notHTMLimageErr:		"cache: not HTML or Image?",helperItem:			"Helpers",		// View:Helpers -> list helper AppsoldVersionLabel:	"old version",	// in Install package dialognewVersionLabel:	"new version",createdLabel:		"created", 	// ...followed by date// !!!a1//Other OptionsacceptItem:				"Accept",acceptLangItem:			"Accept Language",ignoreFontFaceItem:		"Ignore FONT FACE",displayUnkTagItem:		"Display unknown <tags>",autoLinkExcItem:		"AutoLink Exceptions",//overview:ScheduleautoLinkLabel:			"AutoLink",		// ***monthlyItem:			"monthly",//GonewerHTMLitem:			"Newer HTML Cache Item",newerImageItem:			"Newer Image Cache Item",setHTMLitem:			"Set HTML Cache Item",setImageItem:			"Set Image Cache Item",}, // end Chinese// -----French: {	//Martin Jean <martinje@globetrotter.net>// File menufileLabel:				"Fich.",     //"File",		//***openLocationItem:		"Ouvrir la page",     //"Open Location",openNotesItem:			"Ouvrir des notes",     //"Open Notes",openInboxItem:			"Ouvrir corbeille InBox",     //"Open Inbox",openPaperbackItem:		"Ouvrir Paperback",     //"Open Paperback",paperbackItem:			"Paperback",WabumiUniItem:			"WabumiUni",openWabumiUniItem:		"Ouvrir WabumiUni",     //"Open WabumiUni",//openPersonalMediaItem:	"Ouvrir Personal Media",     //"Open Personal Media",//personalMediaItem:		"Personal Media",//storesItem:				"Stores",//workspacesItem:			"Workspaces",//docsItem:				"Docs",openNewtWorksItem:		"Ouvrir NewtWorks",     //"Open NewtWorks",newtworksItem:			"NewtWorks",openHTMLCacheItem:		"Ouvrir cache HTML",     //"Open HTML Cache",openImageCacheItem:		"Ouvrir cache d'images",     //"Open Image Cache",OpenNetHopperCacheItem:	"Ouvrir cache NetHopper",     //"Open NetHopper Cache",openDesktopItem:		"Ouvrir ordinateur",     //"Open Desktop",serial9600:				"Srie (9600)",     //"Serial(9600)",serial57600:			"Srie (57600)",     //"Serial(57600)",chooseMsg:				"Slectionner",     //"Choose",connectToMsg:			"connexion ",     //"connect to",ADSPlabel:				"ADSP",		// AppleTalk ***ADSPslabel:				"ADSPs",	//***closeDesktopItem:		"Fermer ordinateur",     //"Close Desktop",//openDemoURLsItem:		"Ouvrir URLs dmo",     //"Open Demo URLs",savePackageItem:		"Enreg. comme fichier",     //"Save as Package",saveHTMLNotes:			"Enreg. HTML dans Notes",     //"Save HTML to Notes",saveImageNotes:			"Enreg. image dans Notes",     //"Save Image to Notes",saveHTMLNewtworksItem:	"Enreg. HTML dans NewtWorks",     //"Save HTML to NewtWorks"saveImageNewtworksItem:	"Enreg. image dans NewtWorks",     //"Save Image to NewtWorks",saveBookNewtworksItem:	"Enreg. livre dans NewtWorks",     //"Save Book to NewtWorks",//saveTextDesktopItem:	"Envoyer texte vers ordinateur",     //"Save as Text to Desktop",removeCurrentBookItem:	"Supprimer le livre courant",     //"Remove Current Book",removeFromCacheItem:	"Supprimer de la cache",     //"Remove from Cache",resetHTTPlabel:			"Rtablir HTTP",     //"Reset HTTP",// View menuviewLabel:				"Voir",     //"View",	//***currentBookItem:		"Livre courant",     //"Current Book",//closeOverViewItem:		"Fermer la vue d'ensemble",     //"Close Overview",reloadItem:				"Recharger",     //"Reload",loadWithImagesItem:		"Charger les images",     //"Load with Images",//allImagesItem:			"Toutes les images",     //"All Images",loadLinksItem:			"Charger les liens",     //"Load Links",loadFramesItem:			"Charger les cadres", 	//"Load Frames",documentSourceItem:		"Source du document",     //"Document Source",//overviewsHTMLlabel:				"HTML",		// *** (also in i:General)imagesLabel:			"Images",	// *** (also in i:General)//HTMLCacheLabel:			"Cache HTML",     //"HTML Cache",//ImageCacheLabel:		"Cache d'images",     //"Image Cache",linksItem:				"Liens",     //"Links",framesItem:				"Cadres",				// "Frames",allLabel:				"Tous",     //"All",	//***loadItem:				"Charger",     //"Load",openItem:				"Ouvrir",     //"Open",processItem:			"Actions",     //"Process",displayURLitem:			"Afficher l'URL",     //"Display URL",saveOutlineItem:		"Enregistrer comme plan",     //"Save as Outline",addBookmarkItem:		"Ajouter un signet",     //"Add Bookmark",lockItem:				"Verrouiller",     //"Lock",unlockItem:				"Dverrouiller",   //"Unlock",deleteItem:				"Supprimer",     //"Delete",bookmarkLabelL:			"signet",     //"bookmark",bookmarksLabelL:		"signets",     //"bookmarks",itemItem:				"item",itemsItem:				"items",//SchedulescheduleLabel:			"Enreg.",     //"Schedule",	//***CancelSchedLabel:		"Annuler la programmation",     //"Cancel Schedule",startDateLabel:			"Dbutant",  //"Start Date",	// ***frequencyLabel:			"Frquence",  		//"Frequency",	//***immedItem:				"Maintenant",  		//"immediately",onceItem:				"Unique",  			//"once",hourlyItem:				"Chaque heure",  	//"hourly",twiceDailyItem:			"2 fois par jour",  //"twice daily",dailyItem:				"Quotidien",  		//"daily",daily5Item:				"Quotidien (sauf weekend)",  //"daily (except weekend)",weeklyItem:				"Hebdomadaire",  	//"weekly",// Go menugoLabel:				"Go",	// ***backItem:				"Prcdent",     //"Back",forwardItem:			"Suivant",     //"Forward",clearHistoryItem:		"Supprimer l'historique",     //"Clear History", // (book menu)homeItem:			"Accueil",  //"Home",	// i.e., startup URL// Bookmarks menubookmarksLabel:			"Signets",     //"Bookmarks",	// ***openBookmarksItem:		"Fureter/Programmer",     //"Browse/Schedule",removeBookmarkItem:		"Supprimer le signet",     //"Remove Bookmark",newtscapeBookmarkItem:	"Page exemples de Newt's Cape",     //"Newt's Cape Example Page",//removeAllItem:			"Tout supprimer",     //"Remove All",// info buttonaboutItem: 			"A propos",     //"About",helpItem:				"Aide",     	//"Help",prefsItem:				"Prfrences",     //"Prefs",registerItem:		"Enregistrer",  //"Register",	// open Register application (if installed)// about box/textintroductionText:		"Introduction",aboutCreate:			"Crer des livres Newton comprenant du texte, des graphiques,des tableaux et des formulaires  partir du HTML",     //"Create Newton books with text, graphics, tables and forms from HTML",rightsReserved:			"Tous droits rservs",     //"All Rights Reserved Worldwide",moreInfo:				"Pour plus d'information",     //"For More Information",webInfo:				"Site Web",     //"web info",thanksRegister:			"Merci de vous tre enregistr",     //"Thanks for registering",//bookLabel:				"Livre",     //"Book",//optionsLabel:			"Options",generalItem:			"Gnral",     //"General",appearanceItem:			"Apparence",     //"Appearance",encodingItem:			"Encodage",     //"Encoding",//(Process)displayItemItem:		"Afficher l'item",     //"Display Item",displayPageItem:		"Afficher la page",     //"Display Page",displayPage1Item:		"Afficher la page 1",     //"Display Page1",displayAllItem:			"Tout afficher",     //"Display All",cacheOnlyItem:			"Cache seulement",     //"Cache Only",saveNewtworksItem:		"Enregistrer dans NewtWorks",     //"Save to NewtWorks",//i:GeneralnoCacheItem:			"Pas de cache",     //"no cache",maxLabel:				"Max.",trustCacheItem:			"croire la cache?",     //"trust cache?",storeItem:				"Store",ignoreExpirationItem: 	"Ignorer l'expiration",     //"Ignore Expiration",emptyQuitItem:			"Vider en quittant?",     //"empty upon quit?",showItemOverview:		"Afficher dans les vues d'ensemble",  //"show items in overviews",autoloadFramesItem:		"Autocharger les cadres?",	//"autoload Frames?",mergeFramesItem:	"merge Frame source?",removeItem:				"Supprimer",     //"remove?",includeDesktopItem:		"Ordinateur?",     //"desktop?",fixISOItem:			"Correction Carac. ISO?",  //"Fix ISO Chars?",//openURLitem:			"ouvrir URL immdiatement?",     //"open URL immediately?",defaultItem:			"dfaut",     //"default",autoLoadItem:			"Auto-chargement?",     //"autoLoad?",firstOneItem:		"Premire",  //"first 1",	// Images autoload #rawImageItem:			"Original (non-converti)?",     //"original (unconverted)?",animatedItem:			"Animation?",     //"animated?",scaleImage:				"Rduire",     //"scale to fit?",resolutionLabel:		"Rs.",     //"Res.",bwItem:					"N&B(seuil)",     //"b&w(threshold)",gray4Item:				"4 gris",     //"4-gray",gray16Item:				"16 gris",     //"16-gray",unfiledBkMenuItem:		"Signets non classs dans menu",  //"Unfiled bookmarks in menu",cookiesLabel:			"Cookies",skipItem:				"Non",     //"Skip",askItem:				"Demand",     //"Ask",keepItem:				"Oui",     //"Keep",NSlabel:				"NewtonScript",compileItem:			"Compiler",     //"Compile",noneItem:				"Non",     //"none",docDoneLabel:			"Alerte",     //"Doc Done",pageSizeLabel:			"Taille",     //"Page Size",phelpItem:				"Aide",     //"help",portraitItem:			"Portrait",landscapeItem:			"Paysage",     //"landscape",fullitem:				"Plein",     //"full",pkgLabel:			"Pkg",		// Pkg (package) menu options	//***standaloneLabel:		"Livre autonome?",     //"Standalone book pkg?",	//***compressedItem:			"Compress",     //"Compressed",autoHideLabel:			"Auto-masquer",     //"Auto hide?",	//***//inetSetupLabel:			"Profil",     //"Inet Setup",NIEsetupLabel:			"Config NIE",  //"NIE Setup",	//***IPaidLabel:				"J'ai pay",     //"I Paid?",	//***//AuthenticatehostsItem:				"Htes",  //"Hosts",	//***hostLabel:				"Hte",     //"Host",	//***tempItem:				"Temp.", //temporary (new password category) vs. "Keep"proxyLabel:				"Proxy",nameLabel:				"Nom",     //"Name",	//***passwordLabel:			"MotDePasse",     //"Password",	//***authenticateLabel:		"Authentifier",     //"Authenticate",	//*** also SchedulerequireUserMsg:			"requiert l'authentification de l'usager",     //"requires user authentication",unauthErr:				"Non autoris; requiert l'authentification de l'usager",     //"Unauthorized; request requires user authentication",//i:General:Other OptionsotherOptionsLabel: 		"Autres options",     //"Other Options",	//***startupURLItem:			"URL dpart",     //"Startup URL",proxyURLitem:			"URL proxy",     //"Proxy URL",//proxyHostItem:			"Hte proxy",     //"Proxy Host",proxyOnlyItem: 			"Proxy seulement",     //"Proxy Only",proxyExItem:			"Exceptions proxy",     //"Proxy Exceptions",findTitleItem:			"Recherche:Titre",     //"Find.Title",findURLitem:			"Recherche:URL",     //"Find.URL",findMethodItem:			"Recherche:Mthode",     //"Find.Method",findDataItem:			"Recherche:Donnes",     //"Find.Data",findCheckItem:			"Recherche:CheckData",     //"Find:CheckData",UserAgentItem:			"Agent:Prfixe",     //"Agent Prefix",AgentSizeItem:			"Agent:Taille et Rs.",     //"Agent Size&Res.",helpISBNitem:			"Aide ISBN",     //"Help ISBN",autoLoginItem:			"Connexion automatique",     //"Auto Login",dontShowNCItem: 		"Masquer Newt's Cape",     //"Don't Show Newt's Cape",dontCloseBookItem:		"Ne pas fermer le livre",     //"Don't Close Book",ignoreMETArefresh:		"Ignorer les recharges META",  //"Ignore META Refresh",ignoreTablesItem:		"Ignorer les tableaux",     //"Ignore Tables",includeFramesItem:		"Inclure les cadres",	//"Include Frames",tagFrameItem:			"Assigner les FRAME  des tiquettes",  //"map FRAME to tag",	missingImgItem:			"IMG: pas de ALT",  //"IMG: no ALT",NCmenuItem:				"Bouton Newt's Cape",     //"Newt's Cape button",bkoverItem:				"Signets dans vue d'ensemble seul.",     //"Bookmarks in overview only",overfloatItem:			"Vue d'ensemble fixe",     //"Overview not floating",changeKbdItem:			"Modifier quivalents clavier",     //"Change keyboard keys",nwSummaryItem:			"HTML NewtWorks via Sommaire",     //"NewtWorks HTML via Summary",mailtoBodyItem:			"mailto: corps",  //"mailto: body",bookWidthItem:			"Livre: Largeur de page",     //"Book Page Width",bookHeightItem:			"Livre: Hauteur de page",     //"Book Page Height",bookBaseItem:			"Livre: BASE",     //"Book BASE",bookISBNitem:			"Livre: ISBN",     //"Book ISBN",booksTitleItem:			"Livre: Titre court",     //"Book ShortTitle",bookTitleItem:			"Livre: Titre",     //"Book Title",bookContentsTitle:		"Sommaire",  //"Contents",		// title of TOC//PrefSetsmainPrefSetLabel:		"Prefs. dfaut", //"Main PrefSet",prefSetItem:			"Configuration", //"PrefSet",renameItem:				"Renommer",   //"Rename",duplicateItem:			"Dupliquer",  //"Duplicate",resetAllitem:			"Dfaut",     //"Reset All",//i:AppearancetagLabel:				"ti.",     	//"Tag",	// ***missingErr:				"manquant",     //"missing",defaultsLabel:			"Dfauts",     //"Defaults",	// ***indentsLabel:			"Alinas",     //"Indents",	// ***aboveLabel:				"Avant",     //"Above",		// ***leftLabel:				"Gauche",     //"Left",	// ***belowLabel:				"Aprs",     //"Below",	// ***splitLabel:				"Spa.",     //"Split",	// ***alignLabel:				"Alig.",     //"Align",	// ***rightItem:				"Droite",     //"Right",centerItem:				"Centre",     //"Center",justifyItem:			"Justifi",     //"Justify",fontLabel:				"Police",     //"Font",	// ***familyLabel:			"Famille",     //"Family",	// ***sizeLabel:				"Corps",     //"Size",	// ***faceLabel:				"Style",     //"Face",	// ***plainItem:				"Standard",     //"Plain",boldItem:				"Gras",     //"Bold",italicItem:				"Italique",     //"Italic",boldItalicItem:			"Gras Italique",     //"BoldItalic",underlineItem:			"Soulign",     //"Underline",sampleLabel:			"Exemple",     //"Sample",	// ***// Directory menu (if applicable)//directoryLabel:			"Dossier",     //"Directory",// status fields//urlLabel:				"URL",//titleLabel:				"Titre",     //"Title",//isbnLabel:				"ISBN",//shortTitleLabel:		"Titre abrg",     //"Short Title",linesLabel:				"Lignes",     //"Lines",itemsLabel:				"Items",pagesLabel:				"Pages",// HREF popuploadImageItem:			"Charger l'image",     //"Load Image",// Notes menugetURLItem:				"URL",     //"getURL",findItem:				"Chercher",     //"Find",// keyboard (labels) [holding down cmd-]//"General":			"Gnral",//quitItem:				"Quitter",stopLabel:				"Stop",	// also in Progress Box//"Hide/Show":			"Affichage",//"History":			"Historique",//saveLabel:			"Enregistrer",// FORM button defaultssubmitLabel:			"Envoi",resetLabel:				"RAZ",// parsing status, general errorsnoHeapStoreErr:			"mmoire/espace insuffisant",     //"out of heap/store?",errorOccurred:			"Une erreur est survenue dans",     //"An error occured in",errorLabel:				"Erreur",     //"Error",//parsingMsg:			"Parsing",lengthMsg:				"Longueur",     //"Length",untitledLabel:			"Sans titre",     //"Untitled",compileErr:				"erreur de compilation",     //"compile err",evalErr:				"erreur d'valuation",     //"eval err",unknownTagErr:			"TIQUETTE INCONNUE",     //"UNKNOWN TAG",noNameErr:				"pas de NOM",     //"no NAME",missingNameValErr:		"NOM ou VALEUR manquant",     //"missing NAME or VALUE",screenSmallErr:			"cran plus petit que",     //"Screen smaller than",unknownValErr:			"valeur inconnue",     //"unknown val",notFormErr:				"pas dans la FORME",     //"not inside FORM",processErr:				"action",     //"process",nameValErr:				"erreur de nom ou de valeur",     //"name or val err",notArrayOddErr:			"pas un tableau (ou longueur incorrecte)",     //"not an array (or odd length)",okMsg:					"OK",// graphicsImageConvertErr:		"Erreur de conversion image?",     //"Image conversion err?",notGIFerr:				"pas un vrai GIF",     //"not a real GIF",graphicHeading:			"objet non-textuel",     //"non-text object",noBinaryLenErr:			"pas taille binaire?",  //"no binary len?", // no binary length from server// packagesnotPkgErr:				"pas un fichier",     //"not a package",installPackage:			"Voulez-vous installer le fichier?",     //"Do you want to install package?",replacePackage:			"Remplacer le fichier existant?",     //"Replace existing package?",installingPackage:		"Installation du fichier",     //"Installing Package",installErr:				"L'installation a choue",     //"Installation Failed",noPackageErr:			"pas de fichier",     //"no package",//prefSetsnameExistsErr:			"nom dj utilis",  //"name already exists",nameEmptyErr:			"nom vide",  //"name empty",// comm (http/serial) status messages and errors.  FSM abort, wait, etc.?openingLinkMsg:			"Ouverture du lien",     //"Opening link",lookupHostMsg:			"Recherche de l'hte",     //"Looking up host",cancelOpenMsg:			"Annulation de la requte",     //"Cancelling Open Link Request",instantiatingMsg:		"Instantiating",instantiateErr:			"Instantiate Err",IPaddressMsg:			"IP Address",bindPortMsg:			"Liaison au port",     //"Binding to port",connectingPortMsg:		"Connexion au port",     //"Connecting to port",connectingMsg:			"connexion",     //"connecting",connectedMsg:			"connect",     //"connected",connectErr:				"Connect Err",disconnectingPortMsg:	"Dconnexion du port",     //"Disconnecting port",disconnectingMsg:		"Dconnexion",     //"disconnecting",unbindingMsg:			"Libration",     //"UnBinding",disposingMsg:			"Nettoyage",     //"Disposing",closingLinkMsg:			"Fermeture du lien",     //"Closing link",sendingHTTPMsg:			"Commande HTTP",     //"HTTP Command",binaryLabel:			"Binaire",     //"Binary",textLabel:				"Texte",     //"Text",waitMsg:				"Veuillez patienter",     //"Please wait",terminalMsg:			"HTTP FSM excut en mode terminal",     //"HTTP FSM is executing toward terminal state",goAwayLabel:			"Relchement",     //"Go Away",redirectionMsg:			"redirection",badRequestErr:			"Mauvaise requte",     //"Bad request",forbiddenErr:			"Impossible pour raison inconnue",     //"Forbidden for unspecified reason",notFoundErr:			"Introuvable",     //"Not found",internalErr:			"Serveur interne",     //"Internal server",notImplementedErr:		"Non implant",     //"Not implemented",badGatewayErr:			"Mauvaise passerelle; rponse invalide de la passerelle ou du serveur en amont",     //"Bad gateway; invalid response from gateway or upstream server",noServiceErr:			"Service temporairement hors d'usage",     //"Service temporarily unavailable",addCookiesMsg:			"Ajouter le Cookie",     //"Add Cookies?",yesLabel:				"Oui",     //"Yes",noLabel:				"Non",     //"No",inboxItem:				"Inbox",inboxErr:				"Erreur Inbox",     //"Inbox Error",clientErr:				"client",serverErr:				"serveur",     //"server",unknownHelperErr:		"auxiliaire inconnu pour",     //"unknown helper for",noHelperErr:			"pas d'auxiliaire pour",     //"no helper for",notHTMLimageErr:		"cache: not HTML or Image?",helperItem:			"Helpers",		// View:Helpers -> list helper AppsoldVersionLabel:	"old version",	// in Install package dialognewVersionLabel:	"new version",createdLabel:		"created", 	// ...followed by date// !!!a1acceptItem:				"Accepter",     //"Accept",acceptLangItem:			"Accepter la langue",     //"Accept Language",ignoreFontFaceItem:		"Ignorer FONT FACE",     //"Ignore FONT FACE",displayUnkTagItem:		"Afficher les <tiquettes> inconnues",     //"Display unknown <tags>",autoLinkExcItem:		"Exceptions d'autolien",     //"AutoLink Exceptions",//overview:ScheduleautoLinkLabel:			"Autolien",		// *** "AutoLink",monthlyItem:			"mensuel",     //"monthly",//GonewerHTMLitem:			"Item cache HTML rcent",     //"Newer HTML Cache Item",newerImageItem:			"Item cache image rcent",    //"Newer Image Cache Item",setHTMLitem:			"Slectionner item cache HTML",     //"Set HTML Cache Item",setImageItem:			"Slectionner item cache image",     //"Set Image Cache Item",}, // end FrenchRussian: {	//"Evgueni A. Natalenko" <adam@spb.cityline.ru>//Last addshelperItem:		     "Helpers",	                                                    // View:Helpers -> list helper AppsoldVersionLabel:	 "\u00D200DA2021F7FF2021FB02\u \u201A00C2F7FF00D200CBFB02\u",	// old version in Install package dialognewVersionLabel:	 "\u00CC00D3201A2021FB02\u \u201A00C2F7FF00D200CBFB02\u",       //new versioncreatedLabel:		 "\u00D200D300C12030202100CC\u", 	                            // created...followed by date// File menufileLabel:				"\u042404300439043B\u",			//*** FileopenLocationItem:		"\u041E0442043A0440\u. URL",	// Open LocationopenNotesItem:			"\u041E0442043A0440\u. Notes",	// Open NotesopenInboxItem:			"\u041E0442043A0440\u. Inbox",	// Open Inbox openPaperbackItem:		"\u041E0442043A0440\u. Paperback",	// Open PaperbackpaperbackItem:			"Paperback",WabumiUniItem:			"WabumiUni",openWabumiUniItem:		"\u041E0442043A0440\u. WabumiUni",	// Open WabumiUni //openPersonalMediaItem:	"\u041E0442043A0440\u. Personal Media",//personalMediaItem:		"Personal Media",//workspacesItem:			"Workspaces",//docsItem:				"Docs",//storesItem:			"Stores",openNewtWorksItem:		"\u041E0442043A0440\u. NewtWorks",	   // Open NewtWorks ItemopenHTMLCacheItem:		"\u041E0442043A0440\u. HTML Cache",    // Open HTML CacheopenImageCacheItem:		"\u041E0442043A0440\u. \u0418043C043804340436\u Cache",OpenNetHopperCacheItem:	"\u041E0442043A0440\u. NetHopper Cache", openDesktopItem:		"\u041E0442043A0440\u. Desktop",	   // Open Desktopserial9600:				"\u04210435044004380430043B\u(9600)",  // Serial(9600)serial57600:			"\u04210435044004380430043B\u(57600)", // Serial(57600)chooseMsg:				"\u0412044B0431044004300442044C\u",	   // ChooseconnectToMsg:			"\u0421043E04350434\u. \u0441\u...",   // connect to ADSPlabel:				"ADSP",				                   // AppleTalk ***ADSPslabel:				"ADSPs",			                   //***closeDesktopItem:		"\u04170430043A0440\u. Desktop",       // Close Desktop //openDemoURLsItem:		"\u041E0442043A0440\u. Demo URLs",savePackageItem: 	    "\u0421043E04450440\u. \u043A0430043A\u \u041F0430043A04350442\u",saveHTMLNotes:	        "\u0421043E04450440\u. HTML \u0432\u Notes",saveImageNotes:	        "\u0421043E04450440\u. \u0418043C043804340436\u \u0432\u Notes",        // Save Image to saveHTMLNewtworksItem:	"\u0421043E04450440\u. HTML â NewtWorks",                               // Save HTML to saveImageNewtworksItem:	"\u0421043E04450440\u. \u0418043C043804340436\u \u0432\u NewtWorks",    // Save Image to saveBookNewtworksItem:	"\u0421043E04450440\u. \u041A043D043804330443\u \u0432\u NewtWorks",	// Save Book to //saveTextDesktopItem:	"\u0421043E04450440\u. \u043A0430043A\u \u04220435043A04410442\u \u0432\u Desktop",	//Save as Text toremoveCurrentBookItem:	"\u042304340430043B\u. \u04220435043A044304490443044E\u \u041A043D043804330443\u",  // Remove Current Book removeFromCacheItem:	"\u042304340430043B\u. \u04380437\u Cache", // Remove from CacheresetHTTPlabel:			"\u041E0447043804410442\u. HTTP",			// Reset HTTP // View menuviewLabel:				"\u041204380434\u",					                                           //*** ViewcurrentBookItem:		"\u04220435043A044304490430044F\u \u043A043D043804330430\u ",                  // Current Book //closeOverViewItem:    "\u04170430043A0440\u. \u041E0433043B04300432043B0435043D04380435\u",          // Close Overview reloadItem:		        "\u041F0435044004350437043004330440\u.",		// Reload loadWithImagesItem:     "\u041704300433044004430437\u. \u0441\u \u0418043C0438043404360430043C0438\u", // Load with Images //allImagesItem:	    "\u041204410435\u \u0418043C0438043404360438\u",		                       // All Images loadLinksItem:	        "\u041704300433044004430437\u. \u04210432044F04370438\u",	                   // Load Links loadFramesItem:	        "\u041704300433044004430437\u. \u0424044004350439043C044B\u",                  // Load Frames documentSourceItem:     "\u041804410442043E0447043D0438043A\u",		                                   // Document Source//overviewsHTMLlabel:				"HTML",			// *** (also in i:General)imagesLabel:			"Images",			// *** Images //HTMLCacheLabel:		"HTML Cache",			// HTML Cache //ImageCacheLabel:		"Image Cache",		// Image Cache linksItem:				"\u04210432044F04370438\u",	            // Links framesItem:				"\u00EEF7FF00C200C800CF02DA\u",			// Frames allLabel:				"\u0424044004350439043C044B\u",			//*** AllloadItem:				"\u041704300433044004430437\u.",			// Load openItem:				"\u041E0442043A0440\u.",		            // Open, also in Notes processItem:			"\u041F0440043E0446043504410441\u.",		// Process , also About,i displayURLitem:	        "\u041F043E043A04300437\u. URL",	        // Display URL,also HREF popup saveOutlineItem:	    "\u0421043E04450440\u. \u043A0430043A\u \u041F043B0430043D\u ",     // Save as OutlineaddBookmarkItem:	    "\u0414043E043104300432\u. \u04170430043A043B04300434043A0443\u",	// Add Bookmark lockItem:				"\u0411043B043E043A\u.",	                // Lock unlockItem:				"\u0420043004370431043B043E043A\u.",		// Unlock deleteItem:				"\u042304340430043B\u.",		            // Delete bookmarkLabelL:			"\u04370430043A043B04300434043A0430\u",		// bookmark bookmarksLabelL:		"\u04370430043A043B04300434043A0438\u",		// bookmarks itemItem:				"\u043F0443043D043A0442\u",		            // item itemsItem:				"\u043F0443043D043A0442044B\u",		        // items // SchedulescheduleLabel:			"\u04170430043404300442044C\u",			                              //*** ScheduleCancelSchedLabel:	    "\u041E044104420430043D043E0432\u. \u0417043004340430043D04380435\u", // Cancel SchedulestartDateLabel:			"\u04210442043004400442\u/\u0434043004420430\u",                      // *** Start DatefrequencyLabel:			"\u0427043004410442043E04420430\u",                                   //*** FrequencyimmedItem:				"\u043D0435043C04350434043B0435043D043D043E\u",	                      // immediatelyonceItem:				"\u043E0434043D043004360434044B\u",	                                  // oncehourlyItem:				"\u043A043004360434044B0439\u \u044704300441\u",                      // hourlytwiceDailyItem:			"\u04340432043004360434044B\u \u0432\u \u04340435043D044C\u",         // twice dailydailyItem:				"\u0435043604350434043D04350432043D043E\u",                                   // dailydaily5Item:	            "\u0435043604350434043D04350432043D043E\u (\u043A0440043E043C0435\u \u0432044B0445\u.)",  //daily (ex.weekend)weeklyItem:		        "\u043504360435043D043504340435043B044C043D043E\u",	                  // weekly// Go menugoLabel:				"Go",					                                               // *** GobackItem:				"\u041D0430043704300434\u",	                                           // BackforwardItem:			"\u0412043F0435044004350434\u",	                                       // ForwardclearHistoryItem:		"\u041E0447043804410442\u. \u041804410442043E04400438044E\u",          // Clear History homeItem:				"\u0414043E043C043E0439\u",				                               // Home// Bookmarks menubookmarksLabel:			"\u04170430043A043B04300434043A0438\u",                                 // *** BookmarksopenBookmarksItem:	    "\u041F0440043E0441043C\u./\u04170430043404300442044C\u",               // Browse/Schedule removeBookmarkItem:		"\u042304340430043B\u. \u04170430043A043B04300434043A0443\u ",          // Remove Bookmark newtscapeBookmarkItem:	"Newt's Cape Example Page",//removeAllItem:		"\u042304340430043B\u. \u041204410435\u",		                        // Remove All // info buttonaboutItem: 				"About",helpItem:				"Help",prefsItem:				"Prefs",registerItem:			"Register",			// open Register// about box/textintroductionText:		"Introduction",aboutCreate:			"CreateNewton books with text, graphics, tables andforms from HTML",	//***rightsReserved:			"All Rights Reserved Worldwide",moreInfo:				"For More Information",webInfo:				"web info",thanksRegister:			"\u0421043F0430044104380431043E\u!",//bookLabel:			"\u041A043D043804330430\u",			// Book //optionsLabel:			"\u041E043F044604380438\u",					// Options generalItem:			"\u0413043B04300432043D043E0435\u", 		// General appearanceItem:			"\u0412043D04350448\u. \u041204380434\u",	// Appearance encodingItem:			"\u041F043504400435043A043E043404380440043E0432043A0430\u",	// Encoding //(Process)displayItemItem:		"\u041F043E043A04300437\u. \u041F0443043D043A0442\u",       	       // Display ItemdisplayPageItem:	    "\u041F043E043A04300437\u. \u0421044204400430043D043804460443\u",     // Display PagedisplayPage1Item:		"\u041F043E043A04300437\u. \u042104420440\u.1",	                       // Display Page1displayAllItem:		    "\u041F043E043A04300437\u. \u041204410435\u",	                       // Display AllcacheOnlyItem:		    "\u0422043E043B044C043A043E\u \u041A044D0448\u",                       // Cache OnlysaveNewtworksItem:		"\u0421043E04450440\u. \u0432\u NewtWorks",                            // Save to NewtWorks//i:GeneralnoCacheItem:			"no cache",maxLabel:				"Max.",			// after 10 items -- MaximumtrustCacheItem:			"trust cache?",storeItem:				"Store",ignoreExpirationItem: 	"Ignore Expiration",emptyQuitItem:			"empty upon quit?",showItemOverview:		"show items in overviews",autoloadFramesItem:		"autoload Frames?",	// HTMLmergeFramesItem:		"merge Frame source?",	// HTMLremoveItem:				"remove?",		// <!-- HTML comments-->includeDesktopItem:		"desktop?",			// HTMLfixISOItem:				"Fix ISO Chars?",	// HTML//openURLitem:			"open URL immediately?",defaultItem:			"default",			// Store (also Schedule:NIE setup)autoLoadItem:			"autoLoad?",		// imagesfirstOneItem:			"first 1",			// Images autoload #rawImageItem:			"original (unconverted)?", // imagesanimatedItem:			"animated?",		// imagesscaleImage:				"scale to fit?",	// images//"Scale bitmaps to fit?"	// 1.xresolutionLabel:		"Res.",	// resolution ***bwItem:				    "b&w(threshold)",gray4Item:				"4-gray",gray16Item:				"16-gray",unfiledBkMenuItem:		"Unfiled bookmarks in menu",cookiesLabel:			"Cookies",		//***skipItem:				"Skip",askItem:				"Ask",keepItem:				"Keep",			//*** also AuthenticateNSlabel:				"NewtonScript",compileItem:			"Compile",noneItem:				"none",			// also Schedule:Frequency, Authenticate:HostsdocDoneLabel:			"Doc Done",		//*** soundspageSizeLabel:			"Page Size",	//***phelpItem:				"help",portraitItem:			"portrait",landscapeItem:			"landscape",fullitem:				"full",pkgLabel:				"Pkg",			// package ***standaloneLabel:		"Standalone book pkg?",		// ***compressedItem:			"Compressed",autoHideLabel:			"Auto hide?",	//***//inetSetupLabel:		"Inet Setup",		NIEsetupLabel:			"NIE Setup",		//*** also ScheduleIPaidLabel:				"I Paid?",			//***//AuthenticatehostsItem:				"Hosts",	//***hostLabel:				"Host",		//***tempItem:				"Temp.", 	// temporary (only for session) vs. "Keep"proxyLabel:				"Proxy",nameLabel:				"Name",		//***passwordLabel:			"Password",	//***authenticateLabel:		"Authenticate",	// *** also SchedulerequireUserMsg:		    "\u0442044004350431044304350442\u \u043F0440043E043204350440043A0438\u \u043F043E043B044C0437043E0432043004420435043B044F\u",           //req_user_authent unauthErr:			    "\u041D0435043004320442043E044004380437043E04320430043D\u: \u04370430043F0440043E0441\u \u0442044004350431044304350442\u \u043F0440043E043204350440043A0438\u \u043F043E043B044C0437043E0432043004420435043B044F\u",//Unauthorized; req_requires_user_auth//i:General:Other OptionsotherOptionsLabel: 		"Other Options",	// ***startupURLItem:			"Startup URL",proxyURLitem:			"Proxy URL",proxyHostItem:			"Proxy Host",		// 1.xproxyOnlyItem: 			"Proxy Only",proxyExItem:			"Proxy Exceptions",findTitleItem:			"Find.Title",findURLitem:			"Find.URL",findMethodItem:			"Find.Method",findDataItem:			"Find.Data",findCheckItem:			"Find:CheckData",UserAgentItem:			"Agent Prefix",AgentSizeItem:			"Agent Size&Res.",helpISBNitem:			"Help ISBN",autoLoginItem:			"Auto Login",dontShowNCItem: 		"Don't Show Newt's Cape",dontCloseBookItem:		"Don't Close Book",ignoreMETArefresh:		"Ignore META Refresh",ignoreTablesItem:		"Ignore Tables",includeFramesItem:		"Include Frames",tagFrameItem:			"map FRAME to tag",missingImgItem:			"IMG: no ALT",NCmenuItem:				"Newt's Cape button",bkoverItem:				"Bookmarks in overview only",overfloatItem:			"Overview not floating",changeKbdItem:			"Change keyboard keys",nwSummaryItem:			"NewtWorks HTML via Summary",mailtoBodyItem:			"mailto: body",bookWidthItem:			"Book Page Width",bookHeightItem:			"Book Page Height",bookBaseItem:			"Book BASE",bookISBNitem:			"Book ISBN",booksTitleItem:			"Book ShortTitle",bookTitleItem:			"Book Title",bookContentsTitle:		"\u041E0433043B04300432043B0435043D04380435\u:", // Contents //PrefSetsmainPrefSetLabel:		"\u041E0441043D043E0432043D043E0439\u PrefSet",	// Main PrefSet prefSetItem:			"PrefSet",renameItem:				"\u041F0435044004350438043C0435043D\u.",	    //  Rename duplicateItem:			"\u0421043E04370434\u. \u041A043E043F0438044E\u",   // Duplicate resetAllitem:			"\u041E0447043804410442\u. \u041204410435\u",	// Reset All // i:AppearancetagLabel:				"Tag",			// ***missingErr:				"missing",		// missing Hx tagdefaultsLabel:			"Defaults",		// ***indentsLabel:			"Indents",		// ***aboveLabel:				"Above",		// ***leftLabel:				"Left",			// ***belowLabel:				"Below",		// ***splitLabel:				"Split",		// ***alignLabel:				"Align",		// ***rightItem:				"Right",centerItem:				"Center",justifyItem:			"Justify",fontLabel:				"Font",			// ***familyLabel:			"Family",		// ***sizeLabel:				"Size",			// ***faceLabel:				"Face",			// ***plainItem:				"Plain",boldItem:				"Bold",italicItem:				"Italic",boldItalicItem:			"BoldItalic",underlineItem:			"Underline",sampleLabel:			"Sample",		// ***// Directory menu (if applicable)//directoryLabel:		"\u041A043004420430043B043E0433\u",			// Directory // status fields/msgs//urlLabel:				"URL",//titleLabel:			"Title",//isbnLabel:			"ISBN",//shortTitleLabel:		"Short Title",linesLabel:				"Lines",itemsLabel:				"Items",pagesLabel:				"Pages",// HREF popuploadImageItem:			"\u041704300433044004430437\u. \u0418043C043804340436\u",  // Load Image // Notes menugetURLItem:				"getURL",findItem:				"\u041D0430043904420438\u",		// Find // keyboard (labels) [holding down cmd-]//"General"//quitItem:				"\u0412044B0445043E0434\u!",	// Quit stopLabel:				"\u04210442043E043F\u!",		// Stop //"Hide/Show"//"History"//saveLabel:			"\u0421043E04450440\u.",		// Save // FORM button defaultssubmitLabel:			"\u041E0442043F044004300432\u.",		// Submit resetLabel:				"\u041E0447043804410442\u.",			// Reset // parsing status, general errorsnoHeapStoreErr:			"out of heap/store?",errorOccurred:	        "\u041E044804380431043A0430\u \u043F0440043E04380437043E0448043B0430\u \u0432\u...", // An error occured in errorLabel:				"\u041E044804380431043A0430\u",        // Error parsingMsg:				"Parsing",lengthMsg:				"Length",untitledLabel:			"Untitled",compileErr:				"compile err",evalErr:				"eval err",unknownTagErr:			"UNKNOWN TAG",noNameErr:				"no NAME",missingNameValErr:		"missing NAME or VALUE",screenSmallErr:			"Screen smaller than",unknownValErr:			"unknown val",notFormErr:				"not inside FORM",processErr:				"process",nameValErr:				"name or val err",notArrayOddErr:			"not an array (or odd length)",okMsg:					"OK",// graphicsImageConvertErr:		"Image conversion err?",notGIFerr:				"not a real GIF",graphicHeading:			"non-text object",noBinaryLenErr:			"no binary len?", // no binary length// packagesnotPkgErr:				"not a package",installPackage:	        "\u0425043E0442043804420435\u \u0443044104420430043D043E043204380442044C\u \u041F0430043A04350442\u?", // Do you want to install package?replacePackage:	        "\u04170430043C0435043D04380442044C\u \u04410443044904350441044204320443044E044904380439\u \u041F0430043A04350442\u?", // Replace existing package?installingPackage:	    "\u0423044104420430043D043E0432043A0430\u \u041F0430043A043504420430\u...",      // Installing Package... installErr:			    "\u0423044104420430043D043E0432043A0430\u \u043F04400435044004320430043D0430\u!",  // Installation Failed noPackageErr:			"no package",//prefSetsnameExistsErr:			"name already exists",nameEmptyErr:			"name empty",// comm (http/serial) status messages and errors.  FSM abort, wait, etc.?openingLinkMsg:		    "\u041E0442043A0440044B044204380435\u \u04210432044F04370438\u...", // Opening link lookupHostMsg:			"\u041F043E04380441043A\u \u0445043E044104420430\u...",  // Looking up hostcancelOpenMsg:			"\u041F04400435043A0440043004490435043D04380435\u \u04170430043F0440043E04410430\u \u043D0430\u \u041E0442043A0440044B044204380435\u \u04210432044F04370438\u...",// Cancelling Open Link RequestinstantiatingMsg:		"\u041F043E04340442043204350440043604340435043D04380435\u...", // Instantiating instantiateErr:	        "\u041E044804380431043A0430\u \u041F043E04340442043204350440043604340435043D0438044F\u ",	// Instantiate Err IPaddressMsg:			"\u04100434044004350441\u IP",		                                                        // IP AddressbindPortMsg:	        "\u04210432044F0437044B04320430043D04380435\u \u0441\u \u043F043E04400442043E043C\u...",    // Binding to port connectingPortMsg:		"\u0421043E043504340438043D0435043D04380435\u \u0441\u \u043F043E04400442043E043C\u...",    // Connecting to port connectingMsg:			"\u0441043E043504340438043D0435043D04380435\u",                                             // connectingconnectedMsg:			"\u0441043E043504340438043D0435043D\u",                                                     // connectedconnectErr:				"\u041E044804380431043A0430\u \u0421043E043504340438043D0435043D0438044F\u!",               // Connect Err disconnectingPortMsg:	"\u041E04420441043E043504340438043D0435043D04380435\u \u041F043E044004420430\u...",         // Disconnecting port disconnectingMsg:		"\u043E04420441043E043504340438043D0435043D04380435\u",                                     // disconnectingunbindingMsg:			"\u0420043004370440044B0432\u \u04410432044F04370438\u \u0441\u \u043F043E04400442043E043C\u...",  // UnBinding disposingMsg:			"\u04230441044204400430043D0435043D04380435\u...",       // Disposing closingLinkMsg:			"\u04170430043A0440044B044204380435\u \u04410432044F04370438\u...",    // Closing link sendingHTTPMsg:			"HTTP Command",binaryLabel:			"Binary",textLabel:				"Text",waitMsg:				"\u041F043E04360430043B04430439044104420430\u, \u043F043E0434043E04360434043804420435\u...",   // Please wait terminalMsg:			"HTTP FSM \u04380441043F043E043B043D044F043504420441044F\u...",      // HTTP FSM is executing goAwayLabel:			"\u04230445043E04340438\u...",                                       // Go AwayredirectionMsg:			"redirection",badRequestErr:			"\u041E044804380431043E0447043D044B0439\u \u04370430043F0440043E0441\u!",   // Bad request forbiddenErr:	        "\u04170430043F0440043504490435043D\u \u0434043B044F\u \u043D0435043E0431043E0437043D043004470435043D043D044B0445\u \u0430044004330443043C0435043D0442043E0432\u!",// Forbidden for unspecified reason notFoundErr:			"\u041D0435\u \u043D0430043904340435043D\u!",    // Not foundinternalErr:			"\u042104350440043204350440\u: \u0412043D0443044204400435043D043D044F044F\u \u043E044804380431043A0430\u!",  // Internal server notImplementedErr:		"\u041D0435\u \u04380441043F043E043B043D0435043D\u!",	// Not implemented badGatewayErr:			"\u041F043B043E0445043E0439\u \u0448043B044E0437\u: \u043E044804380431043E0447043D044B0439\u \u043E0442043204350442\u \u043E0442\u \u0448043B044E04370430\u \u0438043B0438\u \u044304340430043B0435043D043D043E0433043E\u \u0441043504400432043504400430\u!",										 // Bad gateway; invalid response from gateway or upstream servernoServiceErr:			"\u042104350440043204380441\u \u043204400435043C0435043D043D043E\u \u043D04350434043E044104420443043F0435043D\u!",// Service temporarily unavailableaddCookiesMsg:			"Add Cookies?",yesLabel:				"\u04140430\u",				//YesnoLabel:				"\u041D04350442\u",			//NoinboxItem:				"Inbox",		// destination for packageinboxErr:				"\u041E044804380431043A0430\u Inbox!",		// Inbox ErrorclientErr:				"client",serverErr:				"server",unknownHelperErr:		"unknown helper for",noHelperErr:			"no helper for",notHTMLimageErr:		"cache: not HTML or Image?",//Other OptionsacceptItem: "\u00E8F7FF00CB00CCFB0200DA00B8\u",acceptLangItem: "\u041F04400438043D044F0442044C\u \u044F0437044B043A\u",ignoreFontFaceItem: "\u04180433043D043E044004380440043E043204300442044C\u FONT FACE",displayUnkTagItem: "\u041F043E043A0430043704300442044C\u \u043D0435043804370432043504410442043D044B0435\u <tags>",autoLinkExcItem: "\u04180441043A043B044E04470435043D0438044F\u AutoLink",//overview:ScheduleautoLinkLabel: "AutoLink", // ***monthlyItem: "\u043504360435043C04350441044F0447043D043E\u",//GonewerHTMLitem: "\u041D043E043204350439044804380439\u \u043E0431044A0435043A0442\u HTML Cache",newerImageItem: "\u041D043E043204350439044804380439\u \u043E0431044A0435043A0442\u Image Cache",setHTMLitem: "\u042304410442\u. \u043E0431044A0435043A0442\u HTML Cache",setImageItem: "\u042304410442\u. \u043E0431044A0435043A0442\u Image Cache",}, // end RussianKorean: {	// "Vincent Lee" <jacobins@chollian.net>// File menufileLabel:				"\uc6c4c0cf\u",				//*** openLocationItem:		"\uc6e4c0ccc1f60020bfadb1e2\u",openNotesItem:			"Notes \ubfadb1e2\u",openInboxItem:			"Inbox \ubfadb1e2\u",openPaperbackItem:		"Paperback \ubfadb1e2\u",paperbackItem:			"Paperback",WabumiUniItem:			"WabumiUni",openWabumiUniItem:		"WabumiUni \ubfadb1e2\u",//openPersonalMediaItem:"Open Personal Media",//personalMediaItem:	"Personal Media",//workspacesItem:		"Workspaces",//docsItem:				"Docs",//storesItem:			"Stores",openNewtWorksItem:		"NewtWorks \ubfadb1e2\u",newtworksItem:			"NewtWorks",openHTMLCacheItem:		"HTML \uc4b3bdac0020bfadb1e2\u",openImageCacheItem:		"Image \uc4b3bdac0020bfadb1e2\u",OpenNetHopperCacheItem:	"NetHopper \uc4b3bdac0020bfadb1e2\u",openDesktopItem:		"Desktop \ubfadb1e2\u",serial9600:				"\ubdc3b8aebef3\u(9600)",serial57600:			"\ubdc3b8aebef3\u(57600)",chooseMsg:				"\ubcb1c5c3\u",connectToMsg:			"\ubfacb0e1\u",ADSPlabel:				"ADSP",				// AppleTalk ***ADSPslabel:				"ADSPs",			//***closeDesktopItem:		"Desktop \ub4ddb1e2\u",//openDemoURLsItem:		"Open Demo URLs",savePackageItem:		"Package\ub7ce0020c0fac0e5\u",	// also i, overview:ProcesssaveHTMLNotes:			"HTML\ub8a6\u Notes\ubfa10020c0fac0e5\u",saveImageNotes:			"Image\ub8a6\u Notes\ubfa10020c0fac0e5\u",saveHTMLNewtworksItem:	"HTML\ub8a6\u NewtWorks\ubfa10020c0fac0e5\u",saveImageNewtworksItem:	"Image\ub8a6\u NewtWorks\ubfa10020c0fac0e5\u",saveBookNewtworksItem:	"Book\ub8a6\u NewtWorks\ubfa10020c0fac0e5\u",//saveTextDesktopItem:	"Save as Text to Desktop",removeCurrentBookItem:	"\uc7f6c0e70020c6e4c0ccc1f60020bbe8c1a6\u",					// VincentremoveFromCacheItem:	"\uc4b3bdacb7ce0020bacec5cd0020bbe8c1a6\u",resetHTTPlabel:			"HTTP \uc3cab1e2c8ad\u",		// also in Other Options// View menuviewLabel:				"\ubab8b1e2\u",			//***currentBookItem:		"\uc7f6c0e70020c6e4c0ccc1f6\u",				closeOverViewItem:		"Overview \ub4ddb1e2\u",reloadItem:				"\ub4d9bdc30020c0d0b1e2\u",loadWithImagesItem:		"Images\ub8a60020c6f7c7d4c7d8bcad0020bad2b7afbfc0b1e2\u",//allImagesItem:		"\ub8f0b5e7\u Image",loadLinksItem:			"Links \ubad2b7afbfc0b1e2\u",loadFramesItem:			"Frames \ubad2b7afbfc0b1e2\u",documentSourceItem:		"\uc6e4c0ccc1f60020bcd2bdba\u",//overviewsHTMLlabel:				"HTML",			// *** (also in i:General)imagesLabel:			"Images",		// *** (also in i:General)//HTMLCacheLabel:		"HTML \uc4b3bdac\u",//ImageCacheLabel:		"Image \uc4b3bdac\u",linksItem:				"Links",framesItem:				"Frames",allLabel:				"All",			//***										// VincentloadItem:				"\ubad2b7afbfc0b1e2\u",openItem:				"\ubfadb1e2\u",			// also in NotesprocessItem:			"Process",		// also About,i								// VincentdisplayURLitem:			"URL \uc7a5bdc3\u",	// also HREF popupsaveOutlineItem:		"Outline \ub7ce0020c0fac0e5\u",addBookmarkItem:		"\uc3a5b0a5c7c70020c3dfb0a1\u",	// also Bookmarks, HREF popuplockItem:				"\uc0e1b1dd\u",unlockItem:				"\uc0e1b1dd0020c7d8c1a6\u",deleteItem:				"\ubbe8c1a6\u",bookmarkLabelL:			"\uc3a5b0a5c7c7\u",bookmarksLabelL:		"\uc3a5b0a5c7c7\u",	// same as bookmarksLabel but lowercaseitemItem:				"item",			// also i:General caches					// VincentitemsItem:				"items",													// Vincent// SchedulescheduleLabel:			"\uc0cfc1a4\u",		//***CancelSchedLabel:		"\uc0cfc1a40020c3ebbcd2\u",startDateLabel:			"\ubdc3c0db0020c0cfc1a4\u",	// ***frequencyLabel:			"\ubaf3b5b5\u",	//***immedItem:				"\uc7d7bbf3\u",onceItem:				"\uc7d1b9f8\u",hourlyItem:				"\ubdc3b0a3b8b6b4d9\u",twiceDailyItem:			"\uc0ccc6b2b8b6b4d9\u",dailyItem:				"\uc7cfb7e7b8b6b4d9\u",daily5Item:				"\uc7cfb7e7b8b6b4d9\u (\uc1d6b8bbc1a6bfdc\u)",weeklyItem:				"\uc1d6b8b6b4d9\u",autoLinkLabel: 			"\uc0dab5bf0020b8b5c5a9\u", // ***monthlyItem: 			"\ub4deb8b6b4d9\u",// Go menugoLabel:				"\uc0ccb5bf\u",			// ***backItem:				"\ub5dab7ce\u",forwardItem:			"\ubed5c0b8b7ce\u",clearHistoryItem:		"History \ubbe8c1a6\u", // (book menu)homeItem:				"\uc8a8\u",		// i.e., startup URLnewerHTMLitem: 			"\ub4d9b8a5\u HTML \uc4b3bdac0020c7d7b8f10020bab8b1e2\u",		// VincentnewerImageItem: 		"\ub4d9b8a5\u Image \uc4b3bdac0020c7d7b8f10020bab8b1e2\u",setHTMLitem: 			"HTML \uc4b3bdac0020bab8b1e2\u",setImageItem: 			"Image \uc4b3bdac0020bab8b1e2\u",// Bookmarks menubookmarksLabel:			"\uc3a5b0a5c7c7\u",	// ***openBookmarksItem:		"\ub1b8bcba\u/\uc0cfc1a4\u",removeBookmarkItem:		"\uc3a5b0a5c7c70020bbe8c1a6\u",newtscapeBookmarkItem:	"Newt's Cape \ubfb9c1a60020c6e4c0ccc1f6\u",//removeAllItem:		"Remove All",// info buttonaboutItem: 				"About",helpItem:				"\ub5b5bff2b8bb\u",prefsItem:				"Prefs",													// VincentregisterItem:			"\ub5eeb7cf\u",	// open Register application// about box/textintroductionText:		"\ubcd2b0b3\u",aboutCreate:			"HTML \ub7ce0020bacec5cd\utext, graphics, tables, forms\ub8a60020c6f7c7d4c7d10020b4bac6b0bacf0020b8b8b5e9b1e2\u",	//***rightsReserved:			"All Rights Reserved Worldwide",moreInfo:				"\ub1d7b9dbc0c70020c1a4bab8\u",webInfo:				"web info",													// VincentthanksRegister:			"\ub5eeb7cfc7d80020c1d6bcc5bcad0020b0a8bbe7c7d5b4cfb4d9\u",//bookLabel:			"Book",//optionsLabel:			"Options",generalItem:			"\uc0cfb9dd\u",appearanceItem:			"\ub1dbb2c3\u",encodingItem:			"\uc0cec4dab5f9\u",//(Process)displayItemItem:		"Item \uc7a5bdc3\u",displayPageItem:		"Page \uc7a5bdc3\u",displayPage1Item:		"Page1 \uc7a5bdc3\u",displayAllItem:			"\ub8f0b5ce0020c7a5bdc3\u",cacheOnlyItem:			"\uc4b3bdacb7cebacec5cd0020c0d0c0bd\u",	// also HREF popupsaveNewtworksItem:		"NewtWorks\ub7ce0020c0fac0e5\u",//i:GeneralnoCacheItem:			"\uc4b3bdac0020bef8c0bd\u",maxLabel:				"\uc3d6b4eb\u",			// after 10 items -- MaximumtrustCacheItem:			"\uc4b3bdac0020bfecbcb1\u",storeItem:				"\uc0fac0e50020c0a7c4a1\u",ignoreExpirationItem: 	"\ub8b8b1e20020b9abbdc3\u",emptyQuitItem:			"\uc1beb7e1bdc30020bbe8c1a6\u",showItemOverview:		"\ub8f0b5e70020006c0069006e006b0020c7a5bdc3\u",autoloadFramesItem:		"Frame \uc0dab5bfc0b8b7ce0020bad2b7afbfc0b1e2\u",	// HTMLmergeFramesItem:		"Frame\ub5e9c0bb0020c7cfb3aab7ce0020bab4c7d5\u",	// HTMLremoveItem:				"\uc1d6bcae0020bbe8c1a6\u",		// <!-- HTML comments-->includeDesktopItem:		"Desktop \uc0b8b7ce\u text \uc0fcbcdb\u",			// HTMLfixISOItem:				"ISO \ub9aec0da0020b0edc4a7\u",	// HTML//openURLitem:			"URL\ub8a60020c1efbdc30020bfa9bdc3b0dabdc0b4cfb1ee\u?",defaultItem:			"\ub1e2babb\u",			// Store (also Schedule:NIE setup)autoLoadItem:			"\uc0dab5bf0020c0d0b1e2\u",		// imagesfirstOneItem:			"first 1",			// Images autoload #rawImageItem:			"\ubff8babb\u (\ubaafc8afc7cfc1f60020becac0bd\u)", // imagesanimatedItem:			"Animated GIF \ubab8b1e2\u",		// imagesscaleImage:				"\uc8adb8e90020c5a9b1e2bfa10020b8c2c3e3\u",	// images//"Scale bitmaps to fit?"	// 1.xresolutionLabel:		"\uc7d8bbf3b5b5\u",				// resolution ***bwItem:					"b&w(threshold)",											// Vincentgray4Item:				"4-gray",gray16Item:				"16-gray",unfiledBkMenuItem:		"\uc1a4b8aeb5c7c1f60020becac0ba0020c3a5b0a5c7c7\u",cookiesLabel:			"Cookies",		//***skipItem:				"\ub9abbdc3\u",askItem:				"\uc1fac0c7\u",keepItem:				"\ubab8c1b8\u",			//*** also AuthenticateNSlabel:				"NewtonScript",compileItem:			"Compile",noneItem:				"\ubef8c0bd\u",			// also Schedule:Frequency, Authenticate:HostsdocDoneLabel:			"\ub8f0b5ce0020c0d0c0bd\u",		//*** soundspageSizeLabel:			"\uc6e4c0ccc1f60020c5a9b1e2\u",	//***phelpItem:				"\ub5b5bff2b8bb\u",portraitItem:			"\ubcbcb7ce\u",landscapeItem:			"\ub0a1b7ce\u",fullitem:				"full",														// VincentpkgLabel:				"Pkg",			// package ***standaloneLabel:		"\ub4bac6b0bacf\u",		// ***compressedItem:			"\ubed0c3e0\u",autoHideLabel:			"\uc0dab5bf0020bcfbb1e8\u",//inetSetupLabel:		"Inet \ubcc2bef7\u",		NIEsetupLabel:			"NIE \ubcc2bef7\u",		//*** also ScheduleIPaidLabel:				"\ubaf30020c6e4c0ccc1f6\u",			//***//AuthenticatehostsItem:				"Hosts",	//***											// VincenthostLabel:				"Host",		//***											// VincenttempItem:				"\uc0d3bdc3\u", 	// temporary (only for session) vs. "Keep"proxyLabel:				"Proxy",nameLabel:				"\uc0ccb8a7\u",		//***passwordLabel:			"\ubecfc8a3\u",	//***authenticateLabel:		"\uc0cec1f5\u",	// *** also SchedulerequireUserMsg:			"\ubbe7bfebc0da0020c0cec1f5c0cc0020c7cabfe4c7d5b4cfb4d9\u",unauthErr:				"\ub1c7c7d1bef8c0bd\u; \ubbe7bfebc0da0020c0cec1f5c0cc0020c7cabfe4c7d5b4cfb4d9\u",//i:General:Other OptionsotherOptionsLabel: 		"\ub1d7b9dbc0c70020bfc9bcc7\u",	// ***startupURLItem:			"\ubdc3c0db\u URL",proxyURLitem:			"Proxy URL",proxyHostItem:			"Proxy Host",		// 1.xproxyOnlyItem: 			"Proxy Only",proxyExItem:			"Proxy Exceptions",findTitleItem:			"Find.Title",findURLitem:			"Find.URL",findMethodItem:			"Find.Method",findDataItem:			"Find.Data",findCheckItem:			"Find:CheckData",UserAgentItem:			"Agent Prefix",					AgentSizeItem:			"Agent Size&Res.",helpISBNitem:			"Help ISBN",autoLoginItem:			"\uc0dab5bf0020b7ceb1d7c0ce\u",dontShowNCItem: 		"Newt's Cape \ub0a1b8aeb1e2\u",dontCloseBookItem:		"\uc6e4c0ccc1f60020c7d7bbf30020bab8b1e2\u",ignoreMETArefresh:		"META Refresh \ub9abbdc3\u",ignoreTablesItem:		"Tables \ub9abbdc3\u",includeFramesItem:		"Frames \uc6f7c7d4\u",tagFrameItem:			"FRAME\ub8a6\u tag\ub7ce0020baafc8af\u",	missingImgItem:			"IMG: no ALT",NCmenuItem:				"Newt's Cape \ub9f6c6b0\u",//bkoverItem:			"Bookmarks in overview only",overfloatItem:			"\uc3d6bbf3c0a70020bfc9bcc70020b2f4b1e2\u",	changeKbdItem:			"\uc5b0bab8b5e50020bcb3c1a4\u",nwSummaryItem:			"NewtWorks HTML \ubfe4bee00020c3e2b7c2\u",mailtoBodyItem:			"mailto: body",bookWidthItem:			"Book Page \ub0a1b7ce\u",bookHeightItem:			"Book Page \ubcbcb7ce\u",bookBaseItem:			"Book BASE",bookISBNitem:			"Book ISBN",booksTitleItem:			"Book \ubcd2c1a6b8f1\u",bookTitleItem:			"Book \uc1a6b8f1\u",bookContentsTitle:		"Contents",													// VincentacceptItem: 			"\uc8aec0ce\u",acceptLangItem: 		"Language \uc8aec0ce\u",ignoreFontFaceItem: 	"\ub1dbb2c30020c0afc7fc0020b9abbdc3\u",displayUnkTagItem: 		"\ub8f0b8a3b4c2\u <tags> \uc7a5bdc3\u",autoLinkExcItem: 		"\uc0dab5bf0020b8b5c5a900200028bfb9bfdc0020c7d7b8f10020c1a6bfdc0029\u",										// Vincent//PrefSetsmainPrefSetLabel:		"\ub1e2babb0020bcb3c1a4\u",prefSetItem:			"\ubbe7bfebc0da0020bcb3c1a4\u",renameItem:				"\uc0ccb8a70020baafb0e6\u",duplicateItem:			"\ubab9bbe7\u",resetAllitem:			"\uc3cab1e20020bcb3c1a4\u",	// i:AppearancetagLabel:				"Tag",			// ***missingErr:				"missing",		// missing Hx tagdefaultsLabel:			"Defaults",		// ***indentsLabel:			"Indents",		// ***aboveLabel:				"Above",		// ***leftLabel:				"Left",			// ***belowLabel:				"Below",		// ***splitLabel:				"Split",		// ***alignLabel:				"Align",		// ***rightItem:				"Right",centerItem:				"Center",justifyItem:			"Justify",fontLabel:				"Font",			// ***familyLabel:			"Family",		// ***sizeLabel:				"Size",			// ***faceLabel:				"Face",			// ***plainItem:				"Plain",boldItem:				"Bold",italicItem:				"Italic",boldItalicItem:			"BoldItalic",underlineItem:			"Underline",sampleLabel:			"Sample",		// ***// Directory menu (if applicable)//directoryLabel:		"Directory",// status fields/msgs//urlLabel:				"URL",//titleLabel:			"Title",//isbnLabel:			"ISBN",//shortTitleLabel:		"Short Title",linesLabel:				"Lines",itemsLabel:				"Items",pagesLabel:				"Pages",// HREF popuploadImageItem:			"Image \ubad2b7afbfc0b1e2\u",// Notes menugetURLItem:				"getURL",findItem:				"\uc3a3b1e2\u",// keyboard (labels) [holding down cmd-]//"General"//quitItem:				"Quit",stopLabel:				"\uc1dfc1f6\u",//"Hide/Show"//"History"//saveLabel:			"Save",// FORM button defaultssubmitLabel:			"\uc8aec0ce\u",				resetLabel:				"\ubab9bff8\u",// parsing status, general errorsnoHeapStoreErr:			"\ub8deb8f0b8ae002fc8fc0020bacec1b7\u",errorOccurred:			"\ubfa1b7af\u :",errorLabel:				"\ubfa1b7af\u",parsingMsg:				"\ubad0bcaec1df\u",lengthMsg:				"\ub1e6c0cc\u",untitledLabel:			"\uc1a6b8f10020bef8c0bd\u",compileErr:				"compile \ubfa1b7af\u",evalErr:				"eval \ubfa1b7af\u",unknownTagErr:			"\ub8f0b8a3b4c2\u TAG",noNameErr:				"\uc0ccb8a70020bef8c0bd\u",missingNameValErr:		"\uc0ccb8a7c0ccb3aa0020b0aac0bb0020bafcc6aeb7c8b4d9\u",screenSmallErr:			"\ub1c7c0e50020c8adb8e90020c5a9b1e2\u",	unknownValErr:			"\ub8f0b8a3b4c20020b0aa\u",notFormErr:				"FORM \ubec8bfa10020bef8c0bd\u",processErr:				"process",													// VincentnameValErr:				"\uc0ccb8a7c0ccb3aa0020b0aabfa1bcad0020bfa1b7af\u",notArrayOddErr:			"\ub9e8bfadc0cc0020bec6b4d4\u (\uc8a4c0ba0020c8a6bcf60020b1e6c0cc\u)",okMsg:					"\uc8aec0ce\u",// graphicsImageConvertErr:		"Image \ubaafc8af0020bfa1b7af\u",notGIFerr:				"GIF\ub0a10020bec6b4d5b4cfb4d9\u",graphicHeading:			"text \uc6c4c0cfc0cc0020bec6b4d4\u",						// VincentnoBinaryLenErr:			"\uc5a9b1e2b0a100200030c0ce\u binary", // no binary length	// Vincent// packagesnotPkgErr:				"Package\ub0a10020bec6b4d5b4cfb4d9\u",installPackage:			"Package\ub8a60020bcb3c4a1c7cfbdc3b0dabdc0b4cfb1ee003f\u?",replacePackage:			"Package\ub8a60020bcb3c4a1c7cfbdc3b0dabdc0b4cfb1ee003f\u",installingPackage:		"Package \ubcb3c4a1c1df\u",installErr:				"\ubcb3c4a1bdc7c6d0\u",noPackageErr:			"Package\ub0a10020bef8bdc0b4cfb4d9\u",//prefSetsnameExistsErr:			"\uc0ccb8a7c0cc0020c0ccb9cc0020c1b8c0e7c7d5b4cfb4d9\u",nameEmptyErr:			"\uc0ccb8a7c0cc0020baf1befabdc0b4cfb4d9\u",// comm (http/serial) status messages and errors.  FSM abort, wait, etc.?openingLinkMsg:			"Link \ubfa9b4c20020c1df\u",lookupHostMsg:			"Host \uc3a3b4c20020c1df\u",cancelOpenMsg:			"Link \ubfadb1e20020c3ebbcd20020c1df\u",instantiatingMsg:		"\ubfb9c1a60020c1d8baf10020c1df\u",instantiateErr:			"\ubfb9c1a60020bfa1b7af\u",IPaddressMsg:			"IP \uc1d6bcd2\u",bindPortMsg:			"Port \ub9d9c0ceb5f90020c1df\u",connectingPortMsg:		"Port \ubfacb0e10020c1df\u",connectingMsg:			"\ubfacb0e10020c1df\u",connectedMsg:			"\ubfacb0e1\u",connectErr:				"\ubfacb0e10020bfa1b7af\u",disconnectingPortMsg:	"Port\ub0fa0020bfacb0e10020b2f7b4c20020c1df\u",disconnectingMsg:		"\ubfacb0e10020b2f7b4c20020c1df\u",unbindingMsg:			"\ub9d9c0ceb5f90020c7d8c1a60020c1df\u",disposingMsg:			"\uc3b3bad0c1df\u",closingLinkMsg:			"Link \ub4ddb4c20020c1df\u",sendingHTTPMsg:			"HTTP Command",binaryLabel:			"Binary",textLabel:				"Text",waitMsg:				"\ub1e2b4d9b7c10020c1d6bdcabdc3bfc0\u",terminalMsg:			"HTTP FSM \ubdc7c7e00020c1df\u",goAwayLabel:			"\ub3aab0a1b4d9\u",redirectionMsg:			"\uc0fcbcdb\u",			badRequestErr:			"\uc0dfb8f8b5c80020bfe4c3bb\u",forbiddenErr:			"\ubad2c6afc1a40020c0ccc0afb7ce0020b1ddc1f6b5ca\u",notFoundErr:			"\ubef8c0bd\u",internalErr:			"\ub3bbbace0020bcadb9f6\u",notImplementedErr:		"\ubdc7c7e0c7d20020bcf60020bef8c0bd\u",	badGatewayErr:			"\uc0dfb8f8b5c80020b0d4c0ccc6aebffec0cc\u; \ubbf3c0a70020bcadb9f6b3aa0020b0d4c0ccc6aebffec0ccb7cebacec5cdc0c70020c0dfb8f8b5c80020b9ddc0c0\u",noServiceErr:			"\ubcadbaf1bdbab0a10020c0cfbdc3c0fbc0b8b7ce0020c1dfb4dcb5c7befabdc0b4cfb4d9\u",addCookiesMsg:			"Cookie \uc3dfb0a1\u?",yesLabel:				"\uc8aec0ce\u",noLabel:				"\uc3ebbcd2\u",inboxItem:				"Inbox",		// destination for packageinboxErr:				"Inbox \ubfa1b7af\u",clientErr:				"client",serverErr:				"server",unknownHelperErr:		"\ub5b5bff2b8bb0020bfa1b7af0020003a0020\u",								noHelperErr:			"\ub5b5bff2b8bb0020bef8c0bd0020003a0020\u",notHTMLimageErr:		"\uc4b3bdac\u: HTML \ub3aa\u Image\ub0a10020bec6b4d4\u",helperItem:			"\ub5b5bff2b8bb\u",		// View:Helpers -> list helper AppsoldVersionLabel:	"\ub1b80020b9f6c1af\u",	// in Install package dialognewVersionLabel:	"\ubdc50020b9f6c1af\u",createdLabel:		"\uc1a6c0db0020b5ca\u", 	// ...followed by date}, // end Korean});/*// !!!a1//Other OptionsacceptItem:				"Accept",acceptLangItem:			"Accept Language",ignoreFontFaceItem:		"Ignore FONT FACE",displayUnkTagItem:		"Display unknown <tags>",autoLinkExcItem:		"AutoLink Exceptions",//overview:ScheduleautoLinkLabel:			"AutoLink",		// ***monthlyItem:			"monthly",//GonewerHTMLitem:			"Newer HTML Cache Item",newerImageItem:			"Newer Image Cache Item",setHTMLitem:			"Set HTML Cache Item",setImageItem:			"Set Image Cache Item",*/// End of text file Language Data// Beginning of text file Project Data// Project Data// NewtsCape 2.1/Newt's Cape Lite// Copyright 1995-2000. S. Weyer & G. Simon. All Rights Reserved Worldwide// see kAboutText also// before release -- Print ////// test PrefSets on 1.x?// test Hemlock (add Print stmts)// avoid HTMLCache:NewtsCape_Titles, etc. -- don't reg soup change??// use base instead of overviewApp?// avoid some compiler warningsDeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);//for 1.x only: set kNIE to NIL. add NATIVE to kSplitTextHeightFunc ? (if there are 2.0 native fns)if not IsGlobalConstant('kNIE)then DefineGlobalConstant('kNIE, 	kBuild20 or kIgnoreNativeKeyword);		// NIE-specific version? (1.x-oNly, 1.x-NIE, 2.x-NIE)DefineGlobalConstant('kVersionNum, 		"2.1");DefineGlobalConstant('kVersionInt, 		"21");DefineGlobalConstant('kBetaVersion, 	"d");DefineGlobalConstant('kStyleMeasure,	kBuild20 and TRUE);		// !!!mDefineGlobalConstant('kExpiringVersion, kNIE and NIL);DefineGlobalConstant('kDebugHTTP, 		kDebugOn or NIL);			/**/DefineGlobalConstant('kNewEndPoint,		kNIE);DefineGlobalConstant('kNCfont,			language='Japanese or language='Chinese or language='Russian or language='Korean); // !!!a1DefineGlobalConstant('kSubmitQ,			kNIE and NIL); 	// !!!g. NASA?DefineGlobalConstant('kFullOffset,		40);			// !!!a1DefineGlobalConstant('kFullOffset2,		2*kFullOffset);	// !!!a1/*in many places in code, kNIE is also used to mean "running on a 2.x system at development time".kBuild20 would flag 2.x-specific code called from a book at run-time*/ //DefineGlobalConstant('kCParser,		kBuild20 and NIL);		// replace with C parser//DefineGlobalConstant('kCParseVersion,	"13");//DefineGlobalConstant('kAddEncoding,	language='Japanese or language='Chinese or NIL);DefineGlobalConstant('kVerBeta, kVersionNum & kBetaVersion);DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &		(if not kIgnoreNativeKeyword then $N) &		//(if kCParser then $C & kCParseVersion) &		(if kDebugOn or kDebugHTTP then $D) &		(if kProfileOn then $P) &		(if kExpiringVersion then $X) &		(if kBuild20 then "-2") &		(if kNIE then "(NIE)") &// should compare actual symbols to avoid problems like "Japan"		(if language<>'english then $~ & Upcase(SPrintObject(language))[0]) // else if kAddEncoding then "~E"));DefineGlobalConstant('kAppNameS, kAppName); // for soup names etc.DefineGlobalConstant('kAppNameL, "Newt's Cape"); // maybe slightly longerconstant kBrowserName := kAppNameL;DefineGlobalConstant('kVersion, kAppNameL && kVersionString);Print("nwcp" & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then nil	// $N?	else if language='English	then /*if kAddEncoding		then $E		else*/ if kBuild1x		then if kNIE			then $X			else $L		else $2	else Upcase(SPrintObject(language))[0])	& ".pkg");Print(kAppNameS && kVersionString && DateNTime(Time()));Print(kAppSymbol);// use this in most places instead of kAppSymbol so "Newt's Cape Lite" can shareif not IsGlobalConstant('kNewtsCapeSymbol)then DefineGlobalConstant('kNewtsCapeSymbol, kAppSymbol); // '|NewtsCape:NewtsCape|// -----constant kProfileFnOffset := 1; // for 2.0? (0 for 1.x?)// Eventually the following global functions will be defined?DeclareGlobalFn('ClearVBOCache,1);if kNIEthen begin	DeclareGlobalFn('RegUnionSoup, 2);	DeclareGlobalFn('UnRegUnionSoup, 2);	end;if kBuild20then begin	DeclareGlobalFn('Query,2);	endelse begin	if kNIE	then begin		DeclareGlobalFn('GetFunctionArgCount,1);		DeclareGlobalFn('IsNumber,1);		DeclareGlobalFn('SubstituteChars,3);		DeclareGlobalFn('PowerOffResume,1);		DeclareGlobalFn('CreateSoupFromSoupDef, 3);		DeclareGlobalFn('IsCharacter, 1);		DefineGlobalConstant('protoStatusTemplate,@467);		DefineGlobalConstant('protoBasicEndpoint, @383);		DefineGlobalConstant('protoDragger, @132);		DefineGlobalConstant('protoSmallKeyboardButton, @624);		DefineGlobalConstant('protoPopupButton, @386);		DefineGlobalConstant('protoDragNGo, @804);		DefineGlobalConstant('ROM_DefRotateFunc, @588);		DefineGlobalConstant('protoTXView, @826);		DefineGlobalConstant('protoDateNTimeTextPicker, @630);		DefineGlobalConstant('protoNewFolderTab, @669);		DefineGlobalConstant('protoSoupOverview, @460);		//DefineGlobalConstant('newtCheckAllButton, @872); // 2.1 only		DefineGlobalConstant('ROM_routeUpdateBitmap,@761);		DefineGlobalConstant('ROM_alarmIconTinyBitmap, @591);		DefineGlobalConstant('ROM_routePasteText, @773);		DefineGlobalConstant('ROM_closedPadlockBitmap, @601);		DefineGlobalConstant('ROM_openPadlockBitmap, @600);		DefineGlobalConstant('ROM_routeDeleteIcon, @291);		DefineGlobalConstant('ROM_routeDuplicateIcon, @292);		DefineGlobalConstant('kShiftModifier, 	1 << 26);		DefineGlobalConstant('kOptionModifier,  1 << 28);		DefineGlobalConstant('editFont10, 0x00002803);		DefineGlobalConstant('editFont12, 0x00003003);				DeclareGlobalFn('MakeFontMenu, 4);		DeclareGlobalFn('BInsertRight, 5);		DeclareGlobalFn('BDelete, 5);		DeclareGlobalFn('SetFontParms, 2);		DeclareGlobalFn('SetFontFamily, 2);		DeclareGlobalFn('SetFontFace, 2);		DeclareGlobalFn('SetFontSize, 2);		DeclareGlobalFn('PerformIfDefined, 3);		DeclareGlobalFn('GetFolderStr, 1);		DeclareGlobalFn('GetFolderList, 2);		end	else begin		DefineGlobalConstant('ROM_DefRotateFunc, nil);	// e.g. protoNamePassword (unused)		DefineGlobalConstant('protoSmallKeyboardButton, nil);		DeclareGlobalFn('GetFolderStr, 1);		DeclareGlobalFn('GetFolderList, 2);		DeclareGlobalFn('SetFontFace, 2);		DeclareGlobalFn('BDelete, 5);		end;	DefineGlobalConstant('kCommandModifier, 1 << 25);	DeclareGlobalFn('EntryFlushXmit, 2);	DefineGlobalConstant('kCommandKeyCode, 55);	DeclareGlobalFn('IsEntryAlias, 1);	DeclareGlobalFn('EntryFromObj, 1);	DeclareGlobalFn('CreateTargetCursor, 2);	DeclareGlobalFn('RemoveAlarm, 1);	DeclareGlobalFn('GetAlarm, 1);	DeclareGlobalFn('TargetIsCursor, 1);	DeclareGlobalFn('GetTargetCursor, 2);	DeclareGlobalFn('GetSoupDef, 1);	DeclareGlobalFn('EntryCopyXmit, 3);	DeclareGlobalFn('EntryMoveXmit, 3);	DeclareGlobalFn('GetAppAlarmKeys, 1);	DeclareGlobalFn('MakeTextLines, 4);	DeclareGlobalFn('StyledStrTruncate, 3);	DeclareGlobalFn('InetGetAllLinksStatus, 0);	DeclareGlobalFn('InetSetDefaultLinkID, 1);	DeclareGlobalFn('InetGetDefaultLinkID, 0);	DeclareGlobalFn('AddAlarm, 5);	DeclareGlobalFn('StrTokenize, 2);	DeclareGlobalFn('IsFunction,1);	DeclareGlobalFn('IsInteger,1);	DeclareGlobalFn('ObjectPkgRef, 1);	DefineGlobalConstant('kTextCompander,	"TLZStoreCompander");	DefineGlobalConstant('kBitmapCompander,	"TPixelMapCompander");	DeclareGlobalFn('RegPowerOff,2);	DeclareGlobalFn('UnRegPowerOff,1);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('GetGlobalFn,1);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('TransportNotify,3);	DeclareGlobalFn('GetDataDefs,1);	DeclareGlobalFn('GetAppPrefs,2);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('IsRichString,1);	DeclareGlobalFn('AddDelayedSend,4);	DeclareGlobalFn('AddDeferredSend,3);	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('AddDelayedCall,3);	DeclareGlobalFn('AddProcrastinatedSend, 5);	DeclareGlobalFn('LSearch,5);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('IsSymbol,1);	DeclareGlobalFn('RegUnionSoup,2);	DeclareGlobalFn('UnRegUnionSoup,2);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('Send,2);	DeclareGlobalFn('EntryRemoveFromSoupXmit,2);	DeclareGlobalFn('RegSoupChange,3);	DeclareGlobalFn('EntryChangeXmit,2);	DeclareGlobalFn('EntryReplaceXmit,3);	DeclareGlobalFn('UnRegSoupChange,2);	DeclareGlobalFn('BInsert,5);	DeclareGlobalFn('isVBO, 1);	DeclareGlobalFn('GetVBOStore, 1);	DeclareGlobalFn('GlobalFnExists, 1);	DeclareGlobalFn('KeyboardConnected, 0);	DeclareGlobalFn('ResolveEntryAlias, 1);	DeclareGlobalFn('GetUnionSoupAlways, 1);	DeclareGlobalFn('MakeEntryAlias, 1);	DeclareGlobalFn('ProtoPerformIfDefined, 3);	DeclareGlobalFn('GetFontFace, 1);	DeclareGlobalFn('GetFontSize, 1);	DeclareGlobalFn('GetFontFamilySym, 1);	DeclareGlobalFn('BFind, 4);	DeclareGlobalFn('ArrayInsert, 3);	DeclareGlobalFn('GetVBOcompander, 1);	DeclareGlobalFn('OffsetRect, 3);	if not IsGlobalConstant('HTMLParser)	then DefineGlobalConstant('HTMLParser,{});	DeclareGlobalFn('GetPkgRefInfo, 1);	DeclareGlobalFn('RegisterViewDef, 2);	DeclareGlobalFn('UnRegisterViewDef, 2);	DeclareGlobalFn('DecodeRichString, 2);	DeclareGlobalFn('StrExactCompare, 2);	DeclareGlobalFn('AddProcrastinatedCall, 4);	DeclareGlobalFn('SubstituteChars, 3);	end;DeclareGlobalFn('SoundList, 0);DeclareGlobalFn('GetRegisteredSound,1);DeclareGlobalFn('InetGetIPAddress, 1);DeclareGlobalFn('CharPos,3);DeclareGlobalFn('BookAvailable,2);//DeclareGlobalFn('StrHexDump,2);DeclareGlobalFn('GetPkgRef,2);DeclareGlobalFn('XmitSoupChange,4);DeclareGlobalFn('ThawPackage,1);DeclareGlobalFn('AsyncConfirm,3);DeclareGlobalFn('SafeRemovePackage,1);DeclareGlobalFn('TotalTextBounds,2);DeclareGlobalFn('DoProgress,3);DeclareGlobalFn('MakeCompactFont,3);DeclareGlobalFn('OpenPrefsTo, 1); // NTE// these are deprecated (and might disappear)DefineGlobalConstant('kMyRegCardSoup, func(soupName,soupIndexes,appSymbol,appObject)if kBuild20 or Functions.RegUnionSoup existsthen RegUnionSoup(appSymbol,		{name: 	 	soupName,		userName: 	soupName,		ownerApp:	kNewtsCapeSymbol, // note: to match UnRegUnionSoup		userDescr:	soupName && appObject[1],		indexes: 	soupIndexes,		})else call kRegisterCardSoupFunc with (soupName,soupIndexes,appSymbol,appObject));DefineGlobalConstant('kMyRegCardSoupNC, func(soupName,soupIndexes,appSymbol,appObject) // non-standalone (unused so far)GetRoot().(kNewtsCapeSymbol):?RegisterCardSoup(soupName,soupIndexes,appSymbol,appObject));DefineGlobalConstant('kMyUnRegCardSoup, func(soupName)if kBuild20 or Functions.UnRegUnionSoup existsthen UnRegUnionSoup(soupName, kNewtsCapeSymbol)else call kUnregisterCardSoupFunc with (soupName));DefineGlobalConstant('kMyUnRegCardSoupNC, func(soupName) // non-standalone (unused so far)GetRoot().(kNewtsCapeSymbol):?UnRegisterCardSoup(soupName));DefineGlobalConstant('kMyGetUserConfig, func(configSym)if kBuild20 or Functions.GetUserConfig existsthen GetUserConfig(configSym)else call kGetUserConfigFunc with (configSym));DefineGlobalConstant('kMyGetUserConfigNC, func(configSym) // non-standalonebegin	local app;	if not (app := GetRoot().(kNewtsCapeSymbol))	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	app:?GetUserConfig(configSym);end);// -----DefineGlobalConstant('kAboutText,"<HTML><HEAD><META CONTENT=\"icon\" NAME=\"data.ic\"><TITLE>" & LocObj("About", 'aboutItem) && kAppNameL & "</TITLE></HEAD><BODY><H1>" & kAppNameL && kVersionString & "</H1><IMG SRC=\"ic\"><H2>" & LocObj("Introduction", 'introductionText) & "</H2><P>" &LocObj("CreateNewton books with text, graphics, tables andforms from HTML", 'aboutCreate) & ".<P>&copy;1995-2000. S.Weyer&amp;G.Simon." &&LocObj("All Rights Reserved Worldwide", 'rightsReserved) &$. & (if language='German then $  else unicodeCR) &"<H2>" & LocObj("For More Information", 'moreInfo) & "</H2><UL><LI>" & (if language<>'German then unicodeCR) &"<A HREF=\"http://members.bellatlantic.net/~sweyer/newton/newtscape.htm\">" & LocObj("web info", 'webInfo) &"</A><LI><A" & (if language='German then $  else unicodeCR) &"HREF=\"mailto:weyer@kagi.com\">Steve</A>, <A HREF=\"mailto:greg@accesscom.com\">Greg</A></UL></BODY></HTML>");// File menuDefineGlobalConstant('kOpenLocation,	LocObj("Open Location", 'openLocationItem));DefineGlobalConstant('notesSoupName,	ROM_paperrollsoupname);DefineGlobalConstant('kNotesSym,		'paperroll);DefineGlobalConstant('kOpenNotes, 		LocObj("Open Notes", 'openNotesItem) & $É);DefineGlobalConstant('kSaveHTMLNotes, 	LocObj("Save HTML to Notes", 'saveHTMLNotes));DefineGlobalConstant('kSaveImageNotes,	LocObj("Save Image to Notes", 'saveImageNotes));DefineGlobalConstant('inboxSoupName,	ROM_inboxsoupname);DefineGlobalConstant('kOpenInbox,		LocObj("Open Inbox", 'openInboxItem) & $É);DefineGlobalConstant('kInboxSym,		'ioBox);DefineGlobalConstant('kPaperback,		"Paperback");DefineGlobalConstant('kOpenPaperback,	LocObj("Open Paperback", 'openPaperbackItem) & $É);DefineGlobalConstant('kNamesSym,		'cardfile);DefineGlobalConstant('kWabumiUni,		"WabumiUni");DefineGlobalConstant('kOpenWabumiUni,	LocObj("Open WabumiUni", 'openWabumiUniItem) & $É);/*DefineGlobalConstant('kUnfiled,			"Unfiled");	// via GetFolderStr?DefineGlobalConstant('kPersonalMedia,	LocObj("Personal Media", 'personalMediaItem));DefineGlobalConstant('kPMSoupName,		"DocDir:Gaia");DefineGlobalConstant('kPersonalMediaSym,'|Personal Media:Gaia|);DefineGlobalConstant('kOpenPersonalMedia,LocObj("Open Personal Media", 'openPersonalMediaItem) & $É);*/DefineGlobalConstant('kNewtworksSoupName,	"NewtWorks");	// not localized?DefineGlobalConstant('kNewtworksSym,		'Newtworks);DefineGlobalConstant('kOpenNewtworks,		LocObj("Open NewtWorks", 'openNewtWorksItem) & $É);DefineGlobalConstant('kSaveHTMLNewtworks,	LocObj("Save HTML to NewtWorks", 'saveHTMLNewtworksItem));DefineGlobalConstant('kSaveImageNewtworks,	LocObj("Save Image to NewtWorks", 'saveImageNewtworksItem));DefineGlobalConstant('kSaveBookNewtworks,	LocObj("Save Book to NewtWorks", 'saveBookNewtworksItem) & $É);constant kExtrasSym 	:= 'ExtrasDrawer;constant kURLcopSymbol	:= 'urlCop;DefineGlobalConstant('kOpenDesktop, 	LocObj("Open Desktop", 'openDesktopItem) & $É);DefineGlobalConstant('kCloseDesktop,	LocObj("Close Desktop", 'closeDesktopItem));constant kOpenSerial9600	:= LocObj("Serial(9600)", 'serial9600);constant kOpenSerial57600	:= LocObj("Serial(57600)", 'serial57600);constant kOpenADSP			:= LocObj("ADSP", 'ADSPlabel);DefineGlobalConstant('kSaveAsPackage,	LocObj("Save as Package", 'savePackageItem));DefineGlobalConstant('kRemoveBook,		LocObj("Remove Current Book", 	'removeCurrentBookItem));DefineGlobalConstant('kRemoveCache,		LocObj("Remove from Cache", 	'removeFromCacheItem));//DefineGlobalConstant('kDumpText,		LocObj("Save as Text to Desktop", 'saveTextDesktopItem) & $É);// soup names, indexes, queriesconstant sysSoupName 		:= ROM_systemsoupname;DefineGlobalConstant('kSystemQuery, {type: 'index, indexPath: 'tag, startKey: kPackageName});constant kPkgSoupName  		:= "TEMPPKG:TKnollSys";   // same as NewtPack (1.x)DefineGlobalConstant('kHTMLSoupName, "TEMPHTML:" & kAppNameS);DefineGlobalConstant('kHTMLQuery, if kNIE then nil else {type: 'index}); // {type:'index,indexPath:'contentID});DefineGlobalConstant('kHTMLIndexes, []); 	// [{structure: 'slot, path: 'contentID, type: 'int}]);DefineGlobalConstant('kTempHTMLSoupDef, {	name: 	 	kHTMLSoupName,	userName: 	kHTMLSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && "Temp Soup",	indexes: 	kHTMLIndexes,	});constant kSoupDir := "soup/";	// for local "files" (for HREF, ACTION)DefineGlobalConstant('kSoupChanged, func(soupName,appSymbol,changeType,changeData) // for RegSoupChangeGetRoot().(kNewtsCapeSymbol):?soupChanged(soupName));//DefineGlobalConstant('kResourceQuery, {type: 'index, indexPath: 'name}); // bitmaps, sounds// -----// {URL*: string, text: string (or bitmap: binary), modified: date, expires: date}DefineGlobalConstant('kCacheHTMLSoupName, 	"HTMLCache:"  & kAppNameS);DefineGlobalConstant('kOpenHTMLcache, 	LocObj("Open HTML Cache", 'openHTMLCacheItem) & $É);DefineGlobalConstant('kCacheImagesSoupName, "ImageCache:" & kAppNameS);DefineGlobalConstant('kOpenImagecache, 	LocObj("Open Image Cache", 'openImageCacheItem) & $É);//DefineGlobalConstant('kOpenDemoURLs, 	LocObj("Open Demo URLs",   'openDemoURLsItem) & $É);DefineGlobalConstant('kOpenNetHopperCache, 	LocObj("Open NetHopper Cache", 'OpenNetHopperCacheItem) & $É);constant kCacheNetHopperSoupName := "NH3StreamDOX:ALLPEN";DefineGlobalConstant('kCacheIndex, {structure: 'slot, path: 'URL, type: 'string});DefineGlobalConstant('kCacheSortIndex, {structure: 'slot, path: '_modTime, type: 'int, order: 'descending});DefineGlobalConstant('kCacheHTMLSoupDef, {	name: 	 	kCacheHTMLSoupName,	userName: 	kCacheHTMLSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && LocObj("HTML", 'HTMLlabel),	// !!!j. LocObj("HTML Cache", 'HTMLCacheLabel),		indexes: 	[kCacheIndex, kCacheSortIndex],	});DefineGlobalConstant('kCacheImagesSoupDef, {	name: 	 	kCacheImagesSoupName,	userName:	 kCacheImagesSoupName,	ownerApp:	 kNewtsCapeSymbol,	userDescr: 	kAppNameL && LocObj("Images", 'imagesLabel),	// !!!j. LocObj("Image Cache", 'ImageCacheLabel),	indexes: 	[kCacheIndex,				kCacheSortIndex,				],	});// !!!gDefineGlobalConstant('kSubmitQueue, 		"Submit Queue");	//LocObj???DefineGlobalConstant('kOpenSubmitCache, 	"Open" && kSubmitQueue & $É); //LocObj???		DefineGlobalConstant('kCacheSubmitSoupName,	"SubmitQueue:" & kAppNameS);DefineGlobalConstant('kCacheSubmitSoupDef, {	name: 	 	kCacheSubmitSoupName,	userName: 	kCacheSubmitSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && kSubmitQueue,	indexes: 	[],		//kCacheIndex, kCacheSortIndex,	???	});DefineGlobalConstant('kBookmarksLabel, LocObj("Bookmarks", 'bookmarksLabel));/* {name: string, URL: string, labels: symbol, type*: symbol, created: date,	modified: date, valid: int, sortOn*: string, labels: symbol} */DefineGlobalConstant('kBookmarkSoupName, "Bookmarks:" & kAppNameS);DefineGlobalConstant('kBookmarkSoupDef, {	name: 	 	kBookmarkSoupName,	userName: 	kBookmarkSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && kBookmarksLabel,	indexes: 	[		'{structure: slot, path: sortOn, type: string},		'{structure: slot, path: type, type: symbol},		//'{structure: slot, path: Labels, type: symbol},		//kCacheSortIndex		],		});// {domain*: string, path: string, expires: date, name: string, value: string}/*DefineGlobalConstant('kCookieSoupName, "Cookies:" & kAppNameS);DefineGlobalConstant('kCookieIndex, {structure: 'slot, path: 'domain, type: 'string});DefineGlobalConstant('kCookieSoupDef, {	name: 	 	kCookieSoupName,	userName: 	kCookieSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && LocObj("Cookies", 'cookiesLabel),	indexes: 	[kCookieIndex],	});*/// -----constant kNewtSymbol		:= '|NewtDevEnv:TKnollSys|; // for saving bookconstant kSloupSymbol		:= '|Sloup:TKnollSys|;constant kBookReaderSymbol	:= 'Copperfield;constant kHelpReaderSymbol	:= 'tinyTim;// View menuDefineGlobalConstant('kCurrentBook,		LocObj("Current Book", 'currentBookItem));//DefineGlobalConstant('kBookProperties, "Book Properties");	// LocObj//DefineGlobalConstant('kCloseOverView,	LocObj("Close Overview", 'closeOverViewItem));DefineGlobalConstant('kReload,			LocObj("Reload", 'reloadItem));DefineGlobalConstant('kLoadWithImages,	LocObj("Load with Images", 'loadWithImagesItem) & $É);DefineGlobalConstant('kLoadLinks,		LocObj("Load Links", 'loadLinksItem) & $É);	// !!!cDefineGlobalConstant('kLoadFrames,		LocObj("Load Frames", 'loadFramesItem) & $É);	// !!!eDefineGlobalConstant('kViewSource,		LocObj("Document Source", 'documentSourceItem));DefineGlobalConstant('kHelpers,			LocObj("Helpers", 'helperItem));	// !!!o// Bookmark menuDefineGlobalConstant('kAddBookmark,		LocObj("Add Bookmark", 'addBookmarkItem));DefineGlobalConstant('kRemoveBookmark,	LocObj("Remove Bookmark", 'removeBookmarkItem));//DefineGlobalConstant('kAddPattern,		"http://www.");//DefineGlobalConstant('kRemoveAll,		LocObj("Remove All", 'removeAllItem));DefineGlobalConstant('kSaveOutline,		LocObj("Save as Outline", 'saveOutlineItem));DefineGlobalConstant('kOpenBookmarks,	LocObj("Browse/Schedule", 'openBookmarksItem)  & $É);// Options menuDefineGlobalConstant('kRegisterOption,	LocObj("Register", 'registerItem) & $É);DefineGlobalConstant('kGeneralOption,	LocObj("General", 'generalItem) & $É);DefineGlobalConstant('kAppearanceOption,LocObj("Appearance", 'appearanceItem) & $É);DefineGlobalConstant('kProcessOption,	LocObj("Process", 'processItem) & $É);DefineGlobalConstant('kEncodingOption,	LocObj("Encoding", 'encodingItem) &  $É);DefineGlobalConstant('kResetAllOption,	LocObj("Reset All", 'resetAllItem) & $É);// processOption (Newt's Cape)constant kDisplayItem	:= 0;constant kDisplayPage	:= 1;constant kDisplayPage1	:= 2;constant kDisplayAll	:= 3;constant kCacheOnly		:= 4;constant kSavePkg		:= 5;constant kSaveNW		:= 6;DefineGlobalConstant('kProcessDefault, kDisplayPage);DefineGlobalConstant('kProcessMax, if kNIE then kSaveNW else kSavePkg);	// in case other built-in options?constant kCacheItem := LocObj("Cache Only", 'cacheOnlyItem);constant kPkgItem := kSaveAsPackage;constant kNWItem := LocObj("Save to NewtWorks", 'saveNewtworksItem);// for Register (Newt's Cape)constant kRegistrationPackage := '|Register:FlaSheridn|;constant kSharewareFee := 35.00;DefineGlobalConstant('kRegFrame,	{package: kNewtsCapeSymbol, 	price:	  kSharewareFee,	platform: 'Newton, 	Version:  kVersionString,	notes:	 LocObj("Thanks for registering", 'thanksRegister) && kAppNameL,	});// Notesconstant dataNoteFont := userFont10; // 10241DefineGlobalConstant('slotNoteFont, dataNoteFont + tsBold); //1058817constant noteHeight := 265;constant noteWidth := 226;constant noteLeft := 10;constant noteTop := 2;DefineGlobalConstant ('kSourcePath,'[pathExpr: data,0,text]);constant kDelay 		:= 2000;	// for disconnect, also for saveNowconstant kLineDelay 	:= 1; 		// for between lines during viewIdleScript/AddDelayedSendconstant kDragRadius 	:= 4;// communications (Newt's Cape)constant kLineLength := 3000; // was 2K/*DefineGlobalConstant('kconfigBPS57600, // openButton.pickActionScript	{label: kCMOSerialIOParms,	type: 	'option,	opCode: if kNewEndPoint then opSetRequired else opSetNegotiate,	result:	nil,	form:	'template,	data: 	if kNewEndPoint		then {			arglist: [				k1StopBits,		// 1 stop bit				kNoParity,		// no parity bit				k8DataBits,		// 8 data bits				k57600bps,		// data rate in bps		// ***				],			typelist: ['struct,				'long,			// stop bits				'long,			// parity				'long,			// data bits				'long,			// bps				],			}		else {			bps: k57600bps, dataBits: k8DataBits,		// ***			stopBits: k1StopBits, parity: kNoParity,			},	});if not kNewEndPointthen begin	RemoveSlot(kconfigBPS57600, 'result);	RemoveSlot(kconfigBPS57600, 'form);	end;DefineGlobalConstant('kADSPconfig,[ // configOptions for ADSP{label:	kCMSAppleTalkID,type:	'service,opCode:	opSetRequired,},{label:	kCMSAppleTalkID,type:	'option,opCode:	opSetRequired,form:	'template,data:	if kNewEndpoint	then {		arglist: [KCMOAppleTalkADSP],		typelist:['struct,			['array, 'char, 4],			],		}	else kCMOAppleTalkADSP,},{label:	kCMOEndpointName,type:	'option,opCode:	opSetRequired,form:	'template,		data:	if kNewEndpoint	then { 		arglist:  [kADSPEndpoint],		typelist: ['struct,			['array, 'char, 0],			],		}	else kADSPEndpoint,},		]);if not kNewEndPointthen begin	RemoveSlot(kADSPconfig[1], 'form);	//kCMSAppleTalkID	RemoveSlot(kADSPconfig[2], 'form);	//kCMOEndpointName	end;*/// for character entitiesconstant kSpace 			:= " ";constant kDash 				:= "-";DefineGlobalConstant('kSplitArray, func(ARRAY a1, a2, nv) // for development timebegin	SetLength(a1, Length(nv) div 2);	SetLength(a2, Length(nv) div 2);	local INT i;	for i:=0 to Length(nv)-1 by 2	do begin		a1[i div 2] := nv[i];		a2[i div 2] := nv[i+1];		end;end);DefineGlobalConstant('kCharNames160,[ // proposed? p.66-67, p.75-76// a contiguous list of char names (case sensitive)// *** have no Newton font char (see kCharExcept)"nbsp",		// 160. no-break space ***"iexcl",	// inverted exclamation mark"cent",		// cent sign"pound",	// pound sterling sign"curren",	// general currency sign"yen",		// yen sign"brvbar",	// broken (vertical) bar ***	// !!!x"sect",		// section sign"uml",		// umlaut (dieresis)"copy",		// copyright sign"ordf",		// 170. ordinal indicator, feminine"laquo",	// angle quotation mark, left"not",		// not sign"shy",		// soft hyphen ***"reg",		// registered sign"macr",		// macron"deg",		// degree sign"plusmn",	// plus-or-minus sign"sup2",		// superscript 2 ***"sup3",		// superscript 3 ***"acute",	// 180. acute accent"micro",	// micro sign"para",		// pilcrow (paragraph sign)"middot",	// middle dot"cedil",	// cedilla"sup1",		// superscript 1 ***"ordm",		// ordinal indicator, masculine"raquo",	// angle quotation mark, right"frac14",	// fraction one-quarter ***"frac12",	// fraction one-half ***"frac34",	// 190. fraction three-quarters ***"iquest",	// inverted question mark"Agrave",	// A, grave accent"Aacute",	// A, acute accent"Acirc",	// A, circumflex accent"Atilde",	// A, tilde"Auml",		// A, dieresis or umlaut mark"Aring",	// A ring"AElig",	// AE, diphthong (ligature)"Ccedil",	// C, cedilla"Egrave",	// 200. E, grave accent"Eacute", 	// E, acute"Ecirc",	// E, circumflex"Euml",		// E, umlaut"Igrave",	// I, grave"Iacute", 	// I, acute"Icirc",	// I, circumflex"Iuml",		// I, umlaut"ETH",		// Eth, Icelandic ***"Ntilde", 	// N, tilde"Ograve",	// 210. O, grave"Oacute", 	// O, acute"Ocirc",	// O, circumflex"Otilde", 	// O, tilde"Ouml",		// O, umlaut"times",	// multiply sign ***"Oslash",	// O, slash"Ugrave",	// U, grave"Uacute", 	// U, acute"Ucirc",	// U, circumflex"Uuml",		// 220. U, umlaut"Yacute", 	// Y, acute ***"THORN",	// THORN, Icelandic ***"szlig",	// sharp s, German (sz ligature)"agrave",	// a, grave"aacute",	// a, acute"acirc",	// a, circumflex"atilde",	// a, tilde"auml",		// a, umlaut"aring",	// a ring"aelig",	// 230. ae, diphthong (ligature)"ccedil",	// c, cedilla"egrave",	// e, grave"eacute", 	// e, acute"ecirc",	// e, circumflex"euml",		// e, umlaut"igrave",	// i, grave"iacute", 	// i, acute"icirc",	// i, circumflex"iuml",		// i, umlaut"eth",		// 240. eth, Icelandic ***"ntilde", 	// n, tilde"ograve",	// o, grave"oacute", 	// o, acute"ocirc",	// o, circumflex"otilde", 	// o, tilde"ouml",		// o, umlaut"divide",	// divide sign"oslash",	// o, slash"ugrave",	// u, grave"uacute", 	// 250. u, acute"ucirc",	// u, circumflex"uuml",		// u, umlaut"yacute", 	// y, acute ***"thorn",	// thorn, Icelandic ***"yuml",		// y, umlaut]);// fixStringDefineGlobalConstant('kCharCodes, []);DefineGlobalConstant('kCharNames, []);// a non-contiguous list of char names (case sensitive) & corresponding codescall kSplitArray with (kCharCodes, kCharNames,[60, "lt",62,	"gt",38,	"amp",34,	"quot",]);// a few chars with no unicode charDefineGlobalConstant('kCharExceptNames, []);DefineGlobalConstant('kCharExceptValues,[]);constant kBullet := $\u2022;// used in fixString. also if fixISO, single chars (only) copied in HTTP.Instantiatecall kSplitArray with (kCharExceptNames, kCharExceptValues,[//127//128//129130, $\u201A,	// [sbquo] 	!!!f131, $\u0192,	// [fnof]	!!!f132, $\u201E,	// [bdquo]	!!!f133, $\u2026,	// [hellip] ...134, $\u2020,	// dagger [dagger]135, $\u2021,	// doubledagger [Dagger]136, $\u02C6,	// circumflex [circ]137, $\u2030,	// salinity//138139, $\u2039,	// [lsaquo]	!!!f140, $\u0152,	// OE diphthong [OElig]//141//142//143//144145, $\u2018,	// [lsquo]	!!!f146, $\u2019,	// [rsquo]	!!!f147, $\u201C,	// [ldquo]	!!!f148, $\u201D,	// [rdquo]	!!!f149, kBullet,	// bullet [bull]150, $\u2013,	// [ndash]	!!!f151, $\u2014,	// [mdash] 	!!!f152, $\u02DD,	// [Prime?]	!!!f153, $\u2122,	// trademark [trade]//154155, $\u203A,	// [rsaquo]	!!!f156, $\u0153,	// oe diphthong [oelig]//157//158159, $\u0178,	// Yumlaut [Yuml]?// kCharNames160//160, $ ,		// [nbsp] non breaking space. !!!g166, $|,		// [brvbar] broken vertical bar173, $-,  		// [shy] soft hyphen178, "^2", 		// [sup2] superscript 2179, "^3", 		// [sup3] superscript 3185, "^1", 		// [sup1] superscript 1 $\u0131 ?188, "1/4",		// [frac14]189, "1/2",		// [frac12]190, "3/4",		// [frac34]//208, kCharNames160[208-160],	// ETH215, $*,  		// times//221, kCharNames160[221-160],	// Yacute//222, kCharNames160[222-160], 	// THORN//240, kCharNames160[240-160],	// eth//253, kCharNames160[253-160],	// yacute//254, kCharNames160[254-160],	// thorn]);/*Euro&euro; = &#8364;in iso-8859-15, 164 decimal (map to curren?)*/// possibly share kCharExceptValues, kCharSpecialValues -- most of beginning are same? but what about diffs?// entities with no code#DefineGlobalConstant('kCharSpecialNames, []);DefineGlobalConstant('kCharSpecialValues,[]);call kSplitArray with (kCharSpecialNames, kCharSpecialValues,[// Latin Extended-B"fnof",		$\u0192,	// florin latin small f = function// GREEK capital//Alpha    CDATA "&#913;",U+0391//Beta     CDATA "&#914;".U+0392//Gamma    CDATA "&#915;",U+0393"Delta",	$\u2206,	// CDATA "&#916;",U+0394//Epsilon  CDATA "&#917;",U+0395//Zeta     CDATA "&#918;",U+0396//Eta      CDATA "&#919;".U+0397//Theta    CDATA "&#920;",U+0398//Iota     CDATA "&#921;",U+0399//Kappa    CDATA "&#922;",U+039A//Lambda   CDATA "&#923;",U+039B//Mu       CDATA "&#924;",U+039C//Nu       CDATA "&#925;",U+039D//Xi       CDATA "&#926;",U+039E//Omicron  CDATA "&#927;",U+039F"Pi",		$\u220F,	// CDATA "&#928;",U+03A0//Rho      CDATA "&#929;",U+03A1//no Sigmaf, and no U+03A2 character either"Sigma",	$\u2211,	// CDATA "&#931;",U+03A3//Tau      CDATA "&#932;",U+03A4//Upsilon  CDATA "&#933;",U+03A5//Phi      CDATA "&#934;",U+03A6//Chi      CDATA "&#935;",U+03A7//Psi      CDATA "&#936;",U+03A8"Omega",	$\u2126,	//    CDATA "&#937;",U+03A9// Greek small letter//alpha    CDATA "&#945;",U+03B1//beta     CDATA "&#946;",U+03B2//gamma    CDATA "&#947;",U+03B3"delta",	$\u2202,	// CDATA "&#948;",U+03B4//epsilon  CDATA "&#949;",U+03B5//zeta     CDATA "&#950;",U+03B6//eta      CDATA "&#951;",U+03B7//theta    CDATA "&#952;",U+03B8//iota     CDATA "&#953;",U+03B9//kappa    CDATA "&#954;",U+03BA//lambda   CDATA "&#955;",U+03BB"mu",		$\u00B5,    // CDATA "&#956;",U+03BC//nu       CDATA "&#957;",U+03BD//xi       CDATA "&#958;",U+03BE//omicron  CDATA "&#959;",U+03BF"pi",		$\u03C0,//rho      CDATA "&#961;",U+03C1//sigmaf   CDATA "&#962;",U+03C2//sigma    CDATA "&#963;",U+03C3//tau      CDATA "&#964;",U+03C4//upsilon  CDATA "&#965;",U+03C5//phi      CDATA "&#966;",U+03C6//chi      CDATA "&#967;",U+03C7//psi      CDATA "&#968;",U+03C8//omega    CDATA "&#969;",U+03C9//thetasym CDATA "&#977;",U+03D1//upsih    CDATA "&#978;",U+03D2 w/ hook symbol//piv      CDATA "&#982;",U+03D6// General Punctuation"bull",		kBullet,	// bullet. NOT the same as bullet operator, U+2219"hellip",	$\u2026,	// horizontal ellipsis = three dot leader"prime",	$\u00B4,	// !!!f. $',// prime = minutes = feet, U+2032"Prime",	$\u02DD,	// !!!f. $", 		// double prime = seconds = inches, U+2033//oline    CDATA "&#8254;" -- overline = spacing overscore, U+203E"frasl",	$\u2044,	// fraction slash// Letterlike Symbols//weierp   CDATA "&#8472;" -- script capital P = power set = Weierstrass p, U+2118//image    CDATA "&#8465;" -- blackletter capital I = imaginary part, U+2111//real     CDATA "&#8476;" -- blackletter capital R = real part symbol, U+211C"trade",	$\u2122,	// CDATA "&#8482;" -- trade mark sign, U+2122//alefsym  CDATA "&#8501;" -- alef symbol = first transfinite cardinal, U+2135	//NOT the same as hebrew letter alef, U+05D0 although the same glyph could be used to depict both characters// Arrows//larr     CDATA "&#8592;" -- leftwards arrow, U+2190//uarr     CDATA "&#8593;" -- upwards arrow, U+2191//rarr     CDATA "&#8594;" -- rightwards arrow, U+2192//darr     CDATA "&#8595;" -- downwards arrow, U+2193//harr     CDATA "&#8596;" -- left right arrow, U+2194//crarr    CDATA "&#8629;" -- downwards arrow with corner leftwards = carriage return, U+21B5//lArr     CDATA "&#8656;" -- leftwards double arrow, U+21D0. 'is implied by'?//uArr     CDATA "&#8657;" -- upwards double arrow, U+21D1//rArr     CDATA "&#8658;" -- rightwards double arrow, U+21D2. 'implies'?//dArr     CDATA "&#8659;" -- downwards double arrow, U+21D3//hArr     CDATA "&#8660;" -- left right double arrow, U+21D4// Mathematical Operators// forall   CDATA "&#8704;" -- for all, U+2200"part",		$\u2202,	// CDATA "&#8706;" -- partial differential, U+2202//exist    CDATA "&#8707;" -- there exists, U+2203//empty    CDATA "&#8709;" -- empty set = null set = diameter, U+2205//nabla    CDATA "&#8711;" -- nabla = backward difference, U+2207//isin     CDATA "&#8712;" -- element of, U+2208//notin    CDATA "&#8713;" -- not an element of, U+2209//ni       CDATA "&#8715;" -- contains as member, U+220B"prod",		$\u220F,	// CDATA "&#8719;" -- n-ary product = product sign, U+03A0 'greek capital letter pi'"sum",		$\u2211,	// CDATA "&#8721;" -- n-ary sumation, U+2211. U+03A3 'greek capital letter sigma'"minus",	$-,			// CDATA "&#8722;" -- minus sign, U+2212//lowast   CDATA "&#8727;" -- asterisk operator, U+2217"radic",	$\u221A,	// CDATA "&#8730;" -- square root = radical sign, U+221A//prop     CDATA "&#8733;" -- proportional to, U+221D"infin",	$\u221E,	// CDATA "&#8734;" -- infinity, U+221E//ang      CDATA "&#8736;" -- angle, U+2220//and      CDATA "&#8743;" -- logical and = wedge, U+2227//or       CDATA "&#8744;" -- logical or = vee, U+2228//cap      CDATA "&#8745;" -- intersection = cap, U+2229//cup      CDATA "&#8746;" -- union = cup, U+222A"int",		$\u222B,	// CDATA "&#8747;" -- integral, U+222B//there4   CDATA "&#8756;" -- therefore, U+2234"sim",		$~,			// CDATA "&#8764;" -- tilde operator = varies with = similar to, U+223C	// NOT the same character as the tilde, U+007E, although the same glyph might be used to represent both//cong     CDATA "&#8773;" -- approximately equal to, U+2245"asymp",	$\u2248,	// CDATA "&#8776;" -- almost equal to = asymptotic to, U+2248"ne",		$\u2260,	// CDATA "&#8800;" -- not equal to, U+2260//equiv    CDATA "&#8801;" -- identical to, U+2261"le",		$\u2264,	// CDATA "&#8804;" -- less-than or equal to, U+2264"ge",		$\u2265,	// CDATA "&#8805;" -- greater-than or equal to, U+2265//sub      CDATA "&#8834;" -- subset of, U+2282//sup      CDATA "&#8835;" -- superset of, U+2283	//nsup, 'not a superset of, U+2283' is not covered by the Symbol font encoding//nsub     CDATA "&#8836;" -- not a subset of, U+2284//sube     CDATA "&#8838;" -- subset of or equal to, U+2286//supe     CDATA "&#8839;" -- superset of or equal to, U+2287//oplus    CDATA "&#8853;" -- circled plus = direct sum, U+2295//otimes   CDATA "&#8855;" -- circled times = vector product, U+2297//perp     CDATA "&#8869;" -- up tack = orthogonal to = perpendicular, U+22A5//sdot     CDATA "&#8901;" -- dot operator, U+22C5. NOT the same character as U+00B7 middle dot// Miscellaneous Technical//lceil    CDATA "&#8968;" -- left ceiling = apl upstile, U+2308//rceil    CDATA "&#8969;" -- right ceiling, U+2309//lfloor   CDATA "&#8970;" -- left floor = apl downstile, U+230A//rfloor   CDATA "&#8971;" -- right floor, U+230B//lang     CDATA "&#9001;" -- left-pointing angle bracket = bra, U+2329	//lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark'//rang     CDATA "&#9002;" -- right-pointing angle bracket = ket, U+232A	//rang is NOT the same character as U+003E 'greater than' or U+203A 'single right-pointing angle quotation mark'// Geometric Shapes"loz",		$\u25CA,	// CDATA "&#9674;" -- lozenge, U+25CA// Miscellaneous Symbols//spades   CDATA "&#9824;" -- black spade suit, U+2660	//black here seems to mean filled as opposed to hollow//clubs    CDATA "&#9827;" -- black club suit = shamrock, U+2663//hearts   CDATA "&#9829;" -- black heart suit = valentine, U+2665//diams    CDATA "&#9830;" -- black diamond suit, U+2666// Latin Extended-A -->"OElig",	$\u0152,	// CDATA "&#338;"  -- latin capital ligature OE, U+0152"oelig",	$\u0153,	// CDATA "&#339;"  -- latin small ligature oe, U+0153	//ligature is a misnomer, this is a separate character in some languages -->//Scaron  CDATA "&#352;"  -- latin capital letter S with caron, U+0160 ISOlat2 -->//scaron  CDATA "&#353;"  -- latin small letter s with caron, U+0161 ISOlat2 -->"Yuml",		$\u0178,	// CDATA "&#376;"  -- latin capital letter Y with diaeresis, U+0178// Spacing Modifier Letters"circ",		$\u02C6,	// CDATA "&#710;"  -- modifier letter circumflex accent, U+02C6"tilde",	$\u02DC,	// CDATA "&#732;"  -- small tilde, U+02DC// General Punctuation"ensp",		$ ,		// CDATA "&#8194;" -- en space, U+2002"emsp",		$ ,		// CDATA "&#8195;" -- em space, U+2003"thinsp",	$ ,		// CDATA "&#8201;" -- thin space, U+2009//zwnj    CDATA "&#8204;" -- zero width non-joiner, U+200C//zwj     CDATA "&#8205;" -- zero width joiner, U+200D//lrm     CDATA "&#8206;" -- left-to-right mark, U+200E//rlm     CDATA "&#8207;" -- right-to-left mark, U+200F"ndash",	$\u2013,	// CDATA "&#8211;" -- en dash, U+2013"mdash",	$\u2014,	// CDATA "&#8212;" -- em dash, U+2014"lsquo",	$\u2018,	// CDATA "&#8216;" -- left single quotation mark, U+2018"rsquo",	$\u2019,	// CDATA "&#8217;" -- right single quotation mark, U+2019"sbquo",	$\u201A,	// CDATA "&#8218;" -- single low-9 quotation mark, U+201A"ldquo",	$\u201C,	// CDATA "&#8220;" -- left double quotation mark, U+201C"rdquo",	$\u201D,	// CDATA "&#8221;" -- right double quotation mark, U+201D"bdquo",	$\u201E,	// CDATA "&#8222;" -- double low-9 quotation mark, U+201E"dagger",	$\u2020,	// CDATA "&#8224;" -- dagger, U+2020"Dagger",	$\u2021,	// CDATA "&#8225;" -- double dagger, U+2021"permil",	$\u2030,	// CDATA "&#8240;" -- per mille sign, U+2030"lsaquo",	$\u2039,	// CDATA "&#8249;" -- single left-pointing angle quotation mark, U+2039 ISO proposed"rsaquo",	$\u203A,	// CDATA "&#8250;" -- single right-pointing angle quotation mark, U+203A ISO proposed //euro   CDATA "&#8364;"  -- euro sign, U+20AC// dots//"ldots", 	$\u2026,	// ???// spaces//"sp", 	$ ,		// ???//Icon Entities (see html3:entities.htm)//substitute IMG inline in fixString?//&ftp; -- ftp server//&gopher; -- gopher server//&telnet; -- telnet connection//&archive; -- archive server//&filing.cabinet; -- filing cabinet//&folder; -- folder or directory//&fixed.disk; -- fixed media drive//&disk.drive; -- removeable media drive//&document; -- unspecified document type//&unknown.document; -- unrecognised document type//&text.document; -- text/plain, text.html etc//&binary.document; -- binary data//&binhex.document; -- binhex format//&audio; -- audio sequence//&film; -- film or animation, such as an MPEG movie//&image; -- photograph, drawing or graphic of any kind//&map; -- geographical or a schematic map//&form; -- fill-out form//&mail; -- email messages//&parent; -- parent of current document//&next; -- next document in current sequence//&previous; -- previous document in current sequence//&home; -- home document//&toc; -- table of contents//&glossary; -- glossary of terms etc//&index; -- searchable index//&summary; -- summary//&calculator; -- A calculator//&caution; -- Warning sign//&clock; -- A clock//&compressed.document;//&diskette; -- A diskette//&display; -- A computer screen//&fax; -- A fax machine//&mail.in; -- mail-in tray//&mail.out; -- mail-out tray//&mouse; -- mouse/pointing device//&printer; -- hardcopy device//&tn3270; -- tn3270 terminal session//&trash; -- waste paper basket//&uuencoded.document; -- uuencoded data]);constant kGIFextension	:= ".gif";constant kGIFStart		:= "GIF";			// for matching binaryconstant kJPEGStart		:= "JFIF";DefineGlobalConstant('kEmptyGlobal, {	cache: [], historyPos: 0,				htmlApps: {}, helperApps: {},	imageExtensions: [kGIFextension],	protos: {},	}); constant kPkgStart := "package";constant kHistoryPath	:= 'cache;		// should have been called historyconstant kHistoryPos	:= 'historyPos;DefineGlobalConstant('kInitGlobal, func(slot,val)begin	local gData;	if kBuild1x or Functions.GetGlobals exists	then begin		if not gData := GetGlobals().(kNewtsCapeSymbol)		then GetGlobals().(EnsureInternal(kNewtsCapeSymbol)) := gData := EnsureInternal(kEmptyGlobal);		end	else begin		if not gData := GetGlobalVar(kNewtsCapeSymbol)		then DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal(kEmptyGlobal));		end;	if slot	then if gData.(slot)		then gData.(slot)		else gData.(EnsureInternal(slot)) := EnsureInternal(val)	else gData;end);constant kFirstFieldsFlag	:= '_pageField1;// FORM functionsDefineGlobalConstant('kAllData, func(keep) // "allData"// use this instead of :AuthorData() to make sure Hidden values, form_init used// keep=nil means resetbegin	local iData := call kInitGlobal with (Intern(ISBN), {}), iaction, adata;	if not (adata := idata.(iaction := EnsureInternal(Intern(action))))	then adata := idata.(iaction) := {};	if not idata.(kFirstFieldsFlag)	// keep track for book of which TEXT/PASSWORD field on page is first	then idata.(EnsureInternal(kFirstFieldsFlag)) := [];	if not keep or Length(adata) = 0	then begin		bdata := :BookData();		local hidden := if bdata then DeepClone(bdata.form_hidden.(iaction)) else {}; // closed?		ReplaceObject(adata, EnsureInternal(hidden));		bdata:?form_init(adata,action);		if not keep and call kViewIsOpenFunc with (GetRoot().(kBookReaderSymbol)) // refresh for reset		then :ScrollPage(0);		end;	adata;end);DefineGlobalConstant('kGetData, func(name) // assume symbolif namethen :AllData(true).(name));DefineGlobalConstant('kSetData, func(name,val) // assume symbolif namethen :AllData(true).(EnsureInternal(name)) := EnsureInternal(Clone(val)));DefineGlobalConstant('kPrintFunc, func(val) Print(val)); // for default SCRIPTconstant cr := "\n";constant lf := "\u000A";DefineGlobalConstant('crlf, unicodeCR&unicodeLF);DefineGlobalConstant('kNilFunc0, func() nil);DefineGlobalConstant('kNilFunc1, func(arg) nil);  // for viewClickScriptDefineGlobalConstant('kAppHeight, 152);		// 1.3 = 136DefineGlobalConstant('kAppWidth, 240);DefineGlobalConstant('kThick, 3); 			// thickness of app frame. just let it possibly clip on left/rightconstant kTagP	  := '{_tag: P};DefineGlobalConstant('kATagP, [kTagP]);constant kTagHTML := '{_tag: HTML, _value: true};constant kTagBODY := '{_tag: BODY, _value: true};constant kHTMLStart		:= "<HTML>";constant kHTMLStop		:= "</HTML>";constant kTitleStart	:= "<TITLE>";constant kTitleStop		:= "</TITLE>";constant kBodyStart		:= "<BODY";constant kBodyStop		:= "</BODY>";constant kHeadStop		:= "</HEAD>";constant kBaseStart 	:= "<BASE";constant kFrameStart	:= "<FRAME";constant kIFrameStart	:= "<IFRAME";constant kLinkStart		:= "<LINK";constant kHREF			:= "HREF=";	// !!!gconstant kSRC			:= "SRC=";constant kNAME			:= "NAME=";constant kALT			:= "ALT=";constant kCommentStart	:= "<!--";constant kCommentStop	:= "-->";constant kHelpISBN := "introtoc.htm"; // first bookconstant kAlign := '["Left", "Right", "Center", "Justify"];DefineGlobalConstant('kPrefTags, [	"ADDRESS", "BLOCKQUOTE", "CAPTION", "DD", "DT",	// !!!e,b "DIV"	"H1","H2", "H3", "H4", "H5", "H6",	"LI", "P", "PRE",	"TITLE",	// "XMP",	//"TD", "TH",		// these are containers	'pickSeparator,		// add form objs (some in tagDict, inputDict)	"CHECKBOX", "RADIO", 	//"PASSWORD", "PASSWORD_LABEL", "RESET",	"SELECT", "SELECT_LABEL", "SELECT_MENU", "SUBMIT",	"TEXT", "TEXT_LABEL", "TEXTAREA",		]);if kBuild1xthen begin	ArrayRemoveCount(kPrefTags,		ArrayPos(kPrefTags,"SELECT_MENU",SetContains(kPrefTags,'pickSeparator)+1,Functions.StrEqual), 1);	end;DefineGlobalConstant('kNoName, 		LocObj("no NAME", 'noNameErr));DefineGlobalConstant('kNoHelper,	LocObj("no helper for", 'noHelperErr));DefineGlobalConstant('kMissing,		${ & LocObj("missing", 'missingErr) && "^0}");DefineGlobalConstant('kReplacePkg,	LocObj("Replace existing package?", 'replacePackage));constant kHTTP 		:= "http:";constant kHTTPS		:= "https://";constant kHTTPlen	:= 7;			// = http://constant kMailTo 	:= "mailto:";constant kNews		:= "news:";constant kFtp		:= "ftp:";constant kJavaScript:= "javascript:";constant kLocation	:= "Location";constant kPost 		:= "POST";constant kGet		:= "GET";constant kTitles	:= "_Titles";DefineGlobalConstant('kDefaultMethod, kGet);constant kNewtsPaperSymbol := '|NewsNewt:SKoren|;constant kURL		:= "URL";constant kUnkURL  := "x"; // for form stuff?constant kDefaultEncType 		:= "application/x-www-form-urlencoded";constant kHTMLMediaType 		:= "text/html";constant kGIFMediaType			:= "image/gif";constant kTextMediaType 		:= "text/plain";constant kJPEGMediaType			:= "image/jpeg";constant kAllMediaType			:= "*/*";DefineGlobalConstant('kContentTypeSym, Intern("Content-Type"));DefineGlobalConstant('kIsHTML, func(htmlSource)	// !!!j. was :skipHTMLif htmlSourcethen begin	local spos := StrPos(htmlSource, kHTMLStart, 0);	if spos	then spos	else StrPos(htmlSource, "<!DOCTYPE", 0);	end);// BOOKS// page indent/bounds  (see :bookTemplate)DefineGlobalConstant('kGetInt, func(val, default)	// !!!bbegin	if (if kBuild20 then isInteger(val) else isInstance(val, 'int))	then val	else if (if kBuild20 then IsString(val) else isInstance(val, 'string))		and val := StringToNumber(val)	then Floor(val)	else default;		// typically: 0, nilend);DefineGlobalConstant('kGetStr, func(val, default)	// !!!b. see bookTemplatebegin	if (if kBuild20 then IsString(val) else isInstance(val, 'string)) and StrFilled(val)	then Clone(val)	else default;end);DefineGlobalConstant('kprotoContainer, {	// used for rootContainer, UL, TABLE, etc.	left:		0,	top:		0,	right:		0,	bottom:		0,	indent:		0,	above:		0,	indentR:	0,	below:		0,	align:		0,	height:		0,	// e.g., for UL	_tag:		NIL,	_value:		NIL,	_container:	NIL,	_contents:	NIL,	getWidth:	func() 				right  - left - indent - indentR,	getHeight:	func() 				bottom - top,	addTop:		func(INT newVal)	top := top + newVal,	// !!!a1. unnecessary accessors (save some space)	//getLeft:	func()				left,	//setLeft:	func(INT newVal)	left := newVal,	//getRight:	func()				right,	//setRight:	func(INT newVal)	right := newVal,	//getTop:		func()				top,	//setTop:		func(INT newVal)	top := newVal,	//getBottom:	func()				bottom,	//setBottom:	func(INT newVal)	bottom := newVal,	setContainer: func(newContainer)	// msg to currentContainer. push/pop a container		if newContainer		then begin			newContainer.left 		:= left;	//  + newContainer.indent			newContainer.indent 	:= newContainer.indent + indent;			//newContainer.indentR 	:= newContainer.indentR + indentR;			newContainer.top 		:= top; 	//  + newContainer.above; (only if not=rootcontainer.top?)	// :setTop ???  			newContainer.right 		:= right;	// - newtContainer.indentR;			newContainer.bottom		:= bottom;	// - newtContainer.below;			newContainer._container := self;			newContainer;			end		else if _container		then begin			_container.top := top; // :setTop(top);	//  + below ?			_container;			end		else self,	// keep around just in case (e.g., TD outside TABLE)	fixWidth: func(str, INT availWid, INT contWid)	// str: width as a percentage or pixels	begin		local slen, ival, wid :=			if (if kBuild20 then IsString(str) else isInstance(str, 'string)) and				(slen := StrLen(str)) > 0			then if str[slen-1] = $% //EndsWith(str,"%")					then begin					if ival := StringToNumber(SubStr(str,0,slen-1))	// !!!q. nec for German ROMs & small nums?					then min(availWid, Floor(contWid * ival/100));	// % of container width					end				else if ival := StringToNumber(str)				then min(availWid, Floor(ival));				// pixels <= availWid		if wid		then right := left + wid		else wid := right - left;		wid;	end,	renderObj:	func(obj)	// copied by P		while isFrame(obj) and obj := obj:addBlock() do obj:newPage(),	addItem: func(obj)	// default/direct behavior: render and display	begin//if kDebugHTTP then Print("container:" && _tag && if _value then "start" else "stop");		local obj1 := obj._tag, newobj;		if optionsAPI.ignoreTables and SetContains('[TD,TH,TR,TABLE],obj1)		then return NIL;		if obj._value and		// moved/expanded			(((obj1='TR or (obj1='CAPTION and not optionsAPI.ignoreTables))	// !!!k				and _tag <> newobj := 'TABLE) or	// e.g., missing <TABLE> tag in concerts.calendar.com			 ((obj1='TD or obj1='TH) 	  and _tag <> newobj := 'TR)		// missing TABLE/TR after nested?			)		then begin//Print("adding:" && newobj);			currentContainer:addItem(:getObj(tagDict, newobj, true)); 	// add TABLE/TR			return currentContainer:addItem(obj);						// add obj to new TABLE/TR			end;		if newobj := obj:get_data()		then if isArray(newobj)			then // array of objs (assume only single level)				foreach obj1 in newobj	// 				do :renderObj(obj1)			else :renderObj(newobj);	// single obj	end,	get_data: func()	// used by TABLE, TR, TD/TH	begin		if _value		then begin			align := :getAlign();			currentContainer := currentContainer:setContainer(self);			_contents := [];			end		else if _tag = currentContainer._tag	// !!!g. only pop if same tag (e.g., extra </DIV>		then currentContainer := currentContainer:setContainer(nil);		NIL;	end,	fixAttribute: func(val, type, default)	// used by TABLE, TR, TD/TH. copied by P	if isInstance(val, type)	// already converted?	then val	else if (if kBuild20 then IsString(val) else isInstance(val, 'string))	then if type='int		then begin			local slen := StrLen(val), ival;			if val[slen-1] = $%			then if ival := StringToNumber(SubStr(val,0,slen-1))	// !!!q. for German ROMs. see fixWidth				then Floor(default * ival / 100)		// HR WIDTH				else default			else if ival := StringToNumber(val)			then Floor(ival)			else default;			end		else if type='symbol		then Intern(val)		else val	else default,	});constant kSplitHeight := 14; // see :addBlockDefineGlobalConstant ('kContentsPath,	'contents);DefineGlobalConstant ('kPagePath,		'[pathExpr: rendering,0,pages]);DefineGlobalConstant ('kHintPath,		'[pathExpr: rendering,0,contents,0]);DefineGlobalConstant ('kTemplatePath,	'[pathExpr: templates,0]);DefineGlobalConstant ('kScriptsPath,	'[pathExpr: templates,0,scripts]);DefineGlobalConstant ('kTOCPath,		'[pathExpr: browsers,0,list]);DefineGlobalConstant ('kStringHintsPath,'hints);DefineGlobalConstant ('kStylePath,		'styles);DefineGlobalConstant ('kDataPath,		'data);							// doublecheck separate access via :BookData()DefineGlobalConstant ('kBasePath,		'[pathExpr: data, base_href]);DefineGlobalConstant ('kEdataPath,		'[pathExpr: data, edata]);DefineGlobalConstant ('kLinkPath,		'[pathExpr: data, links]);DefineGlobalConstant ('kFHiddenPath,	'[pathExpr: data, form_hidden]);DefineGlobalConstant ('kFPrintPath,		'[pathExpr: data, form_printnames]);// title, shortTitle, author, isbn, help, appSymbol, _package ?/*1.x:whereisBook{...bookSoup: {book: <book itself>} = libooklibrary.books [	{<book info slots>,	booksoup: {book: <book itself>},	}...]2.0:whereisBook{library: {<book info, soup entry slots>} = :getLibraryEntrybookSoup: {book: <book itself>} = libooklibrary [??]*/DefineGlobalConstant('kLFetch, func(ARRAY a, item, INT start, testfn, path, ix) // if ix=true then index else entry/*begin	local INT rest := Length(a) - start;	local testFn := if kNIE		then if rest=1			then GetGlobalFn(if testSym='|str=| then 'StrEqual else testSym)			else if testSym='|=| or testSym='|str=| then testSym else if testSym then GetGlobalFn(testSym) else '|=|		else xxxif Length(a) - start = 1then if call (if kNIE then GetGlobalFn(testSym) else Functions.(testSym)) with (item, a[start])	then if ix		then start		else a[start]	else nilelse if kNIEthen if (start := LSearch (a, item, start, if testSym='|=| or testSym= '|str=| then testSym else GetGlobalFn(testSym), path))	then if ix		then start		else a[start]	else nil	else if path then*/begin // like limited LFetch for 1.x. if path=nil, use ArrayPos directly	local entry, val;	local INT i;	for i := 0 to Length(a)-1	do if (val := (entry := a[i]).(path)) and call testfn with (item, val)	then return if ix then i else entry;	NIL;	end//else ArrayPos(a, item, start, testfn));DefineGlobalConstant('kFindPkg, func(pkgname)if kNIEthen begin	local store, pkg;	foreach store in GetStores()			// was GetPackageStores	do if pkg := GetPkgRef(pkgname, store)	then return pkg;	NIL;	endelse call kLFetch with (GetPackages(), pkgname, 0, Functions.StrEqual, 'title, nil));DefineGlobalConstant('kThawPkg, func(pkgname) // thaw an app or bookif (kBuild20 or Functions.ThawPackage exists) and	pkgname := call kFindPkg with (pkgname)then begin	ThawPackage(pkgname);	TRUE;	end);// same def as used in NewtDefineGlobalConstant('kFindBook, func(isbn,libentry) // used by refreshBook, kGotoHREF, saveBook, dumpBookbegin	local viewer := GetRoot().(kBookReaderSymbol), nos20 := kBuild20 or HasVariable(viewer,'getLibraryEntry);	local libook := viewer:whereIsBook(isbn), library := viewer.library; // !!!u	if (kBuild20 or nos20) and libook and		(not isFrame(libook.bookSoup)									// <bad pkg ref>		or not try libook.bookSoup.book onexception |evt.ex| do NIL)	// *** evt.ex.fr ***	then begin // see kBookCleanup		if library		then RemoveSlot(library, Intern(isbn)); // NOS 2.x bug. badly removed help book?		libook := NIL;		end;	if not libook	then libook := if call kThawPkg with (isbn) then viewer:whereIsBook(isbn);	if libook	then if libentry		then if kBuild20 or nos20			then libook.library			else begin				if library				then call kLFetch with (library.books, isbn, 0, Functions.StrEqual, 'isbn, nil);				end		else if libook.bookSoup and			(not nos20 or not libook.library or libook.library.bookPresent>0 or libook.bookSoup.help)		then libook.bookSoup.book;end);DefineGlobalConstant('kFindApp, func(appsym)if (if kBuild20 then IsSymbol(appsym) else isInstance(appsym,'symbol))then begin	local root := GetRoot(), app;	if app := root.(appsym)	then app	else if call kThawPkg with (SprintObject(appsym))	then root.(appsym);	end);DefineGlobalConstant('kAllBooks, func()begin // return array of current ISBNs	local viewer := GetRoot().(kBookReaderSymbol), nos20 := kBuild20 or HasVariable(viewer,'getLibraryEntry);	local libentry, all := [], libentries := viewer.library; // ?? undoc	if libentries and (kBuild20 or nos20 or libentries := libentries.books)	then foreach libentry in libentries		do if kBuild20 or nos20			then begin				if libentry.book //and not libentry.help 	// deleted?				then AddArraySlot(all, libentry.book.isbn);				end			else if libentry.booksoup				then AddArraySlot(all, libentry.isbn);	Sort(all, '|str<|, nil);end);DefineGlobalConstant('kSubStr, func(str, pos, upto, bwith)if StrFilled(str)then begin	local pos1 := pos;	if (if kBuild20 then IsString(pos) else isInstance(pos,'string)) // pos = str or int	then begin		local INT slen := StrLen(pos);		pos1 :=			if bwith			then (if BeginsWith(str,pos) then 0)			else if kBuild20 and slen=1			then CharPos(str,pos[0],0)			else StrPos(str,pos,0);		if pos1		then pos1 := pos1 + slen		else return NIL;		end;	local pos2 := if (if kBuild20 then IsString(upto) else isInstance(upto,'string))  // upto = str, int or NIL (end)		then if kBuild20 and StrLen(upto)=1			then CharPos(str, upto[0], pos1)			else StrPos(str, upto, pos1)		else upto;	SubStr(str, pos1, if pos2 then pos2- pos1);	endelse str);DefineGlobalConstant('kMyTrim, func(str, start, stop)	// !!!eTrimString(SubStr(str, start, if stop then stop-start)));DefineGlobalConstant('kSendMsg, func(addr, namestr, subj, bodyText)if StrFilled(bodyText)	// !!!gthen begin	local href, root := GetRoot();	if not addr and BeginsWith(bodyText, kHTTP)	then begin 		local newtscape;		if (newtscape := root.(kNewtsCapeSymbol)) and			(addr := newtscape:fixOptions(nil).httpProxy)		then addr := call kSubStr with (addr, kMailTo, nil, true);		if not StrFilled(addr)		then addr := Clone("web-mail@ebay.com");	// ???		namestr := "WebMail";		subj := "WebMail Request";		href := call kSubStr with (bodyText, 0, "#", nil);		bodyText := "WebMail-Format: text-source\nWebMail-ID:" & kAppNameL & $- &				kVersionInt & "\n\n<URL:" & href & ">\n";		end;	TrimString(addr);	local spos := if kBuild20 then CharPos(addr, $?, 0) else StrPos(addr, "?", 0), entry; // mailto:...?subject=...	if spos	then begin		if entry := call kSubStr with (addr, "?subject=", "&", nil)	// in case &body= also		then subj := entry;		if entry := call kSubStr with (addr, "&body=", nil, nil)		then begin			StrReplace(entry, "\\n", cr, nil);			bodyText := ParamStr(entry & unicodeCR, [if href then href else bodyText]);			end;		addr := SubStr(addr, 0, spos);		end;	if spos := if kBuild20 then CharPos(addr, $<, 0) else StrPos(addr, "<", 0)	// John Smith <jsmith@foo.com>	then begin		namestr := call kMyTrim with (addr, 0, spos);	// !!!e. TrimString(SubStr(addr, 0, spos));		addr := call kSubStr with (addr, spos+1, ">", nil);		end;	local item := {}, mailSym := 'mail;	if kBuild20 or Functions.TransportNotify exists	then begin // 2.x		gc();		entry := GetUnionSoup(ROM_cardfileSoupName):Query( // find existing person based on email addr.			{type: 'words,			words: if (spos := CharPos(addr, $@, 0))				then [SubStr(addr,0,spos), SubStr(addr,spos+1,nil)]				else [addr]}):entry();		if not entry		then begin			local firstName := "", lastName := "";			if namestr			then if spos := CharPos(namestr,$ ,0)				then begin					firstName := SubStr(namestr, 0, spos);					lastName  := SubStr(namestr, spos+1, nil);					end				else lastName := namestr;			entry := {				name: {class: 'person, first: firstName, last: lastName},				email: if ClassOf(addr)='string then SetClass(addr,'|string.email|) else addr,				country: GetUserConfig('country),				};			end;		if not isFrame(item := TransportNotify(mailSym:='|WyndMAIL:GDT|, 'NewItem, [nil])) and		   not isFrame(item := TransportNotify(mailSym := 'mail, 'NewItem, [nil])) 				//last used mail transport		then return NIL;// customroute.  setupItem of routing format. cram in toRef.// newest docs about setupItm in Prog Guide		item.toRef := [GetDataDefs('|nameRef.email|):MakeNameRef(entry, '|nameRef.email|)];		if not item.fromRef		then item.fromRef := GetDataDefs('|nameRef.email|):MakeNameRef(GetUserConfig('currentPersona), '|nameRef.email|);			// {email: GetUserConfig('mailAccount)} ?		item.class := 'mailText;	//'ioItem; ?? (only if Text stationery installed?)		//item.state := 'ready;		end	else item.email := addr; // 1.x	item.appSymbol := kNotesSym;	// Notes.  copperfield?	item.connect 	:= NIL;			// sendNow	item.hidden 	:= NIL;			// hideIOBox	item.title 		:= subj;		// Subject:	item.body 		:= { // for ?		//class: 'text, //(only if Text stationery installed?)  //kdatasymbol,  // with this -- no stationery?		text: bodyText,		//timeStamp: Time(),		//version: kVersionInt,		};	item.text := bodyText;			// for eWorld, GoFetch, ?	/*if kBuild20 or Functions.OpenRoutingSlip exists	then OpenRoutingSlip(item, {target: item, targetView: root.(kBookReaderSymbol)})		//self:GetTargetInfo('routing))	else*///if kDebugHTTP then Print(item);	if kBuild20 or Functions.Send exists	then begin		Send(mailSym, item);		root.(kInboxSym):?Open();	// !!!a. OpenAsOutBox(); this seems to set Outbox as a perm pref		end	else call kSendFunc with (mailSym, item); 	// Outbox automatically opens for 1.xend);DefineGlobalConstant('kNetHopperURL, func(urlframe)if urlframethen begin	// use NetHopper API?  bodyDataStr, extraDataStr, markerStr?	local url := urlframe.protocolStr & "://" & urlframe.domainNameStr;	if urlframe.port	then url := url & $: & urlframe.port;	url & urlframe.directoryStr & urlframe.fileNameStr;end);DefineGlobalConstant('kNewVBO, func(store, cl, dlen)	// the recommended initializationbegin	gc();	local data := if not IsInteger(dlen) then dlen;		// string or binary obj	local vbo :=		(if store then store else GetDefaultStore()):NewCompressedVBO(			EnsureInternal(if cl then cl else 'string),		// cl == binary. !!!g			if data then Length(data) else dlen,// length of string or binary or #			kTextCompander, 					//kBitmapCompander unreliable for bin?			nil);	if data	then begin		BinaryMunger(vbo, 0, nil, data, 0, nil);		if Length(data) > 2		then ClearVBOCache(vbo);		end;	vbo;end);constant kMinVBOlen := 8192; 	// :getRun, :addBlock, parse:AddContentItem, kBigSubStrDefineGlobalConstant('kVBOFlush, 16*1024);	// !!!d was 20K. was 24K. ( < 32K?). :getRun, inputLine, inputTextSpec, inputBinarySpecDefineGlobalConstant('kCopyRawHTML, func(str)	// used by matchHTMLtitle(EETransfer), openDoc(NetHopper)if kNIE and strthen begin // packed ascii (8-bit not unicode chars)	local INT i, len := Length(str), byte;	local htmlSource := call kNewVBO with (nil, nil, (len*2) + 2);	for i := 0 to len-1	do begin		if (byte := ExtractByte(str,i)) = 0		then break StrMunger(htmlSource,i,nil, nil,0,nil);		htmlSource[i] :=			if byte = chLF			then unicodeCR			else Chr(byte);		if (i mod kVBOFlush) = 0 and i > 0		then ClearVBOCache(htmlSource);		end;	ClearVBOCache(htmlSource);	htmlSource;	end);// note: URL comparison should probably be case sensitive (except for host name) ???DefineGlobalConstant('kCacheEqual, func(url, url2, edata, edata2) // used in kGetURLCache[2], kGoHistory. kGotoHREF(url = url2 or	(if kBuild20	then IsString(url) and IsString(url2) and StrEqual(url, url2)	else isInstance(url,'string) and isInstance(url2,'string) and StrEqual(url, url2)	)) and 		(edata = edata2 or	(if kBuild20	then IsString(edata) and IsString(edata2) and StrEqual(edata, edata2)	else isInstance(edata,'string) and isInstance(edata2,'string) and StrEqual(edata, edata2) 	)));// return nil if not found; or entry or text/bitmap (not "true" anymore?)DefineGlobalConstant('kGetURLCache, func(soupCacheName, href, field, edata, expOK)if kNIE and soupCacheName and hrefthen begin	gc();	local newtscape := GetRoot().(kAppSymbol), result, removed;	local entry := GetUnionSoupAlways(soupCacheName):Query({		indexPath: 'URL, 	// for l-o-n-g strings		beginKey: href,		endKey: href,		validTest: func(entry)			call kCacheEqual with (entry.url, href, entry.edata, edata)			//or (EntryUndoChanges(entry) and nil)		}):entry();		if entry and call kCacheEqual with (entry.url, href, entry.edata, edata)	// doublecheck	then if field = '_delete or (not expOK and entry.expires and entry.expires <= Time())		then begin			EntryRemoveFromSoupXmit(entry, nil);	// avoid multiple xmits			result := field = '_delete;				// avoid extra lookups? (NH, other cache)			removed := true;						end		else begin			if kDebugHTTP			then begin Print("get cache:" && href); Print("edata:" && edata); end;			result := if field then entry.(field) else entry;			local type := entry.type;			EntryUndoChanges(entry);		// prevent problems during Save?			if isBinary(result)	and not IsString(result) // normally, result is a soup entry, or text or a bitmap frame				and ClassOf(result) <> 'picture	// !!!r. PICT ok.			then begin//Print("kGetURLCache raw Image");//Print(result);				result :=		// if not (rawImage), then convert it here (e.g., GIF, JPEG?)					if not type or StrEqual(type, kGIFMediaType)					then newtscape:convertImage(type, href, result, {_proto: newtscape.optionsAPI, cacheImages: nil, rawImage: nil}, nil)					else newtscape:dispatchFile(type, href, result, nil);	// e.g., JPEG?//Print(result);				if IsString(result) // error msg				then begin					GetRoot().(kAppSymbol):Notify(kNotifyAlert, result, href);	// !!!j					result := NIL;					end;				end;			end;	if removed	then XmitSoupChange(soupCacheName, kNewtsCapeSymbol, 'whatThe, NIL);	local soup, cursor, url, data;	if not result and field <> '_delete and (soup := GetUnionSoup(kCacheNetHopperSoupName)) // !!!d. (field='text or field='bitmap)	then begin		entry := nil;		gc();		cursor := soup:Query(nil);		entry := cursor:entry();		while entry		do begin			url := call kNetHopperURL with (entry.fTransReq.targetURL);			data := entry.fStreamVBO;			if url and StrEqual(href, url)			then break result :=				if field = 'text				then call kCopyRawHTML with (data)				else if field = 'bitmap				then if data					then newtscape:convertImage(kGIFMediaType, href, data, {_proto: newtscape.optionsAPI, cacheImages: NIL, rawImage: nil}, nil)					else entry.fFrameObject.icon				else if data	// !!!k				then entry;		// !!!d			entry := nil;			entry := cursor:next();			end;		end;	/* to include LunaSuite cache (why?)	Inbox(Cache folder)	URL = :fixString(entry.fCacherStr)	// possible % e.g., for ~	text = fdocument.fbody.fbody;		// "raw"?  are graphics cached? how distinguish? what format?	*/	result;	end);// used in ReceiveTextSuccess, ReceiveBinarySuccess(convertImage), protoSerialProtocolDefineGlobalConstant('kPutURLCache, func(store, soupCacheName, href, field, entry, content, modified, expires, edata, data, type) //, labelsif kNIE and soupCacheName and hrefthen begin	if entry	then entry.URL := href		// should be same except for redirect?	else entry := {URL: href};	//, labels: labels	entry.(field) := content;	entry.modified := if modified then modified else Time();	// but if Newton clock is wrong...	if edata	then entry.edata := edata;	if data	then entry.data := data;if kDebugHTTP then Print("put cache:" && href && "==" && edata);	if expires	then entry.expires := expires;	entry.type := type;	if isSoupEntry(entry)	then EntryFlushXmit(entry, kNewtsCapeSymbol)	// EntryChangeXmit(entry,nil)		// !!!j  AddFlushedXmit(entry, kNewtsCapeSymbol); // AddToDefaultStoreXmit(entry, nil);	else GetUnionSoupAlways(soupCacheName):AddToStoreFlushedXmit(entry, store, kNewtsCapeSymbol)	end);/*DefineGlobalConstant('kTempCacheEntry, func(entry)entry and (StrFilled(entry.edata)) // or CharPos(entry.URL, $?, 0))	// a POST result or generated document?);*/DefineGlobalConstant('kCollectURLs, func(soupCacheName, results, maxEntries, aentry, keep, expOK)	// check/collect URLs in a cache. used in viewSetupFormScript & cachemenuif kNIE and soupCacheNamethen begin	gc();	local cursor := GetUnionSoupAlways(soupCacheName):Query(nil);	if soupCacheName <> kCacheHTMLSoupName and		maxEntries and cursor:countEntries() <= maxEntries	then return results;	local INT now := Time(), count := 0;	local entry := cursor:reset();	while entry	do begin		if isFrame(entry)		then if (not expOK and entry.expires and entry.expires <= now) or	// remove expired entries				(not results and not keep and StrFilled(entry.edata)) // call kTempCacheEntry with (entry))	// remove results/gendoc entries			then begin				EntryRemoveFromSoupXmit(entry, nil); // no need to notify since new list assigned (Open) or nil-ed (quit) immed afterwardsif kDebugHTTP then Print("expiring:" && entry.URL && entry.edata);				end			else if (count := count+1) and		// count good entries					isArray(results) and					not StrFilled(entry.edata)	// currently don't add POST temp entries to cache (menu) list			then begin//Write(entry.URL & $ ); Print(entry.bitmap);				AddArraySlot(results, if aentry then {item: entry.URL, _alias: MakeEntryAlias(entry)} else entry.URL);				EntryUndoChanges(entry);				end			else if kDebugHTTP and results=true			then begin Print(entry.URL); Print(entry.edata); end;		entry := nil;		entry := cursor:next();		end;	if results or (count := count - maxEntries) <= 0	then return results;	// delete some entries from beginningif kDebugHTTP then Print("remove additional" && count && "regular entries");	entry := cursor:reset();	while count > 0 and entry	do begin		if isFrame(entry) and not entry.locked		then beginif kDebugHTTP then Print("removing old:" && entry.URL);			EntryRemoveFromSoupXmit(entry, nil); // ditto on change notif			count := count - 1;			end;		entry := nil;		entry := cursor:next();		end;	end);DefineGlobalConstant('kCharPosLast, func(str, ch)if kBuild1x or CharPos(str,ch,0)then begin	local INT i;	for i := StrLen(str)-1 to 0 by -1	do  if str[i] = ch		then return i;	NIL;	end);DefineGlobalConstant('kGetFileName, func(href) // used by kGoToHREF, BASE, dispatchFilebegin	// find last //*	local spos := 0, cpos := 0;	while spos := if kBuild20 then CharPos(href, $/, spos) else StrPos(href, "/", spos)	do cpos := spos := spos+1;*/	local cpos := call kCharPosLast with (href, $/);	call kSubStr with (href, if cpos then cpos+1 else 0, "#", nil);		// +1end);/*DefineGlobalConstant('kEndsWithAny, func(str, exts)if kBuild20then LFetch(exts, str, 0, GetGlobalFn('EndsWith), nil)else begin	local ext;	foreach ext in exts	do if EndsWith(str, ext)	then return ext;	NIL;	end);*/DefineGlobalConstant('kImageExtension, func(href)if hrefthen begin//EndsWith(href, kGIFextension)//call kEndsWithAny with (href, ) // !!!h,a	local exts := call kInitGlobal with ('imageExtensions, [kGIFextension]);	if kNIE	then LSearch (exts, href, 0, GetGlobalFn('EndsWith), nil)	else ArrayPos(exts, href, 0, Functions.EndsWith);end);DefineGlobalConstant('kHTMLExtensions, [".html", ".htm"]);constant kMaxHistory := 20; // for History (book) popup. compute for landscape???DefineGlobalConstant('kUntitled, LocObj("Untitled", 'untitledLabel));DefineGlobalConstant('kUntitledISBN, kUntitled & ".htm");// structure of History entry (kGoHistory)// isbn, pagenum, title, url, edataDefineGlobalConstant('kAddHistory, func() // called by kGotoHREF, kPostData, kSendHTTPbegin	local root := GetRoot(), viewer := root.(kBookReaderSymbol), bdata, newtscape, curBook;	if call kViewIsOpenFunc with (viewer)		// book might now be closed	then curBook := viewer	else if newtscape := root.(kAppSymbol)	// otherwise, see if Newt's Cape is active	then curBook := newtscape.curBook;	// assume history(cache) exists from kBookOpenScript	local gData := call kInitGlobal with (nil, nil);	local ARRAY history := gData.(kHistoryPath);	local INT len := Length(history);	if curBook and (len=0 or gData.(kHistoryPos) <> len-1)		and not StrEqual(curBook.isbn, kUntitledISBN)	then begin		local bdata, cp, title, isbn, bhref, edata;		if viewer = curBook		then begin			bdata 	:= viewer:bookData();			isbn 	:= viewer.isbn;			// these are EnsureInternal-ed below			cp	 	:= viewer:currentPage();				title 	:= viewer:BookTitle();				bhref 	:= bdata.base_href;			edata 	:= bdata.edata;			end		else begin	// newtscape. for ultimate o-o, add :bookData, :currentPage, :BookTitle methods to book?			bdata 	:= curBook.data;			isbn	:= Clone(curBook.isbn);		// clone these because of savePkg?			cp 		:= 1;			title 	:= Clone(curBook.title);			bhref 	:= Clone(bdata.base_href);			edata 	:= Clone(bdata.edata);			end;if kDebugHTTP then begin Print("adding"); Print([isbn, cp, title, bhref, edata]); end;		// avoid duplicate (kCacheEqual)??		// !!!b. save some heap for same book?		local entry :=			if len > 0	// !!!u			then if kBuild20				then LFetch(history, isbn, 0, '|str=|, 0)				else call kLFetch with (history, isbn, 0, Functions.StrEqual, 0, nil);		if entry and call kCacheEqual with (entry[3],bhref, entry[4],edata)		then begin	// share			isbn  := entry[0];			title := entry[2];			bhref := entry[3];			edata := entry[4];			entry := history[len-1]; // !!!e. elim dup entries at end			if entry[1]=cp and call kCacheEqual with (entry[3],bhref, entry[4],edata)			then isbn := nil;			end;		if isbn	// !!!e		then AddArraySlot(history, EnsureInternal([isbn, cp, title, bhref, edata]));		local INT diff := len + 1 - kMaxHistory;		if diff > 0		then ArrayRemoveCount(history, 0, diff);		end;	gData.(kHistoryPos) := Length(history);end);DefineGlobalConstant('kSendHTTP, func(href, methenc, hname, edata, data, options) // ~same args&order as 'newURL (except hname<->enctype)if StrLen(href) > kHTTPlen // more than http:// ?then begin	local root := GetRoot(), newtscape := root.(kNewtsCapeSymbol), proxy;	if kNIE and newtscape and 		// options usually from HTTP FSM. otherwise, current "global" options		(options := newtscape:Init(if options then options else newtscape.optionsAPI))		and not ((proxy := options.httpProxy) and BeginsWith(proxy, kMailto)) 	// allow cache entries even if NIE frozen (if not mailto:)		//and GlobalFnExists('InetDisplayStatus) // InetGrabLink 2.0? InetGrabLinkVerbose	then beginif kDebugHTTP then begin Write("kSendHTTP: "); Print(options); end;		if not options.noStatus		then newtscape:open();		local tmp := StrPos(href,":/",0);	// !!!s		if not tmp		then return nil;		if href[tmp+2] <> $/	// e.g., http:/w3opac-cgi-bin/expertensuche.pl		then StrMunger(href := Clone(href),tmp+2,0, "/",0,1);				// if just host (no dir or file), then make sure it ends with /		if not CharPos(href,$/,tmp+3)		then href := href & $/;		local method := methenc, enctype := kDefaultEncType; // compat with < 1.3f		if isArray(methenc)		then begin			method	:= methenc[0];			enctype := methenc[1]; // future support of PUT etc.?			end;		if not options.noHistory		then call kAddHistory with ();	// don't add when just navigatingif kDebugHTTP then Print("edata");		if edata and StrEqual(method,kGet)		then href := href & $? & edata;		newtscape:displayURL(href);		if options.edata		then (if not edata then edata := options.edata)	// kGoHistory. href ok.		else options.edata := edata;	// (for infonautics search from Newtworks)		if not options.start		then options.start := 0;		//options.base := href;	// in :DoEvent		if hname		then options.hrefname := hname;if kDebugHTTP then Print("cache");		if call kImageExtension with (href) or			not ((options.cacheEntry :=				call kGetURLCache with (newtscape.cacheHTML, href, nil, edata, options.ignoreHTMLExpiration))	// options.cacheHTML ??				or LSearch(kHTMLextensions, href, 0, GetGlobalFn('EndsWith), nil)) // !!!h				//or call kEndsWithAny with (href, kHTMLextensions))		then options.cacheEntry :=		// options.cacheImages ??			call kGetURLCache with (newtscape.cacheImages, href, nil, edata, options.ignoreImageExpiration);	// possibly generated (non .gif) image?if kDebugHTTP then Print("close");		// defer for highlighting?		if not options.noClose		then begin			root.(kBookReaderSymbol):?close();	// AddDeferredSend(root.(kBookReaderSymbol),'close,nil);			root.(kHelpReaderSymbol):?close();	// AddDeferredSend(root.(kHelpReaderSymbol),'close,nil);			end;if kDebugHTTP then Print("doEvent");		newtscape:DoEvent('newURL, [href, method, enctype, edata, data, options]);		end	else call kSendMsg with (nil,nil,nil,href);	end);// return array of positions or nil. used twice by kResolveURLDefineGlobalConstant('kStrPosS, func(str, subs, pos)begin	local ARRAY apos := [];	local sub1 := if kNIE and StrLen(subs)=1 then subs[0];	while pos := if kNIE and sub1 then CharPos(str, sub1, pos) else StrPos(str, subs, pos)	do begin		AddArraySlot(apos, pos);		pos := pos+1;		end;	apos;end);DefineGlobalConstant('kURLmatch, func(s)if (if kNIE then IsString(s) else isInstance(s,'string))	// !!!jthen BeginsWith(s, kHTTP & "//")	// !!!r	or BeginsWith(s, kMailto) or BeginsWith(s, kNews) or BeginsWith(s, kFtp)	or BeginsWith(s, kHTTPS)		// !!!g);// merge relative href with BASE. used kGoToHref, SUBMIT:SCRIPTDefineGlobalConstant('kResolveURL, func(bhref, href)if call kURLmatch with (href)	// !!!j. href and BeginsWith(href, kHTTP)then hrefelse if bhref and BeginsWith(bhref, kHTTP) and StrFilled(href)then begin	local del :=		if BeginsWith(href,"./") //  ./foo -> foo		then 2		else if BeginsWith(href, kHTTP)	// !!!r. but not // (since kURLmatch didn't succeed). make just start with /. e.g., http:/w3opac-cgi-bin/index1.pl?DATABASE=sisis		then 5;	if del	then StrMunger(href:=Clone(href),0,del, nil,0,nil);//http://host.domain.net/dir/resource.htm[;var1=value1][?<query string>][#<fragment]	//bhref := call kSubStr with (bhref, 0, "?", nil);	local npos, qpos :=			// e.g., http://.....?...&pubURL=http*C*//...		if kBuild20		then CharPos(bhref, $?, 0)		else StrPos(bhref, "?", 0);		if qpos	then begin		if (npos := if kBuild20 then CharPos(bhref, $;, 0) else StrPos(bhref, ";", 0))		and npos < qpos		then qpos := npos;		bhref := SubStr(bhref, 0, qpos);		end;	if npos := StrPos(bhref, "//", kHTTPlen)	 // !!!r. e.g., http://www.altavista.com//cgi-bin...	then begin	// include one / ?		bhref := SubStr(bhref, 0, npos+1);		npos := nil;		end;	local ARRAY hdir, bdir := call kStrPosS with (bhref, "/", kHTTPlen);	// !!!r	local INT hdirlen, bdirlen := Length(bdir), nhref;	if bdirlen=0	then begin		bdir := [StrLen(bhref)];		bhref := bhref & $/;		bdirlen := 1;		end;	if href[0] = $/ //BeginsWith(href, "/")	then //href := SubStr(href,1,nil);		nhref := SubStr(bhref, 0, if npos then npos+1 else bdir[0]) & href	else begin		hdir := call kStrPosS with (href, "../", 0);		if bdirlen >= (hdirlen := Length(hdir))		then nhref :=			SubStr(bhref, 0,				if npos then npos+2				else if bdirlen > hdirlen then bdir[bdirlen-hdirlen-1]+1 //else nil				) &			if hdirlen=0 then href			else SubStr(href, hdir[hdirlen-1]+3, nil);		end;	//if kDebugOn then print("resolving" && bhref && "\n +" && href && "\n ->" && nhref);	nhref;	end);/* for example:base:  http://somesite.com/  http://somesite.com/dir1/dir2/foo.htm  http://somesite.com//cgi-bin/dir1/foo.htmhref:  bar.htm  /bar.htm  ../bar.htm  /foo/bar.htm  ./foo/bar.htm  /cgi-bin/dir2/bar.htm*/DefineGlobalConstant('kHelpViewerSetup, func(helpBook)// helpBook = next help book (or nil for close)// returns viewer// used by kGoToHref, :refreshBook, :removeAppbegin	local viewer := GetRoot().(kHelpReaderSymbol);	if kBuild20 or GetVariable(viewer,'ReOrientToScreen)	then begin		if not helpBook or viewer.bookRef <> helpBook		then viewer:close();		viewer;		end	else begin // 1.x		local curView := GetView('viewFrontMost);		if HasVariable(curView,'openManual)		then if helpBook			then if curView.bookRef = helpBook				then return curView				else nil			else return curView:close();		// else nil;		BuildContext({_proto: viewer, bookRef: helpBook});		end;end);DefineGlobalConstant('kDoHREF, func(isbn, name, helpbook)begin	// see refreshBook	local viewer := GetRoot().(kBookReaderSymbol), openMsg := 'openBook, openArg := isbn, num;	if helpbook	then begin		openMsg := 'openManual;		viewer := call kHelpViewerSetup with (openArg := helpbook);		end;/*	// unused	local cp;	if not helpbook		and call kViewIsOpenFunc with (viewer) // book might now be closed. e.g., NewtATut	then cp := viewer:currentPage();*/	if isbn	then Perform(viewer, openMsg, [openArg]);	if name	then if helpbook		then begin			viewer:openHelpTo(name);	// openHelpBookTo -- aValue error??? viewer.outline:?TopicByName(name);				viewer.outline:?Show();			end		else if (if kBuild20 then IsInteger(num := name) else isInstance(num := name, 'int))			or num := call kGetInt with (call kSubStr with (name, "PAGE#", nil, true), nil) // !!!b				//((num := call kSubStr with (name, "PAGE#", nil, true)) and				//(num := StringToNumber(num)) and num := Floor(num))		then viewer:TurnToPage(min(num, viewer:countPages()))		else viewer:TurnToContent('name, name);end);DefineGlobalConstant('kGetAttrib, func(str, delim1, delim2, INT spos)begin	local epos := CharPos(str, delim1, spos);	if not epos then return NIL;	local name := call kMyTrim with (str, spos, epos);	// !!!e. TrimString(SubStr(str, spos, epos-spos));	spos := epos+1;	epos := if delim2 then CharPos(str, delim2, spos);	//local val := TrimString(SubStr(str, spos, if epos then epos-spos));	[name, call kMyTrim with (str, spos, epos), if epos then epos+1];	// !!!eend);DefineGlobalConstant('kGetAttribS, func(str, delim1, delim2, INT spos)begin	local epos := StrPos(str, delim1, spos);	if not epos then return NIL;	local name := call kMyTrim with (str, spos, epos);	// !!!e. TrimString(SubStr(str, spos, epos-spos));	spos := epos+1;	epos := if delim2 then StrPos(str, delim2, spos);	//local val := TrimString(SubStr(str, spos, if epos then epos-spos));	[name, call kMyTrim with (str, spos, epos), if epos then epos+1];	// !!!eend);// minimum compile for standalone books or user-controlled options. no error returnedDefineGlobalConstant('kCompileVal,{compileVal: func(str) try call Compile(str) with () onexception |evt.ex| do NIL});DefineGlobalConstant('kGoToHREF, func(bk,bdata,hrefstr, x1,y1,href,item)if (if kBuild20 then IsString(href) else isInstance(href,'string)) and StrFilled(href)then begin // called by kGoToHREFclick and :getURL//Print([bk,bdata,hrefstr,x1,y1,href,item]);	local ihref := Intern(href), nref := bdata.(ihref);	if (if kBuild20 then IsString(nref) else isInstance(nref, 'string))	then nref := bdata.(ihref := Intern(href := nref));  // string shadow (immediate map)	if (if kBuild20	// !!!g. moved from later npos<>0 test		then IsFunction(nref)		else isInstance(nref, '_function) or isInstance(nref, 'CodeBlock))	then /* we could pass bk instead of item to provide more context; if so, then GetVariable(xxx,'item) */		return Perform(bdata,ihref,[x1,y1,href,bk]);	local npos := if kBuild20 then CharPos(href, $#, 0) else StrPos(href, "#", 0), href1 := href, href2;	if npos	then begin		href1 := SubStr(href,0,npos);		href2 := SubStr(href,npos+1,nil);		end;//Print([href, href1, href2, nref, ihref, npos]);	local nbk, bhref, app, newisbn, httpref, addr, entry, tmp := bk, msg, args;	// save bk(obj)	local help := bk and GetVariable(bk,'openManual);	if help 		// !!!g. moved earlier	then bk := GetVariable(bk,'bookRef);	local curisbn := if bk then GetVariable(bk,'ISBN);//Print(curisbn);	local newtscape := GetRoot().(kNewtsCapeSymbol), cpos;	local options := if newtscape then newtscape:?fixOptions(newtscape.optionsAPI); // use global if any	if not options	then options := {};//Write("kGotoHREF: "); Print(options);	if npos<>0 // nil or >0	then 		//if BeginsWith(href, kHTTP)	// do below to resolve isbn		//then httpref := href1		if newtscape		// allow pseudo-URL of form: "Notes/theTitle"			and (((addr := call kSubStr with (href, "Notes/", nil, true)) and app := notesSoupName)				 /*or ((addr := call kSubStr with (href, "Inbox/", nil, true)) and app := inboxSoupName)*/				 )			and (entry := newtscape:findHTMLentry(app, addr, true, kTitleStart, kTitleStop))		then /*if isArray(entry)			then begin				entry[3] := options;				Perform(newtscape, 'dispatchFile, entry);				end			else*/ newtscape:dispatchFile(kHTMLMediaType, href, entry, options) /* how about file:// ??		else if kNIE and newtscape and 				// soup/foosoup/bar.htm			(addr := call kSubstr with (href, kSoupDir, nil, true)) and		// soup/			(app :=  call kSubstr with (addr, 0, "/", nil)) and				//      foosoup			(addr := call kSubstr with (addr, app & $/, nil, true)) and		//			    bar.htm			entry := call kGetURLCache with (app, addr, nil, nil, nil)		then newtscape:dispatchFile(entry.type, addr, entry.(if BeginsWith(entry.type, "text/") then 'text else 'bitmap), options) */		else if (			if app := call kFindApp with (ihref)			then (msg := 'toggle) and args := '[]			else if ((newtscape and options.allowCompile) or					(IsReadonly(href) and newtscape := kCompileVal)) // NOTE: newtscape only used in this block, not later in method					and (cpos := if kBuild20	// start of msg							then CharPos(href1, $/, 0)							else  StrPos(href1, "/",0)						) <> 0					and (begin						if not cpos						then cpos := -1;						tmp := if kBuild20 // start of args							then CharPos(href1,$?, cpos+1)							else  StrPos(href1,"?",cpos+1);						msg := Intern(SubStr(href1, cpos+1, if tmp then tmp-cpos-1));						if cpos > 0						then app := call kFindApp with (Intern(SubStr(href1,0,cpos)))			// appSymbol						else msg := if kBuild20 then GetGlobalFn(msg) else  Functions.(msg);	// function						end)			then args :=				if tmp				then if (if kBuild20 then CharPos(href1,$=,tmp) else StrPos(href1,"=",tmp))					then begin // frame: ?a=1&b=2&c=3						args := {};						local ARRAY attrib := [nil,nil,tmp+1];						while (tmp := attrib[2]) and attrib :=							if kBuild20							then call kGetAttrib  with (href1, $=,  $&,  tmp)							else call kGetAttribS with (href1, "=", "&", tmp)						do args.(Intern(attrib[0])) := newtscape:compileVal(attrib[1]);						[args];						end					else newtscape:compileVal($[ & SubStr(href1,tmp+1,nil) & $])	// array of csv: ?1,2,3				else '[]			)		then if app			then Perform(app, msg, args)			else Apply(msg, args)		else if (cpos := if kBuild20 then CharPos(href1, $:, 0) else StrPos(href1,":",0))			and not BeginsWith(href, kHTTP) // have Newt's Cape handle directly (below)?			and (app := GetRoot().(kURLcopSymbol)):?PreferredApp(href, 'getURL, {})		then app:getURL(href, options)		else if addr := call kSubStr with (href, kMailTo, nil, true)		then call kSendMsg with (			addr,			if hrefstr then hrefstr else bdata.name,			if bk then GetVariable(bk, 'TITLE) else bdata.subject,			if bdata.body then bdata.body			else options.mailBody				// !!!g. "hi,\nI saw this cool document in Newt's Cape."			)		else if BeginsWith(href, kNews)	// not registered for URLcop?		then return call kFindApp with (kNewtsPaperSymbol):?getURL(href,options)		else if BeginsWith(href, kFtp)			// not registered for URLcop			or BeginsWith(href, kJavaScript)		then return NIL	// |NewtFTPConnection:Tactile| ???		else begin // http: or relative. now better checking for book even if absolute//if kDebugHTTP then Print("href1:" && href1);			newisbn := call kGetFileName with (href1);//if kDebugHTTP then Print("newisbn:" && newisbn);			tmp := call kResolveURL with (bhref := bdata.base_href, href1);//if kDebugHTTP then Print("tmp:" && tmp);			if curisbn and StrEqual(curisbn,newisbn) // same book?				and call kCacheEqual with (bhref, tmp, bdata.edata, nil)				//and not bdata.edata				//and (not IsInstance(bhref,'string) or StrEqual(bhref, href1))			then nil 	// newisbn := NIL			else if not (					((nbk := call kFindBook with (newisbn,nil))		// other book not \ed?					//or nbk := call kFindBook with (newisbn := $/ & newisbn,nil) // for old (<= 1.6m) standalone books?? (see addIncludes)					) and					nbk.data and					(not bhref or call kCacheEqual with (nbk.(kBasePath), tmp, nbk.(kEdataPath), nil))					)					//and StrFilled(bhref) and BeginsWith(bhref, kHTTP)			then begin//Print("base:" && nbk.(kBasePath)); Print("edata:" && nbk.(kEdataPath));				httpref := tmp; // call kResolveURL with (bhref, href1);				npos := href2 := newisbn := NIL; // don't try to use that topic				end			else if not nbk then newisbn := nil;			end;//if kDebugHTTP then Print("httpref:" && httpref);	if httpref	// TCP or WebMail	then call kSendHTTP with (httpref, kGet, href2, nil, nil, nil)	else if newisbn or npos	then begin		args := [			newisbn,			if href2 then href2 else options.hrefname,			if nbk and nbk.help			then nbk			else if help			then call kFindBook with (curisbn,nil)];		call kAddHistory with ();		if kBuild1x and Functions.AddDeferredAction exists		then AddDeferredAction(kDoHREF, args)		else AddDeferredCall  (kDoHREF, args);		// do callbackFn ??		end;end);DefineGlobalConstant('kShapeHilite, {transferMode: modeXor, fillPattern: vfBlack});DefineGlobalConstant('kPickHREFfunc, func(INT cmd) // assumes newscape, args slotsbegin	local bhref := args[1].base_href;	local url :=		if cmd > 0		then call kResolveURL with (bhref, if kBuild20 and cmd > 3 then args[6].src else args[5]); // IMG,doc URL	if cmd=0		// get URL	then if newtscape		then begin			if kBuild20			then AddDeferredSend(newtscape, 'gotoHREF, args)			else AddDeferredAction(Functions.Perform, [newtscape, 'gotoHREF, args]);			end		else if kBuild20		then   AddDeferredCall(kGotoHREF, args)		else AddDeferredAction(kGotoHREF, args)// note: these other commands weren't added if newtscape=nil	else if cmd=1	// display resolved URL of link	then begin		newtscape:open();		newtscape:displayURL(url);		end			else if kBuild20	then begin		local pos := CharPos(url,$#,0);		if pos		then url := SubStr(url,0,pos);		if cmd=2	// cache only		then newtscape:DoEvent(NIL, [{			cacheOnly: true,			fURLqueue: [url]	// resolved URL			}])		else if cmd=3	// bookmark highlighted text w/ resolved URL		then begin			//newtscape:init(nil);	// !!!i			newtscape:AddBookmark(if StrFilled(args[2]) then args[2] else url, url);			end		else // if cmd=4 then	// load image, redisplay original doc			begin			AddDeferredSend(newtscape, 'removeApp, [true,true]);	// keep open if desired			newtscape:DoEvent(NIL, [{				checkCache: true,				fURLqueue: [	// also add Referer option?					url,		// resolved IMG URL					bhref,		// current doc (force later cache lookup via checkCache)					],				}]);			end;		end;end);DefineGlobalConstant('kBuiltinFonts, '[espy, newYork, geneva]); // 1.x & 2.x [familyPicker, dumpBook]// use ROM_fontSystemxxx instead for Japanese/Chinese system patch??constant kSystemFontSym := 'espy;	//ROM_systemFont ??DefineGlobalConstant('kEspy9,	if kNIE then ROM_fontSystem9 		else 0x00002400);	// was kNCfont	DefineGlobalConstant('kEspy9B,	if kNIE then ROM_fontSystem9Bold 	else 0x00102400);DefineGlobalConstant('kEspy10,	if kNIE then ROM_fontSystem10 		else 0x00002800);DefineGlobalConstant('kEspy10B,	if kNIE then ROM_fontSystem10Bold	else 0x00102800);DefineGlobalConstant('kEspy12,	if kNIE then ROM_fontSystem12		else 0x00003000);DefineGlobalConstant('kGoToHREFclickShare, func(obj,unit,gestureID)	// viewGestureScript compatible (rather than viewClickScript)if gestureID=aeTap or gestureID=aeLinethen begin// see kGetHrefRegions// [0=href, 1=start, 2=count, 3=left, 4=top, 5=right, 6=bottom, ] or ... 3=rect,polygon,oval,	local INT gx := GetPoint(firstX,unit);	// (save gx,gy for 1.x DoPopup)	local INT gy := GetPoint(firstY,unit);//Print(obj); GetRoot().(kAppSymbol).curObj := obj;	local item 	 := GetVariable(obj,'item);//Print(item);	local data	 := item.data;	local INT dataOffset := if not (if kBuild20 then IsString(data) else IsInstance(data,'string)) or data = obj.text then 0 else StrPos(data, obj.text, 0); // moved here for PointToCharOffset and SetHilite	local INT cpos :=		if (kBuild20 or HasVariable(obj,'PointToCharOffset)) and IsString(data)		then obj:PointToCharOffset(gx,gy) + dataOffset		else -1;//Print(cpos);	local sview := obj.scrolledView;	if not sview then sview := obj;	local href, gb := sview:GlobalBox(), hrefstr, bdata, vh, scale;	local ARRAY hrefentry;	local INT x1 := gx - gb.left; // offset for 1.x or all/graphic compare	local INT y1 := gy - gb.top;//Print([x1,y1,]); Print(item.hrefs);	local hrefstart, hreflen, hrefobj;	foreach hrefentry in item.hrefs	do if (if (hreflen := hrefentry[2]) and cpos >= 0			then hrefentry[1] <= cpos and cpos <= (hrefentry[1]+hreflen)			else Length(hrefentry) > 3				and (hrefobj := hrefentry[3]) and				if (if kBuild20 then IsInteger(hrefobj) else isInstance(hrefobj,'int))				then hrefobj      <= x1 and x1 <= hrefentry[5] and				  	 hrefentry[4] <= y1 and y1 <= hrefentry[6]				else HitShape(if kBuild1x and isFrame(hrefobj) then hrefobj := DeepClone(hrefobj) else hrefobj,x1,y1) // polygons crash for Hitshape/DoDrawing?			)		then break href := hrefentry[0];//Print(href);	if href	then begin		if (scale := item.scale) and scale <> 1		then begin			x1 := RIntToL(x1 / scale);			y1 := RIntToL(y1 / scale);			end;//Print([x1,y1,href]);		if not (bdata := obj:BookData())		then bdata := {};					if hreflen		then begin			hrefstr := SubStr(data, hrefstart := hrefentry[1], hreflen); // for mail addr or bookmark			if gestureID = aeTap			then begin // hilight it				//obj:HiliteBlock(item, hrefstart, hreflen);  // hilite range (for regular book). doesn't work w/ aliases?				//RefreshViews();				// hilite is wrt to text in child, but should use hrefstart-dataOffset (but not avail in obj)				hrefstart := hrefstart - dataOffset;				obj:SetHilite(hrefstart, hrefstart + hreflen, true);				Sleep(4);				//SetValue(obj, 'hilites, nil); // delayed?				call kClearSelectionHilitesFunc with (obj);				//SetKeyView(nil, 0); // caret when return??				end;			end		else begin // graphic or area			if Length(hrefentry) <= 3 or (if kBuild20 then IsInteger(hrefobj) else isInstance(hrefobj,'int))			then begin				if gestureID = aeTap // highlight it				then sview:Hilite(vh := true); 	// all (e.g., IMG)				if item.ismap and not 			// server side image map					((hrefstr := bdata.(Intern(href)))	// except if shadow URL					and (if kBuild20						then IsFunction(hrefstr)						else isInstance(hrefstr, '_function) or isInstance(hrefstr, 'CodeBlock))					)				then href := href & $? & x1 & $, & y1;				end			else if gestureID = aeTap			then begin	// client-side image map -- highlight it				//obj:DrawShape(hrefobj, kShapeHilite); // shape?				sview:DoDrawing('DrawShape, [hrefobj, kShapeHilite]);	// avoid clipping problems				sview:Dirty(); // unhilite after delay				end;			hrefstr := "";			end;		local newtscape := call kFindApp with (kNewtsCapeSymbol);		if gestureID = aeTap		then begin			if newtscape	// use latest version if possible			then newtscape:?gotoHREF(obj,bdata,hrefstr, x1,y1,href,item);			else call kGotoHREF with (obj,bdata,hrefstr, x1,y1,href,item);			if vh //and call kViewIsOpenFunc with (obj)			then 				// turn off highlight (if still open, e.g., NewtATut?) help???				//obj:?scrollPage(0);	// takes too long				// call kClearSelectionHilitesFunc with (obj);	// gets left on (e.g., email)				sview:Hilite(nil);			end		else begin	// aeLine			local args := [obj,bdata,hrefstr,x1,y1,href,item];			local cmds := [LocObj("Go", 'goLabel) & $: && href];			if newtscape			then AddArrayslot(cmds, LocObj("Display URL", 'displayURLitem));			if kBuild20 or HasVariable(self, 'PopupMenu)			then begin				local font := kEspy9;				if newtscape				then begin					AddArraySlot(cmds, kCacheItem);					AddArraySlot(cmds,						kAddBookmark & $: &&						if StrFilled(hrefstr) then hrefstr else href);					if item.src					then AddArraySlot(cmds,						LocObj("Load Image", 'loadImageItem) & $: && item.src);					if kNCfont and newtscape.menuFontJ					then font := newtscape.menuFontJ;	// !!!j					end;				obj.newtscape := newtscape;	// this avoids BuildContext mess				obj.args := args;				obj.pickActionScript := kPickHREFfunc;				vh := obj:PopupMenu(cmds, {left: x1, top: y1});				vh.pickMaxWidth := GetAppParams().appAreaWidth-10;				SetValue(vh, 'viewFont, font);				end			else begin				gb := newtscape:GlobalBox();//Print([gx,gy]); Print(gb);				DoPopup(cmds, gx - gb.left, gy - gb.top, {					newtscape: newtscape,					args: args,					pickActionScript: kPickHREFfunc,					//pickCancelledScript: kNilFunc0,					});				end;			end;		TRUE;	// handled		end;	//NIL	// allow hilighting etc.	end);DefineGlobalConstant('kGoToHREFclickNC, func(obj,unit,gestureID) // non-standalonebegin	local app;	if not (app := GetRoot().(kNewtsCapeSymbol))	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	if HasVariable(app, 'hrefScriptG)	// so new books can work with old or new Newt's Cape	then app:hrefScriptG(obj,unit,gestureID)	else app:?hrefScript(obj,unit);end);DefineGlobalConstant('kGoToHREFclick, func(obj,unit,gestureID)begin	local app;	if not (app := GetRoot().(kNewtsCapeSymbol))	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	if HasVariable(app, 'hrefScriptG)	// so new books can work with old or new Newt's Cape	then app:hrefScriptG(obj,unit,gestureID)	else if HasVariable(app, 'hrefScript)	then app:hrefScript(obj,unit)	else // nil might mean either kGoToHREFclickNC had no script, or no HREF		//call kGoToHREFclickNC with (obj, unit, gestureID) or		call kGoToHREFclickShare with (obj,unit, gestureID);end);DefineGlobalConstant('kAHREF, [ // sharable (via bookTemplate). see :addBlock	//'viewClickScript,	//func(unit) :hrefScript(self,unit),	'viewGestureScript,	func(unit,gestureID) :hrefScript(self,unit,gestureID),	// -> kGoToHREFclick or kGoToHREFclickNC]);DefineGlobalConstant('kAHREFG, [ // sharable version for graphics	'viewGestureScript,	kAHREF[1],	'viewFlags,	vVisible+vClipping+vClickable+vGesturesAllowed, // otherwise vGestureScript wouldn't work	'viewClickScript,	func(unit)	if self.scrolledView	then :hrefScript(self, unit, aeTap),	// otherwise, client image maps don't work if scrolling	//else nil so line gesture can be recognized]);DefineGlobalConstant('kLineBreakChars, [$\n, $ , $\t, $-, $/, $+, $], $[, $*, $=, $&, $^, $|, $<, $>, $\\, ]);// !!!j. borrowed from HTMListDefineGlobalConstant('kBigStringObj, {new: func(str)	{_proto: self,	bigStr: str,	nextFlush: if kNIE then kVBOFlush,	},append: func(str,start,count)	begin		StrMunger(bigStr,StrLen(bigStr),0, str,start,count);		if kNIE		then begin			local INT slen := StrLen(bigStr);			if IsVBO(str)			then begin				if (slen*2) >= nextFlush				then begin					ClearVBOCache(bigStr);					nextFlush := slen + kVBOFlush;					end;				end			else if slen > kMinVBOlen	// mutate large heap str to VBO			then begin				bigStr := call kNewVBO with (nil, nil, bigStr);				nextFlush := slen + kVBOFlush;				end;			end;	end,length: func() StrLen(bigStr),contents: func()	begin		if kNIE		then ClearVBOCache(bigStr);		bigStr;	end,});DefineGlobalConstant('kBigSubStr, func(str,start,count)	// !!!m. used in kSplitTextHeightFunc, addBlockif kNIE and IsVBO(str) and (if count then count else StrLen(str)-start) > kMinVBOlenthen begin	local bigStr := call kNewVBO with (nil,nil,"");	StrMunger(bigStr,0,nil, str,start,count);	ClearVBOCache(bigStr);	// !!!b1	bigStr;	endelse SubStr(str, start, count));// !!!m. if both=true then return both (as earlier);// otherwise return only single styles array//   if start=0, return upto count//   if start>0 then return until end(ignoring count)DefineGlobalConstant('kSplitRuns, func (ARRAY styles, INT start, count, both)begin // ASSUMES pos < string length	local INT i, tot := 0, ntot, pos := if start=0 then count else start; // split point	local s1,s2;	for i:=0 to Length(styles)-1 by 2	do  if (ntot := tot+styles[i]) < pos		then tot := ntot // again		else break;	// split	if both or start=0	then s1 := ArrayMunger([],0,nil, styles,0,i+2);	if ntot > pos	then begin		if s1		then s1[i] := pos-tot;		if ntot = pos+1		then i:=i+2;		end;	else i := i+2;	if both or start > 0	then begin		s2 := ArrayMunger([],0,nil, styles,i,nil);		if ntot > pos+1		then s2[0] := ntot-pos-1;		end;	// return	if both	then [s1,s2]	else if s1	then s1	else s2;end);/*call func(runs)	// calc total run lengthbegin	local i, tot := 0;	for i:=0 to Length(runs)-1 by 2	do tot := tot + runs[i];	tot;end with ()getroot().|NewtsCape:NewtsCape|:simpletextheight(substr("", 0,719), 320, [])getroot().|NewtsCape:NewtsCape|.curbook.rendering[0].pages[1].blocks[4].bounds*/if kStyleMeasure thenDefineGlobalConstant('kDummyHeightView, { // !!!m. used in kMySimpleHeightFunc for TotalTextBounds	viewClass: clEditView,	viewFlags: vAnythingAllowed,	recConfig: ROM_rcPrefsConfig,	//@443	});DefineGlobalConstant('kScreenChars, if kNIE then 1800 else 900); // !!!oDefineGlobalConstant('kMySimpleHeightFunc, func(text, INT start, count, INT width, font) // !!!o,m. used in kMakeNote, :SimpleTextHeightbegin//Print([start,count,width]);//Print("kMySimpleHeightFunc1");	if (if count then count=0 else StrLen(text) = start)	// !!!o. empty?	then return 0;	if count or start > 0	then text :=			if kNIE			then call kBigSubStr with (text, start, count)	// !!!o. avoid measuring too much in some situations. 2K sems like plenty			else Substr(text, start, count);/*if not isArray(font)then begin//Print(text);Write("totaltextbounds: " &	TotalTextBounds({	// avoid earlier Substr in addBlock (but viewOriginY doesn't work in dummyheightview?)			text: text,			viewFont: font,			viewBounds: RelBounds(0,0,width,0)},			kDummyHeightView).bottom);Print("; textbounds: " &	TextBounds(text, font, RelBounds(0,0,width,0)).bottom + if Endswith(text,cr) then FontHeight(font) else 0);end;*///local ht :=	if kStyleMeasure and isArray(font)	// !!!m	then TotalTextBounds({	// avoid earlier Substr in addBlock (but viewOriginY doesn't work in dummyheightview?)			text: text,			styles: if start = 0 then font else call kSplitRuns with (font, start, nil, nil), // !!!o. ok to be longer?			viewBounds: RelBounds(0,0,width,0)},			kDummyHeightView).bottom	else/*		TotalTextBounds({			text: text,			viewFont: font,			viewBounds: RelBounds(0,0,width,0)},			kDummyHeightView).bottom;*/		(if text[StrLen(text)-1] = unicodeCR //EndsWith(text,cr)	// bug in TextBounds,kSimpleTextHeightFunc		then FontHeight(font)		else 0) +		(if kBuild20		then TextBounds(text, font, RelBounds(0,0,width,0)).bottom	// faster than TotalTextBounds?		else call kSimpleTextHeightFunc with (text,width,font)		);//Print("kMySimpleHeightFunc2");//	ht;/*if kStyleMeasure and GetRoot().(kAppsymbol).debugHeightthen beginPrint("\nkMySimpleHeightFunc. wid:" && width & "; ht:" && ht); Print(font); Print(text);end;ht;*/end);// used by kGetHrefRegions, :addBlockDefineGlobalConstant('kSplitTextHeightFunc, func NATIVE (str, ARRAY stcnt, INT wid, font, nht) // !!!o. native for 1.xif kStyleMeasure	// !!!mthen begin	// it would be nice to avoid substr/splitRuns (viewOriginY w/in editView?)	local INT cpos := 0, start := stcnt[0], count := stcnt[1];//Print(["kSplitTextHeightFunc1",start,count,wid,font,nht]);	local copyRange := start > 0 or StrLen(str) > count;	// !!!y	local gb, ch, view := BuildContext({		viewClass: clParagraphView,		viewFlags: vVisible,		ReorientToScreen:	ROM_DefRotateFunc,	// !!!q		text: if copyRange then str := call kBigSubStr with (str, start, count) else str, // !!!y,o. nil. avoid copying/too much?		viewBounds: RelBounds(0,0,wid,nht),		});	try begin		if isArray(font)		then view.styles := if copyRange then font := call kSplitRuns with (font, start, count, nil) else font // !!!y,o. nil		else begin			view.viewFont := font;			//!!!z. doesn't work with landscape or styles or ???  view.viewFlags := vVisible+vCalculateBounds;	// !!!y more accurate for PRE?			end;		view:open();		gb := view:GlobalBox();		cpos := view:PointToCharOffset(gb.right, gb.bottom); // bottom of last line?  FontHeight(font));//if GetRoot().(kAppSymbol).debugHeight then//Print("\nkSplitTextHeightFunc. cpos:" && cpos);		if cpos < 0 or call kMySimpleHeightFunc with (str, 0, cpos, wid, font) > nht // !!!o		then begin//Print("\nkSplitTextHeightFunc. actual height:" && stlen & "; wid:" && wid & "; nht:" && nht);//Print(font); Print(str);			cpos := view:PointToCharOffset(gb.right, gb.bottom-10); // earlier line?//Print("\nkSplitTextHeightFunc2. cpos:" && cpos);			end;//Print("kSplitTextHeightFunc2");		if cpos <= 0		then cpos := 0		else if cpos >= count		then cpos := count-1		else while cpos > 0			 do if SetContains(kLineBreakChars, ch := str[cpos])				then break				else if ch = $. and (cpos=count-1 or isWhiteSpace(str[cpos+1]))	// !!!o				then break cpos:=cpos+1				else cpos := cpos-1;//Print("kSplitTextHeightFunc3. cpos:" && cpos & "; cpos+start:" && start+cpos);		end	onexception |evt.ex| do nil;	view:close();//Print("kSplitTextHeightFunc3");	start + cpos;	endelse begin// sort of inverse of SimpleTextHeight// for given height, return max position in str (where line would break) -- see addBlock// or// 1.x: if nht=NIL, then return array of all line ends -- see kGetHrefRegions	local INT lpos := stcnt[0], start := stcnt[0], count := stcnt[1], slen := start + count;	// !!!o	local INT swid, ht := FontHeight(font), spos;	local ARRAY lines := [];	local cpos, toowide, xht := nht;	local kSetContains  := Functions.SetContains;	local kStrFontWidth := Functions.StrFontWidth;	loop begin		cpos := nil;		for spos := lpos to slen-1		do if cpos := call kSetContains with(kLineBreakChars, str[spos]) // faster than CharPos		then break;		swid := call kStrFontWidth with(SubStr(str,start,(if cpos and cpos<=2 then spos else spos+1)-start),font);		toowide := swid >= wid;		if (toowide and (if cpos=1 and swid=wid then lpos := spos+1 else true))			or (if cpos=0 then lpos := spos+1) // cr?		then begin			if nht			then (if (xht := xht - ht) < ht then break)			else if kBuild1x	// !!!m			then AddArraySlot(lines, lpos-1);			start := lpos; // new beginning of line			if toowide and cpos=0 then spos := spos-1; // don't lose cr			end;		lpos := spos+1;		if lpos > slen then break;		end;	if nht	then if lpos=0 then 0 else lpos-1	else if kBuild1x	// !!!m	then SetAdd(lines,slen,nil);end);/*call func(str,start,wid,font,nht)beginlocal kLineBreakChars := '[$\n, $ , $\t, $-, $/, $+, $], $[, $*, $=, $&, $^, $|, $<, $>, $\\,];local gb, cpos, view := BuildContext({		viewClass: clParagraphView,		viewFlags: vVisible+vCalculateBounds,		viewJustify: 0,		ReorientToScreen:	ROM_DefRotateFunc,		text: if start=0 and StrLen(str) < 1800 then str else str := SubStr(str, start, 1800),		viewBounds: RelBounds(0,0,wid,nht),		});		if isArray(font)		then view.styles := font		else view.viewFont := font;		//view.textFlags := vFixedTextStyle;	try begin		view:open();//Print(view);		gb := view:GlobalBox();		cpos := view:PointToCharOffset(gb.right, gb.bottom);local ch, ht2 := TextBounds(	Substr(str,start,cpos), font, RelBounds(0,0,wid,0)).bottom;Print("height:" && ht2);		if cpos < 0 or ht2 > nht		then cpos := view:PointToCharOffset(gb.right, gb.bottom-10);		if cpos <= 0		then cpos := 0		else if cpos >= count		then cpos := count-1		else while cpos > 0			 do if SetContains(kLineBreakChars, ch := str[cpos])				then break				else if ch = $. and (cpos=count-1 or isWhiteSpace(str[cpos+1]))	// !!!o				then break cpos:=cpos+1				else cpos := cpos-1;		end	onexception |evt.ex| do nil;	view:close();	start+cpos;end with (ss, 0, 320, 12288, 402)end with (	getroot().copperfield.contentarea:childviewframes()[1].item.data, 0,	320, 12288, 402)*/DefineGlobalConstant('kGetHrefRegions, func (str, INT start, count, INT wid, INT ht, font, ARRAY hrefs) // NATIVE?if Length(hrefs)=2then begin	if isArray(hrefs[0])	then hrefs	else if (if kNIE then IsString(hrefs[1]) else isInstance(hrefs[1], 'string))	then [[hrefs[1], start, count, 0, 0, wid, ht, ], ];	 // href for entire para (or IMG)	endelse if Length(hrefs) > 0 and isArray(hrefs[0])	// already converted image mapthen hrefselse begin// hrefs: [len1, nil, len2, "#href", len3, nil, len4, "#href",...]// return new format array of hrefs or NIL// [[0=href, 1=left, 2=top, 3=right, 4=bottom, 5=start, 6=count, ], ]// see kGotoHREFclick	local INT i := 0, hlen, hlast := Length(hrefs)-1, tot := start, inc, regionLen := 0;	local ARRAY regions := Array(Length(hrefs), NIL);	local href;//Print([str, start, count, wid, ht, font]); Print(hrefs);	if kBuild1x	then begin		local INT x1, x2, y1, ntot, spos, epos, fht := FontHeight(font);		local ARRAY lines := call kSplitTextHeightFunc			with (str,				//[start, if hlast>0 and hrefs[hlast]=nil then count-(hrefs[hlast-1]-start) else count],				[start, if hlast>0 and hrefs[hlast]=nil then count-hrefs[hlast-1] else count], // !!!o				wid, font, NIL);		local ARRAY xhrefs := Clone(hrefs); // due to KLUDGE below		local linenum := 0, comparefn := Functions.|<=|;		local findOld := Functions.ArrayPos exists;//if BeginsWith(str,"¥ Index: A") then Print(lines);		end;	while i <= hlast	do if isArray(obj := hrefs[i])	// (e.g., AREA already added in a TABLE)	then begin		regions[regionLen] := obj; //AddArraySlot(regions, obj);		regionLen := regionLen+1;		i := i+1;		end	else if kBuild20	then begin		hlen := obj;		if href := hrefs[i+1]		then begin			regions[regionLen] := [href, tot, hlen]; //AddArraySlot(regions, [href, tot, hlen]);			regionLen := regionLen+1;			end;		tot := tot + hlen;		i := i+2;		end	else begin		hlen := xhrefs[i];		href := xhrefs[i+1];		inc := 2;//if BeginsWith(str,"¥ Index: A") then Print([hlen, href]);		if href and linenum and			(linenum := if kBuild1x and findOld				then ArrayPos(lines, tot, linenum, comparefn)				else  LSearch(lines, tot, linenum, comparefn, nil))		then begin			y1 := linenum * fht;			spos := if linenum=0 then start else lines[linenum-1]+1;			epos := lines[linenum];			x1 := StrFontWidth(SubStr(str, spos, tot-spos), font);			if (ntot := tot + hlen) > epos			then begin // split				hlen := epos - tot + 1;				xhrefs[i] := ntot - epos - 1;  // UGLY KLUDGE				inc := 0;				ntot := epos+1;				end;			x2 := StrFontWidth(SubStr(str, spos, ntot-spos), font);			regions[regionLen] := [href, tot, hlen, x1, y1, x2, y1+fht, ]; //AddArraySlot(regions, [href, tot, hlen, x1, y1, x2, y1+fht, ]);			regionLen := regionLen+1;			tot := ntot;			end		else tot := tot + hlen;		i := i + inc;		end;//if BeginsWith(str,"¥ Index: A") then Print(regions);	if regionLen > 0	then begin		SetLength(regions, regionLen);		regions;		end;	end);DefineGlobalConstant('kRemoveAllSoupEntries, func(soupName)	// remove all entriesif soupNamethen begin	local soup := if kNIE then GetUnionSoupAlways(soupName) else if isFrame(soupName) then soupName else GetUnionSoup(soupName);	local soups := if soup then if kNIE then soup:GetSoupList() else soup.soupList;	if soups	then foreach soup in soups	do if kNIE		then soup:removeAllEntriesXmit(kNewtsCapeSymbol)		else soup:removeAllEntries();	end);DefineGlobalConstant('kGetHTMLFunc, func(contentID) // used during Save Pkg (1.x), during developmentbegin	local soup 	 := GetRoot().(kNewtsCapeSymbol).htmlSoup;	local cursor := if kNIE		then begin gc(); GetUnionSoupAlways(soup):Query(kHTMLQuery); end		else Query(soup, kHTMLQuery);	local entry  := cursor:GoToKey(contentID), entdata;	if entry	then begin		cursor := soup := nil;		entdata := entry.data;		if kNIE //kBuild20 or Functions.EntryRemoveFromSoupXmit exists		then EntryRemoveFromSoupXmit(entry,nil)		else EntryRemoveFromSoup(entry);		if isFrame(entdata) and entdata.hrefs		then entdata.scripts := if isInstance(entdata.data, 'string) then kAHREF else kAHREFG;	// no interference with kImgAnim?		end;	entdata;end);if kNIEthen DefineGlobalConstant('kMungeContentScript, func(content) // see :addBlock, kGetHTMLFunc/*if IsEntryAlias(content)then begin	content := ResolveEntryAlias(content).data;	if isFrame(content) and content.hrefs	then content.scripts := if IsString(content.data) then kAHREF else kAHREFG;	content;	endelse*/ if IsEntryAlias(content.data)then begin	content := Clone(content);	content.data := ResolveEntryAlias(content.data).data;	if IsEntryAlias(content.hrefs)	then content.hrefs := ResolveEntryAlias(content.hrefs).data;	content;	endelse content);if kNIEthen DefineGlobalConstant('kFixPkgHREF, func(content) // for fixing already retrieved aliasif isFrame(content)then begin	if content.hrefs	then content.scripts := if IsString(content.data) then kAHREF else kAHREFG;	content;	endelse content);/*if kNIEthen DefineGlobalConstant('kBookSearchScript, func(searchStr,stringLen,theContent,bookData, bookFrame) // implement (or prevent) Findbegin	Print(searchStr);	TRUE;	// just prevent for nowend);*/DefineGlobalConstant('kGetFontFamily, func(font)//if kBuild20 then GetFontFamilyNum(font) or GetFontFamilySym(font) elseif isFrame(font)then font.familyelse Band(font,tsFamilyMask) // >> tsFamilyShift;);DefineGlobalConstant('kGetFontFace, func(font)if kNIEthen GetFontFace(font)else if isFrame(font)then font.faceelse Band(font,tsFaceMask) >> tsFaceShift);DefineGlobalConstant('kGetFontSize, func(font)if kNIEthen GetFontSize(font)else if isFrame(font)then font.sizeelse Band(font,tsSizeMask) >> tsSizeShift);DefineGlobalConstant('kSetFont, func(font,family,face,size) // used in getRun and Prefs.if kNIEthen SetFontParms(font, {family: family, face: face, size: size})	// !!!melse begin	if not family	then family := if kNIE then GetFontFamilySym(font) else call kGetFontFamily with (font); // !!!k	local fpos := SetContains(kBuiltinFonts,family);	if fpos then family := fpos;	if not face	then face := if kNIE then GetFontFace(font) else call kGetFontFace with (font);	if not size	then size := if kNIE then GetFontSize(font) else call kGetFontSize with (font);	if kNIE	then MakeCompactFont(family,size,face)	else if isInstance(family,'symbol)	then {family: family,			face: face,			size: size}	else family + //(family << tsFamilyShift) +		  (face   << tsFaceshift) +		  (size   << tsSizeShift);end);DefineGlobalConstant('kAddEmphasis, func(font, bits)begin	font := Clone(font);	font.face := Bor(font.face, bits);	font;end);DefineGlobalConstant('kFaceStrings, [	[kFaceBold, 		"B"],	[kFaceItalic, 		"I"],	[kFaceUnderline, 	"U"],	[kFaceOutline,		"O"],	[kFaceSuperScript,	"SUP"],	[kFaceSubScript,	"SUB"],	]);/*DefineGlobalConstant('kCollectFontNames, func()begin	local ARRAY labelCommands := [Fonts.espy.name, Fonts.newYork.name, Fonts.geneva.name]; // order important (same as kBuiltinFonts symbols)	local s,v;	// add 2.x-only built-ins (e.g., handwriting), user-installed (e.g., Monaco, Minico)	foreach s,v deeply in Fonts					// 2.x use?: call kGetAllFontsFunc with () except where System font?	do if not SetContains(kBuiltinFonts, s)		// = ok	then AddArraySlot(labelCommands, v.name);	labelCommands;end);DefineGlobalConstant('kFindFontSymbol, func(fam)begin	local s, v;	foreach s,v deeply in Fonts	do if StrEqual(v.name,fam)	then return s;	kSystemFontSym;end);*/// return [{item: "Casual", family: 'casual},...]DefineGlobalConstant('kCollectFontNames, func()	// !!!jif kNIEthen begin	local ARRAY items;	local font, val;	if GlobalFnExists('MakeFontMenu) 			// 2.1 only	then items := MakeFontMenu(nil,'all,'none,'none)	// & wrong for MacCenter/DinamPatch (dup names)	else begin		items := [];		local sym, symMap := '{		// ROM_systemFont = 'espy			//espyFont: espy, 	// not in GetAllFonts, but added later			newYorkFont: newYork,			genevaFont: geneva,			handwritingFont: handwriting,			};		foreach font in call kGetAllFontsFunc with ()		do begin			val := symMap.(sym := font.screenSym);			BInsertRight(items, {item: font.name, family: if val then val else sym}, '|str<|, 'item, nil);			end;		font := Fonts.(sym := kSystemFontSym);	// add system font (not in GetAllFonts)		BInsertRight(items, {item: font.name, family: sym}, '|str<|, 'item, nil);		end;	// if any duplicate names(e.g., MacCenter/DinamPatch), add font sym to disambiguate	val := "";	// prev	foreach font in items	do  if StrEqual(val, val := font.item)		then font.item := val & $( & font.family & $);	items;	endelse begin // 1.x	local sym, font;	Sort(foreach sym,font deeply in Fonts		 collect {item: font.name, family: sym},		'|str<|,'item);	end);// labelPicker doesn't save or return :popupMenu in Popit// and not possible to use inherited:popupMenu (and :parent():popupMenu appears in wrong place)DefineGlobalConstant('kFixPicker, func(menuFont, wid)	// ~Jbegin	local INT i;	local ARRAY children := GetRoot():childViewFrames();	local pp;	for i := Length(children)-1 to 0 by -1	do  if isFrame(pp := children[i]) and pp.pickItems		then begin			pp.bounds := pp.viewBounds;			if wid			then pp.pickMaxWidth := GetAppParams().appAreaWidth-10;			pp.viewFont := menuFont;       		return pp:?SyncView(); // SetValue(clast, 'viewFont, kEspy);			end;end);// maybe do this in protos, then specific pickers can inherited: to get at least true?DefineGlobalConstant('kFixPickerSetup, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then AddDeferredCall(kFixPicker, [newtscape.menuFontJ, nil]);	// !!!j	TRUE;end);DefineGlobalConstant('kFixPickerFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then begin		viewFont 			:= 	newtscape.labelFontJ;		entryLine.viewFont 	:= 	newtscape.dataFontJ;		end	else if language='Chinese	then entryLine.viewFont := kEspy10;  // ~C	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kFixButtonFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// !!!j	then viewFont := newtscape.labelFontJ;	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kFixButtonClickScript, func() // !!!j. protoInfoButton, protoPopupButton, protoNewFolderTab.showBarTextbegin	local pp := inherited:buttonClickScript();	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then SetValue(pp, 'viewFont, newtscape.menuFontJ);	//{family: sym, face: kFaceBold, size: 10});	pp;end);DefineGlobalConstant('kFixActionClickScript, func() // !!!j. protoActionButtonbegin // almost same as protoInfoButton (popupView)//Print("action start");	popupForm := NIL;	inherited:buttonClickScript();	// !!!j//Print(popupForm);	if kNCfont and popupForm and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then SetValue(popupForm, 'viewFont, newtscape.menuFontJ);	//{family: sym, face: kFaceBold, size: 10});//Print("action end");end);constant kFixTextFormScript := kFixButtonFormScript; // share// newtscape vs. newtscape.prefsEntry ?????DefineGlobalConstant('kFixInputFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then viewFont := newtscape.entryFontJ;	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kFixCheckFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then viewFont := newtscape.dataFontsJ;	inherited:?viewSetupFormScript();end);// used in SUBMIT, IMAGEDefineGlobalConstant('kPostSoup, func(btitle,soupName,fdata)begin // uses kNewtsCapeSymbol instead of isbn for appsymbol	local soup := :RegisterCardSoup(soupName, [], kNewtsCapeSymbol, ["form", "forms"]);	if kBuild20 or HasVariable(soup,'AddToStoreFlushedXmit)	then soup:AddFlushedXmit(fdata, nil) // AddToDefaultStoreXmit(fdata,nil)	else soup:AddToDefaultStore(fdata);	:UnRegisterCardSoup(soupName);	NIL;	// don't resetend);DefineGlobalConstant('kMakeNote, func(title, str, styles, font)begin	local nos20 := kBuild20 or Functions.XmitSoupChange exists;	local INT ht;	local para;	if (if kBuild20 then IsString(str) else isInstance(str, 'string))	then begin // create a para object to embed		if not (kBuild20 or nos20) and StrFilled(title)		then str := title & unicodeCR & unicodeCR & str;		if not font		then font := if styles then styles[1] else dataNoteFont;		ht := 2*FontHeight(font) + // add two lines			call kMySimpleHeightFunc with (str, 0, nil, noteWidth, if kStyleMeasure and styles then styles else font); // !!!o,m		para := {			viewStationery: 'para,			viewBounds: RelBounds(noteLeft,noteTop,noteWidth,ht),			text: str,			}; 		if styles		then para.styles := styles		else para.viewFont := font;		end	else if isFrame(str)	then begin // e.g., picture		para := str;		ht := para.viewBounds.bottom - para.viewBounds.top;		end	else return NIL; // error?	local noteframe := {		viewStationery: kNotesSym,		height: ht,		data: [para],		timeStamp: Time(),		};	if kBuild20 or nos20	then begin		if StrFilled(title)		then noteframe.title := title;		noteframe.class := kNotesSym;		GetUnionSoup(notesSoupName):AddFlushedXmit(noteframe, 'entryAdded);		//XmitSoupChange(notesSoupName, kNewtsCapeSymbol, 'whatThe, NIL);		end	else begin		GetUnionSoup(notesSoupName):AddToDefaultStore(noteframe);		BroadcastSoupChange(notesSoupName);		end;	NIL; // does not reset by defaultend);DefineGlobalConstant('kMyStringer, func(ARRAY a) // like Stringer, with commas between valsif athen begin	local str, s;	foreach s in a	do str := str & (if str then $,) & s;	str; // maybe nil	end);constant kForm := "FORM:";DefineGlobalConstant('kPostNotes, func(btitle, ARRAY pnames, fdata)begin // METHOD??	local str := Clone(""); // kForm && btitle & unicodeCR & unicodeCR;	local ARRAY styles := Array(Length(pnames)*4, nil);	local INT i := 0, len := 0, oldlen := 0;	local sym, val;	foreach sym in pnames // actually a string	//foreach sym,val in fdata	do begin		val := fdata.(Intern(sym));		// slot		StrMunger(str,len,0, sym & ": ", 0, nil);		styles[i] 	:= (len := StrLen(str)) -oldlen;		styles[i+1] := slotNoteFont;		oldlen 		:= len;		i			:= i+2;		// value(s)		StrMunger(			str,len,0,			(if isArray(val) or isFrame(val)			then call kMyStringer with (val) else val ) & unicodeCR,0,nil);		styles[i] 	:= (len := StrLen(str)) -oldlen;		styles[i+1] := dataNoteFont;		oldlen 		:= len;		i			:= i+2;		end; 	call kMakeNote with (btitle, str, styles, slotNoteFont); // does not reset by defaultend);DefineGlobalConstant('kAppendFrame, func(f1, f2) // used by addIncludes,connect,begin	local s, v;	foreach s,v in f2	do f1.(s) := v;	f1;end);/*DefineGlobalConstant('kAppendString, func(s1, s2) // unused?	StrMunger(s1,StrLen(s1),0, s2,0,nil));DefineGlobalConstant('kAppendArray, func(array a1, array a2) // unused?	ArrayMunger(a1,Length(a1),0, a2,0,nil));*/DefineGlobalConstant('kAppendObj, func(a, obj)if athen begin	if isReadonly(a)	then a := Clone(a);	if isArray(obj)	then ArrayMunger(a,Length(a),0, obj,0,nil)	else if obj	then AddArraySlot(a, obj);	a;	endelse if isArray(obj)	// "nil" array. create a new onethen objelse if objthen [obj]else []	);DefineGlobalConstant('kGetResource, func(name)begin	local rf := OpenResFileX(HOME & "NewtsCape.rsc");	local icon := GetPictAsBits(name,nil);	CloseResFileX(rf);	icon;end);DefineGlobalConstant('kGoHistory, func(gData, INT i, curisbn) // used by kHistoryButton, kBackButton, Go popup. same fn as end of kGotoHref???.begin	local ARRAY history := gData.(kHistoryPath);	if i < 0 or i >= Length(history)	then return NIL;	local ARRAY historyEntry := history[i];	gData.(kHistoryPos) := i;	//SetLength(history, i);	local historyid := historyEntry[0];	local pnum := historyEntry[1], href, bdata, edata;	local viewer := GetRoot().(kBookReaderSymbol);	if kNIE	then begin		href := historyEntry[3];		bdata := viewer:BookData();		edata := if Length(historyEntry) > 4 then historyEntry[4];		end;	if (StrEqual(curisbn, historyid) or call kFindBook with (historyid, nil)) and		(not kNIE or			(bdata and call kCacheEqual with (bdata.base_href, href, bdata.edata, edata)))	then begin		viewer:openBook(historyid);		viewer:turnToPage(min(pnum, viewer:countPages()));		TRUE;		end	else if kNIE and href	then begin		call kFindApp with (kNewtsCapeSymbol):?getURL(href,			{hrefname: pnum,			edata: edata,			noHistory: true,			});		TRUE;		end;	//else return NIL;end);DefineGlobalConstant('kClearHistoryItem,	LocObj("Clear History", 'clearHistoryItem));DefineGlobalConstant('kHistoryList, func(topLabels) // kHistoryButton, Go popupbegin	local gData := call kInitGlobal with (nil, nil);	local ARRAY history := gData.(kHistoryPath);	local INT len := Length(history);	if len > 0	then begin		local INT i, tlen := Length(topLabels), historyPos := gData.(kHistoryPos);		local ARRAY historyList := Array(tlen + 2 + len, NIL);		ArrayMunger(historyList,0,tlen, topLabels,0,tlen);		historyList[tlen]	:= kClearHistoryItem;		historyList[tlen+1] := 'pickSeparator;		tlen := tlen+2;		for i:= 0 to len-1 // add most recent kMaxHistory titles		do historyList[i+tlen] := history[i][2] && "p." & history[i][1];			//AddArraySlot(historyList, history[i][2] && "p." & history[i][1]);		if historyPos >= 0 and historyPos < len		then historyList[historyPos + tlen] := {item: historyList[historyPos + tlen], mark: kCheckMarkChar};		historyList;		end	else topLabels;	// historyListend);DefineGlobalConstant('kBackItem,	// for Go popup	/*if kNIE	then {item: LocObj("Back", 'backItem), icon: ROM_leftbitmap}	else*/ LocObj("Back", 'backItem));DefineGlobalConstant('kForwardItem,	// for Go popup	/*if kNIE	then {item: LocObj("Forward", 'forwardItem), icon: ROM_rightbitmap}	else*/ LocObj("Forward", 'forwardItem));DefineGlobalConstant('kHomeItem, LocObj("Home",'homeItem));	// !!!fDefineGlobalConstant('kNewerHTMLCacheItem,  LocObj("Newer HTML Cache Item",  'newerHTMLitem));	// !!!a1,sDefineGlobalConstant('kNewerImageCacheItem, LocObj("Newer Image Cache Item", 'newerImageItem));	// !!!a1,sDefineGlobalConstant('kResetHTMLCacheItem,  LocObj("Set HTML Cache Item",    'setHTMLitem));  	// !!!a1,sDefineGlobalConstant('kResetImageCacheItem, LocObj("Set Image Cache Item",	 'setImageItem));	// !!!a1,sDefineGlobalConstant('kHistoryButton,	{_proto: protoPictureButton,	icon: call kGetResource with ("overviewDot"), // ROM_overviewBitmap undef in 2.1	viewBounds: RelBounds(0,0,12,12),	buttonClickScript: func()	begin		local ARRAY historyList := call kHistoryList with ([]);		if kBuild1x and Functions.DoPopup exists		then DoPopup(historyList,0,0,self) 		else :PopupMenu(historyList, {left: 0, top: 0});	end,	pickActionScript: func(INT i)	begin		// assume exists from kBookOpenScript		local gData := call kInitGlobal with (nil, nil);		if i = 0		then SetLength(gData.(kHistoryPath), 0)			// no need to set historyPos? (it gets set with next add)		else call kGoHistory with (gData, i-2, isbn);	// Clear History, 'pickSeparator	end,	});DefineGlobalConstant('kBackButton,	{_proto: protoPictureButton,	icon: ROM_leftbitmap,	viewBounds: RelBounds(0,0,10,12),	step: -1,	// !!!e. was limit	buttonClickScript: func() // shared with kForwardButton, _Back(kbd), _Forward(kbd)	begin		// assume exists from kBookOpenScript		local gData := call kInitGlobal with (nil, nil);		local historyPos := gData.(kHistoryPos), len := Length(gData.(kHistoryPath));		if (if step < 0 then historyPos > 0 else historyPos < len-1) // !!!e		then begin			if step < 0 and historyPos = len			then call kAddHistory with (); // add current book when going back at end			call kGoHistory with (gData, historyPos+step, if kBuild20 then GetRoot().(kBookReaderSymbol).isbn else isbn); // !!!e. in case called via kbd			end;	end,	viewSetupFormScript: func()	begin		local gData := call kInitGlobal with (nil, nil), historyPos := gData.(kHistoryPos);		if (if step < 0 then historyPos=0 else historyPos >= Length(gData.(kHistoryPath))-1) // !!!e		then viewFormat := 67109425; //Band(bnot(vfFrameMask), viewFormat) + vfFrameGray;		inherited:?viewSetupFormScript();	end,	});DefineGlobalConstant('kForwardButton,	{_proto: kBackButton,	icon: ROM_rightbitmap,	//viewBounds: RelBounds(0,0,10,12),	step: 1,	// !!!e	});DefineGlobalConstant('kDummyButton,	{_proto: protoPictureButton,	viewBounds: RelBounds(0,0,10,0),	// was 11 (same as kBackButton for width)	viewFormat: 0,	viewFlags: vVisible,	/*buttonClickScript: func() // this unfortunately is on top of the markupButton		markupButton:buttonClickScript(),*/	});DefineGlobalConstant('kScrollPage2, func(n)begin	inherited:scrollPage(n);	if n = 0	then GetRoot().(kBookReaderSymbol):Dirty();end);DefineGlobalConstant('kBrowserQuit, func() // for NOS 2.x rotate bug (Overview)begin	inherited:?viewQuitScript();	self.(EnsureInternal('ReOrientToScreen)) := ROM_DefRotateFunc; //@588end);//GatherKeyCommands(view)//if kNIE then	// !!!xDefineGlobalConstant('kBookKeys, [	{char:		$[,	modifiers:	kCommandModifier,	keyMessage:	'_Back,	name:		kBackItem,	category:	kAppNameL,	},	{char:		$\1C,	// !!!f. left arrow	modifiers:	kCommandModifier,	keyMessage:	'_Back,	name:		kBackItem,	category:	kAppNameL,	},	{char:		$],	modifiers:	kCommandModifier,	keyMessage:	'_Forward,	name:		kForwardItem,	category:	kAppNameL,	},	{char:		$\1D,	// !!!f. right arrow	modifiers:	kCommandModifier,	keyMessage:	'_Forward,	name:		kForwardItem,	category:	kAppNameL,	},	{char:		$8,	modifiers:	kCommandModifier, // + kShiftModifier,	keyMessage:	'_NewtsCape,	name:		kAppNameL,	category:	kAppNameL,	showChar:	$*,	},/* !!!f. fix in NC??	{char:		$w,	modifiers:	kCommandModifier,	keyMessage:	'_CloseBook, _CloseFrontView	name:		"Close",	category:	"Viewing",	},*/]);DefineGlobalConstant('kBrowserSetup, func()	// !!!jbegin	local newtscape;	if kNCfont and (newtscape := GetRoot().(kNewtsCapeSymbol)) // !!!k		and newtscape.prefsEntry and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then begin		SetValue(outline, 'viewFont, newtscape.menuFontJ);		AddDeferredCall(func()			SetValue(:childViewFrames()[3]:childViewFrames()[0], 'viewFont, newtscape.menuFontJ), nil); //"Contents"		end;	inherited:?viewSetupFormScript();	// !!!k. re-fixup bounds so at upper right?	local gb := GetRoot().(kBookReaderSymbol):GlobalBox();	// this should go at bottom of actual title, but viewer.contentArea:childViewFrames()[0].viewBounds.bottom is wrong	viewBounds := RelBounds(gb.right-232, gb.top+20, 224, 173);	// !!!r,n,k. -gb.left. 224+8 for border. gb.bottom-178. 20 for titleend);DefineGlobalConstant('kBookOpenScriptShare, func(obj, protoDummyButton, protoHistoryButton, protoBackButton, protoForwardButton) // standalone usebegin//Print('kBookOpenScriptShare);	call kInitGlobal with (kHistoryPath, []);	call kInitGlobal with (kHistoryPos,	 0);	local viewer := GetRoot().(kBookReaderSymbol), bdata := viewer:BookData(), titleFormat, obj;	//viewer.contentArea.(EnsureInternal('viewSetupDoneScript)) := kviewSetupDone2; // fix TITLE	if bdata	then begin		if isFrame(titleFormat := bdata.titleFormat) and Length(titleFormat) > 0	// inline		then begin			local sym, titleObj := viewer.contentArea:childViewFrames()[0];			foreach sym,obj in titleFormat	// e.g., viewFont, viewJustify			do SetValue(titleObj,sym,obj);			end;		GetRoot().(kNewtsCapeSymbol):?displayURL(EnsureInternal(bdata.base_href));	// !!!g		end;	if kBuild20 or HasVariable(viewer, 'SetStatusBarButtons) // 2.x ?	then begin		if not viewer.cntrlPanel.NCinit	// !!!k		then begin			viewer:SetStatusBarButtons({				left:  [protoDummyButton, protoHistoryButton],	// 2.0 (bug in viewSetupChildren)				right: [protoForwardButton,protoBackButton,],				});			// !!!e. viewer.(EnsureInternal('scrollPage)) := kScrollPage2;			obj := viewer.browser;			if not GlobalFnExists('PackRGB)	// not needed for 2.1?			then obj.(EnsureInternal('viewQuitScript)) := kBrowserQuit;			obj.(EnsureInternal('viewSetupFormScript)) := kBrowserSetup;	// !!!k,j			obj := viewer.cntrlPanel;			obj.(EnsureInternal('NCinit)) := true;	// !!!k			if Length(obj.stepChildren)=0	//  automatically open?			then obj:ChangeState();			//viewer.(EnsureInternal('_CloseFrontView)) := viewer._CloseFrontView;			SetKeyView(viewer, 0);	// !!!f			viewer:?AddKeyCommands(kBookKeys);			end;		end	else if viewer.buttonsOn // MP100 ?	then begin		obj := viewer.pagenumber:parent();		if not obj.stepChildren or Length(obj.stepChildren)=0		then begin			AddStepView(obj, {				_proto: protoHistoryButton,	// history/NC				viewBounds: RelBounds(143,2, protoHistoryButton.viewBounds.right,13),				});			AddStepView(obj, {				_proto: protoBackButton,				viewBounds: RelBounds(165,2, 10,13),				});			AddStepView(obj, {				_proto: protoForwardButton,				viewBounds: RelBounds(181,2, 10,13),				});			obj:dirty();			end;		end	else if (obj := viewer.extraButtons) and not HasSlot(obj, 'stepChildren)	then begin // MP110 (other 1.x)		obj.viewBounds := SetBounds(-188,-17,-33,0); // -168 for back w/o forward		obj.stepChildren := [stepChildren:			{_proto: 	protoHistoryButton,			viewBounds: RelBounds(82,2, protoHistoryButton.viewBounds.right,13)}, // history/NC			{_proto: protoBackButton,			viewBounds: RelBounds(104,2, 10,13)},			{_proto: protoForwardButton,			viewBounds: RelBounds(120,2, 10,13)},			];		end;	TRUE;end);DefineGlobalConstant('kBookOpenScriptNC, func() // NC needed at runtimebegin	local app := GetRoot().(kNewtsCapeSymbol);	if not app	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	app:?BookOpenScript(self);end);DefineGlobalConstant('kBookOpenScript, func() // regular (standalone use; NC not needed at runtime)begin	// !!!f,e	local app := GetRoot().(kNewtsCapeSymbol);	if not app	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	app:?BookOpenScript(self)			// try NC script first	or	call kBookOpenScriptShare with (self, kDummyButton, kHistoryButton, kBackButton, kForwardButton);end);DefineGlobalConstant('kBookCloseScript, func() // for regular bookbeginif kDebugHTTP then Print("BookCloseScript0");	local viewer := GetRoot().(kBookReaderSymbol);	//RemoveSlot(viewer.contentArea, 'viewSetupDoneScript);	// not needed?	if kBuild20 or SetStatusBarButtons exists // 2.0 ?	then beginif kDebugHTTP then Print("BookCloseScript1");		// !!!e. RemoveSlot(viewer, 'scrollPage); //AddDeferredCall(GetGlobalFn('RemoveSlot), [viewer, 'scrollPage]);		//viewer.scrollPage := GetVariable(viewer._proto, 'scrollPage)		//RemoveSlot(viewer, 'TurnToPage);			//RemoveSlot(viewer, 'TurnToContent);		//RemoveSlot(viewer, 'TurnToSubject);if kDebugHTTP then Print("BookCloseScript2");		viewer:?ClearKeyCommands();		end	else if not viewer.buttonsOn and viewer.extraButtons  // 1.x (not MP100)?	then RemoveSlot(viewer.extraButtons,'stepChildren);end);// used by :removeApp, and also "noStatus" books (kBookCloseScriptInv, kHelpBookCloseScriptInv2, kHelpBookCloseScriptInv1x)// coord with :bookTemplate, :refreshBookDefineGlobalConstant('kBookCleanup, func(isbn, help, ver)if helpthen if kBuild20 or ver	then //RemoveSlot(GetRoot().(kBookReaderSymbol).library, Intern(isbn))		GetRoot().(kBookReaderSymbol):UnRegisterBookRef(isbn)	else begin		local pos := call kLFetch with (Extras, isbn, 0, Functions.StrEqual, 'isbn, true);		if pos then ArrayRemoveCount(Extras,pos,1);		SetRemove(GetRoot().(kBookReaderSymbol).library.books, call kFindBook with (isbn,true)); // BookRemoved({isbn: isbn}); //???		endelse begin // regular book (both 1.x and 2.0)if kDebugHTTP then Print("kBookCleanup1");	GetRoot().(kBookReaderSymbol):?close();	// for StartBar (SAS)if kDebugHTTP then Print("kBookCleanup2");	BookRemoved({isbn: isbn});if kDebugHTTP then Print("kBookCleanup3");	RemoveSlot(call kInitGlobal with (nil,nil), Intern(isbn));if kDebugHTTP then Print("kBookCleanup4");	end);DefineGlobalConstant('kBookCleanup2, func(isbn, help, ver)	// removeApp, refreshBookbegin	if help	then call kHelpViewerSetup with (nil);	call kBookCleanup with (isbn, help, ver);end);DefineGlobalConstant('kBookCloseScriptInv, func()		// 1.x&2.0. regular "noStatus" bookbegin	call kBookCloseScript with ();	call kBookCleanup with (isbn,nil,true);end);DefineGlobalConstant('kHelpBookCloseScriptInv2, func()	// 2.0. contentArea.viewQuitScriptbegin	call kBookCleanup with (isbn,true,true);	inherited:?viewQuitScript();end);DefineGlobalConstant('kHelpBookCloseScriptInv1x, func()	// 1.x. contentArea.viewQuitScriptbegin	call kBookCleanup with (isbn,true,nil);	inherited:?viewQuitScript();end);/*DefineGlobalConstant('kInstallScriptHelpBook, func(partFrame)begin Print(partFrame.theForm);Print("saving isbn:" && partFrame.isbn := partFrame.theForm.isbn); // save for removeScriptend);DefineGlobalConstant('kRemoveScriptHelpBook, func(partFrame)RemoveSlot(GetRoot().(kBookReaderSymbol).library, Intern(partFrame.isbn)));*/DefineGlobalConstant('kAllType, func(alist, cl) // used in addBlock (1.x)if isArray(alist)then begin	local a;	foreach a in alist	do if not isInstance(a, cl)		then return NIL;	TRUE;end);DefineGlobalConstant('k036, ["0", "3", "6"]); // left, belowDefineGlobalConstant('kAddHTMLitem, func(tag, results) // a default htmlApp:addHTMLitembegin	local tag1 := tag._tag, mf := self.(tag1), args := [tag];	local newtscape := GetRoot().(kNewtsCapeSymbol);	if results	then begin		local ntags := LocObj("Tag", 'tagLabel) & $: && self._numTags := if self._numTags then _numTags+1 else 1;		local INT pos := results.bytesSoFar, len := results.sourceLength;		if newtscape.prefsEntry.showCmdStatus		then begin			newtscape:setGauge(ntags & $; && pos & $/ & len & $; && UPCASE(SPrintObject(tag1)), pos, len); // !!!y. inline sofar,utag			RefreshViews();			end;		end;	if newtscape.debugFlag		// !!!k.	then begin		Write("\ntag: "); Print(tag);		end;	//PerformIfDefined(self, tag1, args);	if (if kNIE		then IsFunction(mf)		else isInstance(mf, '_function) or isInstance(mf, 'CodeBlock))	then Perform(self, tag1, args)	else if isFrame(mf)	then Perform({_parent: self, _proto: mf}, 'addHTMLitem, args);end);// -----constant kParseUpdateSize	:=  200;constant kPkgUpdateSize	 	:= 2048;constant kPrefUpdateDelay	:= 2000;	// for procrastinated :setPreferenceDefineGlobalConstant('kMaxISBN, 14);	// longer for 2.x?DefineGlobalConstant('kMaxString, func(str, slen)if StrLen(str) > slen then call kMyTrim with (str,0,slen) else str	// !!!e. TrimString(SubStr(str,0,slen)) else str);DefineGlobalConstant('kDeclareSelf, func()	// for some viewSetupFormScriptsbegin	newtscape.(childSym) := self;	inherited:?viewSetupFormScript();end);constant kDefaultEncoding	:= 'sjis; //'|string.sjis|;/*DefineGlobalConstant('kNTEforFORM, func(str)begin	// note: this might create a "empty" pref frame from a saved book?	local prefs := GetAppPrefs(kAppSymbol, {}).NTEncoding;	local def := NTE_methods:GetPrefsNTEncoding(prefs, kDefaultEncoding);	local bin := NTE_methods:uni2code(str, def, nil);	local INT len := Length(bin), i;	local result := MakeBinary((len+1) * 2, 'string);			for i:=0 to len-1	do //result[i] := CHR(ExtractByte(bin, i));		StuffUniChar(result, i*2, ExtractByte(bin, i));	// better if =0	//StuffUniChar(result, len*2, unicodeNUL);	result;end);*/constant kHex := "0123456789ABCDEF";DefineGlobalConstant('kURLencodeString, func(val)	// moved from inside kURLencodeValbegin	local i := 0, ch, s := if (if kBuild20 then IsString(val) else isInstance(val,'string)) then Clone(val) else SPrintObject(val), code; // support long(>1024) string	local addEncoding := if kNIE then call kInitGlobal with ('protos,{}).NTEforFORM;	if kNIE and addEncoding and language <> 'Chinese	then s := call addEncoding with (s);	// call kNTEforFORM			while i < StrLen(s)	do if (if kNIE and addEncoding		then (IsAlphaNumeric(ch := s[i]) and (ORD(ch) < 0x7F)) or				SetContains('[    $-, $_, $.,     $*,            $@, ], ch)		else isAlphaNumeric(ch := s[i]) or				SetContains('[$$, $-, $_, $., $!,    $(, $), $'], ch)	// add /:?  earlier removed $&, $+, $/.  add $,* ?				)		then i:= i+1/* according to http://www.ietf.org/rfc/rfc1738.txtonly alphanumerics, the special characters "$-_.+!*'(),", andreserved characters used for their reserved purposes may be usedunencoded within a URL -- but we'll also allow / and :*/		else if ch = $ 	// space?		then begin			s[i] := $+;			i := i+1;			end		else if ch = unicodeCR		then begin			StrMunger(s,i,1, "%0D%0A",0,nil);			i := i+6;			end		else if ch = unicodeLF		then StrMunger(s,i,1, nil,0,nil) 	// delete		else begin 			// other non-alpha. => %HH			code := Ord(ch);//Print([ch,code]);			if code > 255			then code :=				if ch := SetContains(kCharExceptValues, ch)	// map a few out-of-range chars back to char entity code				then kCharExceptNames[ch]				else Ord($?);	//??			StrMunger(s,i,1, $% & kHex[code div 16] & kHex[code mod 16],0,nil);			i := i+3;			end;	s;end);// note: kURLencodeObject isn't defined until later, so accessed here via a parameterDefineGlobalConstant('kURLencodeVal, func(osym, str, fdata, enc, psym, val, kURLencodeObject)	// shareif (isArray(val) and Length(val) > 0) or isFrame(val)then call kURLencodeObject with (psym,str,val,enc,NIL) 	// recur. CHECKBOX [values], IMAGE {x: y:}else str	& (if str then if enc then $& else unicodeCR)	// field separator	& (begin		local namestr :=			call kURLencodeString with (				// name. encode				if osym				then if isFrame(fdata)					// repeat for array; foo.x for frame					then osym & $. & psym					else osym				else psym);		if StrLen(namestr) > 0	// !!!b. for ISINDEX		then namestr & $=		else namestr;		end)	& if isArray(val)	// and Length(val=0)		then nil		else if val=true		then "TRUE"		else if enc and (							// value			if (if kBuild20				then IsString(psym)				else isInstance(psym,'string))		// exceptions to encoding:  how to generalize??			then not StrEqual(psym, "address") and not StrEqual(psym, "usermail")			else psym<>'address and psym<>'usermail)		then call kURLencodeString with (val)		//instead of inline (so share w/ name)		else val);DefineGlobalConstant('kURLencodeObject,begin // kludge so recursion in definition will worklocal fn :=func(osym, str, fdata, enc, pnames)begin // called from kPostMail and self	local psym, val;	if pnames	then foreach psym in pnames	// avoids lookup, preserves order		do begin//Print(psym);			if HasSlot(fdata, val := Intern(psym))	// avoid problems with unused Submit/Image		 	then str := call kURLencodeVal with (osym, str, fdata, enc, psym, fdata.(val), fn); // fn = kURLencodeObject			end	else foreach psym,val in fdata // array or frame		 do if psym <> '_proto			then str := call kURLencodeVal with (osym, str, fdata, enc, psym, val, fn);	str;end;fn;end);// used directly in :getURLDefineGlobalConstant('kPostData, func(addr, btitle, methenc, fdata, pnames, options)begin // ??? currently, enctype not checked (everything is url-encoded); it's just passed along//Print(addr); Print(methenc); Print(fdata); Print(pnames); Print(options);	local edata :=		if (if kNIE then IsString(fdata) else isInstance(fdata,'string))		then fdata		else call kURLencodeObject with (nil, nil, fdata, true, pnames);	if BeginsWith(addr,kHTTP) // kHTTPS ??	then call kSendHTTP with (addr, methenc, nil, edata, fdata, options) // kAddHistory in kSendHTTP	else call kSendMsg  with (addr, nil, kForm && btitle, edata);	NIL; // does not reset by defaultend);DefineGlobalConstant('kPostMail, func(btitle, addr, fdata) // called from SUBMIT, IMAGEbegin	local newtscape := call kFindApp with (kNewtsCapeSymbol);	local bdata := :BookData(), options := {}; //extraHeader: {Referer: bdata.base_href}};	local pnames := if bdata then bdata.form_printnames.(Intern(action));	if newtscape	then newtscape:?getURL(addr, {subject: btitle, data: fdata, dataNames: pnames, method: METHOD,})		//extraHeader: options.extraHeader})	else call kPostData with (addr, btitle, [METHOD,ENCTYPE], fdata, pnames, options);	// use saved (old?) versionend);DefineGlobalConstant('kLookupError, func(ARRAY alist, errnum1, errnum2) // fInputHeaderSpec, :errorbegin	local spos;	if (spos := SetContains(alist,errnum1))		or (errnum2 and spos := SetContains(alist,errnum2))	then alist[spos+1];end);DefineGlobalConstant('kFilterHTMLStrings, nil);DefineGlobalConstant('kEmptyQuit,	LocObj("empty upon quit?", 'emptyQuitItem));DefineGlobalConstant('kTrustCache,	LocObj("trust cache?", 'trustCacheItem));DefineGlobalConstant('kShowItemsOverview, LocObj("show items in overviews", 'showItemOverview));	// !!!kDefineGlobalConstant('kIgnoreExpiration, LocObj("Ignore Expiration", 'ignoreExpirationItem)); // !!!e//DefineGlobalConstant('kFollowURL,  	LocObj("open URL immediately?", 'openURLitem));		//DefineGlobalConstant('kKeepQueryResults, "keep query results?");DefineGlobalConstant('kStoreItem,  	LocObj("Store", 'storeItem));		// !!!g	DefineGlobalConstant('kDefaultItem,	LocObj("default", 'defaultItem));DefineGlobalConstant('kNoneItem,	LocObj("none", 'noneItem));DefineGlobalConstant('kStrPosAny, func (str, ARRAY astrs, INT start, minp, chOnly)begin // find minimum of a set of chars/strings	local pos, mpos, astr;	foreach astr in astrs	do if (pos := if kNIE and chOnly then CharPos(str,astr,start) else StrPos(str,astr,start))		then if minp			then (if (not mpos) or pos < mpos then mpos := pos)			else return pos;	mpos;end);constant kMaxPWChar  := 0x00FF;constant kHidePWChar := 0xFF00;// used in INPUT PASSWORD, protoNamePasswordDefineGlobalConstant('kEncodeFunc, func(txt, enc) // enc=true (encode), =nil (decode)begin	// return string (or nil if already all encoded)//if kDebugHTTP then Print("encoding(" & (if enc then "true" else "nil") & "):" && txt);	local INT i, char, slen := StrLen(txt);/*	local newtxt := Clone(txt);	for i := 0 to StrLen(newtxt)-1	do begin		char := ORD(newtxt[i]);		newtxt[i] := CHR(if enc then BOR(kHidePWChar,char) else BAND(kMaxPWChar,char));		end;*/	if slen=0	then return if enc then nil else txt;	local newchar, newtxt := if not enc then Clone(txt);	for i := 0 to slen-1	do begin		char := ORD(txt[i]);		newchar :=			if enc			then begin				if char <= kMaxPWChar				then begin					if not newtxt					then newtxt := txt;	// overwrite directly (not readonly!)					BOR(kHidePWChar, char);					end;				end			else BAND(kMaxPWChar,char);	// assume encoded (so always decode)		if newchar		then newtxt[i] := CHR(newchar);		end;	newtxt;end);DefineGlobalConstant('kImgAnim, [ // sharable (via bookTemplate). see :addBlock'viewIdleScript,func() if (kBuild1x or call kViewIsOpenFunc with (self)) and not stoppedthen begin	local ARRAY pics := item.data.pics;	local view := self.scrolledView, views;	if kBuild1x and not view and		Length(views := :childViewFrames()) > 0	then view := views[Length(views)-1].scrolledView;	if not view	then view := self;	SetValue(view, 'icon, pics[ipics]);	//RefreshViews();	local delay := item.data.delays[ipics];	if (ipics := ipics+1) >= Length(pics)	then begin		ipics := 0;		if loops and (loops := loops-1) <= 0		then delay := nil;		end;	if delay and kBuild20	then begin		AddDelayedSend(self, 'viewIdleScript, nil, delay);		nil;	// in case invoked via :setupIdle		end	else delay;end,'viewSetupFormScript,func()beginif item.data.picsthen begin	self.loops := item.data.loops; // number of times to repeat	local INT delay := item.data.delays[self.ipics := 0];	self.icon := item.data.pics[0];	self.stopped := NIL;	if kBuild20	then AddDelayedSend(self, 'viewIdleScript, nil, delay)	else :setupIdle(delay);	end;inherited:?viewSetupFormScript();end,]);DefineGlobalConstant('kColorTable16,SetLength(SetClass("\uF000F000F000F000E000E000E000E000D000D000D000D000C000C000C000C000B000B000B000B000A000A000A000A0009000900090009000800080008000800070007000700070006000600060006000500050005000500040004000400040003000300030003000200020002000200010001000100010000000000000000000",'grayPattern), 128));DefineGlobalConstant('kColorTable4,SetLength(SetClass("\uF000F000F000F000A000A000A000A00050005000500050000000000000000000",'grayPattern), 32));// after MakeBitmap or ScaleShapeDefineGlobalConstant('kFixBitmap, func(obj, bnds, bpp)	// tagDict.IMG, convertImageif isInstance(obj, 'bitmap)then begin	if not bnds	then bnds := ShapeBounds(obj);	if not bpp	then bpp :=			if kBuild20 and obj.colordata			then obj.colordata.bitdepth			else 1;	local bits := obj.data;	if kBuild20 and not bits and obj.colordata	then bits := obj.colordata.cbits;	if bpp=1	then {		bounds: bnds,		bits: bits,		}	else if kBuild20	then {						// gray scale for 2.1		bounds: bnds,		colordata: {			cbits: bits,			bitdepth: bpp,			colortable: if bpp=4 then kColorTable16 else kColorTable4,	// so printing will work?			},		};	endelse obj	//PICT?);DefineGlobalConstant('kScaleBounds, func(bounds, scale)	// tagDict.IMG (anim, AREA)SetBounds(	RIntToL(bounds.left * scale),	RIntToL(bounds.top * scale), 	RIntToL(bounds.right * scale), 	RIntToL(bounds.bottom * scale)	));/*DefineGlobalConstant('kHideKbdButton, func() // viewSetupFormScript for kbdButton, protoNamePasswordbegin	if kNIE and KeyboardConnected()	then viewFlags := 0;	inherited:?viewSetupFormScript();end);*/DefineGlobalConstant('kHelpBookData, func()	if bookRef exists	then bookRef.data);//constant kNewUIObjs			:= 9;	// # new interface items. URLtri, commandTri, ncGoButton, statusPara, statusGauge, errorPara, stopButton, hideButton, quitButtonconstant kURLlines			:= 3;	// # of URL lines to expand toconstant kLineSpacing		:= 13;	// for URLpara, statusParaconstant kTBmargin			:= 4;	// top/bottom marginconstant kmidmargin			:= 5;	// margin between "lines"constant kNewUIinsetR		:= 18;	// space for book close boxconstant kNewUIbuttonHeight := 13;constant kNewUIbuttonTop	:= kTBmargin + kLineSpacing + kmidmargin;constant kNewUIbuttonTopL	:= kTBmargin + (kLineSpacing*kURLlines) + kmidmargin;constant kNewUIstatusTop	:= kNewUIbuttonTop  + kNewUIbuttonHeight + kmidmargin;constant kNewUIstatusTopL	:= kNewUIbuttonTopL + kNewUIbuttonHeight + kmidmargin;constant kNewUIerrorTop		:= kNewUIstatusTop  + kLineSpacing;constant kNewUIerrorTopL	:= kNewUIstatusTopL + kLineSpacing;constant kTriMargin := 13;		// start of URLpara, infoButton/*4	margin(drag dot)13	URLpara(13	2nd&3rd lines)5	spacing13	buttons5	spacing(13	statusPara)4	margin*/DefineGlobalConstant('kShiftButton, func() // viewSetupFormScript for infoButton, fileButton, etc. assumes sibling h justifbegin	viewBounds :=		if kNIE and not nos21 and GetAppParams().AppAreaWidth <= kAppWidth	// 2.0 portrait		then OffsetRect(_proto.viewBounds,-2,0);		else Clone(_proto.viewBounds);	viewBounds.top :=  if prefsEntry.showLongURL then kNewUIbuttonTopL else kNewUIbuttonTop;	viewBounds.bottom := viewBounds.top + kNewUIbuttonHeight;	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym	then self.viewFont := labelFontJ;	if childSym exists	then :parent().(childSym) := self;//Write(self.text && "button: "); Print(viewBounds);	inherited:?viewSetupFormScript();end);// unusedDefineGlobalConstant('kShiftOptionsButton, func() // viewSetupFormScript for optionsButtonbegin // like kShiftbutton, but if on 2.0 in portrait mode, omit	// moved kEncodingOption to buttonClickScript	viewBounds := Clone(_proto.viewBounds);	if kNIE and not nos21 and GetAppParams().AppAreaWidth <= kAppWidth	// 2.0 portrait	then viewBounds.right := 0;	viewBounds.top :=  if prefsEntry.showLongURL then kNewUIbuttonTopL else kNewUIbuttonTop;	viewBounds.bottom := viewBounds.top + kNewUIbuttonHeight;//Write(self.text && "button: "); Print(viewBounds);	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym	then viewFont := labelFontJ;	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kTriButton, {	// a toggling triangleviewClass: clView,viewFlags: vClickable + vVisible + vClipping,opened: nil,//viewBounds: 10x10//prefSym:	closedTri:	[0,0, 8,4, 0,8, 0,0],	// can't create polygon itself at build time?openTri:	[0,0, 8,0, 4,8, 0,0],viewDrawScript: func()	:DrawShape(		MakePolygon(if opened			then openTri			else closedTri),		{transferMode: modeCopy,		penSize: 1,		fillPattern: if opened then vfWhite else vfBlack,		}),viewClickScript: func(unit)	begin	// toggle. redisplay, open/close sound		:setPreference(prefSym, opened := not opened);	// !!!k		/*if kNIE		then AddDeferredSend(self, 'setPreference, [prefSym, opened := not opened])		else AddDeferredAction(Functions.Perform, [self, 'setPreference, [prefSym, opened := not opened]]);		*/		PlaySound(if opened then ROM_draweropen else ROM_drawerclose);		:Dirty();	// redraw immed? returns TRUE	end,viewSetupFormScript: func()	self.opened	:= prefsEntry.(prefSym),});DefineGlobalConstant('kShowNCButton, { // a tiny NC button for book bar_proto: protoPictureButton,viewBounds: RelBounds(0,0,16,16),buttonClickScript: func()				// shared with hideButton, _NewtsCape(kbd)	GetRoot().(kAppSymbol):?open(),	/*begin		local newtscape := GetRoot().(kAppSymbol);		if call kViewIsOpenFunc with (newtscape) then newtscape:hide();		newtscape:open();	end,*///icon -- set in afterScript//icon: call kGetResource with ("NC book 13x13"),});DefineGlobalConstant('kScanAttribute, func(line, attrib)	// used in scanImages, scanLinks, scanFrames, scanFixFrame, kGetBaseif linethen begin	local INT stop := StrLen(line);	local i, pos1, pos2, ch;	// looks for ...  attrib= "........"     >	//				  ^       ^        ^     ^	if not i := StrPos(line, attrib, 0)	// !!!g,f. assume immed = suffix (otherwise, heALThcare)	then return NIL;	// look for first char of value	for i := i+StrLen(attrib) to stop-1	// !!!g	do  if (ch := line[i]) = $" or ch = $'		// find next " or '		then begin			pos1 := (pos2 := i) + 1;			while (pos2 := CharPos(line, ch, pos2+1))				and line[pos2-1] = $\\	// !!!g. quoted quote?			do nil;			break if not pos2 then pos2 := stop;			end					else if not isWhiteSpace(ch) // and ch <> $=		then break pos1 := i;	// pos2 is nil	if pos1	then begin		if not pos2		then for i := pos1+1 to (pos2 := stop)-1	// break on next whitespace		 	 do if isWhiteSpace(line[i])				then break pos2 := i;		if pos1 < pos2		then TrimString(SubstituteChars(SubStr(line,pos1,pos2-pos1), "\n\t", "  ")); // kMyTrim		// else NIL;		end;	end);DefineGlobalConstant('kHideNewtsCape, func()begin	local root := GetRoot(), newtscape := root.(kAppSymbol);	if Visible(newtscape)	then begin		if kNIE and not newtscape.hideObj	// !!!g		then newtscape.hideObj := root.notifyIcon:?AddAction(			kAppNameL, kShowNCButton.buttonClickScript, nil); //func() GetRoot().(kAppSymbol):open()		SetKeyView(nil, 0);	// !!!f		newtscape:hide();		end;end);DefineGlobalConstant('kFixMenuItem, func(str, pick)if pick then str else $( & str & $)	// {item: $( & str & $), pickable: NIL});constant kLogicKbdSym := '|TLK:LogicTools|;DefineGlobalConstant('kBounds0, SetBounds(0,0,0,0));DefineGlobalConstant('kPopupCancelScript, func()	// !!!bbegin	popup := NIL;	inherited:?pickCancelledScript();end);DefineGlobalConstant('kProcessNextCallback, func(options)	// overview:Process, FRAMESETbegin	local newtscape := GetRoot().(kAppSymbol), msg := "", sel := options.processParams[0], len := Length(sel);	if len > 0	then begin		local entry := EntryFromObj(sel[0]);		msg := options.processMsg & $[ & len & "]:" && entry.URL;		ArrayRemoveCount(sel,0,1);		AddDelayedSend(newtscape, 'dispatchEntry, [entry, options], kDelay);		end;	newtscape:setStatus(msg);end);constant kFixedFrame := "<!--FIXEDFRAME-->";DefineGlobalConstant('kMakeSeparatorItem, func(str, pick)	// !!!jbegin	local item := {item: "--" & (if str then str else GetFolderStr(nil)) & "--"};	// !!!a1	if not pick	then item.pickable := NIL;	item;end);DefineGlobalConstant('kGetStoresList, func(val)	// !!!j. was in protoCachePicker, now shared by bookmarkPickerbegin	local store, name;	local INT pos := 0;	local ARRAY cmds := [{item: kDefaultItem}, 'pickSeparator];	// default.value = nil	foreach store in GetStores()	do begin		AddArraySlot(cmds, {item: name := store:GetName(), value: name});		if val and StrEqual(val, name)		then pos := Length(cmds)-1;		end;	cmds[pos].mark := kCheckMarkChar;	cmds;end);constant kStopError := 'stopButtonNC;	// !!!kDefineGlobalConstant('kCollectList, func(str, ch)	// !!!tbegin	local result := [], fn := StrTokenize(str, ch), val;	while val := call fn with ()	do  if StrFilled(TrimString(val))		then AddArraySlot(result, val);	result;end);// "item" is search arg, array element is aitem. used by :getRun, :scanLinksDefineGlobalConstant('kStrContains, func(item, aitem) // !!!f. test-fn for LSearch/ArrayPosif kNIEthen isInteger(StrPos(item, aitem, 0))	// !!!u,m. result must be 0 or true for matchelse StrPos(item, aitem, 0)				// !!!m (ArrayPos doesn't reverse));/*DefineGlobalConstant('kScanURL, func(url1, url2)	// !!!wif IsString(url2)then if IsString(url1)	// common case	then StrEqual(url1,url2)	else begin		if isEntryAlias(url1)		then url1 := EntryFromObj(url1).URL		else if isArray(url1)		then url1 := url1[0]		else if isFrame(url1)		then url1 := url1.URL;		//if isEntryAlias(url2)		//then url2 := EntryFromObj(url2).URL		//else if isArray(url2)		//then url2 := url2[0]		//else if isFrame(url2)		//then url2 := url2.URL;		IsString(url1) and StrEqual(url1,url2);		end);DefineGlobalConstant('kLinkMatch, func(entry, url)	// !!!wStrEqual(url, if IsString(entry) then entry else entry[0]));*/// ===========/*xx := getroot():notify(knotifymessage, "Newt's Cape:Open", "");xx.viewSetupFormScript := func()begin //Print("viewSetupFormScript");	GetRoot().|NewtsCape:NewtsCape|:?open();	AddDeferredSend(base,'close,nil);end;xx.viewChildren := nil;xx.sound := nil;*//*hh := {_proto: protoPictureButton, icon: ROM_overviewBitmap, viewBounds: RelBounds(0,0,12,12),};bb := {_proto: protoPictureButton, icon: ROM_leftbitmap, viewBounds: RelBounds(0,0,10,12),};ff := {_proto: protoPictureButton, icon: ROM_rightbitmap, viewBounds: RelBounds(0,0,10,12),};dd := {_proto: protoPictureButton, viewBounds: RelBounds(0,0,10,0), viewFormat: 0, viewFlags: vVisible,};nn := {_proto: protoPictureButton, icon: GetRoot().|Newtscape:Newtscape|.icon, viewBounds: RelBounds(0,0,16,16),};getroot().copperfield:SetStatusBarButtons({left: [dd, hh], right: [ff,bb]});getroot().copperfield:SetStatusBarButtons({left: [dd, nn], right: [dd,dd]});DoProgress('vGauge, {statusText: "this is a status", titleText: "a title", gauge: 0},	func(progressView)	getroot().|ViewFrame:JRH|:newValue("setStatus", progressView.setStatus))functions.doprogress.literals[0].setstatus	// :eventpause(true) ??strhexdump(@624.icon.bits, 0)getglobals().|NewtsCape:NewtsCape|getroot().|NewtsCape:NewtsCape|.debugflag := breakonthrows := nil ;getroot().|NewtsCape:NewtsCape|.debugflag := true;getroot().|NewtsCape:NewtsCape|:geturl("http://lthmtek.msek.lth.se/~cim93hf4/avanti.html", nil)getroot().|NewtsCape:NewtsCape|:geturlcache("htmlcache:newtscape", "http://www.siebel.com/company/company.html", 'text, nil)getroot().|NewtsCape:NewtsCape|:dispatchfile("text/html", "foo.htm", "<HTML><HEAD><TITLE>test</TITLE></HEAD><BODY><FORM ACTION=\"foo\"><TABLE><TR><TD>some text<TD><TEXTAREA NAME=x>abc</TEXTAREA></TABLE></FORM></BODY></HTML>", nil)getroot().|NewtsCape:NewtsCape|.URLpara.textgetroot().|NewtsCape:NewtsCape|.curbook.contentsgetroot().|NewtsCape:NewtsCape|.curbook.contents[0].datagetroot().|NewtsCape:NewtsCape|.curbook.rendering[0].pages[0].blocksgetroot().|NewtsCape:NewtsCape|:collectURLs("htmlcache:newtscape", true, nil)getroot().copperfield.contentarea:childviewframes()getroot().copperfield:whereisbook("")getroot().copperfield:whereisbook("test2.htm").booksoup.book.datagetroot().copperfield.librarylength(getroot():childviewframes())length(getroot().copperfield:getOfflineBooks())length(getroot().copperfield:getOnlineBooks())call func(book)begin	local obj, href, newtscape := getroot().|NewtsCape:NewtsCape|, bhref := book.data.base_href;	foreach obj in book.contents	do if obj.hrefs		then begin//Print(obj.hrefs);			foreach href in if IsEntryAlias(obj.hrefs) then ResolveEntryAlias(obj.hrefs).data else obj.hrefs			do begin Print(href[0]); Print(newtscape:resolveURL(bhref, href[0])); end;			end;end with (getroot().|NewtsCape:NewtsCape|.curbook)call func(x)begin	local i,obj;	foreach obj in x	do Print(obj);end with (xxx)call func(n)begin local i, t := ticks();for i:=1 to ndo xxx;ticks() - t;end with (100);getviewdefs('copperfield)getdefs('viewdef,['copperfield],nil)getdatadefs('copperfield)getrouteformats({class: '|Data:NewtsCape:NewtsCape|})GetFormatTransports(	getrouteformats({class: '|Data:NewtsCape:NewtsCape|}),	getroot().|NewtsCape:NewtsCape|:gettargetinfo('routing).target)xx := getroot().extrasdrawer:GetPartCursor(nil, nil, '_all) xx:next()getroot().extrasDrawer:GetPartEntryData(xx:entry())*//*options stuffInit:NC.viewSetupDoneScript (nil)NC.getURL (options)NC.dispatchFile (options)NC.DoEvent (options)NC.connect (nil)NC.goToHref (nil)kSendHTTP (options/optionsAPI)NC.cachePicker (nil)NC.addIncludes (options)----fixOptions:NC.viewSetupFormScript (nil)NC.getOptionkSendMsgkGoToHREF----neitherNC.addFileNC.startHTMLkSendMsg called by: kGoToHref, kSendHTTP, kPostDatakPostData called by :getURL, kPostMailkPostMail called by "SUBMIT"kSendHTTPkGoToHref called by :getURL, :gotoHREF, kGoToHREFclickShare:goToHref called by kGoToHREFclickShare, "RADIO/CHECKBOX/TEXT"http://bigweb.misty.com/weyer/newton/graphics/HELLOSMALL.JPGKillStdButtonBar(Array(4, '{buttonBarPosition: none}));KillStdButtonBar(nil);// continue to HTTP Project Data// for debugging serialxx := {	_parent: getroot().|NewtsCape:NewtsCape|,	_proto: getroot().|NewtsCape:NewtsCape|.protoSerialProtocol,	setInputSpec: func(x) Print("setInputSpec"),	};xx.commEndPt := xx;call func(ep,str)begin	local pos, spos := 0;	while (pos := CharPos(str,unicodeCR,spos))	do begin		ep:InputLine(SubStr(str,spos,pos-spos));		spos := pos+1;		end;end with (xx,"findlocale("http:NewtsCape")getglobals().|NewtsCape:NewtsCape|.|foo.htm|.|1_saveMap|getroot().|NewtsCape:NewtsCape|.curbook.datagetroot().|NewtsCape:NewtsCape|.curbook.rendering[0].pages[1].blocksgetroot().copperfield.contentarea:childviewframes()[2]printlength:= 100;breakonthrows := nilgetroot():childviewframes()getroot().|NewtsCape:NewtsCape|:setpreference('includeFrames, "x")getroot().|NewtsCape:NewtsCape|:fixFrame("http://download.planetnewton.com/downindex.asp",getroot().|NewtsCape:NewtsCape|:dispatchfile("text/html", "foo.htm", "<HTML><HEAD><TITLE>test</TITLE></HEAD><BODY></BODY></HTML>", nil)getroot().|NewtsCape:NewtsCape|.wwwfsmgetroot().|NewtsCape:NewtsCape|:resetfsm()getroot().|NewtsCape:NewtsCape|.tempoverview.overview.selectedcall func(href)GetUnionSoupAlways("HTMLCache:NewtsCape"):Query({	indexPath: 'URL, 	// for l-o-n-g strings	beginKey: href,	endKey: href,	validTest: func(entry)		StrEqual(entry.url,href),	}):entry()with ("http://members.bellatlantic.net/~sweyer/testx.htm")getroot().|hemlock:seanl|GetRoot().|Hemlock:seanl|:APIDoSimpleSearch("Newton");qq := GetRoot().|Hemlock:seanl|:APISearchEngineCursor();ee := qq:entry(); nilGetRoot().|Hemlock:seanl|:APIDoSearch([ee], "Newtown")GetRoot().|Hemlock:seanl|:APIDoFullSearch([ee], "Newtown", {})pp := getroot().|NewtsCape:NewtsCape|.prefsEntry; [pp.prefName, pp.tag, pp.curPrefTag, pp.prefNames]call func(old, cur)begin	local cur := clone(cur), slot,val;	foreach slot,val in old	do removeslot(cur,slot);	cur;end with (gg, GetGlobals())end with (rr, GetRoot())call func(old, cur)begin	local slot,val;	foreach slot,val in old	do if val <> GetVariable(cur,slot)	then Print(slot);end with (gg, GetGlobals())end with (rr, GetRoot())xx := {closeBox: nil,icon: getroot().|NewtsCape:NewtsCape|.icon, statusText: "Loading Links",gauge: 1000,titleText: "<A",};doprogress('vgauge, xx,func(contextView)beginlocal x; for x:=1 to 100do begin xx.gauge := x; contextView:SetStatus('vGauge, xx); end;Print("done?"); end)gc(); stats(); [length(getglobals()), length(getroot()), length(getroot():childviewframes())]gg := clone(getglobals()); rr := clone(getroot()); nilgetroot().|ViewFrame:JRH|:newValue("x", protoActionButton)getroot().|NewtsCape:NewtsCape|.curbook*/// End of text file Project Data// Beginning of text file HTTP Project Data// HTTP Project Data// continued from Project Data (for Newt's Cape)// these are constants primarily used for NIE, in HTTP FSM (and sometimes elsewhere also)// if they're needed in Project Data (for definition order),// they might be defined here also for standalone useif kNIEthen begin	DeclareGlobalFn('InetOpenConnectionSlip, 3);	DeclareGlobalFn('InetDisplayStatus, 3);	DeclareGlobalFn('InetGrabLink, 3);			// deprecated	DeclareGlobalFn('InetReleaseLink, 3);		// deprecated	DeclareGlobalFn('InetCancelLink, 3);	DeclareGlobalFn('InetGetLinkStatus,1);	DeclareGlobalFn('DNSGetAddressFromName, 3);	DeclareGlobalFn('DNSCancelRequests, 2);	DeclareGlobalFn('InetGetErrorString, 1);	DeclareGlobalFn('InetSetDefaultLinkID, 1);	DeclareGlobalFn('InetGetAllLinksStatus, 0);	DeclareGlobalFn('InetGetDefaultLinkID, 0);	// NIE 2.0	DeclareGlobalFn('InetGrabLinkVerbose, 3);	DeclareGlobalFn('InetReleaseLinkVerbose, 3);	DeclareGlobalFn('InetIPAddressToString, 1);	DeclareGlobalFn('RegInetLinkStatusChange, 3);	DeclareGlobalFn('UnRegInetLinkStatusChange, 1);	DeclareGlobalFn('InetIsValidIPAddressStr, 1);	DeclareGlobalFn('InetIPStringToAddress, 1);	// Event codes used by system	constant kEventToolSpecific	:= 1;	constant kEventDisconnect	:= 2;	constant kEventRelease		:= 3;	end;constant kHTTPver	:= "HTTP/1.0";	// for outgoingconstant kHTTPStr	:= "HTTP";		// for incomingDefineGlobalConstant('kHTTPSym, 'HTTP);// some http Header fieldsconstant kContentType 	:= "Content-Type";DefineGlobalConstant('kContentTypeSym0, Intern(kContentType & $0));	// originalconstant kContentLength := "Content-Length";DefineGlobalConstant('kContentLengthSym, Intern(kContentLength));constant kContentBase := "Content-Base";DefineGlobalConstant('kContentBaseSym, Intern(kContentBase));constant kDate			:= "Date";DefineGlobalConstant('kDateSym, Intern(kDate));constant kLastModified	:= "Last-modified";DefineGlobalConstant('kLastModifiedSym, Intern(kLastModified));constant kAuthorization := "Authorization";//DefineGlobalConstant('kAuthorizationSym, Intern(kAuthorization));constant kAuthenticate	:= "WWW-authenticate";//DefineGlobalConstant('kAuthenticateSym, Intern(kAuthenticate));constant kProxyAuthenticate		:= "Proxy-Authenticate";constant kProxyAuthorization	:= "Proxy-Authorization";//DefineGlobalConstant('kProxyAuthorizationSym, Intern(kProxyAuthorization));constant kSetCookie		:= "Set-Cookie";DefineGlobalConstant('kSetCookieSym, Intern(kSetCookie));DefineGlobalConstant('kLocationSym, Intern(kLocation));constant kServer		:= "Server";DefineGlobalConstant('kServerSym, Intern(kServer));constant kExpires		:= "Expires";DefineGlobalConstant('kExpiresSym, Intern(kExpires));constant kAccept		:= "Accept";//DefineGlobalConstant('kAcceptSym,	Intern(kAccept));constant kAcceptLang	:= "Accept-Language";	// !!!v//DefineGlobalConstant('kAcceptLangSym,	Intern(kAcceptLang));// for sending onlyconstant kSendCookie	:= "Cookie";constant kIfModified	:= "If-Modified-Since";constant kUserAgent		:= "User-Agent";constant kBasic			:= "Basic";		// for authorizationconstant kReferrer 		:= "Referer";	// (sic)DefineGlobalConstant('kReferrerSym,	Intern(kReferrer));// note: serial works for text xfer; how to do binary xfer (w/o xon/xoff)?// to use serial, comment this out. add fsm.fSerial. edit newURL:actionconstant fSerial := NIL;	// leave out for now?constant kTextXferSize	 :=  2000;	// for reading text files partially (check discardAfter)constant kBinaryXferSize :=  2000;	// for reading binary files partiallyconstant kCleanupDelay   :=  1000;	// for NIE cleanup before dispatch?constant kMaxLineSize	 := 36000;	// !!!b1//DefineGlobalConstant('kHemlockDelay, 6 * kCleanupDelay);DefineGlobalConstant('kDoNextState, 	func() :?DoEvent(nextState, nil));DefineGlobalConstant('kErrDoNextState, func(error)beginif kDebugOn then :?MNotifyError(NotifyMsg, error);	// !!!i	error := NotifyMsg &&		if IsNumber(error) and GetGlobalFn('InetGetErrorString)	// NIE 1.1		then InetGetErrorString(error)		else error;	if not fHTTPoptions.error	// !!!k	then fHTTPoptions.error := error;	//:callBackError(error, fHTTPoptions);	// !!!j,h	if nextState	then :?DoEvent(nextState, nil); // for CancelLinkend);DefineGlobalConstant('kDoCancelAbort,	func() fAbort := true);DefineGlobalConstant('kCompletionSpec, { // _proto this. add failEvent, succEvent slots.	async: 		true,	reqTimeout: 0, //kNoTimeout,	failEvent: 	'failEvent, // override this!	succEvent: 	'succEvent, // override this!	completionScript: func(ep, options, result)		if result		then ep:DoEvent(failEvent, [result])		else ep:DoEvent(succEvent, nil),	});DefineGlobalConstant('kDoCancelEP, func()begin	fAbort := true;	try		fEndPoint:?Cancel(nil);	onexception |evt.ex.comm| do	nil;	// Send HTTP:Cancel state would need Disconnectend);DefineGlobalConstant('kByteBeginsWith, func(bytes, str, INT start) // for checking GIF, packagebegin	local INT i, slen := StrLen(str);	if start+slen > Length(bytes)	then return NIL;	for i := 0 to slen-1	do if ExtractChar(bytes, start+i) <> str[i]		then return NIL;	TRUE;end);DefineGlobalConstant('kBytePos, func(bytes, str, INT start) 	// like StrPos for finding "...package"begin	local INT i, slen := StrLen(str);	//if slen=0	//then return start;	if start+slen > Length(bytes)	then return NIL;	local ch0 := str[0];	for i := start to Length(bytes)-slen-1	do  if ExtractChar(bytes, i) = ch0 and call kByteBeginsWith with (bytes,str,i)		then return i;	NIL;end);constant base64Chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";	// the mapDefineGlobalConstant('kEncodeBase64, func (str) //NATIVE? encode from string to BASE64. used in authenticateButton (decoder in vCalCard)begin	local INT code, savecode, bits, usedbits := 0, i, rlen := 0;	local result := str&str; 			// longer than nec, but shorten at end	for i:=0 to StrLen(str)-1	do begin		code := Ord(str[i]); // kOrd. another 8 bits (7?, 16?)		// for each char, map 6 bits via base64Chars, shift remainder		if usedbits = 0		then begin // save 6 bits, keep 2			savecode := code >> 2;			bits 	 := BAND(code, 0x3) << 4;			usedbits := 2;			end		else if usedbits = 2		then begin // save 2+4 bits, keep 4			savecode := BOR(bits, code >> 4);			bits 	 := BAND(code, 0xF) << 2;			usedbits := 4;			end		else //if usedbits = 4 then			begin // save 4+2 bits, save 6, keep 0			savecode := BOR(bits, code >> 6);			result[rlen] := base64Chars[savecode];			rlen := rlen+1;			savecode := BAND(code, 0x3F);			usedbits := 0;			end;		result[rlen] := base64Chars[savecode];		rlen := rlen+1;		end;	if usedbits > 0 // any remaining bits?	then begin		result[rlen] := base64Chars[bits];		rlen := rlen+1;		end;	StrMunger(result,rlen,nil, "===",0,rlen mod 4); // shorten, add paddingend);DefineGlobalConstant('kDecodeBase64, func (str)begin	local INT bit6, bits, usedbits := 0, dpos := 0, i, slen := StrLen(str);	local chmap, savebyte, char;	local data := MakeBinary(slen*2, 'string); //GetDefaultStore():NewCompressedVBO('binary, slen*3 div 4, kTextCompander, nil);	for i:=0 to slen-1	do begin		char := str[i];		if char = $=		then break;		if chmap := CharPos(base64Chars,char,0)	// see vCalCard for faster ~3x NATIVE version?		then begin			bit6 := chmap;			if usedbits = 0			then begin //  +0 [6] start a byte (6 leftover)				savebyte := nil;				bits 	 := bit6 << 2;				usedbits := 6;				end			else if usedbits = 2			then begin // 2+6 [0]	complete a byte, no leftover				savebyte := BOR(bits, bit6);				bits 	 := usedbits := 0;				end			else if usedbits = 4			then begin // 4+4 [2]	complete a byte, 2 leftover				savebyte := BOR(bits, bit6 >> 2);				bits 	 := BAND(bit6, 3) << 6;				usedbits := 2;				end			else // if usedbits = 6 then				begin // 6+2 [4]	complete a byte, 4 leftover				savebyte := BOR(bits, bit6 >> 4);				bits 	 := BAND(bit6, 0xF) << 4;				usedbits := 4;				end;			if savebyte			then begin				StuffUniChar(data, dpos, savebyte);				dpos := dpos+2;				end;			end;		end;	//Print(usedbits);	StrMunger(data,dpos div 2,nil, nil,0,nil); // shorten, return data stringend);// to read/print http format dates (Wdy, DD-Mon-YYYY HH:MM:SS GMT),// efficiently and especially on non-US systemsDefineGlobalConstant('kHTTPtimeSpec,GetDateStringSpec([	[kElementHour,		kFormatNumeric],	[kElementMinute, 	kFormatNumeric],	[kElementSecond, 	kFormatNumeric],	[kElementSuffix, 	kFormatLong],	]));if kDebugHTTP then Print("http time spec:" && kHTTPtimeSpec);	// 10922701DefineGlobalConstant('kHTTPdateSpec,GetDateStringSpec([	// reversed for longDateOrder?	[kElementYear,		kFormatNumeric],	[kElementMonth, 	kFormatAbbr],	[kElementDay, 		kFormatNumeric],	[kElementDayOfWeek, kFormatAbbr],	]));if kDebugHTTP then Print("http date spec:" && kHTTPdateSpec);	// 11614802DefineGlobalConstant('kHTTPlocaleName, "http:" & kAppNameS);DefineGlobalConstant('kHTTPlocale, {_proto: 	nil,	//currentLocale -- see installScript// override/ensure minimum stufftitle: 		kHTTPlocaleName, localeSym: 	kAppSymbol,	// kHTTPlocaleSymlongDateFormat: {	_proto: 		nil, //currentLocale.longDateFormat,	abbrDofWeek: 	["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], 	abbrMonth: 		["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], 	longDateDelim:	["", ", ", " ", " ", ""],	longDateOrder: 	kHTTPdateSpec,	dayLeadingZ: 	kLeadZero, 	},timeFormat: {	_proto:			nil, //currentLocale.timeFormat,	timeSepStr1: 	":",	timeSepStr2: 	":",	//morningStr:	"",	//eveningStr:	"",	suffixStr: 		" GMT",	hourLeadingZ: 	kLeadZero,	minuteLeadingZ: kLeadZero,	secondLeadingZ: kLeadZero,	timeCycle: 		kCycle24,	midNightForm: 	kUseHour24,	//noonForm: 	kUseHour12,	},  });// LongDateStr(Time(), ROM_dateTimeStrSpecs.abbrDateStrSpec)// LongDateStr(Time(), 11614802); //kHTTPdateSpec// Timestr(Time() , ROM_dateTimeStrSpecs.longTimeStrSpec)// Timestr(Time() , 10922701); 	  //kHTTPtimeSpecDefineGlobalConstant('kAdjMin, func()	// used by kPrintDate, kReadDatebegin	local gmtSecs := GetUserConfig('location).gmt;	local dstSecs := GetUserConfig('daylightSavings);	((if gmtSecs then gmtSecs else 0) + (if dstSecs then dstSecs else 0)) div 60;end);DefineGlobalConstant('kPrintDate, func(tt)if ttthen begin // return this format: Sun, 06 Nov 1994 08:49:37 GMT	tt := tt - call kAdjMin with ();	// adjust for time zone, dst	// set "http" locale temporarily	local oldLocaleSym := GetLocale().localeSym, str;	SetLocale(kAppSymbol);	try		// nothing should go wrong, but in case it does...		str := LongDateStr(tt, kHTTPdateSpec) && TimeStr(tt, kHTTPtimeSpec)	onexception |evt.ex| do nil;	SetLocale(oldLocaleSym);	str;end);DefineGlobalConstant('kReadDate, func(str)begin // generally: Wdy, DD-Mon-YYYY HH:MM:SS GMT/*Sun, 06 Nov 1994 08:49:37 GMT	// RFC 822 (http://ds.internic.net/rfc/rfc822.txt)								//	updated by RFC 1123 (http://ds1.internic.net/rfc/rfc1123.txt)Sunday, 06-Nov-94 08:49:37 GMT	// RFC 850 (http://ds.internic.net/rfc/rfc850.txt),								//	obsoleted by RFC 1036 (http://www.w3.org/hypertext/WWW/Protocols/rfc1036/rfc1036.html#z6)Sun Nov 6 08:49:37 1994			// ANSI C's asctime() format*/	local spos, cpos1, cpos2;	// cascade test	if  (spos  := CharPos(str, $ , 0)) and		// skip day of week		(cpos1 := CharPos(str, $:, spos)) and		(cpos2 := CharPos(str, $:, cpos1+1))	then begin//if kDebugHTTP then Print("readDate orig:" && str);		local dstr := SubStr(str, spos, cpos2-spos), totMin;// omit secs & GMT		if not EndsWith(str, "GMT")							// not 1&2 -- i.e., 3 (ANSI C)		then StrMunger(dstr, cpos1-3-spos, 0, str, StrLen(str)-5, 5); // insert year before time		// set "http" locale temporarily		local oldLocaleSym := GetLocale().localeSym;		SetLocale(kAppSymbol);		try	begin		// nothing should go wrong, but in case it does...			if totMin := StringToDate(dstr)			then totMin := totMin + 1 + call kAdjMin with ();	// always adjust (even for 3)			end		onexception |evt.ex| do return 0;		SetLocale(oldLocaleSym);//if kDebugHTTP then Print("readDate conv:" && call kPrintDate with (totMin));		totMin;		end	else 0;end);DefineGlobalConstant('kGetCookies, func(cookies, host, file, pref)	// used in Genesis:newURL, :quitif isArray(cookies) // assume sorted by [domain,path]then begin	local INT i, now := Time(), len := Length(cookies);	local ARRAY cookie;	local str;	// reverse order for remove, and more specific first	for i := len-1 to 0 by -1	// [[domain, path, expire, name, val],...]	do begin		cookie := cookies[i];		if (if cookie[2] then cookie[2] <= now else not host)		then ArrayRemoveCount(cookies, i, 1) // expired -- remove		else if host and EndsWith(host, cookie[0]) and BeginsWith(file, cookie[1])		then str := str & (if str then "; ") & cookie[3] & $= & cookie[4]; // !!!o		end;	if pref and len <> Length(cookies)	then GetRoot().(kAppSymbol):?setPreference('cookies,cookies);	str;	end);/*Set-Cookie: CCB=1; path=/;expires=Wednesday, 09-Nov-99 23:12:40 GMT; domain=.elibrary.comSet-Cookie: id=0; path=/;expires=Wednesday, 09-Nov-99 23:12:40 GMT; domain=.elibrary.comSet-Cookie: CUSTOMER=WILE_E_COYOTE; path=/; expires=Wednesday, 09-Nov-99 23:12:40 GMTSet-Cookie: PART_NUMBER=ROCKET_LAUNCHER_0001; path=/Set-Cookie: SHIPPING=FEDEX; path=/fooSet-Cookie: PART_NUMBER=RIDING_ROCKET_0023; path=/ammoSet-Cookie: Count=1; expires=Wednesday, 09-Nov-1999 23:12:40 GMT; path=/; domain=.illuminatus.comSet-cookie: Name=Fred; expires=Wednesday, 01-Jan-97 12:00:00 GMTSet-cookie: Color=Red; expires=Wednesday, 01-Jan-97 12:00:00 GMT*/DefineGlobalConstant('kMakeAttrib, func(name,val)if valthen name & $: && val & crlf);// renamed from kPutCookie. vals an array of strings (was just val)DefineGlobalConstant('kPutCookies, func(args)	// used in fInputHeaderScriptif argsthen begin	// args = [cookies, host, vals, pref]	local cookies := args[0];	local host 	  := args[1];		local cpos, val, cval, name, attrib;//Print("before"); Print(cookies);	local ARRAY cookie;	foreach val in args[2]	// vals	do begin		cookie := [host, "/", nil, nil, nil];	// defaults		cpos := 0;		while cpos and attrib := call kGetAttrib with (val, $=, $;, cpos)		do begin			name := attrib[0];			cval := attrib[1];			cpos := attrib[2];			if StrEqual(name, "domain")			then cookie[0] := cval			else if StrEqual(name, "path")			then cookie[1] := cval			else if StrEqual(name, "expires")			then cookie[2] := call kReadDate with (cval)			else if StrEqual(name, "Max-Age")	// HTTP/1.1			then cookie[2] := Time() + ((call kGetInt with (cval,1)+59) div 60) // !!!a. round up secs to next minute			//else if not StrEqual(name, "secure") then // ignore 1.1 Version=, Comment=			else begin				cookie[3] := name;				cookie[4] := cval;				end;			end;		cval := BInsert(cookies, cookie,				func(ARRAY a, ARRAY b)				begin					local INT sc0 := StrCompare(a[0],b[0]), sc1;					if sc0=0					then if (sc1 := StrCompare(a[1],b[1])) = 0						then StrCompare(a[3],b[3])						else sc1					else sc0;				end, nil, 'returnElt);		if cval <> cookie		then begin	// replace expires,value in existing entry			cval[2] := cookie[2];			cval[4] := cookie[4];			end;		end;	if args[3] // pref	then GetRoot().(kAppSymbol):?setPreference('cookies,cookies);//Print("after"); Print(cookies);	cookies;end);DefineGlobalConstant('kRemoveComments, func(str)begin	local cpos1 := 0, cpos2, nextFlush := if isVBO(str) then kVBOFlush; // !!!b	while (cpos1 := StrPos(str, kCommentStart, cpos1)) and		  (cpos2 := StrPos(str, kCommentStop,  cpos1+4))	do begin		StrMunger(str, cpos1, cpos2-cpos1+3, nil, 0, nil);		if nextFlush and (cpos1 * 2) > nextFlush		then begin			ClearVBOCache(str);			nextFlush := nextFlush + kVBOFlush;			end;		end;	//cpos1;	// for parserend);constant kNewtonPkgMediaType 	:= "application/x-newton-compatible-pkg";//constant kAppOctetMediaType	:= "application/octet-stream";constant kPKGextension			:= ".pkg";DefineGlobalConstant('kBuiltInMediaTypes, {});DefineGlobalConstant('kMediaAll, {});kMediaAll.(kAppSymbol) := {};kBuiltInMediaTypes.(Intern(kHTMLMediaType)) := kMediaAll;kBuiltInMediaTypes.(Intern(kGIFMediaType)) 	:= kMediaAll;DefineGlobalConstant('kMediaTextPkg, {});kMediaTextPkg.(kAppSymbol) := {extensions: [kPKGextension, ".*"]};kBuiltInMediaTypes.(Intern(kTextMediaType)) := kMediaTextPkg;DefineGlobalConstant('kMediaPkg, {});kMediaPkg.(kAppSymbol) := {extensions: [kPKGextension]};kBuiltInMediaTypes.(Intern(kNewtonPkgMediaType)):= kMediaPkg;kBuiltInMediaTypes.|application/*|				:= kMediaPkg;	// !!!u. (Intern(kAppOctetMediaType))kBuiltInMediaTypes.(Intern(kAllMediaType)) 		:= kMediaPkg;//constant kWWWunknownMediaType 					  := "www/unknown";	// e.g., palmzip ?//kBuiltInMediaTypes.(Intern(kWWWunknownMediaType)) := kMediaPkg;DefineGlobalConstant('kHead, "HEAD");/*allowable (1.1) methods:"OPTIONS"                ; Section 9.2"GET"                    ; Section 9.3"HEAD"                   ; Section 9.4"POST"                   ; Section 9.5"PUT"                    ; Section 9.6"DELETE"                 ; Section 9.7"TRACE"                  ; Section 9.8*/DefineGlobalConstant('kHeapMsg,	LocObj("out of heap/store?", 'noHeapStoreErr));DefineGlobalConstant('kFixOptions, func(fURLqueue, options)	// used by dispatchCache, textSuccess, BinarySuccessif fURLqueue and Length(fURLqueue) > 0then begin	options := Clone(options);	// use _proto?	options.cacheOnly := true;	options;	endelse options);DefineGlobalConstant('kResetHTTP, LocObj("Reset HTTP", 'resetHTTPlabel));// continue to Final Project Data (for Newt's Cape)// End of text file HTTP Project Data// Beginning of text file Final Project Data// Final Project Data// continued from HTTP Project Data// includes Notes and Newtworks API// InstallScript and RemoveScriptDefineGlobalConstant('kOpenLabel, 	LocObj("Open", 'openItem)); // used only by outside apps (GetTitle, Kbd Summary)DefineGlobalConstant('kGetURLlabel, LocObj("getURL", 'getURLItem));DefineGlobalConstant('kFindlabel,	LocObj("Find", 'FindItem));DefineGlobalConstant('kOpenLabelE, 	if kNCfont then "Open"   else kOpenLabel);DefineGlobalConstant('kGetURLlabelE,if kNCfont then "getURL" else kGetURLlabel);DefineGlobalConstant('kFindlabelE,	if kNCfont then "Find"   else kFindlabel);// this handles both Notes and NewtWorks text selection/entries//constant kChecked := '["checked"];	// share//constant kElibraryURL := "http://www.elibrary.com/";DefineGlobalConstant('kAltaVistaFindFrame, {title: "AltaVista Text",	// !!!dURL:	"http://www.altavista.com//cgi-bin/query",method:	kGet,querySlot:		'q,data:	{	q:			"",			// set by kNewtsCapeDoItFunc (via querySlot)	//fmt:		"c",	text:		"yes",		// !!!d	pg: 		"q",	what:		"web",	},dataNames: [				// if case sensitive	"q","text","pg","what",	// !!!d	],dataSource: "[\"q\",\"\",\"text\",\"yes\",\"pg\",\"q\",\"what\",\"web\",],		// !!!d. \"fmt\",\"c\"]",});constant kDefaultCacheSize := 50; // used for default in NC:viewSetupDoneScript// at some point, add additional (> 2.0a) prefs; shorter 1.x version??DefineGlobalConstant('kPrefSetItem, 	LocObj("PrefSet", 'prefSetItem));	// !!!kDefineGlobalConstant('kDefaultPrefName, LocObj("Main PrefSet", 'mainPrefSetLabel));			// !!!kDefineGlobalConstant('kDefaultPrefs, { 					// commented out nil slots to save space	tag: 				kPackageName,//	agentPrefix:		nil, //if kDebugHTTP then "eMateEL",//	agentSizeRes:		nil,	allowCompile:		if not kNIE then 'compile,//	allowHosts:			nil,//	autoHide:			nil,//	autoLogin:			nil,	bitsPerPixel:		1,//	bookmarkLabel:		nil,	bookmarkSoupName:	kBookmarkSoupName,//	cacheDesktop:		nil,	cacheHTML:			kDefaultCacheSize,	cacheImages:		kDefaultCacheSize,//	compressedPkg:		nil,	convAnim:			nil,		// needed for version test	cookies:			[],	cookiesConfirm:		'ask,	curPrefTag:			kPackageName,	// !!!k//	docDoneSound:		nil,//	emptyHTML:			nil,//	emptyImages:		nil,	findFrame: 			if kNIE then kAltaVistaFindFrame else {},//	followHTML:			true,//	followImages:		true,	helpISBN:			kHelpISBN,	//hostADSP:			nil,//	httpNoProxy:		nil,//	httpProxy:			nil,//	ignoreTables:		nil,//	loadImages:			nil,	mailBody:			"hi,\nI saw this cool document in Newt's Cape.",	// !!!g//	noClose:			nil,//	noStatus:			nil,//overviewBookmarksOnly		pageSize:			if kNIE then 'full else 'portrait,	prefName:			kDefaultPrefName,	// !!!k	prefNames:			[kDefaultPrefName],	// !!!k//	rawImage: 			nil,	removeComments: 	true,//	scaleImage:			nil,	standAlone: 		true,//	startupURL:			nil,//systemFontFamily//systemFontSize	threshold:			128,	trustHTML:			true,	trustImages:		true,	//zoneADSP:			nil,	});if kNIE // kNCfontthen begin	kDefaultPrefs.systemFontFamily := kSystemFontSym;	kDefaultPrefs.systemFontSize := 9;	endelse begin	// !!!g	local sym;	foreach sym in '[		bookmarkSoupName, cacheHTML, cacheImages, cookies,		cookiesConfirm, findFrame, trustHTML, trustImages ]	do RemoveSlot(kDefaultPrefs, sym);	end;DefineGlobalConstant('kNewtsCapeDoItFunc, func(data) // called by kNotesRouteScript, kNewtworksDoItFuncbegin	local url := "", options, source, newtscape := GetRoot().(kNewtsCapeSymbol);	if call kViewIsOpenFunc with (newtscape)	then begin newtscape:hide(); newtscape:show(); end	else newtscape:open();		// :init???	if not StrFilled(data)	then return;	if call kIsHTML with (data)		// !!!j. StrPos(data, kHTMLStart, 0)	then begin		source := data;										// text = source <<<<<		options := {loadImages: nil};		end	else if call kURLmatch with (data)	then url := TrimString(data)							// text = URL	 <<<<<	else if kNIE and StrLen(data) < 100 // maxlength?	then begin		local findFrame := newtscape.prefsEntry.findFrame;		local findData := findFrame.data, app;		if StrFilled(url := findFrame.url)		then begin			if BeginsWith(url, "Hemlock")	// !!!h			then begin				if app := GetRoot().|Hemlock:seanl|				then begin/*latest: http://scruffy.cs.umd.edu:8080/seanl/Newton/Hemlock/api.htmlAPISearchEngineCursor()	Returns a cursor for all the search engine plugins in Hemlock.	Most significantly, entries should have a slot called "Name",	which gives the name of the engine. If you need more information	than that, tell me. 	APIDoSimpleSearch(terms)	Opens Hemlock and puts terms into its search terms field, but does	nothing else. This lets users set the search engines themselves. 	APIDoSearch(searchentries,terms)	Opens Hemlock and performs a search on searchentries (an array of	search engine entries accessed through	GetRoot().|Hemlock:seanl|:APISearchEngineCursor()), and terms	(a string of search terms separated by spaces).*/					local fn := StrTokenize(url,$;), engNames := [], val := call fn with (); // skip appSym					while val := call fn with ()					do  if StrFilled(TrimString(val))						then if StrEqual(val,"_all")							then break engNames := nil							else AddArraySlot(engNames, val);					//app:open();					//SetValue(app.SearchTerms.entryLine, 'text, data);					app:APIDoSimpleSearch(data);					if IsArray(engNames) and Length(engNames)=0					then return;					gc();					local cursor := app:APISearchEngineCursor(), entry := cursor:?entry(), engines := [];					while entry					do begin						if not IsArray(engNames) or LSearch(engNames,entry.name,0,'|str=|,nil)						then AddArraySlot(engines, entry);						entry := cursor:next();						end;					if Length(engines) > 0					then app:APIDoSearch(engines, data);						//app:APIDoFullSearch(engines, data, Clone(findData));					end;				return;				end;			if isFrame(findData) and Length(findData) > 0				and StrFilled(findFrame.method)			then begin				options := {					method: 	findFrame.method,					data:		findData := Clone(findData),					dataNames:	findFrame.dataNames,					};				findData.(findFrame.querySlot) := data;			// text = query	 <<<<<				end;			end;		end;	if source	then newtscape:dispatchFile(kHTMLMediaType, url, source, options)	else begin		if kNIE		then begin			newtscape.curSourceBuf := newtscape.curSourceBuf:?close(); // in case set in kCopyNewtWorksRange			if url			then call kRemoveComments with (url := Clone(url));	// !!!g			end;		if url		then if kNIE and CharPos(url,unicodeCR,0)	// list of URLs?			then newtscape:DoEvent(NIL, [{					cacheOnly: true,					autoLogin: nil,					noStatus: nil,					trustHTML: nil,					trustImages: nil,					fURLqueue: call kCollectList with (url, unicodeCR),	// !!!t					}])			else newtscape:getURL(url, options);	// single URL		end;end);// ----------// NotesDefineGlobalConstant('kNotesGetHighlightedText, func(target)if HiliteOwner() and GetHiliteOffsets()	and (target = GetVariable(HiliteOwner(), 'target) or		// Notes	'realData? !!!j		 target = GetVariable(HiliteOwner(), 'parentTarget))	// Inboxthen begin	local ARRAY offset;	local start, str, txt;	foreach offset in GetHiliteOffsets()	do  if (start := offset[1]) and		(isInstance(txt := offset[0].text, 'string) or	// !!!a1  (SimpleMail Text Stationery)			isInstance(txt := offset[0].realData.text, 'string))	// !!!e		then str := str & (if str then unicodeCR)  & call kMyTrim with (txt, start, offset[2]); // !!!o	str;	//if str and call kURLmatch with (str) then str;	end);DefineGlobalConstant('kGetLabel, func(newtscape, langLabel, engLabel)kAppNameL & $: &	if not kNCfont or (newtscape.prefsEntry and newtsCape.prefsEntry.systemFontFamily = kSystemFontSym) // !!!a1	then langLabel	else engLabel);DefineGlobalConstant('kNotesGetTitle, func(target)// for GetTitle slot of routeframeif targetthen begin	local newtscape := GetRoot().(kNewtsCapeSymbol);	local str := call kNotesGetHighlightedText with (target), lab;	if str or target.(kSourcePath) exists	then if call kURLmatch with (if str then str else target.(kSourcePath))	// !!!g		then call kGetLabel with (newtscape, kGetURLlabel, kGetURLlabelE) 		else if newtscape:matchHTMLtitle(if str then str else target, nil, true, kTitleStart, kTitleStop, nil)		then call kGetLabel with (newtscape, kOpenLabel, kOpenLabelE) 		else if kNIE		then begin			local lab := call kGetLabel with (newtscape, kFindlabel, kFindlabelE);			if newtscape.prefsEntry			then if StrFilled(str := newtscape.prefsEntry.findFrame.title)				then lab && $( & str & $)				else NIL			else lab & $?;		// not sure until open			end;	end);DefineGlobalConstant('kNotesRouteScript, func(target,targetView)begin // for RouteScript slot of routeframe	local str := call kNotesGetHighlightedText with (target);	GetRoot().(kNewtsCapeSymbol):NewtsCapeDoIt(if str then str else target.(kSourcePath)); // selection or first paraend);constant kNewtsCapeRouteScriptSym := 'NewtsCapeRouteScript;	// for install/removeDefineGlobalConstant('kNotesRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kNotesGetTitle,icon:				call kGetResource with ("NewtsCape tiny"),	// "NC popup 16x16"tag:				kNewtsCapeSymbol,routeScript:		kNotesRouteScript,});DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chainNCitems:			[kNotesRouteItem],	// !!!jGetRouteScripts:	func(targetInfo)begin	local routes := Clone(NCitems), oldRoutes;	// !!!j	if oldRoutes := inherited:?GetRouteScripts(targetInfo)	then routes := SetUnion(routes, oldRoutes, true);	SetUnion(routes, routeScripts, true);end});// ----------// HyperNewt/*constant kHyperNewtSymbol := '|HyperNewt:ATOW|;DefConst('kDefaultNonSoupHyperLinkInfoFrame, {	appSymbol: nil,	timeStamp: nil,	});DefConst('kNewtsCapeIcon, kNotesRouteItem.icon); //call kGetResource with ("NewtsCape tiny"));DefConst('kNewtsCapeSaveHyperLinkFunc, func(entry)begin	local hyperlinkinfo := Clone(kDefaultNonSoupHyperLinkInfoFrame);	// Required slots	local title := entry.title;	local icon := kNewtsCapeIcon;	hyperlinkinfo.class := ClassOf(entry);	hyperlinkinfo.appSymbol := kNewtsCapeSymbol;	//Newt's Cape specific stuff	hyperlinkinfo.URL := entry.URL;Print(title);Print(hyperlinkinfo);	return { title: title, icon: icon, hyperlinkinfo: hyperlinkinfo };end);DefConst('kNewtsCapeShowHyperLinkFunc, func(hyperlinkInfo)begin	local newtscape := GetRoot().(kNewtsCapeSymbol);	if newtscape	then begin		GetRoot().(kHyperNewtSymbol):?Minimize();		newtscape:?getURL(hyperlinkinfo.URL, nil);		return true;		end;	return nil;end);DefConst('kFrameSymbol, Intern("Frame:" & kNewtsCapeSymbol));DefConst('kDataSymbol, 	Intern("Data:" & kNewtsCapeSymbol));*/// ----------// NewtWorksconstant kNewtWorksChunkSize := 2048; // 2K. was 4Kconstant kRejectChars := "\u2206\u"; // graphic indicatorif kNIEthen DefineGlobalConstant('kNewtWorksBuf, {first:		NIL,last: 		NIL,textView: 	NIL,cleanup: 	NIL,close: func()begin	if cleanup	then textView:close();	textView := NIL;end,next: func()if first < last and textViewthen begin	local str := StringFilter( // strip out graphics characters			textView:GetRangeData(				{first: first, 				last: min(last, first + kNewtWorksChunkSize),				}, 'text),			kRejectChars, 'rejectAll);	first := first + kNewtWorksChunkSize;	str;	end//else nil});if kNIEthen DefineGlobalConstant('kCopyNewtWorksRange, func(textView, range, cleanup)	// added cleanupbegin // QA: Extracting All Text from a ProtoTXView Object	local bufObj := {_proto: kNewtWorksBuf,		first: if range then range.first else 0,		last: if range then range.last else textView:GetCountCharacters(),		textView: textView,		cleanup: cleanup,		};	local str := bufObj:next();	if bufObj.first < bufObj.last	then GetRoot().(kNewtsCapeSymbol).curSourceBuf := bufObj;	str;	// return first part of str (along with separate buffer object)/*	local INT start := if range then range.first else 0;    local INT last := if range then range.last else textView:GetCountCharacters();    local INT i, nextFlush := kVBOFlush, slen := 0;	local cstr, str := call kNewVBO with (nil, nil, "");	for i := start to last by kNewtWorksChunkSize    do begin		cstr := StringFilter( // strip out graphics characters					textView:GetRangeData(						{first: i, 						last: min(last, i + kNewtWorksChunkSize),						}, 'text),					kRejectChars, 'rejectAll);		StrMunger(str, slen, 0,	cstr, 0, nil);	// was i,nil		slen := slen + StrLen(cstr);		if (slen*2) >= nextFlush		then begin			ClearVBOCache(str);			nextFlush := nextFlush + kVBOFlush;			end;		end;	ClearVBOCache(str);	if cleanup	then textView:close();	str;*/end);if kNIEthen DefineGlobalConstant('kNewtWorksDoItFunc, func(viewDefView, newtAppBase)	// newtAppBase is unusedbegin	// check if anything is selected	local range := viewDefView:GetHiliteRange();	// if nothing is selected, treat it as 'Select All'	if range.first = range.last	then range := NIL;		/*begin	  	range.first := 0 ;	  	range.last 	:= viewDefView:GetCountCharacters();		end;*/	GetRoot().(kNewtsCapeSymbol):NewtsCapeDoIt(call kCopyNewtWorksRange with (viewDefView, range, nil)); // GetRangeDataend);if kNIEthen DefineGlobalConstant('kToolFrame,	{ // see Rot13 exampledataTypeSymbol: 'paper,		// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)item: 			kAppNameL,	// REQUIRED: appears in popup in tool picker.//setItemText: func(a,b) begin Print(a); Print(b); "foo"; end,keyCommand: {				// optional	char:		$h,	modifiers:	kCommandModifier,	keyMessage:	'DoNewtsCape,	keyFn:		func(viewDefView)					call kNewtWorksDoItFunc with (viewDefView, nil),	// newtAppBase is unused	name:		kAppNameL,	category:	"General"	// LocObj??	},// REQUIRED: called when user selects the item in the Tools pickercmdFunc:	kNewtWorksDoItFunc,});DefineGlobalConstant('kFixedFont, 	{family: 'Courier, 		face: kFaceNormal, size: 10, });DefineGlobalConstant('kDefaultFont, {family: kSystemFontSym,face: kFaceNormal, size: 10, });DefineGlobalConstant('kMargin32,	SetBounds(32, 32, 32, 32));if kNIEthen DefineGlobalConstant('kDummyTx, {	_proto: protoTxView,	viewBounds: kBounds0,	viewFlags: vNoFlags,	ReorientToScreen: ROM_DefRotateFunc,	viewSetupFormScript: func()	begin		//inherited:?viewSetupFormScript();	// !!!b		:SetGeometry(nil, 0, 0, kMargin32); // how to wrap long lines?		:SetStore(GetDefaultStore());	end,});if kNIEthen DefineGlobalConstant('kNewtWorksGetDoc, func(entry)begin	local dummy := BuildContext(kDummyTx);	dummy:Open();	dummy:Internalize(entry.saveData);	call kCopyNewtWorksRange with (dummy, nil, true); // dummy:GetRangeData(..., 'text);end);/*notes on possibly using HTMList forFile:Save HTML/Image to NewtWorks (kSaveDocument)File:Save Book to Newtworks (kNewtWorksNewDoc)Process:Save to NewtWorks (:newBook,:addBlock,:stopHTML)these would map onto kDummyTx obj in HTMListkDummyTx:newkAppendNewtWorksObjkNewtWorksSaveDocadvantage: improvements in format mapping (e.g., rulers/justification)space savings: kAppendNewtWorksObj, kNewtWorksSaveDoc*/if kNIEthen DefineGlobalConstant('kAppendNewtWorksObj, func(doc, obj)begin	local dlen := doc:GetCountCharacters(), txt, pos, newObj, styles, slen, tlen, slast;	if (newObj :=		if IsString(obj)	// text w/ default font (e.g., HTML source)		then {			text: obj,			styles: [StrLen(obj), kFixedFont]			}		else if isFrame(obj) and IsString(txt := obj.data)	// book text object		then begin			if (pos := obj.dataOffset) or obj.dataLen			then txt := SubStr(txt, if pos then pos else 0, obj.dataLen); // just part on this page			tlen := StrLen(txt);			if styles := obj.styles			then begin // check since some books might be wrong!				slen := 0;				for pos:=0 to (slast := Length(styles)-2) by 2 // add run lengths				do slen := slen + styles[pos];				if (pos := slen-tlen) <> 0				then beginif kDebugHTTP then Print("styles off by:" && pos);					styles := Clone(styles);					if (styles[slast] := styles[slast] - pos) < 0					then return if kDebugHTTP then Print("really off!");					end;				end			else styles := [tlen, if obj.viewFont then obj.viewFont else kDefaultFont];			{text: txt,			styles: styles,			};			end		else if isFrame(obj) or isBinary(obj) // graphic (bitmap, PICT)		then {			class: 'graphics,			shape: MakeShape(obj),			})	then doc:Replace({first: dlen, last: dlen}, newObj, nil);	// doesn't handle rulers/justification (see HTMList)end);if kNIEthen DefineGlobalConstant('kNewtWorksSaveDoc, func(dummy, title, show) // kNewtWorksNewDoc, Process()begin	gc();	local saveData := dummy:Externalize();	ClearVBOCache(saveData);	// !!!d	local summary := SubstituteChars(			StringFilter(				dummy:GetRangeData({first: 0, last: min(dummy:GetCountCharacters(), 80)}, 'text),				kRejectChars, 'rejectAll),			cr, " ");	dummy:Close(); 	local app := GetRoot().(kNewtworksSym);	local entry := app:AdoptEntryFromStationery({	// add the data to Works		title: Clone(title),		saveData: saveData,		hiliteRange: {first: 0, last: 0},		margins: kMargin32,		summary: summary,		},		'paper,		GetDefaultStore());	/*app:AdoptEntryFromStationery({title: url}, 'paper, GetDefaultStore());	app.viewDefView:Replace(		{first: 0, last: 0},		{text: txt,		styles: [StrLen(txt), kFixedFont]},		nil);*/	if show	then begin		app:open();		// DANGER undocumented! open to this doc and titlebox		try app:showFoundItem(entry, {findWords: [""]}) // {setStatus: kNilFunc1})		onexception |evt.ex.outofmem| do begin app:close(); Rethrow(); end		onexception |evt.ex| do nil;		AddDelayedSend(app, '_titleKeyScript, '[nil], 100);		end;end);if kNIEthen DefineGlobalConstant('kNewtWorksNewDoc, func(title, data)	// called via kSaveDocument(Save HTML/Image), Save Book (from Bob Ebert)if GetRoot().(kNewtworksSym)then begin	// use a txView to properly create the SaveData info	local dummy := BuildContext(kDummyTx), obj;	dummy:Open();	if isArray(data)	// curBook.contents	then foreach obj in data		 do begin			obj := call kMungeContentScript with (obj); // resolve any aliases			if obj.type <> 'form	// text and graphics only			then begin					call kAppendNewtWorksObj with (dummy, if IsString(obj.data) then obj else obj.data);				call kAppendNewtWorksObj with (dummy, cr);	// some spacing between paras				end;			end	else call kAppendNewtWorksObj with (dummy, data);	call kNewtWorksSaveDoc with (dummy, title, true);	end);if kNIEthen DefineGlobalConstant('kGetBASE, func(content)	// shared by scanImages, protoSerialProtocolcall kScanAttribute with (call kSubStr with (content, kBaseStart, ">", nil), kHREF); // !!!f,e);if kNIEthen DefineGlobalConstant('kGetTITLE, func(content)	// !!!kbegin	local ftitle := call kSubStr with (content, kTitleStart, kTitleStop, nil);	if ftitle and StrFilled(TrimString(ftitle))	then ftitle;	// :fixString laterend);if kNIEthen DefineGlobalConstant('kSaveDocument, func(cacheSoup, url, field, edata, title, nw) // shared by File:Save as *, kSaveAsHTMLbegin	local obj := if field then call kGetURLCache with (cacheSoup, url, field, edata, true) else cacheSoup;	if obj	then begin		local pos;		if IsString(obj) and not StrPos(obj, kBaseStart, 0)	// add <BASE> if not there		then StrMunger(				obj := Clone(obj), if (pos := StrPos(obj,kTitleStart,0)) then pos else 0, 0,				("<BASE HREF=\"" & url & "\">\n"), 0, nil);if kDebugHTTP then Print(obj);		if kNIE and nw		then call kNewtWorksNewDoc with (title, obj)		else if not nw		then call kMakeNote with (title, obj, nil, nil);		end;end);DefineGlobalConstant('kCopperfieldProtoItem, { // !!!e. for Copperfield _proto chainscrollPage: kScrollPage2,	// 2.x_Back: func(view)			// 2.1. see kBookKeyskBackButton:buttonClickScript(),_Forward: func(view)		// 2.1kForwardButton:buttonClickScript(),_NewtsCape: func(view)		// 2.1. * !!!fbegin	local newtscape := GetRoot().(kNewtsCapeSymbol);	if Visible(newtscape)	then call kHideNewtsCape with ()	// !!!g. newtscape:hide()	else newtscape:?open();	//kShowNCButton:buttonClickScript(),end,// if none, soft kbd closes; hard kbd closes NC_CloseFrontView: func(view)	// 2.1	just book or overview or page num, not NC also!//:close(),	// soft: closes book (only if NC shown/hidden), overview closes book, but kbd closes (if NC hidden) //GetView('viewFrontKey):close(),//GetView('viewFrontMost):close(),	// soft: overview closes NC if hiddenGetRoot().(kBookReaderSymbol):close(),});// ----------// InboxDefineGlobalConstant('kInboxGetTitle, func(target)	// for GetTitle slot of kInboxRouteItembegin	local newtscape := GetRoot().(kNewtsCapeSymbol);	if call kURLmatch with (call kNotesGetHighlightedText with (target))	// !!!j	then call kGetLabel with (newtscape, kGetURLlabel, kGetURLlabelE)	else if newtscape:matchHTMLtitle(target, nil, true, kTitleStart, kTitleStop, nil)	then call kGetLabel with (newtscape, kOpenLabel, kOpenLabelE)end);DefineGlobalConstant('kInboxRouteScript, func(target,targetView)// for RouteScript slot of routeframebegin	local obj := call kNotesGetHighlightedText with (target), newtscape := GetRoot().(kNewtsCapeSymbol);	if StrFilled(obj)	then newtscape:NewtsCapeDoIt(obj)	// !!!j	// what does this do that's different from NewtsCapeDoIt ???	else if isArray(obj := newtscape:matchHTMLtitle(target, true, nil, nil, nil, true))	then begin		obj[3] := {loadImages: nil};		Perform(newtscape, 'dispatchFile, obj); // other media types?		end	else newtscape:dispatchFile(kHTMLMediaType, "", obj, {loadImages: nil});end);DefineGlobalConstant('kInboxRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kInboxGetTitle,icon:				kNotesRouteItem.icon,	// share "Newt's Cape tiny"tag:				kNewtsCapeSymbol,routeScript:		kInboxRouteScript,});DefineGlobalConstant('kInboxProtoItem, { // for Inbox _proto chainNCitems:			[kInboxRouteItem],	// !!!jGetRouteScripts:	kNotesProtoItem.GetRouteScripts,	// !!!j. share});// ----------DefineGlobalConstant('kDayMin, 24*60);// code borrowed/modified from NewtPack (Serg)DefineGlobalConstant('kRegExpDays, 45);						// number of days to expireDefineGlobalConstant('kRegExpMin, kRegExpDays * kDayMin);	// number of mins to expireDefineGlobalConstant('kRegNagDays, 15);						// number of days to nagDefineGlobalConstant('kRegNagMin, kRegNagDays * kDayMin);	// number of mins to nagDefineGlobalConstant('kRegExpSym, Intern($X & kNewtsCapeSymbol)); // this is the app-specific ID for this "lock" DefineGlobalConstant('kRegExpired, func(nag)if kExpiringVersionthen begin	// true - demo has expired	// nil - full demo or non-demo build	local entry := GetAppPrefs(kRegExpSym, {});	if not entry.version or			// first time		entry.version < kVerBeta	// newer beta/version	then begin	// add/update		entry.version := kVerBeta;		EntryChangeXmit(entry,nil);	// init/update		NIL;	// ok to continue		end	else begin		local INT now := Time(), start := EntryModTime(entry);		now < start or now >= start + kRegExpMin - nag;		end;	end);//if kExpiringVersion then SetPartFrameSlot('DoNotInstall, kRegExpired);	// diff fn w/o arg?DefineGlobalConstant('kNamesGetValue, func(target)	// !!!nif targetthen begin	local str, fields;	if  IsArray(fields := GetRoot().(kNamesSym):?BcCustomFields(target, nil))			and (fields := LFetch(fields,kURL,0,'|str=|,'label))		and IsString(str := fields.value)	then str	else if IsArray(fields := target.notes) and Length(fields) > 0			and IsString(str := fields[0].text)	then str;	end);if kNIE thenDefineGlobalConstant('kNamesGetTitle, func(target)// for GetTitle slot of routeframeif targetthen begin	local str := call kNamesGetValue with (target), newtscape := GetRoot().(kNewtsCapeSymbol);	if call kURLmatch with (str)	then call kGetLabel with (newtscape, kGetURLlabel, kGetURLlabelE)	else if newtscape:matchHTMLtitle(str, nil, true, kTitleStart, kTitleStop, nil)	then call kGetLabel with (newtscape, kOpenLabel, kOpenLabelE);	end);if kNIE thenDefineGlobalConstant('kNamesRouteScript, func(target,targetView)	GetRoot().(kNewtsCapeSymbol):NewtsCapeDoIt(call kNamesGetValue with (target))	// !!!n);// ----------DefineGlobalConstant ('kAddPatchFunc, func(target, template)if targetthen begin	// init the patch	target:close();	// !!!j	local patch := EnsureInternal({}), sym, val;	// copy all of the patched slots (including tag)	foreach sym, val in template	do patch.(EnsureInternal(sym)) := val;	patch.(EnsureInternal('tag)) := EnsureInternal(kNewtsCapeSymbol);	// link into the target's proto chain	patch.(EnsureInternal('_proto)) := target._proto;	target._proto := patch; // returns patch	end);DefineGlobalConstant('kRemovePatchFunc, func(target)if targetthen begin	target:close();	// !!!j	local nextProto;	while nextProto := target._proto	do  if nextProto.tag = kNewtsCapeSymbol		then break target._proto := nextProto._proto		else target := nextProto;	end);//----------// INSTALL/REMOVE scripts// abort if no Copperfield?InstallScript := func(partFrame)begin	call kInitGlobal with (nil, nil);	local newtscape := partFrame.theForm, root := GetRoot(), notes := root.(kNotesSym), rf;	if kNIE	then begin		if notes		then call kAddPatchFunc with (notes, kNotesProtoItem);		call kAddPatchFunc with (root.(kInboxSym), kInboxProtoItem);		newtscape:?addLocale();		RegUnionSoup(kNewtsCapeSymbol, kCacheHTMLSoupDef);		// here rather than :init		RegUnionSoup(kNewtsCapeSymbol, kCacheImagesSoupDef);		if kSubmitQ then RegUnionSoup(kNewtsCapeSymbol, kCacheSubmitSoupDef);		// !!!g		//addIndexXmit for additional indexes??		RegUnionSoup(kNewtsCapeSymbol, kBookmarkSoupDef);		RegUnionSoup(kNewtsCapeSymbol, kTempHTMLSoupDef);		//RegAppClasses(kNewtsCapeSymbol, ['routeBinary]);		AddDeferredCall(func()	// defer in case Newtworks installed later, e.g., on MP2K			GetRoot().(kNewtWorksSym):?RegNewtWorksTool(EnsureInternal(kNewtsCapeSymbol), kToolFrame), nil); // eMate only?		//RegisterViewDef(newtscape.speakFormat, kNCDataDefSym);		call kAddPatchFunc with (root.(kBookReaderSymbol), kCopperfieldProtoItem);	// !!!e		if kBuild20	// !!!r. not ~X		then begin		// !!!g. Names routing			rf := EnsureInternal({				GetTitle:	nil,				routeScript:nil,				icon:		nil,				//tag:		kNewtsCapeSymbol,				});			rf.GetTitle		:= kNamesGetTitle;			rf.routeScript	:= kNamesRouteScript;			rf.icon			:= kNotesRouteItem.icon;			call kRegNamesRouteScriptFunc with (kNewtsCapeSymbol, rf);			end;		end	else begin	// 1.x		local routingFrame := GetGlobals().Routing;		routingFrame.(EnsureInternal(kNewtsCapeSymbol)) := newtscape.NIEPrefsLayout.routeScripts; // !!!n		if notes		then begin				rf := EnsureInternal(				{GetTitle: nil, icon: nil, tag: kNewtsCapeSymbol, routeScript: kNewtsCapeRouteScriptSym});			local rs; // := notes.routeScripts;			rf.GetTitle := newtscape.NotesGetTitle; //kNotesGetTitle; // add method (so not cloned)			if isFrame(rs := routingFrame.(kNotesSym)) // 1.x			then begin				notes.(rf.routeScript) := newtscape.NotesRouteScript; // kNotesRouteScript; // add method to Notes				if isReadonly(rs)				then rs := routingFrame.(kNotesSym) := Clone(rs);				rs.(rf.tag) := rf;				end;			end;		end;/*		if kNIE		// already registered with URLcop	then AddDeferredCall(func(appSymbol, types, suitability, handlersFrame)			root.(kURLcopSymbol):?RegURLHandler(appSymbol, types, suitability, handlersFrame),  			[kNewtsCapeSymbol, '[http], 38, {FetchURL: true, GetURL: true}   			]); //Assist: need a lexical dictionary to support URL parsing/matching	partFrame.taskTemplateID :=		RegTaskTemplate(newtscape.taskTemplate); // stash ref globally		local hsoup := GetUnionSoup("Hyperlink Manager"), entry; // HyperNewt		if hsoup and (not (entry := hsoup:query({indexPath: 'appSymbol, beginKey: kNewtsCapeSymbol}):entry())			or entry.appSymbol <> kNewtsCapeSymbol)		then hsoup:AddToStoreFlushedXmit({			appSymbol: kNewtsCapeSymbol,			SaveHyperLink: kNewtsCapeSaveHyperLinkFunc,			ShowHyperLInk: kNewtsCapeShowHyperLinkFunc,			}, GetStores()[0], nil);		RegisterViewDef(newtscape.frameFormat, kDataSymbol);		if StrFilled(root.(kNewtsCapeSymbol):getPrefsEntry().autoOpen)		then AddDeferredSend(root.(kNewtsCapeSymbol), 'open, nil)		else root.(kNewtsCapeSymbol).prefsEntry := NIL;*///if kDebugOn then AddDeferredCall(func() GetRoot().(kNewtsCapeSymbol):?Open(), nil);end;RemoveScript := func(partFrame)begin	local root := GetRoot(), notes := root.(kNotesSym);	if kNIE	then begin		if notes		then call kRemovePatchFunc with (notes);			/* begin			if i := LSearch(rs, kNewtsCapeSymbol, 0, '|=|, 'tag)			then ArrayRemoveCount(rs,i,1);			end */		call kRemovePatchFunc with (root.(kInboxSym));		// restore old locale		//SetLocale(partFrame.oldLocaleTitle);		call kRemoveLocaleFunc with (kHTTPlocaleName);		// RemoveLocale def in 2.1, but undef in 2.0		UnRegUnionSoup(kCacheHTMLSoupName,	kNewtsCapeSymbol);	// here rather than :quit		UnRegUnionSoup(kCacheImagesSoupName, kNewtsCapeSymbol);		if kSubmitQ then UnRegUnionSoup(kCacheSubmitSoupName, kNewtsCapeSymbol);	// !!!g		UnRegUnionSoup(kBookmarkSoupName, kNewtsCapeSymbol);		UnRegUnionSoup(kHTMLSoupName, kNewtsCapeSymbol);		//UnregAppClasses(kNewtsCapeSymbol);		root.(kNewtWorksSym):?UnRegNewtWorksTool(kNewtsCapeSymbol); // eMate only?		//UnRegisterViewDef(kFrameSymbol, kDataSymbol);		//UnRegisterViewDef(kNCViewDefSym, kNCDataDefSym);		call kRemovePatchFunc with (root.(kBookReaderSymbol)); // !!!e		// Names routing		if kBuild20	// !!!r		then call kUnRegNamesRouteScriptFunc with (kNewtsCapeSymbol);	// !!!g		end	else begin // 1.x		local rs, routingFrame := GetGlobals().Routing; // := notes.routeScripts;		RemoveSlot(routingFrame, kNewtsCapeSymbol);	// !!!n		if notes and isFrame(rs := routingFrame.(kNotesSym)) 		then begin			RemoveSlot(rs, kNewtsCapeSymbol);			RemoveSlot(notes, kNewtsCapeRouteScriptSym);			end;		end;/* if partFrame.taskTemplateID	then begin		UnRegTaskTemplate(partFrame.taskTemplateID);		partFrame.taskTemplateID := NIL;		end;*/end;// End of text file Final Project Data// Beginning of file parse.tbaseView :=    {viewBounds: {left: -4, top: 190, right: 184, bottom: 282},     viewFormat: 83953137,     viewFlags: 16453,     lines:       [       "<INPUT TYPE=IMAGE SRC=\"hello\" ALIGN=\"greg\">",       "<INPUT TYPE=HIDDEN name=context value=\"12312378123782\">",       "<INPUT TYPE=PASSWORD name=passwd>",       ],     viewShowScript:       func()       begin       	:StartParser();       end,     StartParser:       func()       begin              	SetValue( statusDisplay, 'text, "Translating..." );              	// **** main entry point of the program ****              	// data would be coming in from the serial port       	// and entering at this point.       	       	local parseJob := parsingFrame:New();                     	foreach line in lines do begin       		parseJob:ProcessLine( clone(line) );       	end;       	       	parseJob:WrapUp();       	parseJob := nil;       	       	SetValue( statusDisplay, 'text, "Complete." );       	self:close();       	       end,     parsingFrame:       constant kCompact	:= '[COMPACT];			// share in unaryAttributes       constant kNoWrap	:= '[NOWRAP];       constant kNoWrapSave:= '[NOWRAP, NOSAVE];	// for TD,TH       constant kNoResize	:= '[NORESIZE];			// for FRAME,IFRAME              {       // _value attribute instead of separate val/on_off arg. :addHTMLitem(tag, res)              // ===========================================================================       //	parsingFrame.cp													©1995-1997       // ===========================================================================       //	The functions enclosed in this frame form a complete HTML parser. This       //	parser works on a line-by-line basis, because that's the most memory-       //	friendly way of doing it.                     // ===========================================================================       //		¥ New ()       // ===========================================================================       //	Creates a new instance of the parsing frame. This function must be called       //	when the starting begins, always. It sets up the state variables needed       //	by the parsing logic *between* lines of HTML.  Most of these variables wouldn't be       //	necessary if the parser could receive the whole file at once (like desktop       //	browsers do)              New: func()       	{ _proto: self,	// for proto inheritance       		         	// dynamic variables need to be added in the instance of this object              	textItems: [], 			// access directly everywhere (since we were cheating several places anyway...)       	HTMLtag: kTagP,			// H1, LI, DD, etc. default is P for normal text       	textStyle: kATagP,		// current text styles I, TT, B, U, P (for normal)       	spaceAfterCur: nil,		// after an HREF, add a space.       	spaceBeforeCur: nil,	// before an HREF add a space.       	spaceBeforePrev: nil,       	spaceAfterPrev: nil,       	lineBreak: nil,			// spacings could exist across a line.       	textBlock: nil,   		// a running string which crosses lines.       	attribList: nil,		// for attriblists which span lines.       	commentOn: nil,			// boolean, are we in a comment?       	commentOff: nil,		// pattern to end a comment/XMP/LISTING       	quoteOn: nil,			// we're inside a quote block       	//oldTextStyle: nil, 	// used to remember text styles after HREFS are used       	gLine : nil,       	gBlocks: [],	       	gFText: nil,			// pre-formatted text (only used for XMP/!--)       	htmlApp: nil,			// the render application       	paraTag: 'P,			// save para HTMLtag (e.g., PRE)       	results: nil,       	},       	              // ===========================================================================       //		¥ AddHTMLitem ( type, results )       // ===========================================================================       //	This is the entry point to the Newt's Cape parser/renderer API. As the       //	parser munges the HTML file, it repeatedly calls addHTMLitem with data to       //	render. This way, the parser filters out anything that it doesn't think       //	the renderer understands.       //              /* just inline this              addHTMLitem:              	func( tag, results )              	htmlApp:addHTMLitem( tag, results ),       */              /* to test parser for debugging (w/o book creation),                     GetRoot().|Newtscape:Newtscape|:addFile(       	"text/html",       	nil,       	"source...",       	{htmlApp: {       		addHTMLitem: func(tag,results)       		begin       			Print("-------------------------------------------");       			Write( ":AddHTMLitem( " );              		Write( tag ); Write(", ");              		Write( results ); Write(");\n");              		end,              	}});       */                     // ===========================================================================       //		     --------- P A R S I N G   F U N C T I O N S ---------       // ===========================================================================       /*	              The parsing Frame is setup as a giant switch statement. Since NewtonScript       doesn't support switch, the parser was setup this way. Because many of the       HTML tags can be parsed the same way (as the parser sees it, they are not        rendered the same way) some parsing "macros" were setup. This allows us       to maintain less code in the parsing Frame. These macros include:              methAA:		tags (possibly with attributes), no value       methH:		       methHA:		       methAH:		       methT:		       */              unaryAttributes: { // for assembleAttributeList       AREA:		'[NOHREF],       DL:			kCompact,       HR:			'[NOSHADE],       IMG:		'[ISMAP],       INPUT:		'[CHECKED],       MENU:		kCompact,       OL:			kCompact,       OPTION:		'[SELECTED],       SELECT:		'[MULTIPLE],       TABLE: 		'[BORDER, NOSAVE],       TD:			kNoWrapSave,       TH:			kNoWrapSave,       TR:			'[NOSAVE],       UL:			kCompact,       ADDRESS:	kNoWrap,       BLOCKQUOTE:	kNoWrap,       //BQ:		kNoWrap,       |DIV|:		kNoWrap,       FRAME:		kNoResize,       IFRAME:		kNoResize,	// !!!g       },                     lineTags: '[PRE, TEXTAREA, XMP],		// these preserve (re-add?) line endings              // ===========================================================================       //		¥ methAA ( )       // ===========================================================================       // 	This parsing macro simply assembles the HTML attributes, and defaults to       //	passing just the HTML tag itself (and attributes)              /* !!!y. see processPhrase       methAA:		func() htmlApp:addHTMLitem(gBlocks, results),              HTML: 		'methAA,              |!DOCTYPE|:	'methAA,              BODY:		'methAA,       HEAD:		'methAA,              META:		'methAA,       BASE:		'methAA,       LINK:		'methAA,       ISINDEX:	'methAA,	// !!!b       BASEFONT:	'methAA,	// !!!e       STYLE:		'methAA,	// !!!a1       FORM: 		'methAA,       TR:			'methAA,              APPLET:		'methAA,       OBJECT:		'methAA,	// !!!a1       PARAM:		'methAA,       MAP:		'methAA,       AREA:		'methAA,       TABLE:		'methAA,              CENTER:		'methAA,       |DIV|:		'methAA,	// !!!e. 'methHAP,       NOFRAMES:	'methAA,	// !!!e       NOFRAME:	'methAA,	// !!!e       FRAMESET:	'methAA,	// !!!e       SCRIPT: 	'methAA,	// !!!g       NOSCRIPT:	'methAA,	// !!!g       IFRAME:		'methAA,	// !!!g              NOBR:		'methAA,       FRAME:		'methAA,       */              // ===========================================================================       //		¥ methHA ( )       // ===========================================================================       // 	This parsing macro simply assembles the HTML attributes, and defaults to       //	passing just a <P> to the parser. (kTagP)              methHA: 	func()       			if gBlocks._value       			then begin       				HTMLtag := gBlocks;       				textStyle := kATagP;       				end       			else HTMLtag := {_tag: paraTag},              methHAP:	func()       			if gBlocks._value       			then begin       				HTMLtag := gBlocks;       				paraTag := HTMLtag._tag;       				textStyle := kATagP;       				end       			else HTMLtag := {_tag: paraTag := 'P},              TITLE: 		'methHA,       H1: 		'methHA,       H2: 		'methHA,       H3: 		'methHA,       H4: 		'methHA,       H5: 		'methHA,       H6: 		'methHA,       CAPTION:	'methHA,              ADDRESS:	'methHAP,       P:  		'methHAP,       PRE:  		'methHAP,       BLOCKQUOTE:	'methHAP,       //NOTE:		'methHA,       //BQ:		'methHAP,              OPTION: 	'methHA,              //XMP:		'methHA,	// handled in processLine       //LISTING:	'methHA,              TEXTAREA: 	'methHA,                     // ===========================================================================       //		¥ methH ( )       // ===========================================================================       //	This macro doesn't attempt to parse any attributes, just sends the HTML       //	tag.  <LI ALIGN=RIGHT> ->  [ 'LI ]              /*       methH:  	func() // LI, DT, DD       			if gBlocks._value       			then begin       				HTMLtag := gBlocks;       				textStyle := kATagP;       				end       			else begin       				htmlApp:addHTMLitem(gBlocks, results);       				HTMLTag := {_tag: paraTag};       				end,       */              LI: 		'methHA,       LH: 		'methHA,	// !!!e       DT:			'methHA,       DD:			'methHA,                     // ===========================================================================       //		¥ methAH ( )       // ===========================================================================              methAH:  	func() // HR, UL, MENU, OL, DL, DIR, TH, TD       			begin       				htmlApp:addHTMLitem(gBlocks, results);       				if gBlocks._value       				then textStyle := kATagP       				else HTMLTag := {_tag: paraTag};       			end,              HR:			'methAH,              UL:			'methAH,       MENU: 		'methAH,       OL:  		'methAH,       DL: 		'methAH,       DIR:		'methAH,              TH:			'methAH,       TD:			'methAH,                                   // ===========================================================================       //		¥ methT ( )       // ===========================================================================       //	This parsing macro toggles text styles. Here we only need to indicate whether       //	the style is going on or off (based on the single function argument)                     methT:  	func() // I,B,U,TT,CITE,BIG,SMALL,SUB,SUP,S,DFN,VAR,CODE,EM,SAMP,STRONG,KBD       /*				textStyle := if on_off       					then gBlocks       					else kTagP,       */       			if gBlocks._value       			then begin	// add to style list       				if textStyle = kATagP       				then textStyle := [gBlocks]       				else AddArraySlot(textStyle := Clone(textStyle), gBlocks);       				end       			else begin // remove from style list       				local sym := gBlocks._tag, pos;       				if Length(textStyle)=1 and textStyle[0]._tag = sym       				then textStyle := kATagP       				else if pos := :findStyle(textStyle, sym, true)       				then ArrayRemoveCount(textStyle := Clone(textStyle), pos, 1)       				else if kDebugOn then Print("not off?" && sym);       				end,              findStyle:	func (ARRAY style, sym, ix)	// return entry or index       	if Length(style)=1	// most common case?       	then if sym = style[0]._tag       		then if ix       			then 0       			else style[0]       		else nil       	else if kNIE       	then if ix       		then LSearch (style, sym, 0, '|=|, '_tag)       		else LFetch  (style, sym, 0, '|=|, '_tag)       	else call kLFetch with (style, sym, 0, Functions.|=|, '_tag, ix),                     I:			'methT,       B: 			'methT,       U: 			'methT,       TT:			'methT,       CITE: 		'methT,       BIG:		'methT,       SMALL:		'methT,       SUB:		'methT,       SUP:		'methT,       S:			'methT,       STRIKE:		'methT,       DFN: 		'methT,       VAR: 		'methT,       CODE: 		'methT,       EM: 		'methT,       SAMP: 		'methT,       STRONG: 	'methT,       KBD: 		'methT,       A:			'methT,       FONT: 		'methT,       SPAN:		'methT,	// !!!a1              ABBR:		'methT,	// !!!b1       ACRONYM:	'methT,	// !!!b1              //AUTHOR:	'methT,       //DEL:		'methT,       //CREDIT:	'methT,       //LANG:		'methT,       //AU:		'methT,       //PERSON:	'methT,       //INS:		'methT,       //Q:		'methT,                     // ===========================================================================       //	Below are HTML tags that could not be easily mapped to one of the macros       //	defined above.       // ===========================================================================                     methTO:	func()	// for BR, IMG, INPUT       		if gBlocks._value       		then begin       			AddArraySlot(textItems, textStyle);       			AddArraySlot(textItems, gBlocks);       			end,              BR:		'methTO,       /*	if gBlocks._value       	then begin       		AddArraySlot(textItems, '[{_tag: BR}]);       		AddArraySlot(textItems, cr);       		end,       */       IMG: 	'methTO,       INPUT: 	'methTO,               SELECT: //'methAA,	// like IMG/INPUT, except end immed       		func()       		begin       			if gBlocks._value       			then begin       				AddArraySlot(textItems, textStyle);       				AddArraySlot(textItems, gBlocks);       				:CondFlush();       				end       			else begin       				:CondFlush();       				htmlApp:addHTMLitem(gBlocks, results);       				end;       		end,                     //	generates an attribute list for the renderer based on       //	the attribute list in an HTML tag. For example, <INPUT ALIGN=RIGHT CHECKED>       //	would become -> [ "ALIGN" "RIGHT" "CHECKED" 'TRUE ].  This function needs       //	to make sure that the array returned has an even number of items; this is       //	how the renderer expects to parse the attribute list.              processPhrase: func(phrase)       	//if IsArray( phrase ) then       	begin 	// it's some kind of attribute list.       //Print("paraTag:" && paraTag);       //Print("HTMLtag:" && HTMLtag);       		attribList := NIL; // reset here       		local tagSym := phrase[0]; // string. note: already tested earlier to be non-zero len??       		local on_off := tagSym[0] <> $/;       		if EndsWith(tagSym,"/")	// !!!w. well-formed?       		then StrMunger(tagSym,StrLen(tagSym)-1,1,nil,0,nil);              		tagSym := Intern(if on_off then tagSym else StrMunger(tagSym,0,1,nil,0,nil));       		gBlocks := {_tag: tagSym, _value: on_off};              		if not SetContains('[ // tagisBreaking (following symbols do NOT cause text to break; i.e., addHTMLitem to be called)       			A, BR, I, B, EM, TT, STRONG, CITE,       			IMG, INPUT, SAMP, CODE, VAR, KBD, DFN, SELECT,	// added IMG. SELECT              		FONT, U, S, SUB, SUP, BIG, SMALL,], tagSym)       		then :CondFlush();              		if on_off       		then begin       			local unary := unaryAttributes.(tagSym), sym, ph;       			local INT plen := Length(phrase), i;       			// for multiple unary attrib, kludge to add NIL for last (hopefully).       			// and handle first regularly?              			for i:=1 to plen-1	// skip tagSym       			do begin       				ph := phrase[i];       				if sym       				then begin	// value       					gBlocks.(sym) := :fixString(ph, sym='HREF); // string value       					sym := NIL;       					end       				else if not StrEqual(ph, "/")	// !!!w. well-formed?       				then begin // symbol name       					sym := Intern(ph);       					if unary and SetContains(unary, sym) // e.g., SELECTED, BORDER       						and not (sym = 'BORDER and i < plen-1 and StringToNumber(phrase[i+1]))       					then begin       						gBlocks.(sym) := TRUE;       						sym := NIL;       						end;       					end;       				end;              			if sym       			then gBlocks.(sym) := "";	// orphan attrib at end?       			end;              		//if kNIE then ProtoPerformIfDefined(self, tagSym, nil) else	// !!!y       		if HasVariable(self, tagSym)       		then Perform(self, tagSym, [])       		else htmlApp:addHTMLitem(gBlocks, results);	// !!!y. default behavior (send regardless)       		end,       	//else :AddContentItem( phrase ), call directly       	                     // ===========================================================================       //		¥ ProcessLine ()       // ===========================================================================       //	ProcessLine is where the caller gives the parsing Frame a line of HTML.       //	It must identify HTML tokens, parse attribute lists, and clean-up the       //	space in HTML files.  This becomes complicated when we have to parse       //	the file on a line-by-line basis (thus all the state in the parsing Frame).       //	One of the state variables includes 'text' which gets the text content       //	of the html file appended to it                     ProcessLine: func( line, ncresults )       	if StrFilled(line) or SetContains(lineTags, HTMLtag._tag)       	then begin       	/*	       	 * Identify HTML Tokens; other than that, concatenate       	 * (all other text together; even over multiple lines       	 * (remember, paragraph view will do the wrapping.)       	 *	       	 * Issue: depending on the size of the paragraph text,       	 * this could take a LOT of heap. We might want to be        	 * caching this in a soup. (but that's later. :-)       	 *       	 * A stack of HTML tags is kept and a paragraph string is       	 * kept. The paragraph string is appened with blocks of text       	 */              	results := ncresults;		// save this for :addHTMLitem              	// if we get a nil back, that means the 'end-of-comment'        	// mark is not in this line.       	//if commentOn then :FindEndCommentMark();              	// comments weren't working properly before       	// here -- just remove comments directly from string       	// this also preserves comments in gfText if in a Java SCRIPT       	// also treat XMP as comments              //***       	local cpos1, cpos1x, cpos2;              	// start a comment (or XMP)?       	while (       		commentOn or // comment on from earlier line?              		if cpos1 := StrPos(line, kCommentStart, 0) // if not already removed in cache       		then begin       			gfText := if HTMLtag._tag = 'SCRIPT then ""; // save if in a SCRIPT ???       			commentOff := kCommentStop;       			end              		else if cpos1 := StrPos(line, "<XMP>", 0) // LISTING also?       		then begin       			:CondFlush(); // if not at beginning of line earlier text will be wrong...       			HTMLtag := {_tag: 'XMP};       			gfText := "";       			commentOff := "</XMP>";       			end       		)       	do begin       /* 4 cases:       comment started on prev line, continues (cpos1=nil,cpos2=nil)       comment started on prev line, ends now  (cpos1=nil,cpos2=#)       comment starts  on this line, continues (cpos1=#;  cpos2=nil)       comment starts  on this line, ends now  (cpos1=#;  cpos2=#)       */       		cpos1x := if cpos1 then cpos1+StrLen(commentOff)-1 else 0; // end of start tag       		cpos2  := StrPos(line, commentOff, cpos1x); 	// start of end tag       		if gfText // save?       		then begin       			if cpos1       			then gfText :=       				if kNIE       				then call kBigSubStr with (line,cpos1x,if cpos2 then cpos2-cpos1x) // !!!b1       				else SubStr(line,cpos1x,if cpos2 then cpos2-cpos1x) // new       			else begin	// continuation       				StrMunger(gfText,StrLen(gfText),0, cr,0,nil);       				StrMunger(gfText,StrLen(gfText),0, line,0,cpos2);       				end;       			if cpos2       			then begin       				if isReadOnly(HTMLtag)       				then HTMLtag := Clone(HTMLtag);       				HTMLtag._value := gfText;       				htmlApp:addHTMLitem(HTMLtag, results);	// no :fixString needed       				HTMLtag := {_tag: paraTag};       				gfText := NIL;       				end;       			end;              		if cpos1 or (cpos2 and cpos1 := 0)       		then StrMunger(line,cpos1,if cpos2 then cpos2+StrLen(commentOff)-cpos1, nil,0,nil)  // remove comment       		else return NIL;  // entire line is comment              		if cpos2       		then commentOn := NIL // now, check if there are more       		else break commentOn := true // done, but maybe earlier non-comments       		end;       //***              	local txt;		// buffer for adding paragraph text       	//local ARRAY blocks := [];                    	//if kProfileOn then EnableProfiling( true );                  	// make the line of text global so some of the other       	// functions can work with it (e.g., get_text() )       	gLine := line;	       	lineBreak := true;	// a linebreak occured (duh)              	// quoted text that spans lines is tricky, thus the       	// state variable 'quoteOn'        	       	if (quoteOn or attribList)       		and :get_mark() 	// get the (assumed) next mark       		//and attribList -- unnec       	then :processPhrase(attribList);                   // ---------------------------------------------------       	// now, completely parse the line of text we have. The       	// scheme we follow is similar to NSCA's XMosaic. Just       	// repeatedly call get_text() and get_mark() until the       	// string is zero-length.       	       	while StrLen(gLine) > 0       	do begin       		// get next block of paragraph text        		if txt := :get_text()       		then :AddContentItem(txt); // :processPhrase(txt) //AddArraySlot( blocks, txt );	       		//else if commentOn then return;		// if we're in a comment, bail                     		if :get_mark() 	// get the (assumed) next mark       			//and attribList -- unnec       		then :processPhrase(attribList);       		end;               	// DONE WITH PHRASES IN THIS LINE                  // if a PRE/TEXTAREA is still active, and textItems           // is not empty, add a carriage return here.              	local INT tlen := Length(textItems);       	if tlen > 0 and SetContains(lineTags, HTMLTag._tag)	       	then if isInstance(txt := textItems[tlen-1], 'string)       		then StrMunger(txt,StrLen(txt),0, cr,0,nil)		// textItems[tlen-1] := txt & unicodeCR       		else begin       			AddArraySlot(textItems, textStyle);	// kATagP or textItems[tlen-2]? "textItem" might be IMG/INPUT       			AddArraySlot(textItems, '{_tag: BR});              			//AddArraySlot(textItems, '[{_tag: BR}]);       			//AddArraySlot(textItems, cr);       			end;       end,                            // ===========================================================================       //		¥ AddContentItem ( content )       // ===========================================================================       //	Adds a content item to the 'content stream.'  The content in this       //	case can be either text or a META type like IMG, etc. Does appropriate        //	spacing for text: If the string has a length of ZERO then it was just a        //	space, record it in case we have to do some adjusting later--UNLESS       //	the text is 'PRE, then we add it anyway.              AddContentItem: func (content)       begin       	local lineTag := SetContains(lineTags, HTMLTag._tag), strcontent, slen, tlen, txt;       //Print(content);       	if (strcontent := if kNIE then IsString(content) else isInstance(content, 'string))       	then begin       		if not lineTag       		then content := :CleanText(content);              //Print("AddContentItem"); Print(textStyle); Print(content);              		slen := StrLen(content);       		if slen=0 or (isWhiteSpace(content[0]) and isWhiteSpace(content[slen-1]) and       			StrLen(TrimString(Clone(content))) = 0)       		then begin       			spaceAfterPrev := spaceAfterCur := true;       			if not lineTag /* and       				(not (lineTag := :findStyle(textStyle, 'A, nil))	// allow empty <A NAME="x"></A>?       				or not lineTag.name) */       			then return;       			end;		       		content := :fixString(content,nil);	// moved earlier       		end;       		       	// WAIT! If this is PRE or TEXTAREA, just & the text + a carriage return       	if lineTag and strcontent and	// !!!b       		(tlen := Length(textItems)) >= 2 and textStyle = textItems[tlen-2]       		and isInstance(txt := textItems[tlen-1], 'string)	// !!!b       	then begin // concatenate lines together       		StrMunger(txt, StrLen(txt), 0, content,0,nil);       		if kNIE					// for big PRE       		then begin       			slen := StrLen(txt);       			if IsVBO(txt)       			then begin       				if (slen*2) >= nextFlush       				then begin       //Print("flush:" && slen);       					ClearVBOCache(txt);       					nextFlush := nextFlush + kVBOFlush;       					end;       				end       			else if slen > kMinVBOlen       			then begin       				textItems[tlen-1] := call kNewVBO with (nil, nil, txt); // temporary VBO       				self.nextFlush := kVBOFlush;       				end;       			end;       		return;       		end;              	AddArraySlot(textItems, textStyle);       	if lineTag or not strcontent       	then AddArraySlot(textItems, content)       	else :PushTextOnStack(content);       	lineBreak := nil;       	end,                            // ===========================================================================       //		¥ CleanText ( inText )       // ===========================================================================       //	CleanText Removes extra spaces from the line of text. This involves picking apart       //	the input string and reassembling it. Probably not a fast operation in NewtonScript.              CleanText: func  (inText)       /*if StrLen(inText)=0       then inText       else*/        begin       	local INT i := 0, slast := StrLen(inText)-1;       	local ch, spaceAdded := true;	// whether or not we need to add a space.                     					// if it starts out as 'true', we are guaranteed to never                     					// have a space at the start of a string (even if one is there)               	// is there a space before this text??       	spaceBeforeCur := isWhiteSpace(inText[0]); // = $\20;       	spaceAfterCur  := isWhiteSpace(inText[slast]);	// = $\20;	// this means there was a space at the end.               	// maybe be a little smarter about runs of spaces??       	// or just modify inText directly w/o clone??              	local INT del := 0;       	local btext := inText;	// defer clone       	for i:=0 to slast       	do if // ((ch := inText[i]) = $\20 and (spaceAdded or i=slast)) or ch = $\t       			(isWhiteSpace(ch := inText[i]) or ch = $\00) and (spaceAdded or i=slast) // ignore embedded null. e.g., "davenet"       		then begin       			if btext=inText then btext := Clone(inText); // clone 1st time       			StrMunger(btext,i-del,1, nil,0,nil);       			del := del+1;       			end       		else spaceAdded := IsWhiteSpace(ch); // ch = $\20;  // leave alone for tab?       	btext;       end,                            // ===========================================================================       //		¥ PushTextOnStack ( newText )       // ===========================================================================       //	push some text onto the stack. If a paragraph text block of the same       //	'type' (attrib) precedes this one, lump them together. This will make       // 	for a cleaner API, and prevent the ugly chopping.       //        // ASSUMPTION: the 'style' of ntext has already been pushed onto the stack (i.e., size-1).              PushTextOnStack: func (ntext)       begin       	local INT size := Length(textItems);       	local ptext;              	if size > 2 and isInstance(ptext := textItems[size-2], 'string)       	then begin       		local INT plen := StrLen(ptext);       		local needSp :=       			if (spaceAfterPrev or spaceBeforeCur or lineBreak) and       				(plen = 0 or ptext[plen-1] <> unicodeCR) //EndsWith(ptext, cr)       			then " ";       		local pstyle := textItems[size-3];       		if pstyle = textItems[size-1]	// eq curStyle (usually just kATagP)       		then begin       			SetLength(textItems, size-2);	// remove curStyle, prevText       			if needSp       			then StrMunger(ptext,plen,0, needSp,0,nil);       			ntext := StrMunger(ptext,StrLen(ptext),0, ntext,0,nil);	// plen might be incorrect       			//if needSp then ptext && ntext else ptext & ntext;       			end              		// we might still need to do some spacing adjustment...       		// but before we add a space let's be SURE there wasn't one already added !       		else if needSp       		then // Ah! but if this is an HREF, we want to do it the next time 'round.       			if :findStyle(pstyle, 'A, true)       			then StrMunger(ntext,0,0, 	 needSp,0,nil) 		// ntext := $  & ntext;       			else StrMunger(ptext,plen,0, needSp,0,nil); 	// textItems[ size-2 ] := ptext & $ ;       		end;              	AddArraySlot(textItems, ntext);              	// back up the previous space-variables       	spaceBeforePrev := spaceBeforeCur;       	spaceAfterPrev 	:= spaceAfterCur;       end,                     // ===========================================================================       //		¥ CondFlush ( )       // ===========================================================================       //  Flushes out all the content NOW. This function causes addHTMLitem to be called       //	immediately, rather than retroactively. The function is intelligent about       //	what types of content it (the parser) needs to keep around for future       //	reference: some of the tags (like 'SELECT) needs to collect content and       //	pass it all at once.               CondFlush: func()       begin	//write( HTMLTag ); print("**flushed**");       	// flush any text we still have here.              /*       	local HTMLTagsym := HTMLTag._tag;              	if SetContains('[TD, TH, TEXTAREA, OPTION], HTMLTag._tag) // moved below       		and Length(textItems)=0       		//and not SetContains('[OPTION,INPUT,SELECT,IMG], gBlocks._tag) // added IMG       	then textItems := [kATagP, Clone("")];       */              	if Length(textItems) > 0       		or (SetContains('[TD, TH, TEXTAREA, OPTION], HTMLTag._tag)  // allow empty?  added OPTION       			and textItems := [kATagP, Clone("")])       	then begin       		if isReadOnly(HTMLtag)       		then HTMLtag := Clone(HTMLtag);       		HTMLtag._value := textItems;       		htmlApp:addHTMLitem(HTMLTag, results);       		//if not SetContains('[PRE,ADDRESS,BLOCKQUOTE], HTMLTagsym) then       		HTMLTag := {_tag: paraTag};              		textItems := [];       		end;              	// reset the spacing variables       	spaceBeforeCur := spaceBeforePrev := spaceAfterCur := spaceAfterPrev := nil;       end,                            // ===========================================================================       //		¥ get_text ( )       // ===========================================================================       // 	Returns the next block of text. A block of text is delimited by the        //	beginning of an HTML tag, or end of the string buffer (gLine)              get_text:  func()       if StrLen(gLine) = 0       then NIL       else begin       	local gNext, retText;     // return buffer for text object.              	local i := if kNIE then CharPos(gLine, $<, 0) else StrPos(gLine, "<", 0);       	if not i       	then begin       		retText := gLine;       		gLine := "";              		// Call CleanText() to "format" the text string; i.e., only one space between words, no tabs, etc.       		//retText := :CleanText( retText );              		return retText;       		end;              	if IsAlphaNumeric(gNext := gLine[i+1]) or gNext = $/         			or gNext = $! //needed for !DOCTYPE, not needed for comment        	then return if i > 0       		then begin       			retText :=       				if kNIE       				then call kBigSubStr with (gLine, 0, i)	// !!!b1       				else SubStr(gLine, 0, i);       			StrMunger(gLine,0,i, nil,0,nil);       			//retText :=  :CleanText( retText );       			retText;	// ???       			end              		else begin	// !!!w       //Print("get_text"); Print(textStyle); Print(gLine);       			if (retText := :findStyle(textStyle, 'A, nil))       				and retText.name       			then Clone("&nbsp;");	// let fixString fix this later       			//else NIL       			end;              	if not retText // not set in loop       	then begin       		retText := gLine;       		gLine := "";       		end;              	if StrLen(retText) > 0 or SetContains(lineTags, HTMLTag._tag)       	then retText;	// :CleanText( retText );        	// else nil;       	end,                                    // ===========================================================================       //		¥ get_mark ( )       // ===========================================================================       // 	parse an attribute list. This attribute list can span multiple lines,       // 	and quoted text inside can span muliple lines as well.  If the first       // 	phrase is a comment, flip on the 'commentOn' flag, and we'll wade through       // 	all characters until we find  '-->' characters.       //       // 	If the attribute list doesn't end before the characters have ended, ProcessLIne       // 	will realize this when it receives a new line, and will just return to this       // 	routine as if nothing had happened. (same process for quote marks)              get_mark: func ()              if StrLen(gLine) = 0       then NIL // this should never happen...              else begin       	local INT i, start := if gLine[0] = $< then 1 else 0;       	local gChar, tokenStart, tokenLast, blockStart, blockLast;       	local gpos, gtpos, pos;       	       	// initialize the attribute list if it wasn't yet.       	if not attribList then attribList := [];              	for i := start to StrLen(gLine)-1       	do begin       		gChar := gLine[i];       		if quoteOn       		then begin       			// if more than a few chars, this is much faster       			qpos  := if kNIE then CharPos(gLine,quoteOn,i) else StrPos(gLine,quoteOn,i);	// !!!y       			gtpos := if kNIE then CharPos(gLine,$>,i) else StrPos(gLine,">",i);       			blockStart := i;       			if qpos or gtpos       			then begin       				pos := if qpos then if gtpos then min(qpos,gtpos) else qpos else gtpos;       				gChar := gLine[i := pos]; // for > test. skip ahead       				//blockLast := pos-1;       				//if not textBlock then textBlock := Clone("");       				AddArraySlot(attribList,       					if blockStart < pos       					then if textBlock       						then StrMunger(textBlock,StrLen(textBlock),0,       									gLine,blockStart,pos-blockStart)       						else SubStr(gLine,blockStart,pos-blockStart)       					else if textBlock       					then textBlock       					else Clone(""));       				quoteOn := textBlock := blockStart := nil;       				end       			else break; // none in this line       			end              // note: this doesn't handle href=/foo.cgi?enter=name>, e.g., www.merc.com              		else if //gChar = $\20 or gChar = $= or       				//gChar = $" or gChar = $> or gChar=$\t       				IsWhiteSpace(gChar) or gChar = $= or gChar = $> or       					if kNIE	// !!!y       					then (if gChar = $" or gChar = $' then quoteOn := gChar)       					else (if gChar = $" then quoteOn := "\"" else if gChar = $' then quoteOn := "'")       		then begin       			if tokenStart       			then begin       				AddArraySlot(attribList, // cool, a token!       					SubStr(gLine, tokenStart, tokenLast+1 - tokenStart));       				tokenStart := nil;       				end;       			//if gChar = $"	// !!!y set in test with ch/str, for ' also       			//then quoteOn := true       			end              		else if tokenStart  // add a char to "token"       		then tokenLast :=i       		else tokenStart := tokenLast := i;              		if gChar = $>       		then return StrMunger(gLine, 0, i+1, nil, 0, nil); // true, meaning this attribute list is complete       		end;              	if tokenStart       	then AddArraySlot(attribList, StrMunger(gLine,0,tokenStart, nil,0,nil))              	else if blockStart // save       	then textBlock := StrMunger(gLine,0,blockStart, textBlock,0,nil);       	       	gLine := "";              	return NIL;	// nil, meaning attribute list has not been terminated, but       				// there are no more characters in the line.       end,                            // ===========================================================================       //		¥ WrapUp ( )       // ===========================================================================       // 	Called by the owner of the parsingFrame to flush any more HTML content       //	that might be sitting around. (flushing causes addHTMLitem() to be called)       //	Content might be sittng around if an attribute list wasn't terminated       //	properly, for example.                // 	IMPORTANT: This function should be called ALWAYS at the       //	end of a parsing session, otherwise content could be lost.              WrapUp:       func()       if Length(textItems) > 0       then begin       	htmlApp:addHTMLitem({_tag: 'P, _value: textItems}, results);       	textItems := [];       	end,       },     version:       "HTML Parser, 1.1, Version 4 (11/25/95) 1:13 AM Greg Simon  [mods by SW]"     ,     _proto: @180 /* protoFloatNGo */    };statusDisplay :=    {text: "Translating...",     viewBounds: {left: 16, top: 24, right: 184, bottom: 40},     _proto: @218 /* protoStaticText */    };AddStepForm(baseView, statusDisplay);StepDeclare(baseView, statusDisplay, 'statusDisplay);// After Script for baseViewthisView := baseView;call func(fr)begin	local isMethod := func(m) isInstance(m,'CodeBlock) or isInstance(m,'_function);	local kProfilenum := func(fr,fname,sname,num)		begin		local s,v;		if sname		then sname := sname & $.		else Print(fname && "[map for Profile]");		foreach s,v in fr		do if call isMethod with (v)			then Print(fname & $. & (num := num+1) && $[ & sname&s & $])			else if isFrame(v) // stackFunction?			then num := call kProfilenum with (v,fname,sname&s,num);		num;		end;	if kProfileOn	then call kProfilenum with (fr,"parsingFrame",nil, kProfileFnOffset);	local s, v, meth, remove := [];	foreach s,v in fr	do if isInstance(v,'symbol)		then if call isMethod with (meth := GetSlot(fr,v))			then begin				fr.(s) := meth; // substitute methods				SetAdd(remove,v,true); // slot not needed when done				end			else Print ("undefined method" && v);	foreach s in remove	do RemoveSlot(fr,s);end with (thisView.parsingFrame)constant |layout_parse.t| := baseView;// End of file parse.t// Beginning of file protoPrefDrawer_v173_0 :=    {viewBounds: {left: 2, top: -152, right: 238, bottom: -2},     declareSelf: 'base,     ReorientToScreen: ROM_DefRotateFunc,     height: kAppHeight+16,     viewSetupFormScript:       func()       begin       	local INT aHt := GetAppParams().appAreaHeight;       	self.viewBounds :=       		SetBounds(2, aHt-height, kAppWidth-2, aHt);       	inherited:?viewSetupFormScript();       end,     viewFlags: 64,     _proto: @173 /* protoDrawer */    };_v173_0_v166_0 := {_proto: @166 /* protoCloseBox */};AddStepForm(_v173_0, _v173_0_v166_0);// After Script for _v173_0thisView := _v173_0;begin	thisView.viewChildren := [protoCloseBox]; //thisView.stepChildren;	RemoveSlot(thisView, 'stepChildren);	RemoveSlot(thisView, 'viewBounds);endconstant |layout_protoPrefDrawer| := _v173_0;// End of file protoPrefDrawer// Beginning of file AboutLayout_v180_0 :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewJustify: 240,     process:       func()       begin       	base:close();       	newtscape:dispatchFile(kHTMLMediaType,       		LocObj("About", 'aboutItem) & $: & kAppNameL, kAboutText, nil);       end,     _proto: @180 /* protoFloatNGo */    };_v180_0_v81_0 :=    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     viewFlags: 1,     viewFont: userFont9,     viewFormat: 256,     viewLineSpacing: 10,     text: "",     viewJustify: 240,     viewSetupFormScript:       func()       begin       	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym //kFixCheckFormScript       	then viewFont := newtscape.dataFontsJ;              	if kNIE       	then AddDelayedSend(self,'process,nil,2000)       	else AddDelayedAction(Functions.Perform, [self,'process,[]], 2000);       	//inherited:?viewSetupFormScript();	// !!!b       end,     viewClass: 81 /* clParagraphView */    };AddStepForm(_v180_0, _v180_0_v81_0);// After Script for _v180_0_v81_0thisView := _v180_0_v81_0;begin	thisView.text := kAboutText;	thisView.viewBounds.left := thisView.viewBounds.top := 2;	if language='Chinese	then thisView.viewFont := kEspy9;	// if not kNCfont then RemoveSlot(thisView, 'viewSetupFormScript);endprocessButton :=    {     buttonClickScript:       func()       begin       	base:close();       	newtscape:dispatchFile(kHTMLMediaType,       		LocObj("About", 'aboutItem) & $: & kAppNameL, kAboutText, nil);       end,     text: "Process",     viewBounds: {left: -70, top: -12, right: -20, bottom: -3},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(_v180_0, processButton);// After Script for processButtonthisView := processButton;begin	thisView.text := LocObj("Process", 'processItem); // LocObj("Book", 'bookLabel);	thisView.viewBounds.top := -13;	thisView.viewBounds.bottom := -4;	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;end// After Script for _v180_0thisView := _v180_0;begin	thisView._proto := GetLayout("protoPrefDrawer");	RemoveSlot(thisView, 'viewJustify); // Left,Top	RemoveSlot(thisView, 'viewBounds);	// computed		ArrayRemoveCount(thisView.stepChildren,1,1);	// remove Process buttonendconstant |layout_AboutLayout| := _v180_0;// End of file AboutLayout// Beginning of file ProtoPrefLabelInputLine_v189_0 :=    {entryFlags: 10753,     textSetup:       func()       begin       	local v := curDict.(curTag).(curSlot);       	if v=true       	then "'true"       	else if v=nil       	then "'nil"       	else if (if kNIE then IsSymbol(v) else isInstance(v,'symbol))       	then $' & v       	else SPrintObject(v);       end,     curSlot: nil,     viewSetupFormScript:       func()       begin       	if labelCommands       	then curLabelCommand :=       		if kNIE       		then  LSearch(labelCommands, :textSetup(), 0, '|str=|, nil)       		else ArrayPos(labelCommands, :textSetup(), 0, Functions.StrEqual);              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       	then begin       		labelFont 			:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.entryFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10; // ~C              	inherited:?viewSetupFormScript();       end,     textChanged:       func()       if kNIE       then AddProcrastinatedSend(       	Intern(curSlot & $: & kAppSymbol),       	self, 'setPref, [curSlot, :getVal()],       	kPrefUpdateDelay)       else :setPref(curSlot, :getVal()),     labelActionScript:       func(cmd)       begin       	curLabelCommand := cmd;       	NIL;       end,     viewLineSpacing: 18,     compileVal: true,     numOnly: nil,     getVal:       func()       begin       	local txt := entryLine.text, val;       	if not compileVal or StrFilled(txt)       	then begin       		val := if compileVal       		then kCompileVal:compileVal(txt)	// ok since user controlled       		else txt;       		end;       	if not numOnly or (if kNIE then IsInteger(val) else isInstance(val,'int))       	then val       	else 0       end,     alwaysCallPickActionScript: true,     labelClick:       func(unit)	// !!!j       begin       	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerSetup(almost)       	then AddDeferredCall(kFixPicker, [newtscape.menuFontJ, nil]);       	NIL;	// click not handled. do popup       end,     _proto: @189 /* protoLabelInputLine */    };// After Script for _v189_0thisView := _v189_0;begin	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);	if not kNCfont	then RemoveSlot(thisView, 'labelClick);	// !!!j	// else not quite kFixPickerSetupendconstant |layout_ProtoPrefLabelInputLine| := _v189_0;// End of file ProtoPrefLabelInputLine// Beginning of file protoMyStatusTextprotoMyStatusText :=    {text: "",     viewSetupFormScript:       func()       begin       	newtscape.(childSym) := self;       	if not label exists       	then self.label := text; // save       	inherited:?viewSetupFormScript();       end,     newStatus:       func(txt)       SetValue(self,'text,       	if txt       	then if (if kNIE then IsString(txt) and CharPos(txt, $:, 0)       			else isInstance(txt,'string) and StrPos(txt,":",0)) // for Chars:...       		then txt       		else label&&txt       	else label),     _proto: @218 /* protoStaticText */    };constant |layout_protoMyStatusText| := protoMyStatusText;// End of file protoMyStatusText// Beginning of file TagPrefsLayoutTagPrefsLayout :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewJustify: 240,     curTag: 'H1,     setPref:       func(slot,val)       begin       	if not GetSlot(curDict,curTag)       	then begin       		curDict.(curTag) := {_proto: curDictOrig.(curTag)};       		prefsEntry.(curTag) := {};       		end;              	local path := [pathExpr: curTag, slot];       	newtscape:setPreference(path, curDict.(path) := val);       	if not call kViewIsOpenFunc with (self)	// e.g., close before Procrastinated call executes       	then return;              	//tagPicker:setMark(curPos);       	defaultsButton:open();	// show              	if slot='font       	then SetValue(sampleText, 'viewFont, val)              	else if slot='align       	then begin       		SetValue(sampleText, 'viewJustify,       			BOR(val, BAND(0x3FFFFFFC, sampleText.viewJustify)));       		sampleText:close(); sampleText:open();       		end;       end,     viewSetupDoneScript:       func()       //if kNIE       //then AddDeferredSend(defaultsButton, if HasSlot(curDict,curTag) then 'show else 'hide, nil)       //else AddDeferredAction(Functions.Perform, [defaultsButton, if HasSlot(curDict,curTag) then 'show else 'hide, []])       if HasSlot(curDict,curTag)       then defaultsButton:open()	// show       else defaultsButton:hide(),     curDict: nil,     curDictOrig: nil,     viewSetupFormScript:       func()       begin       	if HasSlot(curDictOrig := tagDictOrig, curTag)       	then curDict := tagDict       	else if HasSlot(curDictOrig := inputDictOrig, curTag)       	then curDict := inputDict;              	self.allFonts := call kCollectFontNames with (); // !!!j. share w/ familyPicker,systemFamilyPicker              	inherited:?viewSetupFormScript();       end,     curPos: nil,     _proto: @180 /* protoFloatNGo */    };tagPicker :=    {viewBounds: {left: 0, top: 3, right: 138, bottom: 17},     text: "Tag",     labelActionScript:       func(cmd)       begin       	local item := labelCommands[cmd];       	curTag := Intern(       			if (if kNIE then IsString(item) else isInstance(item,'string))       			then item       			else item.item);       	if HasSlot(curDictOrig := tagDictOrig, curTag)       	then curDict := tagDict       	else if HasSlot(curDictOrig := inputDictOrig, curTag)       	then curDict := inputDict;              	defaultsButton:open();	// show       	:parent():redoChildren();       	if not HasSlot(curDict,curTag)       	then defaultsButton:hide();       end,     textSetup: func() Upcase(SPrintObject(curTag)),     viewSetupFormScript:       func()       begin       	self.labelCommands := Clone(kPrefTags);              	if kNCfont and	// necessary since no foreign chars????	kFixPickerFormScript       		newtscape.prefsEntry.systemFontFamily <> kSystemFontSym       	then begin       		viewFont 			:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10; // ~C              	inherited:?viewSetupFormScript();       end,     alwaysCallPickActionScript: true,     pickerSetup:       func()       begin       	// !!!j. not needed (no foreign chars in tag names)       	//if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	//then AddDeferredCall(kFixPicker, [newtscape.menuFontJ, nil]);              	local i, obj, sym;       	foreach i,obj in kPrefTags       	do  if obj <> 'pickSeparator       		then labelCommands[i] :=       			if HasSlot(tagDict, sym := Intern(obj)) or HasSlot(inputDict, sym)       			then {item: obj, mark: kBullet}       			else obj;       	TRUE;       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(TagPrefsLayout, tagPicker);// After Script for tagPickerthisView := tagPicker;begin	thisView.text := LocObj("Tag", 'tagLabel);	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endmissingInput :=    {curSlot: 'missing,     labelCommands: [kMissing, ""],     viewSetupFormScript:       func()       begin       	viewFlags := if curDict.(curTag).(curSlot) then vClickable+vVisible else 0;       	inherited:?viewSetupFormScript();       end,     viewBounds: {left: -132, top: 0, right: -2, bottom: 18},     compileVal: nil,     entryFlags: 14849,     viewJustify: 8388640,     _proto: _v189_0    };AddStepForm(TagPrefsLayout, missingInput);defaultsButton :=    {     buttonClickScript:       func()       begin       	RemoveSlot(curDict, curTag);       	RemoveSlot(prefsEntry, curTag);       	newtscape:setPreference(nil,nil);              	:parent():redoChildren();       	:hide();       /*       four situations affecting visibility:       1st time: tagPrefsView.viewSetupDoneScript       change tag: tagPicker.labelActionScript       change val: tagPrefsView.setPref       Defaults: <here>       */       end,     text: "Defaults",     viewBounds: {left: -55, top: 20, right: -3, bottom: 33},     viewJustify: 8388646,     _proto: @226 /* protoTextButton */    };AddStepForm(TagPrefsLayout, defaultsButton);StepDeclare(TagPrefsLayout, defaultsButton, 'defaultsButton);// After Script for defaultsButtonthisView := defaultsButton;begin	thisView.text := LocObj("Defaults", 'defaultsLabel);	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;endindentsLabel :=    {text: "Indents",     viewBounds: {left: 2, top: 20, right: 61, bottom: 31},     _proto: @218 /* protoStaticText */    };AddStepForm(TagPrefsLayout, indentsLabel);// After Script for indentsLabelthisView := indentsLabel;begin	thisView.text := LocObj("Indents", 'indentsLabel);	if kNCfont	then thisView.viewSetupFormScript := kFixTextFormScript;endaboveInput :=    {viewBounds: {left: 12, top: 31, right: 100, bottom: 49},     labelCommands: ["'Top", "0", "3", "6",],     label: "Above",     curSlot: 'above,     _proto: _v189_0    };AddStepForm(TagPrefsLayout, aboveInput);// After Script for aboveInputthisView := aboveInput;thisView.label := LocObj("Above", 'aboveLabel)leftInput :=    {viewBounds: {left: 0, top: 50, right: 100, bottom: 68},     label: "Left",     labelCommands:       k036 //["0", "3", "6"]       ,     curSlot: 'left,     _proto: _v189_0    };AddStepForm(TagPrefsLayout, leftInput);// After Script for leftInputthisView := leftInput;thisView.label := LocObj("Left", 'leftLabel)belowInput :=    {viewBounds: {left: 12, top: 69, right: 100, bottom: 87},     label: "Below",     labelCommands:       k036 //["0", "3", "6"]       ,     curSlot: 'below,     numOnly: true,     _proto: _v189_0    };AddStepForm(TagPrefsLayout, belowInput);// After Script for belowInputthisView := belowInput;thisView.label := LocObj("Below", 'belowLabel)splitInput :=    {viewBounds: {left: 0, top: 88, right: 100, bottom: 106},     curSlot: 'split,     label: "Split",     labelCommands: ["'true", "'nil", "'P"],     entryFlags: 14849,     _proto: _v189_0    };AddStepForm(TagPrefsLayout, splitInput);// After Script for splitInputthisView := splitInput;thisView.label := LocObj("Split", 'splitLabel)alignPicker :=    {labelCommands: kAlign,     viewBounds: {left: 0, top: 110, right: 140, bottom: 124},     text: "Align",     textSetup: func() labelCommands[curDict.(curTag).align],     labelActionScript: func(cmd) :setPref('align,cmd),     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(TagPrefsLayout, alignPicker);// After Script for alignPickerthisView := alignPicker;begin	thisView.text := LocObj("Align", 'alignLabel);	thisView.labelCommands := [		LocObj("Left", 'leftLabel),		LocObj("Right", 'rightItem),		LocObj("Center", 'centerItem),		LocObj("Justify", 'justifyItem),		];	if kNCfont	then begin		thisView.pickerSetup := kFixPickerSetup;		thisView.viewSetupFormScript := kFixPickerFormScript;		end;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endfontLabel :=    {text: "Font",     viewBounds: {left: -125, top: 20, right: 0, bottom: 31},     viewJustify: 8388640,     _proto: @218 /* protoStaticText */    };AddStepForm(TagPrefsLayout, fontLabel);// After Script for fontLabelthisView := fontLabel;begin	thisView.text := LocObj("Font", 'fontLabel);	if kNCfont	then thisView.viewSetupFormScript := kFixTextFormScript;endfamilyPicker :=    {viewBounds: {left: -125, top: 35, right: 0, bottom: 49},     text: "Family",     viewSetupFormScript:       func()       begin       	self.labelCommands := allFonts; // !!!j. call kCollectFontNames with ();              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym //  kFixPickerFormScript       	then begin       		viewFont 			:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10;	 // ~C              	inherited:?viewSetupFormScript();       end,     textSetup:       func()       begin       	// instead of Font. 2.x use call kGetAllFontsFunc with ()??       	local font := curDict.(curTag).font, family;              	if kNIE       	then begin       		family := GetFontFamilySym(font); // !!!k       		if font := LFetch(labelCommands, family, 0, '|=|, 'family)       		then return font.item;       		end       	else begin       		family := call kGetFontFamily with (font);       		if isInstance(family,'int)       		then family := kBuiltinFonts[family];	// !!!j. for compat with older prefs?       		if font := Fonts.(family)       		then return font.name;       		end;       	       	family & $?; 				// shouldn't occur?       	       	/*if KNIE and family > 2		// Length(kBuiltinFonts)       		then Fonts.(GetFontFamilySym(font)).name	// Casual(other)       		else labelCommands[family] 		// built-in: Espy, NewYork, Geneva       	else if font := Fonts.(family)       	then font.name					// installed: e.g., Monaco, Minico,...       	else family; 					// shouldn't occur??       	*/       end,     labelActionScript:       func(cmd)       begin       	local sel := labelCommands[cmd];       	:setPref('font,       		if kNIE       		then SetFontFamily(curDict.(curTag).font, sel.family)	// !!!m       		else call kSetFont with (       			curDict.(curTag).font,       			sel.family,	// !!!j       			/*if cmd <= 2	// Length(kBuiltinFonts)       			then cmd       			else call kFindFontSymbol with (sel),*/       			nil,       			nil));       	if kBuild1x then :updateText(sel.item);	// !!!j       end,     viewJustify: 8388640,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(TagPrefsLayout, familyPicker);// After Script for familyPickerthisView := familyPicker;begin	thisView.text := LocObj("Family", 'familyLabel);	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endsizeInput :=    {viewBounds: {left: -125, top: 50, right: -2, bottom: 68},     label: "Size",     labelCommands:       ["8", "9", "10", "12", "14", "18", "24"]	// 2.1 note: could use MakeFontMenu(fonts.espy,'none,nil,'none)?       ,     textChanged:       func()       begin       	local size := :getVal(), newfont;       	if size > 0       		and newfont :=       			if kNIE then SetFontSize(curDict.(curTag).font, size)	// !!!m       			else call kSetFont with (       				curDict.(curTag).font,       				nil,       				nil,       				size)       	then if kNIE       		then AddProcrastinatedSend(       			Intern('font & $: & kAppSymbol),       			self, 'setPref, ['font, newfont],       			kPrefUpdateDelay)       		else :setPref('font, newfont);       end,     textSetup:       func()       SPrintObject(       	if kNIE       	then GetFontSize(curDict.(curTag).font)       	else call kGetFontSize with (curDict.(curTag).font)       	),     viewJustify: 8388640,     numOnly: true,     _proto: _v189_0    };AddStepForm(TagPrefsLayout, sizeInput);// After Script for sizeInputthisView := sizeInput;thisView.label := LocObj("Size", 'sizeLabel)facePicker :=    {     labelCommands:       [LocObj("Plain", 'plainItem),        LocObj("Bold", 'boldItem),        LocObj("Italic", 'italicItem),        LocObj("BoldItalic", 'boldItalicItem),        LocObj("Underline", 'underlineItem),       ],     viewBounds: {left: -125, top: 72, right: 0, bottom: 86},     text: "Face",     labelActionScript:       func(cmd)       :setPref('font,       	if kNIE       	then SetFontFace(curDict.(curTag).font, cmd)	// !!!m       	else call kSetFont with (       		curDict.(curTag).font,       		nil,       		cmd, // 0(P),1(B),2(I),3(BI),4(U)       		nil)),     textSetup:       func()       labelCommands[       	if kNIE       	then GetFontFace(curDict.(curTag).font)       	else call kGetFontFace with (curDict.(curTag).font)       	],     viewJustify: 8388640,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(TagPrefsLayout, facePicker);// After Script for facePickerthisView := facePicker;begin	thisView.text := LocObj("Face", 'faceLabel);	if kNCfont	then begin // !!!j		thisView.pickerSetup := kFixPickerSetup;		thisView.viewSetupFormScript := kFixPickerFormScript;		end;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endsampleText :=    {text: "Sample",     viewBounds: {left: -125, top: 86, right: 0, bottom: 115},     viewSetupFormScript:       func()       begin       	viewFont := curDict.(curTag).font;              	if language='Chinese and isInstance(viewFont, 'int) and Band(viewFont, tsFamilyMask) = 0       	then viewFont := {family: kSystemFontSym, face: GetFontFace(viewFont), size: GetFontSize(viewFont)};              	viewJustify := BOR(curDict.(curTag).align, _proto.viewJustify);       	inherited:?viewSetupFormScript();       end,     viewJustify: 8388640,     _proto: @218 /* protoStaticText */    };AddStepForm(TagPrefsLayout, sampleText);StepDeclare(TagPrefsLayout, sampleText, 'sampleText);// After Script for sampleTextthisView := sampleText;thisView.text := LocObj("Sample", 'sampleLabel)TagPrefsTitle :=    {text: "Appearance",     viewBounds: {left: 0, top: -12, right: 75, bottom: -2},     viewJustify: 8388754,     _proto: @218 /* protoStaticText */    };AddStepForm(TagPrefsLayout, TagPrefsTitle);// After Script for TagPrefsTitlethisView := TagPrefsTitle;begin	thisView.text := LocObj("Appearance", 'appearanceItem);	if kNCfont	then thisView.viewSetupFormScript := kFixTextFormScript;endsystemFamilyPicker :=    {viewBounds: {left: 0, top: 127, right: 158, bottom: 141},     text: "System Family",     viewSetupFormScript:       func()	// shared with familyPicker (afterScript)       begin       	self.labelCommands := allFonts; // !!!j. call kCollectFontNames with ();              	if kNIE and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym //  kFixPickerFormScript       	then begin       		if kNCfont       		then viewFont 		:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10; // ~C              	inherited:?viewSetupFormScript();       end,     textSetup:       func()       begin       	local font, family := prefsEntry.(prefSym);       	if kNIE       	then begin       		if family and font := LFetch(labelCommands, family, 0, '|=|, 'family)       		then return font.item;       		end       	else if family and font := Fonts.(family)       	then return font.name;              	ROM_espyFont.name & $?; // shouldn't occur??              /*       	if family and (font := Fonts.(family))	// 2.x use?: call kGetAllFontsFunc with ()       	then font.name			// installed: e.g., Monaco, Minico,...       	else "System"; 			// shouldn't occur??       */       end,     labelActionScript:       func(cmd)       begin       	local val :=  labelCommands[cmd].family;	// !!!j       		//call kFindFontSymbol with (labelCommands[cmd]);       	newtscape:setPreference(prefSym, val);       	newtscape:?fixFontsJ(val, nil);	// NC redo       	:parent():redoChildren();              	//if kBuild1x then :updateText(sel.item);	// !!!j?       end,     prefSym: 'systemFontFamily,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(TagPrefsLayout, systemFamilyPicker);// After Script for systemFamilyPickerthisView := systemFamilyPicker;begin	thisView.text := "System" && LocObj("Family", 'familyLabel);	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endsystemSizePicker :=    {viewBounds: {left: 158, top: 127, right: 237, bottom: 141},     labelCommands: ["9", "10"],     textSetup:       func()       begin       	local size := prefsEntry.(prefSym);       	if size       	then SPrintObject(size)       	else labelCommands[0];       end,     prefSym: 'systemFontSize,     labelActionScript:       func(cmd)       begin       	local val := Floor(StringToNumber(labelCommands[cmd]));       	newtscape:setPreference(prefSym, val);       	newtscape:?fixFontsJ(nil, val);	// w/ NC redo       	:parent():redoChildren();       end,     text: "Size",     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(TagPrefsLayout, systemSizePicker);// After Script for systemSizePickerthisView := systemSizePicker;begin	thisView.text := LocObj("Size", 'sizeLabel);	if kNCfont	then thisView.viewSetupFormScript := kFixPickerFormScript;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);end// After Script for TagPrefsLayoutthisView := TagPrefsLayout;begin	thisView._proto := GetLayout("protoPrefDrawer");	RemoveSlot(thisView, 'viewJustify);	RemoveSlot(thisView, 'viewBounds);/* 0 tagPicker 1 missingInput 2 defaultsButton 3 indentsLabel 4 aboveInput 5 leftInput 6 belowInput 7 splitInput 8 alignPicker 9 fontLabel10 familyPicker11 sizeInput12 facePicker13 sampleText14 prefsTitle15 systemFamilyPicker16 systemSizePicker*/	local children := thisView.stepChildren;	if kNCfont	then begin		children[10].viewSetupFormScript :=	// familyPicker. ..., labelCommands generation		children[15].viewSetupFormScript;	// sysFamilyPicker		end	else ArrayRemoveCount(children, Length(children)-2, 2);	// systemFamilyPicker, systemSizePickerendconstant |layout_TagPrefsLayout| := TagPrefsLayout;// End of file TagPrefsLayout// Beginning of file protoPrefInputLine_v185_0 :=    {     viewChangedScript:       func(slot, view)       if  prefSym and slot='text       then begin       	local val := if StrFilled(text) then text;       	val :=       		if prefType = 'symbol       		then if val then Intern(val) else nil       		else if prefType = 'int       		then call kGetInt with (val,0)	// !!!b. if val and val := StringToNumber(val) then Floor(val) else 0       		else val;              	if kNIE	// don't immed update on each char       	then AddProcrastinatedSend(       			Intern(prefSym & $: & kAppSymbol),       			newtscape, 'setPreference, [prefSym, val],       			kPrefUpdateDelay)       	else newtscape:setPreference(prefSym, val);       	end,     viewSetupFormScript:       func()       begin       	if childSym       	then :parent().(childSym) := self;       	local val := if prefSym then prefsEntry.(prefSym);       	self.text :=       		if prefType='symbol or prefType='int       		then SPrintObject(val)       		else Clone(if val then val else "");              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := newtscape.entryFontJ;              	inherited:?viewSetupFormScript();       end,     viewFont: UserFont10,     viewFormat: 8529,     prefSym: nil,     viewLineSpacing: 16,     prefType: 'string,     childSym: nil,     _proto: @185 /* protoInputLine */    };constant |layout_protoPrefInputLine| := _v185_0;// End of file protoPrefInputLine// Beginning of file protoPrefPicker_v190_0 :=    {viewBounds: {left: 26, top: 18, right: 158, bottom: 30},     textSetup:       func()       begin       	local str := prefsEntry.(prefSym), entry;       	if str       	then if prefType = 'index       		then labelCommands[str]       		else if prefType = 'int       		then SPrintObject(str)       		else if prefType='symbol       		then if isFrame(labelCommands[0]) and       				entry := if kNIE       					then LFetch(labelCommands, str, 0, '|=|, 'value)       					else call kLFetch with (labelCommands, str, 0, Functions.|=|, 'value, nil)       			then entry.item       			else SPrintObject(str)       		else str       	else if isFrame(entry := labelCommands[defaultIndex])       	then entry.item       	else entry;       end,     prefType: 'string,     labelActionScript:       func(cmd)       begin       	local val := labelCommands[cmd];              	newtscape:setPreference(prefSym,       		if prefType = 'index       		then cmd       		else if prefType = 'symbol       		then if isFrame(val) then val.value else Intern(val)       		else if prefType = 'int       		then call kGetInt with (val, nil)	// !!!b. if val := StringToNumber(val) then Floor(val) else val       		else val);       	if kBuild1x and isFrame(val) then :updateText(val.item);       end,     defaultIndex: 0,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };// After Script for _v190_0thisView := _v190_0;begin	Removeslot(thisView,'viewBounds);	if kNCfont	then begin		thisView.pickerSetup := kFixPickerSetup;		thisView.viewSetupFormScript := kFixPickerFormScript;	// !!!j		end;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endconstant |layout_protoPrefPicker| := _v190_0;// End of file protoPrefPicker// Beginning of file protoCachePicker_v190_0 :=    {viewBounds: {left: 26, top: 18, right: 158, bottom: 30},     textSetup:       func()       begin       	local str := prefsEntry.(prefSym);       	if str       	then SPrintObject(str)       	else labelCommands[defaultIndex].item;	// !!!k       end,     prefType: 'int,     labelActionScript:       func(INT cmd)       if cmd >= 0       then begin       	local val := labelCommands[cmd], sym;       	if cmd=0 or cmd=1       	then val := val.item;              	if isFrame(val)	// toggle moreOptions, e.g., trust       	then begin       		//if val.resetTitles	// followHTML, followImages       		//then newtscape.(Intern(soupName & kTitles)) := NIL;              		sym := val.prefSym;       		val := not prefsEntry.(sym);       		labelCommands[cmd].mark := if val then kBullet;       		cmd := -1;       		end              	else begin       		sym := prefSym;       		val := call kGetInt with (val, 0);	// !!!b       		//if val := StringToNumber(val) then val := Floor(val) else val := 0;       		end;              	newtscape:setPreference(sym, val);       	if cmd <= 1       	then :updateText(:textSetup()); // display/fix number display              	if cmd=0	// "no cache"       	then begin       		if newtscape.(prefSym) // if on, clear entries & unreg soups       		then begin       			//call kCollectURLs with (newtscape.(prefSym), nil, 0);       			call kRemoveAllSoupEntries with (newtscape.(prefSym));       			newtscape.(prefSym) := newtscape.(Intern(soupName & kTitles)) := NIL;       			newtscape:Init(nil);	// in case it had caches in it       			end;       		labelCommands[cmd].mark := kCheckMarkChar;       		labelCommands[1].mark := nil; // in case it was on       		end              	else if cmd > 0       	then begin	// # of entries       		newtscape.(prefSym) := soupName;       		labelCommands[0].mark := nil; // in case it was on       		labelCommands[1].mark := if cmd=1 then kCheckMarkChar;       		end;       end,     defaultIndex: 0,     viewSetupFormScript:       func()       begin       	labelCommands 	 := Clone(labelCommands);       	labelCommands[0] := Clone(labelCommands[0]);	// "no cache"       	labelCommands[1] := Clone(labelCommands[1]);	// "10 items"       	local option := prefsEntry.(prefSym);       	if option=0 or (option=10 and option := 1)       	then labelCommands[option].mark := kCheckMarkChar;              	if moreOptions       	then foreach option in moreOptions       		do begin       			if isFrame(option)	// except 'pickSeparator       			then begin       				option := Clone(option);       				option.mark := if prefsEntry.(option.prefSym) then kBullet; // !!!j       				end;       			AddArraySlot(labelCommands, option);       			end;              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       	then begin       		viewFont 			:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10; // ~C              	inherited:?viewSetupFormScript();       end,     labelCommands:       [       {item: LocObj("no cache", 'noCacheItem)},       // if this # changes. see viewSetupFormScript       {item: "10" && LocObj("items", 'itemsItem) && "--" && LocObj("Max.", 'maxLabel)},       "20", "50", "75", "100", "150", "200", "300", "500", // !!!f       ],     alwaysCallPickActionScript: true,     tempCmd: nil,     tempList: nil,     tempSym: nil,     FixAfterSubPicker:       func(cmd,sym,val,markChar)	// !!!j,g       begin       	newtscape:setPreference(sym, val);       	labelCommands[cmd].mark := if val then markChar;       end,     pickCancelledScript:       func()	// !!!g       begin       	tempList := NIL;       	inherited:?pickCancelledScript();       end,     _proto: @190 /* protoLabelPicker */    };// After Script for _v190_0thisView := _v190_0;begin	RemoveSlot(thisView,'viewBounds);	if kNCfont	then thisView.pickerSetup := kFixPickerSetup;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endconstant |layout_protoCachePicker| := _v190_0;// End of file protoCachePicker// Beginning of file protoNamePasswordprotoNamePassword :=    {viewBounds: {left: 6, top: 38, right: -6, bottom: 170},     host: "",     URL: nil,     userName: nil,     userPassword: nil,     options: nil,     cache: nil,     ReorientToScreen:       ROM_DefRotateFunc //@588       ,     hostOrProxy: LocObj("Host", 'hostLabel),     viewJustify: 48,     hosts: nil,     keep: nil,     _proto: @180 /* protoFloatNGo */    };hostPick :=    {text: LocObj("Hosts",'hostsItem),     viewBounds: {left: 1, top: 3, right: -2, bottom: 17},     alwaysCallPickActionScript: true,     viewJustify: 8388656,     viewSetupFormScript:       DefineGlobalConstant('kCollectHosts, func(auth, chosts)       // chosts=nil, get all; otherwise, get just those in chosts (and remove)       if IsFrame(auth) and Length(auth) > 0 and (not chosts or Length(chosts) > 0)       then begin       	local host,val, pos;       	local ARRAY hosts := [];       	foreach host,val in auth       	do  if chosts and Length(chosts)=0       		then break       		else begin       			val := SPrintObject(host);       			if not chosts or pos := LSearch(chosts,val,0,'|str=|,nil)       			then begin       				if pos       				then ArrayRemoveCount(chosts,pos,1);       				AddArraySlot(hosts, val);       				end;       			end;       	hosts;       	end       );              DefineGlobalConstant('kAddHosts, func(allhosts, thosts, label)       if thosts and Length(thosts) > 0       then begin       	ArrayInsert(       		Sort(thosts, '|str<|, nil),       		call kMakeSeparatorItem with (label, nil),	// !!!j       		0);       	ArrayMunger(allhosts, Length(allhosts), 0, thosts,0,nil);       	end);              func()       begin       	local chosts := Clone(hosts);       	// Keep       	call kAddHosts with (       		labelCommands := [],       		call kCollectHosts with (newtscape.prefsEntry.authentication, chosts),       		LocObj("Keep", 'keepItem));              	// Temp.       	call kAddHosts with (       		labelCommands,       		call kCollectHosts with (fsm.fAuthentication, chosts),       		LocObj("Temp.",'tempItem));              	// None       	call kAddHosts with (labelCommands, chosts, kNoneItem);              	local pos := CharPos(host,$;,0), host1, up64, fr;       	if (host1  := if pos then SubStr(host,0,pos) else if StrFilled(host) then host)       		and (up64 := fsm:getAuth(host1, newtscape.prefsEntry))       		and (up64 := call kDecodeBase64 with (up64))       		and pos := CharPos(up64,$:,0)       	then begin       		userName 	 := SubStr(up64,0,pos);       		userPassword := SubStr(up64,pos+1,nil);              		fr := newtscape.prefsEntry.authentication;       		keep := fr and fr.(Intern(host1));       		end       	else userName := userPasword := "";              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	//  kFixPickerFormScript       	then begin       		viewFont 			:= 	newtscape.labelFontJ;       		entryLine.viewFont 	:= 	newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10;  // ~C              	inherited:?viewSetupFormScript();       end,     textSetup:       func()       if CharPos(host,$;,0) then "" else host,     labelActionScript:       func(cmd)       begin       	host := labelCommands[cmd];       	:parent():RedoChildren();       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(protoNamePassword, hostPick);// After Script for hostPickthisView := hostPick;if kNCfontthen thisView.pickerSetup := kFixPickerSetup; // sharehostLabel :=    {text: "",     viewBounds: {left: 2, top: 30, right: 65, bottom: 42},     viewSetupFormScript:       func()       begin       	text := hostOrProxy;              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// kFixTextFormScript       	then viewFont := newtscape.labelFontJ;              	inherited:?viewSetupFormScript();       end,     _proto: @218 /* protoStaticText */    };AddStepForm(protoNamePassword, hostLabel);hostInput :=    {text: "",     viewBounds: {left: 67, top: 22, right: -3, bottom: 62},     viewSetupFormScript:       func()       begin       	if StrLen(text := Clone(host)) = 0       	then SetKeyView(self, 0);              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// kFixInputFormScript       	then viewFont := newtscape.entryFontJ;              	inherited:?viewSetupFormScript();       end,     viewChangedScript:       func(slot, view)       if slot='text       then host :=       	/*if IsRichString(text)       	then DecodeRichString(text,viewfont).text       	else*/ text,     viewJustify: 48,     _proto: @185 /* protoInputLine */    };AddStepForm(protoNamePassword, hostInput);nameLabel :=    {text: "Name",     viewBounds: {left: 2, top: 74, right: 65, bottom: 86},     _proto: @218 /* protoStaticText */    };AddStepForm(protoNamePassword, nameLabel);// After Script for nameLabelthisView := nameLabel;begin	thisView.text := LocObj("Name", 'nameLabel);	if kNCfont	then thisView.viewSetupFormScript := kFixTextFormScript;endnameInput :=    {viewBounds: {left: 67, top: 66, right: -3, bottom: 86},     viewChangedScript:       func(slot, view)       if slot='text       then userName :=        	/*if IsRichString(text)       	then DecodeRichString(text,viewfont).text       	else*/ text,     viewSetupFormScript:       func()       begin       	text := Clone(userName);              	if StrLen(host) > 0       	then SetKeyView(self, StrLen(userName));              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// kFixInputFormScript       	then viewFont := newtscape.entryFontJ;              	inherited:?viewSetupFormScript();       end,     viewJustify: 8388656,     _proto: @185 /* protoInputLine */    };AddStepForm(protoNamePassword, nameInput);passwordLabel :=    {text: "Password",     viewBounds: {left: 2, top: 98, right: 65, bottom: 110},     _proto: @218 /* protoStaticText */    };AddStepForm(protoNamePassword, passwordLabel);// After Script for passwordLabelthisView := passwordLabel;begin	thisView.text := LocObj("Password", 'passwordLabel);	if kNCfont	then thisView.viewSetupFormScript := kFixTextFormScript;endpasswordInput :=    {viewBounds: {left: 67, top: 90, right: -3, bottom: 110},     viewChangedScript:       func(slot, view)       if slot='text       then begin // userPassword := text       /*	local i;       	for i := StrLen(text)-1 to 0 by -1       	do if ORD(text[i]) <= kMaxPWChar       	then return SetValue(self, 'text, :encode(text, true)); // encode, redisplay, then setData       */       	local txt := :encode(text, true);       	if txt       	then SetValue(self, 'text, txt)       	else userPassword := :encode(       		/*if IsRichString(text)       		then DecodeRichString(text,viewfont).text       		else*/ text, nil); 	// decode value       	end,     encode: kEncodeFunc,     viewSetupFormScript:       func()       begin       	text :=       		if StrFilled(userPassword)       		then :encode(Clone(userPassword),true)       		else Clone("");              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym // kFixInputFormScript       	then viewFont := newtscape.entryFontJ;              	inherited:?viewSetupFormScript();       end,     viewJustify: 8388656,     _proto: @185 /* protoInputLine */    };AddStepForm(protoNamePassword, passwordInput);protoNamePassword_v624_0 :=    {viewBounds: {left: 3, top: -15, right: 21, bottom: -2},     viewJustify: 134,     _proto: @624 /* clView */    };AddStepForm(protoNamePassword, protoNamePassword_v624_0);// After Script for protoNamePassword_v624_0thisView := protoNamePassword_v624_0;begin	thisView._proto := protoSmallKeyboardButton;	//thisView.viewSetupFormScript := kHideKbdButton;	// !!!gendkeepCheck :=    {text: LocObj("Keep", 'keepItem),     viewBounds: {left: 28, top: -14, right: 80, bottom: -2},     viewJustify: 132,     valueChanged: func() keep := viewValue,     buttonValue: true,     viewSetupFormScript:       func()       begin       	viewValue := keep;              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := newtscape.dataFontsJ;              	inherited:?viewSetupFormScript();       end,     _proto: @164 /* protoCheckBox */    };AddStepForm(protoNamePassword, keepCheck);authenticateButton :=    {     buttonClickScript:       func() // !!!g       if StrFilled(host)  // and cache?       then begin       	//"Basic" && // add in sendHTTP or if different add here?       	//cache.(Intern(host)) :=              	local fn := StrTokenize(host, $;), host1, up64;       	if StrFilled(userName) and StrFilled(userPassword)       	then up64 := call kEncodeBase64 with (TrimString(userName) & $: & TrimString(userPassword))       	else host := "";	// for continuing              	while host1 := call fn with ()       	do  if StrFilled(TrimString(host1))       		then fsm:setAuth(host1, up64, newtscape.prefsEntry, keep);              	/* note for non-Newt's Cape       	getURL could be simply:       		options.xxx:DoEvent('newURL, [url, kGet, nil, nil, options]);       	*/               	if StrFilled(URL)       	then begin       		options.dispatchApp:?getURL(url, options);       		base:close();	// moved inside       		end       	else :parent():RedoChildren();	// e.g., Hosts list       	end;,     text: "Authenticate",     viewBounds: {left: 0, top: -15, right: 80, bottom: -3},     viewJustify: 8388758,     _proto: @226 /* protoTextButton */    };AddStepForm(protoNamePassword, authenticateButton);// After Script for authenticateButtonthisView := authenticateButton;begin	thisView.text := LocObj("Authenticate", 'authenticateLabel);	if language='German	then thisView.viewBounds.right := 120;	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;end// After Script for protoNamePasswordthisView := protoNamePassword;begin// !!!gRemoveSlot(thisView,'cache);thisView.userName := thisView.userPassword := thisView.host;endconstant |layout_protoNamePassword| := protoNamePassword;// End of file protoNamePassword// Beginning of file ProtoPrefCheckbox_v164_0 :=    {text: "",     valueChanged:       func()       newtscape:setPreference(prefSym, viewValue),     viewSetupFormScript:       func()       begin       	viewValue := prefsEntry.(prefSym);              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := newtscape.dataFontsJ;              	inherited:?viewSetupFormScript();       end,     prefSym: nil,     _proto: @164 /* protoCheckBox */    };// After Script for _v164_0thisView := _v164_0;begin	RemoveSlot(thisView, 'text);	RemoveSlot(thisView, 'prefSym);endconstant |layout_ProtoPrefCheckbox| := _v164_0;// End of file ProtoPrefCheckbox// Beginning of file NIEPrefsLayout// Before Script for NIEPrefsLayout// used in ResetAllScript,constant kPrefSetSlots := '[	curPrefTag, prefName, prefNames,	tag, _uniqueID, _modTime];NIEPrefsLayout :=    {viewBounds: {left: 2, top: 2, right: -2, bottom: -2},     viewJustify: 240,     routeScripts:       {// !!!k       displayPrefName: {       	GetTitle: func(target)       		kPrefSetItem & $: && target.prefName,       	routeScript: 'displayPrefNameScript,       	},              rename: {       	title: LocObj("Rename", 'renameItem),				//check empty/dup?       	routeScript: 'renameScript,	       	},              duplicate: {       	icon: if kNIE then ROM_routeDuplicateIcon,       	title: LocObj("Duplicate", 'duplicateItem),			//check dup?       	routeScript: 'duplicateScript,       	},              delete: {       	icon: if kNIE then ROM_routeDeleteIcon,       	GetTitle: func(target)       		call kFixMenuItem with (LocObj("Delete", 'deleteItem),       			not StrEqual(target.tag, kPackageName)),       	routeScript: 'deleteScript,       	},              resetAll: {       	title: kResetAllOption,       	routeScript: 'resetAllScript,       	},       },     viewSetupFormScript:       func()       begin       	self.target := prefsEntry;       	self.targetView := self;       	inherited:?viewSetupFormScript();       end,     deleteScript:       func(target, targetView) // !!!k       if not StrEqual(target.tag, kPackageName)       then newtscape:Confirm(       	nil,       	kPrefSetItem & $: & LocObj("Delete", 'deleteItem) & $: && target.prefName,       	self, 'deleteSet),     duplicateScript:       func(target, targetView) // !!!k       begin       	local newPrefsEntry := Clone(target), newName := target.prefName & "_copy", val;       //Print("creating:" && newName);       	foreach val in kPrefSetSlots       	do RemoveSlot(newPrefsEntry, val);       	local mainPrefs := newtscape:myGetAppPrefs(kPackageName), prefNames := mainPrefs.prefNames;              	if (if kNIE       		then not BInsert(prefNames, newName, '|str<|, nil, true)       		else ArrayPos(prefNames, newName, 0, Functions.StrEqual))       	then return newtscape:Notify(kNotifyAlert, kPrefSetItem, LocObj("name already exists", 'nameExistsErr));              	newPrefsEntry.prefName := newName;       	:displayPrefNameScript(newPrefsEntry, targetView);              	mainPrefs.curPrefTag := newPrefsEntry.tag := newName & $: & kAppName;              	if kNIE       	then EntrySoup(target):AddXmit(newPrefsEntry, nil)       	else begin       		AddArraySlot(prefNames, newName);       		Sort(prefNames,'|str<|,nil);       		EntrySoup(target):Add(newPrefsEntry);       		end;       	       	targetView.prefsEntry := targetView.target := newPrefsEntry;		// since base not closed       	newtscape:updateSet(prefsEntry, 'duplicate, newPrefsEntry, mainPrefs, nil);	// !!!n. preserve prefsEntry       end,     renameScript:       func(target, targetView) // !!!k       begin       	local mainPrefs := newtscape:myGetAppPrefs(kPackageName), prefNames := mainPrefs.prefNames;       	local newName := Clone(otherOptionsInput.text), pos;              	if StrEqual(newName, target.prefName)	// !!!m       	then return;              	if not StrFilled(newName) or StrEqual(newName, kAppName)       		or (StrEqual(newName, kDefaultPrefName) and mainPrefs <> target)       		or (if kNIE       			then not BInsert(prefNames, newName, '|str<|, nil, true)       			else ArrayPos(prefNames, newName, 0, Functions.StrEqual))       	then return newtscape:Notify(kNotifyAlert, kPrefSetItem,       		if StrFilled(newName)       		then LocObj("name already exists", 'nameExistsErr)       		else LocObj("name empty", 'nameEmptyErr));              //Print("renamed prefs. old:" && target.prefName & $; && "new:" && newName);       	if kNIE       	then BDelete(prefNames, target.prefName, '|str<|, nil, 1) // remove old name. new added in BInsert earlier       	else begin       		if pos := ArrayPos(prefNames, target.prefName, 0, Functions.StrEqual)       		then ArrayRemoveCount(prefNames,pos,1);	// remove old       		AddArraySlot(prefNames, newName);		// add new       		Sort(prefNames, '|str<|, nil);       		end;       	target.prefName := newName;              	if mainPrefs <> target	// not default entry       	then begin       		mainPrefs.curPrefTag := target.tag := newName & $: & kAppName;       		if kNIE       		then EntryFlushXmit(mainPrefs, nil) // this also saves prefNames       		else EntryChange(mainPrefs);       		end;       	if kNIE       	then EntryChangeXmit(target, nil)       	else EntryChange(target);       end,     resetAllScript:       func(target, targetView) // !!!j       newtscape:Confirm(       	nil,       	kPrefSetItem & $: & LocObj("Reset All", 'resetAllItem) & $: && target.prefName,       	self, 'resetSet),     displayPrefNameScript:       func(target, targetView) // !!!k       begin       	otherOptionsInput:update(Clone(target.prefName));       	otherOptionsPicker:updateText(otherOptionsPicker:textSetup());       end              /* fixup code       call func()       begin       	gc();       	local cursor := GetStores()[0]:GetSoup("System"):Query(nil);       	local entry := cursor:reset(), first, mytag := "NewtsCape:NewtsCape";       	while entry       	do begin       		if StrEqual(entry.tag, mytag)       		then if first       			then begin       				Print("duplicate:" && EntryUniqueID(entry));       				//EntryRemoveFromSoupXmit(entry,nil);       				end       			else begin       				first := entry;       				Print("original:" && EntryUniqueID(entry));       				//entry.curPrefTag := mytag; EntryChangeXmit(entry,nil);       				end       		else if EndsWith(entry.tag, ":Newtscape")       		then Print(entry.tag & $: && EntryUniqueID(entry));              		entry := cursor:next();       		end;       end with ()       */,     deleteSet:       func(x) // target is in slot. called via deleteScript(Confirm)       if x       then begin       //Print("deleting prefs:" && target.prefName);       	base:close();              	local mainPrefs := newtscape:myGetAppPrefs(kPackageName), prefNames := mainPrefs.prefNames, pos;       	mainPrefs.curPrefTag := kPackageName;	// switch back to Main       	if kNIE       	then BDelete(prefNames, target.prefName, '|str<|, nil, 1)              	else if pos := ArrayPos(prefNames, target.prefName, 0, Functions.StrEqual)       	then ArrayRemoveCount(prefNames, pos, 1);              	newtscape:updateSet(target, 'delete, mainPrefs, mainPrefs, true);	// !!!n       	end,     resetSet:       func(x) // !!!k. target in slot. called via resetAllScript(Confirm)       if x       then begin       //Print("Reset All:" && target.prefName);       	base:close();              	local slot, newPrefsEntry;       	if StrEqual(target.tag, kPackageName)	// Main Pref Set?       	then begin       		newPrefsEntry := Clone(kDefaultPrefs);       		newPrefsEntry.curPrefTag := target.curPrefTag;	// keep these       		newPrefsEntry.prefNames	 := target.prefNames;       		end       	else begin // like Duplicate but w/ same prefName,tag       		newPrefsEntry := Clone(newtscape:myGetAppPrefs(kPackageName)); // mainPrefs       		foreach slot in kPrefSetSlots       		do RemoveSlot(newPrefsEntry, slot);       		newPrefsEntry.tag := target.tag;       		end;       	newPrefsEntry.prefName := target.prefName; // keep this              	newtscape:updateSet(target, 'replace, newPrefsEntry, nil, true);	// !!!n       	end,     appSymbol:       kNewtsCapeSymbol	// !!!m       ,     _proto: @180 /* protoFloatNGo */    };cookiePicker :=    {viewBounds: {left: 0, top: 48, right: 94, bottom: 62},     prefSym: 'cookiesConfirm,     text: "Cookies",     labelCommands:       [	// coord with 'ask in headerSpec       {item: LocObj("Skip",	'skipItem), value: 'skip},       {item: LocObj("Ask", 	'askItem),	value: 'ask},       {item: LocObj("Keep",	'keepItem),	value: 'keep},       ],     prefType: 'symbol,     labelActionScript:       func(cmd)       begin       	if cmd=0 or not prefsEntry.cookies       	then newtscape:setPreference('cookies, if cmd > 0 then []);       	inherited:labelActionScript(cmd);       end,     _proto: _v190_0    };AddStepForm(NIEPrefsLayout, cookiePicker);// After Script for cookiePickerthisView := cookiePicker;beginthisView.text := LocObj("Cookies", 'cookiesLabel);endthresholdInput :=    {viewBounds: {left: 140, top: 31, right: 175, bottom: 47},     prefSym: 'threshold,     prefType: 'int,     viewFlags: 10753,     childSym: 'thresholdInput,     _proto: _v185_0    };AddStepForm(NIEPrefsLayout, thresholdInput);bookmarkSoupPicker :=    {viewBounds: {left: 0, top: 64, right: 228, bottom: 78},     text: "Bookmarks",     prefSym: 'bookmarkSoupName,     labelCommands:       [       {item: LocObj("Choose", 'chooseMsg), 	value: 'bookmarkSoupName},       {item: LocObj("Store",	'storeItem),	value: 'BookmarkStore},	// !!!j       //{item: LocObj("Bookmarks in overview only",'bkoverItem),	value: 'overviewBookmarksOnly},       {item: LocObj("Unfiled bookmarks in menu", 'unfiledBkMenuItem), value: 'unfiledBookmarkMenu},	// !!!k       ],     alwaysCallPickActionScript: true,     textSetup:       func()       begin       	local str := prefsEntry.(prefSym);       	if str       	then str       	else kNoneItem;       end,     viewSetupFormScript:       func() // !!!j       begin       	labelCommands := Clone(labelCommands);       	local option, sym, val, i;       	foreach i,option in labelCommands       	do begin       		//if isFrame(option)	// except 'pickSeparator       		labelCommands[i] := option := Clone(option);       		val := prefsEntry.(sym := option.value);       		if IsString(val) and StrLen(val)=0		// fix "bookmark in overview" 1st time       		then prefsEntry.(sym) := val := nil;       		option.mark := if val then kBullet;       		end;              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       	then begin       		viewFont 			:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10; // ~C              	inherited:?viewSetupFormScript();       end,     tempList: nil,     pickActionScript:       func(INT cmd) // !!!j       begin       	local sel, sym, val, inh := true;       	if tempList	// sub-popup       	then begin       		sel := tempList[cmd];       		sym := labelCommands[tempCmd].value;       		val := if cmd > 0 then sel.value;       		if tempCmd=0        		then begin       			newtscape.bookmarks := val;	// soupName       			:updateText(:textSetup());       			end;       		labelCommands[tempCmd].mark := if val then kBullet;       		tempList := inh := nil;       		end              	else begin       		sel := labelCommands[cmd];       		sym := sel.value;       		val := prefsEntry.(sym);       		if cmd=0       		then begin	// Choose       			local pos, entry, store, soupName; // iterate thru all stores/soups       			tempList := [       				{item: kNoneItem},       				{item: kBookmarkSoupName, value: kBookmarkSoupName},       				];       			if not val       			then pos := 0       			else if StrEqual(val,kBookmarkSoupName)       			then pos := 1;              			gc();       			foreach store in GetStores()       			do foreach soupName in store:GetSoupNames()        				do if not LSearch(tempList, soupName, 1, '|str=|, 'item)	// !!!j       				then begin // check first entry of each soup       					entry := GetUnionSoup(soupName):?Query(nil):?entry();       					if entry and entry.sortOn and entry.name and entry.URL       					then begin       						if not pos and StrEqual(val, soupName)       						then pos := Length(tempList);       						AddArraySlot(tempList, {item: soupName, value: soupName});       						end;       					entry := NIL;       					end;       			tempList[if pos then pos else 0].mark := kBullet;	// !!!m. kCheckMarkChar;       			end              		else if cmd=1	// Store       		then tempList := call kGetStoresList with (val)              		else sel.mark := if (val := not val) then kBullet;       		end;       	       	if tempList       	then begin       		tempCmd := cmd;       		local pp := :PopupMenu(tempList, nil);       		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       		then SetValue(pp, 'viewFont, newtscape.menuFontJ);	//{family: val, face: kFaceBold, size: 10});       		end       	else newtscape:setPreference(sym, val);              	if inh       	then begin       		inherited:pickActionScript(cmd);       		:updateText(:textSetup());       		end;       end,     pickCancelledScript:       func()	// !!!j       begin       	tempList := NIL;       	inherited:?pickCancelledScript();       end,     tempCmd: nil,     _proto: @190 /* protoLabelPicker */    };AddStepForm(NIEPrefsLayout, bookmarkSoupPicker);// After Script for bookmarkSoupPickerthisView := bookmarkSoupPicker;begin	thisView.text := kBookmarksLabel;	if kNCfont	then thisView.pickerSetup := kFixPickerSetup	else RemoveSlot(thisView, 'pickerSetup);	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endNIEsetupButton :=    {     buttonClickScript:       func()       GetRoot().(appSymbol):?open(),     text: "NIE Setup",     viewBounds: {left: -108, top: -15, right: -48, bottom: -3},     viewJustify: 8388774,     viewSetupFormScript:       func()       begin       	if not GetRoot().(if GlobalFnExists('InetGrabLinkVerbose)       			then appSymbol := '|InternetSetup:NIE|				// NIE 2.0       			else appSymbol)       	then viewFlags := 0;              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := newtscape.labelFontJ;              	inherited:?viewSetupFormsScript();       end,     appSymbol:       '|InternetSetup:Newton|		// for NIE 1.1       ,     _proto: @226 /* protoTextButton */    };AddStepForm(NIEPrefsLayout, NIEsetupButton);// After Script for NIEsetupButtonthisView := NIEsetupButton;begin	thisView.text := LocObj("NIE Setup", 'NIEsetupLabel);	if language='Chinese // shift/narrow a bit	then thisView.viewBounds.left := thisView.viewBounds.left + 5;end// Before Script for scaleFitCheck//1.x only. so LocObj? okscaleFitCheck :=    {viewBounds: {left: 2, top: 32, right: 200, bottom: 46},     prefSym: 'scaleImage,     text: "Scale bitmaps to fit?",     _proto: _v164_0    };AddStepForm(NIEPrefsLayout, scaleFitCheck);pageSizePicker :=    {     labelCommands:       if kBuild20       then [       	{item: LocObj("help", 'phelpItem), 			value: 'help},       	{item: LocObj("portrait", 'portraitItem), 	value: 'portrait},       	// on MP130 portrait, page# doesn't update; landscape doesn't drag       //	{item: LocObj("portrait", 'portraitItem) & $& & LocObj("landscape", 'landscapeItem), value: 'portraitL},       	{item: LocObj("landscape", 'landscapeItem), value: 'landscape},       //	{item: "classic",							value: 'classic},       //	{item: "universal",							value: 'universal},       	{item: "MP2K:2Up",							value: 'MP2K_2Up},	// !!!d1       	{item: "eMate:2Up",							value: 'eMate_2Up},	// !!!d1       	{item: LocObj("full", 'fullItem), 			value: 'full},       	// 2.1 add other(s) in viewSetupFormscript: full-4, full-NIE       	]       else [       	{item: LocObj("help", 'phelpItem), 			value: 'help},       	{item: LocObj("portrait", 'portraitItem), 	value: 'portrait},       //	{item: LocObj("portrait", 'portraitItem) & $& & LocObj("landscape", 'landscapeItem), value: 'portraitL},       	],     text: "Page Size",     viewBounds: {left: 96, top: 16, right: 232, bottom: 30},     prefSym: 'pageSize     ,     prefType: 'symbol,     defaultIndex:       if kBuild20 then 3 else 1 // full or portrait       ,     viewSetupFormScript:       func()       begin       	if kBuild20 and newtscape.nos21	// see NC.bookTemplate       	then begin       		labelCommands := Clone(labelCommands);       		AddArraySlot(labelCommands,       			{item: LocObj("full", 'fullItem) & "-4", 	value: 'full_fix4});       		AddArraySlot(labelCommands,       			{item: LocObj("full", 'fullItem) & "-NIE",	value: 'full_fix}); // !!!a1       		end;       	inherited:?viewSetupFormScript();       end,     _proto: _v190_0    };AddStepForm(NIEPrefsLayout, pageSizePicker);// After Script for pageSizePickerthisView := pageSizePicker;begin	thisView.text := LocObj("Page Size", 'pageSizeLabel);	if not kNIE	then RemoveSlot(thisView, 'viewSetupFormScript);endpkgPicker :=    {viewBounds: {left: 96, top: 48, right: 230, bottom: 62},     text: "Pkg",     viewSetupFormScript:       func()       begin       	if newtscape.NewtPack       	then begin       		local ver :=       			if kBuild20 or	// NC 2.x?       				EndsWith(       					(if kNIE then GetGlobalVar(kNewtSymbol) else GetGlobals().(kNewtSymbol)).installed.|NewtPack:TKnollSys|, "-2")       				then 2 else 1;              		text := text & $( & ver & ".x)";       		labelCommands := Clone(labelCommands);       		local option, i;       		for i:=0 to Length(labelCommands)-1       		do begin       			option := labelCommands[i] := Clone(labelCommands[i]);       			option.mark := if prefsEntry.(option.value) then kBullet else if not kNIE then $ ; // !!!f       			end;              		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       		then begin       			viewFont 			:= 	newtscape.labelFontJ;       			entryLine.viewFont 	:= 	newtscape.dataFontJ;       			end       		else if language='Chinese       		then entryLine.viewFont := kEspy10;  //~C       		end       	else viewFlags := 0;              	inherited:?viewSetupFormScript();       end,     labelCommands:       [       {item: LocObj("Standalone book pkg?", 	'standaloneLabel),	value: 'standAlone},       {item: LocObj("Compressed", 			'compressedItem),	value: 'compressedPkg},       ],     alwaysCallPickActionScript: true,     textSetup:       func() if prefsEntry.standAlone then labelCommands[0].item else "Lite",     labelActionScript:       func(INT cmd)       begin       	local val := labelCommands[cmd], sym;              	sym := val.value;       	val := not prefsEntry.(sym);       	labelCommands[cmd].mark := if val then kBullet else if not kNIE then $ ; // !!!f              	newtscape:setPreference(sym, val);       	       	:updateText(:textSetup());       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(NIEPrefsLayout, pkgPicker);// After Script for pkgPickerthisView := pkgPicker;begin	thisView.text := LocObj("Pkg", 'pkgLabel);	if kNCfont 	then thisView.pickerSetup := kFixPickerSetup;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endNSpicker :=    {viewBounds: {left: 0, top: 80, right: 152, bottom: 94},     prefSym: 'allowCompile,     text: "NewtonScript",     labelCommands:       [       {item: kNoneItem,	value: nil},       {item: LocObj("Compile", 'compileItem),	value: 'compile},       ],     prefType: 'symbol,     alwaysCallPickActionScript: true,     _proto: _v190_0    };AddStepForm(NIEPrefsLayout, NSpicker);// After Script for NSpickerthisView := NSpicker;begin	thisView.text := LocObj("NewtonScript", 'NSlabel);	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endotherOptionsInput :=    {viewBounds: {left: 1, top: 113, right: -1, bottom: 129},     prefSym:       nil	// 'startupURL	// otherOptionsPicker[0]       ,     Update:       func(sym)	// sym = 'symbol, 'path or string (for checkData)       begin       	local str :=       		if (if kNIE then IsString(sym) else isInstance(sym, 'string))       		then begin       			prefSym := NIL;       			sym;       			end       		else prefsEntry.(prefSym := sym);       	SetValue(self, 'text, str);       	SetKeyView(self, if str then StrLen(str) else 0);       end,     viewJustify: 8388656,     childSym: 'otherOptionsInput,     _proto: _v185_0    };AddStepForm(NIEPrefsLayout, otherOptionsInput);// After Script for otherOptionsInputthisView := otherOptionsInput;begin	thisView.viewJustify := thisView.viewJustify - oneLineOnly;	thisView.viewBounds.bottom := thisView.viewBounds.bottom + 32;	// two additional linesendotherOptionsPicker :=    {     labelCommands:       if kNIE       then [       {item: LocObj("Startup URL", 	'startupURLitem),		value: 'startupURL},       {item: LocObj("Proxy URL", 		'proxyURLitem),			value: 'httpProxy},       {item: LocObj("Proxy Only",		'proxyOnlyItem),		value: 'httpProxyOnly},       {item: LocObj("Proxy Exceptions",'proxyExItem), 		value: 'httpNoProxy},       'pickSeparator,       {item: LocObj("Find.Title", 	'findTitleItem),		value: '[pathExpr: findFrame, title]},       {item: LocObj("Find.URL", 		'findURLitem),			value: '[pathExpr: findFrame, url]},       {item: LocObj("Find.Method", 	'findMethodItem),		value: '[pathExpr: findFrame, method]},       {item: LocObj("Find.Data", 		'findDataItem),			value: '[pathExpr: findFrame, dataSource]},       {item: LocObj("Find:CheckData",	'findCheckItem),		value: NIL},			// see labelActionScript       'pickSeparator,       {item: LocObj("Agent Prefix",	'UserAgentItem),		value: 'agentPrefix},       {item: LocObj("Agent Size&Res.",'AgentSizeItem),		value: 'agentSizeRes},       {item: if language='English then kAccept     else LocObj("Accept", 'acceptItem), value: 'acceptAttr}, // !!!a1,v       {item: if language='English then kAcceptLang else LocObj("Accept Language", 'acceptLangItem), value: 'acceptLangAttr}, // !!!a1,v       {item: LocObj("Auto Login",		'autoLoginItem),		value: 'autoLogin},       {item: kResetHTTP,										value: 'resetHTTP},	// !!!e       'pickSeparator,       {item: LocObj("Help ISBN", 		'helpISBNitem),			value: 'helpISBN},       {item: LocObj("Don't Show Newt's Cape",'dontShowNCItem),value: 'noStatus},       {item: LocObj("Don't Close Book", 'dontCloseBookItem),	value: 'noClose},       {item: LocObj("Ignore META Refresh",'ignoreMETArefresh),value: 'noRefresh},		// !!!f       {item: LocObj("Ignore Tables",  'ignoreTablesItem),		value: 'ignoreTables},       {item: LocObj("Include Frames", 'includeFramesItem),	value: 'includeFrames},	// !!!e       {item: LocObj("map FRAME to tag",	'tagFrameItem),		value: 'frameTag},		// !!!i       {item: LocObj("Ignore FONT FACE", 'ignoreFontFaceItem), value: 'ignoreFontFace},// !!!a1,u       {item: LocObj("IMG: no ALT",		'missingImgItem), 	value: 'missingIMG},	// !!!j       {item: LocObj("Display unknown <tags>",	'displayUnkTagItem), value: 'unknownTag},	// !!!a1       {item: LocObj("Newt's Cape button",	'NCmenuItem),		value: 'popupMenu},       {item: LocObj("Overview not floating", 'overfloatItem),	value: 'overviewNoFloat},	// !!!c       //{item: "Overview Offset X",							value: 'overviewOffsetX},       //{item: "Overview Offset Y",							value: 'overviewOffsetY},       {item: LocObj("Change keyboard keys", 'changeKbdItem),	value: 'kbdKeys},       {item: LocObj("NewtWorks HTML via Summary",'nwSummaryItem),value: 'nwSummary},	// !!!a       {item: LocObj("mailto: body",	'mailtoBodyItem),		value: 'mailBody},		// !!!g       {item: LocObj("AutoLink Exceptions", 'autoLinkExcItem),	value: 'linkExcept},	// !!!a1,s       'pickSeparator,       {item: LocObj("Book Page Width", 'bookWidthItem),		value: 'pageWidth},		// !!!b       {item: LocObj("Book Page Height", 'bookHeightItem),		value: 'pageHeight},	// !!!b       {item: LocObj("Book BASE",		'bookBaseItem),			value: 'bookBASE},		// !!!b       {item: LocObj("Book ISBN",		'bookISBNitem),			value: 'bookISBN},		// !!!b       {item: LocObj("Book ShortTitle", 'booksTitleItem),		value: 'bookShortTitle},// !!!b       {item: LocObj("Book Title",		'bookTitleItem),		value: 'bookTitle},		// !!!b       ]              else [       {item: LocObj("Startup URL", 	'startupURLitem),		value: 'startupURL},       {item: "Proxy Host",									value: 'httpProxy},       {item: LocObj("Help ISBN", 		'helpISBNitem),			value: 'helpISBN},       {item: LocObj("Don't Show Newt's Cape",'dontShowNCItem),value: 'noStatus},       {item: LocObj("Don't Close Book", 'dontCloseBookItem),	value: 'noClose},       {item: LocObj("Ignore Tables",  'ignoreTablesItem),		value: 'ignoreTables},       {item: LocObj("Ignore FONT FACE", 'ignoreFontFaceItem), value: 'ignoreFontFace},// !!!a1,u       {item: LocObj("IMG: no ALT",	'missingImgItem), 		value: 'missingIMG},	// !!!j       {item: LocObj("Display unknown <tags>",	'displayUnkTagItem), value: 'unknownTag},	// !!!a1       {item: LocObj("Newt's Cape button",	'NCmenuItem),		value: 'popupMenu},       {item: LocObj("mailto: body",	'mailtoBodyItem),		value: 'mailBody},		// !!!g       'pickSeparator,       {item: LocObj("Book Page Width", 'bookWidthItem),		value: 'pageWidth},		// !!!b       {item: LocObj("Book Page Height", 'bookHeightItem),		value: 'pageHeight},	// !!!b       {item: LocObj("Book BASE",		'bookBaseItem),			value: 'bookBASE},		// !!!b       {item: LocObj("Book ISBN",		'bookISBNitem),			value: 'bookISBN},		// !!!b       {item: LocObj("Book ShortTitle", 'booksTitleItem),		value: 'bookShortTitle},// !!!b       {item: LocObj("Book Title",		'bookTitleItem),		value: 'bookTitle},		// !!!b       ],     viewBounds: {left: 0, top: 96, right: 230, bottom: 110},     labelActionScript:       func(cmd)       begin       	local obj := labelCommands[cmd];       	local val := obj.value;	// prefSym for otherOptionsInput              	if kNIE and not val	// checkData       	then begin       		local findFrame := prefsEntry.findFrame;       		findFrame.data := {};       		findFrame.dataNames := [];       		local src := findFrame.dataSource, err := LocObj("OK", 'okMsg);       		local aval :=       			if StrFilled(src)       			then try call Compile(src) with ()	// ok since user controlled       				 onexception |evt.ex|       				 do err := LocObj("compile err", 'compileErr);       		local INT i, len := if isArray(aval) then Length(aval) else 0;       		if len >= 2 and len mod 2 = 0       		then for i := 0 to len-1 by 2       			do begin       				if  not isString(slot := aval[i]) or       					not (isString(val := aval[i+1]) or isArray(val))       				then break err := LocObj("name or val err", 'nameValErr) & $: && slot;              				AddArraySlot(findFrame.dataNames, slot);       				findFrame.data.(slot := Intern(slot)) := val;       				if i=0       				then findFrame.querySlot := slot;       				end       		else err := LocObj("not an array (or odd length)", 'notArrayOddErr);              		val := err;	 // status string to display in otherOptionsInput       		newtscape:setPreference('findFrame, findFrame);       		end;              	// update menu, input field (or status)       	:updateText(obj.item);       	otherOptionsInput:update(val);       end,     textSetup:       func() LocObj("Other Options", 'otherOptionsLabel)	// labelCommands[0].item       ,     viewSetupFormScript:       func()       begin       	:parent().(childSym) := self;	// !!!k       	self.labelCommands := Clone(labelCommands);              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       	then begin       		viewFont 			:= 	newtscape.labelFontJ;       		entryLine.viewFont 	:= 	newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10;  //~C              	inherited:?viewSetupFormScript();       end,     pickerSetup:       func()       begin       	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym	//kFixPickerSetup       	then AddDeferredCall(kFixPicker, [newtscape.menuFontJ, nil]);              	local i, obj, path, valnew, valorig;	       	foreach i,obj in labelCommands       	do labelCommands[i] :=       			if  not isFrame(obj) or       				not (path := obj.value) or       				(valnew := prefsEntry.(path)) = (valorig := kDefaultPrefs.(path)) or       				(isInstance(valnew,'string) and isInstance(valorig,'string) and StrEqual(valnew,valorig))       			then _proto.labelCommands[i]       			else begin       				if isReadonly(obj)       				then obj := Clone(obj);       				obj.mark := kBullet;       				obj;       				end;       	TRUE;       end,     alwaysCallPickActionScript: true,     childSym: 'otherOptionsPicker,     _proto: @190 /* protoLabelPicker */    };AddStepForm(NIEPrefsLayout, otherOptionsPicker);// After Script for otherOptionsPickerthisView := otherOptionsPicker;begin/*	if not kNCfont 	then begin		RemoveSlot(thisView, 'viewSetupFormScript);		RemoveSlot(thisView, 'pickerSetup);		end;*/	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endautoHideCheck :=    {viewBounds: {left: -82, top: 80, right: -2, bottom: 94},     prefSym: 'autoHide,     text: "Auto hide?",     viewJustify: 36,     _proto: _v164_0    };AddStepForm(NIEPrefsLayout, autoHideCheck);// After Script for autoHideCheckthisView := autoHideCheck;begin	thisView.text := LocObj("Auto hide?", 'autoHideLabel);endresPicker :=    {labelCommands: ["b&w(threshold)"],     text: LocObj("Res.", 'resolutionLabel),     viewBounds: {left: 0, top: 32, right: 140, bottom: 46},     prefSym: 'bitsPerPixel,     viewSetupFormScript:       func()       begin       	if kBuild20 and newtscape.nos21       	then labelCommands := labelCommandsGray;       	local bpp := prefsEntry.(prefSym);       	if not bpp or bpp=0 or kBuild1x or not newtscape.nos21       	then newtscape:setPreference(prefSym, bpp := 1)       	else if bpp > 1 // 1=B&W       	then thresholdInput:hide();              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       	then begin       		viewFont 			:= newtscape.labelFontJ;       		entryLine.viewFont 	:= newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10;  //~C              	inherited:?viewSetupFormScript();       end,     labelCommandsGray:       [LocObj("b&w(threshold)", 	'bwItem),       LocObj("4-gray", 			'gray4Item),       LocObj("16-gray",			'gray16Item),       ]	,     labelActionScript:       func(cmd)       begin       	if cmd=0       	then thresholdInput:show()       	else thresholdInput:hide();       	newtscape:setPreference(prefSym, '[1,2,4][cmd]);	// bpp       end,     textSetup:       func()       begin       	local bpp := prefsEntry.(prefSym);       	labelCommands[if bpp=4 then 2 else bpp-1];	// 1 = b&w, 2 = 4-gray, 4 = 16-gray       end,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(NIEPrefsLayout, resPicker);// After Script for resPickerthisView := resPicker;begin	thisView.labelCommands[0] := thisView.labelCommandsGray[0]; // share	if kNCfont	then thisView.pickerSetup := kFixPickerSetup;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endauthenticateButton :=    {     buttonClickScript:       func()       begin       	newtscape:DoEvent(NIL, [{}]);	// initialize fsm if not there       /*       	local cache := newtscape.wwwFSM.fAuthentication;       	if not cache       	then newtscape.wwwFSM.fAuthentication := cache := {};       */       	BuildContext({       		_proto:	GetLayout("protoNamePassword"),       		newtscape: 	newtscape,       		fsm:		newtscape.wwwFSM,		// !!!g. for setAuth       		//cache:	cache,					// !!!g       		}):open();       end,     text: LocObj("Authenticate", 'authenticateLabel),     viewBounds: {left: -82, top: 97, right: -2, bottom: 109},     viewJustify: 8388646,     _proto: @226 /* protoTextButton */    };AddStepForm(NIEPrefsLayout, authenticateButton);// After Script for authenticateButtonthisView := authenticateButton;begin	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;endcacheHTMLpicker :=    {viewBounds: {left: 0, top: 0, right: 92, bottom: 14},     text: "HTML",     prefSym: 'cacheHTML,     soupName: kCacheHTMLSoupName,     moreOptions:       [       'pickSeparator,       //{item: kFollowURL,									prefSym: 'followHTML, resetTitles: true},       {item: kTrustCache, 									prefSym: 'trustHTML},       {item: kStoreItem,										prefSym: 'HTMLstore},		// !!!g       {item: kIgnoreExpiration,								prefSym: 'ignoreHTMLExpiration},       {item: kEmptyQuit, 										prefSym: 'emptyHTML},       //{item: kKeepQueryResults,								prefSym: 'keepQueryHTML},       {item: kShowItemsOverview,								prefSym: 'showHTMLoverview},// !!!k       {item: LocObj("autoload Frames?", 'autoloadFramesItem), prefSym: 'loadFrames},		// !!!g       {item: LocObj("merge Frame source?",'mergeFramesItem),	prefSym: 'mergeFrameSource},// !!!j       {item: LocObj("remove?", 'removeItem) && "<!--...-->", 	prefSym: 'removeComments},       {item: LocObj("desktop?", 'includeDesktopItem),			prefSym: 'cacheDesktop},       {item: kTextMediaType,									prefSym: 'cacheText},		// !!!o       {item: LocObj("Fix ISO Chars?",'fixISOItem),			prefSym: 'fixISO},			// !!!f       ],     pickActionScript:       func(INT cmd)	// !!!g. same as cacheImagePicker (just for store)       begin       	if tempList       	then begin	// # of images       		:FixAfterSubPicker(tempCmd, tempSym, tempList[cmd].value, kBullet);	// !!!m. kCheckMarkChar);       		return tempList := NIL; // don't do inherited stuff (for picker)       		end;              	local val;       	if isFrame(val := labelCommands[cmd])       		and (tempSym := val.prefSym) = 'HTMLstore	// !!!j,g       	then begin       		tempList := call kGetStoresList with (val := prefsEntry.(tempSym));       		AddDeferredSend(self, 'FixAfterSubPicker,	// major kludge. fix loadImages back again after messed up by pickActionScript/labelActionScript       			[tempCmd := cmd, tempSym, val, kBullet]); 		// save tempCmd (to avoid recomputing)              		local pp := :PopupMenu(tempList, nil);       		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       		then SetValue(pp, 'viewFont, newtscape.menuFontJ); //{family: val, face: kFaceBold, size: 10});       		end;              	inherited:?pickActionScript(cmd);       end,     _proto: _v190_0    };AddStepForm(NIEPrefsLayout, cacheHTMLpicker);// After Script for cacheHTMLpickerthisView := cacheHTMLpicker;begin	thisView.text := LocObj("HTML", 'HTMLlabel);endcacheImagesPicker :=    {viewBounds: {left: 0, top: 16, right: 92, bottom: 30},     text: "Images",     prefSym: 'cacheImages,     soupName: kCacheImagesSoupName,     moreOptions:       [       'pickSeparator,       //{item: kFollowURL,									prefSym: 'followImages, resetTitles: true},       {item: kTrustCache, 									prefSym: 'trustImages},       {item: kStoreItem,										prefSym: 'imageStore},	// !!!g       {item: kIgnoreExpiration,								prefSym: 'ignoreImageExpiration},       {item: kEmptyQuit,	 									prefSym: 'emptyImages},       //{item: kKeepQueryResults,								prefSym: 'keepQueryImages},       {item: kShowItemsOverview,								prefSym: 'showImagesOverview},// !!!k       {item: LocObj("autoLoad?", 'autoLoadItem), 				prefSym: 'loadImages},       {item: LocObj("original (unconverted)?", 'rawImageItem),prefSym: 'rawImage},       {item: LocObj("animated?", 'animatedItem),				prefSym: 'convAnim},       {item: LocObj("scale to fit?", 'scaleImage),			prefSym: 'scaleImage},       ],     pickActionScript:       DefineGlobalConstant('kNumImages, [       {item: kNoneItem, 		value: nil},       {item: LocObj("first 1", 'firstOneItem),value: 1},       {item: "2",		value: 2},       {item: "3",		value: 3},       {item: "4",		value: 4},       {item: "5",		value: 5},       {item: "7",		value: 7},       {item: "10",	value: 10},       {item: "15",	value: 15},       {item: LocObj("All", 'allLabel), value: true},       ]);              func(INT cmd)       begin       	if tempList       	then begin	// # of images       		:FixAfterSubPicker(tempCmd, tempSym, tempList[cmd].value, kBullet);	// !!!m. kCheckMarkChar);       		return tempList := NIL; // don't do inherited stuff (for picker)       		end;              	local val, pos;       	if isFrame(val := labelCommands[cmd])       		and (tempSym := val.prefSym)	// !!!m       	then begin       		val := prefsEntry.(tempSym);       		if tempSym = 'loadImages       		then pos := LSearch(tempList := Clone(kNumImages), val, 0, '|=|, 'value);              		else if tempSym = 'imageStore	// !!!g       		then tempList := call kGetStoresList with (val);	// pos=nil              		if tempList	// !!!g. move to be common for loadImages,imageStore       		then begin       			if pos       			then begin // only for loadImages currently       				tempList[pos] := Clone(tempList[pos]);       				tempList[pos].mark := kBullet;	// !!!m. kCheckMarkChar;       				end;              			AddDeferredSend(self, 'FixAfterSubPicker,	// major kludge. fix loadImages back again after messed up by pickActionScript/labelActionScript       				[tempCmd := cmd, tempSym, val, kBullet]); 		// save tempCmd (to avoid recomputing)              			local pp := :PopupMenu(tempList, nil);       			if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       			then SetValue(pp, 'viewFont, newtscape.menuFontJ);	//{family: val, face: kFaceBold, size: 10});       			end;       		end;              	inherited:?pickActionScript(cmd);       end,     _proto: _v190_0    };AddStepForm(NIEPrefsLayout, cacheImagesPicker);// After Script for cacheImagesPickerthisView := cacheImagesPicker;begin	thisView.text := LocObj("Images", 'imagesLabel);endprefsAction :=    {viewJustify: 166,     viewBounds: {left: -40, top: -15, right: -23, bottom: -2},     _proto: @209 /* protoActionButton */    };AddStepForm(NIEPrefsLayout, prefsAction);// After Script for prefsActionthisView := prefsAction;begin	if kNCfont	then thisView.buttonClickScript := kFixActionClickScript	else RemoveSlot(thisView, 'buttonClickScript);enddocDonePicker :=    {viewBounds: {left: 96, top: 0, right: 232, bottom: 14},     text: "Doc Done",     prefSym: 'docDoneSound,     labelCommands: [],     viewSetupFormScript:       func()       begin       	labelCommands := [kNoneItem, 'pickSeparator,];       	if kNIE       	then ArrayMunger(labelCommands,2,0, SoundList(),0,nil)       	else begin       		local slot,val;       		foreach slot,val in ROM_soundoff       		do AddArraySlot(labelCommands, {       			item: if kNIE or val.userName then val.userName else SPrintObject(slot),       			soundSymbol: slot});       		end;              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym // kFixPickerFormScript       	then begin       		viewFont 			:= 	newtscape.labelFontJ;       		entryLine.viewFont 	:= 	newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryLine.viewFont := kEspy10;  // ~C              	inherited:?viewSetupFormScript();       end,     textSetup:       func()       begin       	local sym := prefsEntry.(prefSym), val;       	if sym       	then if (val := if kNIE then GetRegisteredSound(sym) else ROM_soundoff.(sym))       			and val.userName       		then val.userName       		else SPrintObject(sym)       	else labelCommands[0];       end,     labelActionScript:       func(cmd)       begin       	local sel := labelCommands[cmd];       	local sym := if cmd > 0 then sel.soundSymbol;       	newtscape:setPreference(prefSym, sym);       	if sym       	then begin       		PlaySound(if kNIE then GetRegisteredSound(sym) else ROM_soundoff.(sym));       		if kBuild1x then :updateText(sel.item);       		end;       end,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };AddStepForm(NIEPrefsLayout, docDonePicker);// After Script for docDonePickerthisView := docDonePicker;begin	thisView.text := LocObj("Doc Done", 'docDoneLabel);	if kNCfont	then thisView.pickerSetup := kFixPickerSetup;	if not kNIE	then RemoveSlot(thisView, 'alwaysCallPickActionScript);endNIEPrefsTitle :=    {text: "General",     viewBounds: {left: -22, top: -12, right: 28, bottom: -2},     viewJustify: 8388754,     _proto: @218 /* protoStaticText */    };AddStepForm(NIEPrefsLayout, NIEPrefsTitle);// After Script for NIEPrefsTitlethisView := NIEPrefsTitle;begin	thisView.text := LocObj("General", 'generalItem);	if language='Chinese	then begin // shift/widen a little		thisView.viewBounds.left 	:= thisView.viewBounds.left  - 5;		end;	if kNCfont	then thisView.viewSetupFormScript := kFixTextFormScript;endIPaidCheck :=    {viewBounds: {left: 3, top: -15, right: 70, bottom: -1},     prefSym: 'IPaid,     text: "I Paid?",     viewJustify: 132,     _proto: _v164_0    };AddStepForm(NIEPrefsLayout, IPaidCheck);// After Script for IPaidCheckthisView := IPaidCheck;begin	thisView.text := LocObj("I Paid?", 'IPaidLabel);end// After Script for NIEPrefsLayoutthisView := NIEPrefsLayout;begin	local children := thisView.stepChildren;	// 19 total children	if kNIE	then begin		ArrayRemoveCount(children, 4, 1); 					// remove scaleFitCheck		end	else begin	// 1.x		ArrayRemoveCount(children, 0, 4);	// remove 4: cookiePicker - NIEsetupButton		// keep 6: scaleFitCheck - otherOptionsPicker		ArrayRemoveCount(children, 6, 5);	// remove 6: autohide - cacheImagesPicker		// keep 4: prefsAction - IPaidCheck		end;/* def order: 0	cookiePicker		2.x 1	thresholdInput		2.x 2	bookmarkPicker		2.x 3	NIEsetupButton		2.x  4  scaleFitCheck		1.x 5	pageSizePicker 6	pkgPicker 7	NewtonScriptPicker 8 	otherOptionsInput 9	otherOptionsPicker10  autoHideCheck		2.x11	resPicker			2.x12	authenticateButton	2.x13	cacheHTMLpicker		2.x14	cacheImagesPicker	2.x15	prefsAction			(replaced resetButton)16	docDonePicker17	NIEPrefsTitle18	IPaidChecklayout:cacheHTMLpicker									docDonePickercacheImagesPicker								pageSizePickerresPicker										thresholdInputcookiePicker									standAloneCheckNewtonScriptPicker								authenticateButtonbookmarkPickerotherOptionsPickerotherOptionsInputresetConnectionButton		NIEPrefsTitle		NIEsetupButton*/	thisView._proto := GetLayout("protoPrefDrawer");	thisView.height := kAppHeight+32;	// 2 additional lines for OtherInput	RemoveSlot(thisView, 'viewJustify);	RemoveSlot(thisView, 'viewBounds);endconstant |layout_NIEPrefsLayout| := NIEPrefsLayout;// End of file NIEPrefsLayout// Beginning of file protoEvent// Before Script for _v218_0//	Newton Developer Technical Support Sample Code//	protoEvent - An NTK Finite State Machine User Proto//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes._v218_0 :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     _proto: @218 /* protoStaticText */    };constant |layout_protoEvent| := _v218_0;// End of file protoEvent// Beginning of file protoState// Before Script for _v218_0//	Newton Developer Technical Support Sample Code//	protoState - An NTK Finite State Machine User Proto//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes._v218_0 :=    {viewBounds: {left: 8, top: 16, right: 112, bottom: 56},     _proto: @218 /* protoStaticText */    };constant |layout_protoState| := _v218_0;// End of file protoState// Beginning of file protoFSM// Before Script for _v218_0//	Newton Developer Technical Support Sample Code//	protoFSM - An NTK Finite State Machine User Proto//	by Jim Schram, Newton Developer Technical Support//	Copyright ©1996 Apple Computer, Inc.  All rights reserved.//	//	You may incorporate this sample code into your applications without//	restriction.  This sample code has been provided "AS IS" and the//	responsibility for its operation is 100% yours.  You are not//	permitted to modify and redistribute the source as "DTS Sample Code."//	If you are going to re-distribute the source, we require that you//	make it clear in the source that the code was descended from//	Apple-provided sample code, but that you've made changes.//	kFSMBuildTemplateFunc - compile time only//	//	Function to call at compile time to create a FSM from a text file definition or other non-layout source.//	Performs basic sanity checking, constructs a protoFSM user template, and returns it.//	//	<compile time - in a project data file or beforeScript, after the protoFSM file has been compiled>//	DefConst	(	'kMyFSMTemplate,//						call kFSMBuildTemplateFunc with (	'myFSM,							// symbol = required name of this FSM//																				nil,									// frame or nil = optional context frame//																				Home & "myFSM.f",			// string or frame = required name of frame definition file to load, or frame definition//																				GetLayout("protoFSM")		// frame = required reference to protoFSM engine, or other engine//																			)//					);//	//	<run time>//	fsm := kMyFSMTemplate:Instantiate();//	kFSMBuildTemplateFunc := func(name, context, definition, engine)begin	local fsmSymbol := name;	if not fsmSymbol then		begin			fsmSymbol := 'unknown;			print("A protoFSM implementation is unnamed (kFSMBuildTemplateFunc requires the name parameter).");		end;		if not engine then		begin			print("The '|" & fsmSymbol & "| protoFSM engine is invalid.");			return;		end;		definitionFrame := if IsInstance(definition, 'string) then Load(definition) else definition;	if not IsInstance(definitionFrame, 'frame) then		begin			print("The '|" & fsmSymbol & "| protoFSM definition is invalid.");			return;		end;		if not definitionFrame.Genesis then		print("The '|" & fsmSymbol & "| protoFSM implementation is missing the required '|Genesis| state.");		local templateFrame := if IsInstance(context, 'frame) then context else {};		templateFrame._proto := engine;	templateFrame.declareSelf := fsmSymbol;	templateFrame.fsm_private_states := definitionFrame;		if not kDebugOn then		// GoToState is a debug-only function!		begin			RemoveSlot(templateFrame._proto, 'GoToState);			RemoveSlot(templateFrame, 'GoToState);		end;		RemoveSlot(templateFrame._proto, '_proto);	RemoveSlot(templateFrame._proto, 'viewBounds);		templateFrame;end;//	kFSMCleanUpFunc - compile time only//	//	Function to call in the afterScript of your FSM layout.//	Converts NTK layout data structures into "pure" FSM data structures used by protoFSM.//	//	Example://	//	<compile time - afterScript of a FSM layout>//	call kFSMCleanUpFunc with (thisView);				// let's assume the filename of this layout is "myFSM.t"//	//	<run time>//	fsm := GetLayout("myFSM.t"):Instantiate();//	kFSMCleanUpFunc := func(fsmFrame)begin	local fsmSymbol, stateSymbol, eventSymbol, hasGenesisState;		RemoveSlot(fsmFrame._proto, '_proto);	RemoveSlot(fsmFrame._proto, 'viewBounds);	RemoveSlot(fsmFrame, 'viewBounds);	RemoveSlot(fsmFrame, 'viewJustify);		fsmFrame.fsm_private_states := {	};		if not fsmSymbol := GetSlot(fsmFrame, 'declareSelf) then		begin			fsmSymbol := 'unknown;			print("A protoFSM implementation is unnamed (you forgot the declareSelf slot).");		end;		if fsmFrame.stepChildren then		foreach stateFrame in fsmFrame.stepChildren do			begin				RemoveSlot(stateFrame, '_proto);				RemoveSlot(stateFrame, 'viewBounds);				RemoveSlot(stateFrame, 'viewJustify);								if not stateSymbol := GetSlot(stateFrame, 'declareSelf) then					begin						stateSymbol := 'unknown;						print("A protoState in the '|" & fsmSymbol & "| protoFSM implementation is unnamed (you forgot the declareSelf slot).");					end;				if fsmFrame.fsm_private_states.(stateSymbol) then					print("The '|" & stateSymbol & "| protoState in the '|" & fsmSymbol & "| protoFSM implementation already exists (duplicate declareSelf slot value).");				else					fsmFrame.fsm_private_states.(stateSymbol) := stateFrame;								if stateFrame.stepChildren then					foreach eventFrame in stateFrame.stepChildren do						begin							RemoveSlot(eventFrame, '_proto);							RemoveSlot(eventFrame, 'viewBounds);							RemoveSlot(eventFrame, 'viewJustify);														if not eventSymbol := GetSlot(eventFrame, 'declareSelf) then								begin									eventSymbol := 'unknown;									print("A protoEvent in the '|" & stateSymbol & "| state of the '|" & fsmSymbol & "| protoFSM implementation is unnamed (you forgot the declareSelf slot).");								end;							if stateFrame.(eventSymbol) then								print("The '|" & eventSymbol & "| protoEvent in the '|" & stateSymbol & "| protoState in the '|" & fsmSymbol & "| protoFSM implementation already exists (duplicate declareSelf slot value).");							else								stateFrame.(eventSymbol) := eventFrame;														RemoveSlot(eventFrame, 'declareSelf);						end;								RemoveSlot(stateFrame, 'declareSelf);				RemoveSlot(stateFrame, 'stepChildren);								hasGenesisState := hasGenesisState or stateSymbol = 'Genesis;			end;		if not hasGenesisState then		print("The '|" & fsmSymbol & "| protoFSM implementation is missing the required '|Genesis| state.");		if not kDebugOn then		// GoToState is a debug-only function!		begin			RemoveSlot(fsmFrame._proto, 'GoToState);			RemoveSlot(fsmFrame, 'GoToState);		end;	RemoveSlot(fsmFrame, 'stepChildren);		nil;end_v218_0 :=    {viewBounds: {left: 8, top: 8, right: 232, bottom: 280},     DoEvent:       func(eventSymbol, paramArray)	// SELF can be anything that inherits to the finite state machine instance frame       begin       	local x := if kDebugOn then :?DoEvent_Check('|protoFSM:DoEvent|) else fsm_private_context;       	if not x then       		return;       	       	if kDebugOn then       		if paramArray and PrimClassOf(paramArray) <> 'Array then       			Throw('|evt.ex.msg|, "protoFSM:DoEvent 2nd argument must be Nil or Array");       	       	x.pendingEventQueue:EnQueue(eventSymbol);       	x.pendingParamsQueue:EnQueue(paramArray);       	       	if not x.busy then       		begin       			x.busy := true;       			AddDelayedSend(x.fsm, 'DoEvent_Loop, nil, x.turtle);       		end;       	       	nil;       end,     instantiate:       //	SELF is the finite state machine template frame, e.g.:       //       //	local fsm := GetLayout("myFSM"):Instantiate();       //       //	"myFSM" is assumed to be a layout based on protoFSM,              func()       begin       	local obj := {	_proto:							self,       						fsm:								nil,       						currentStateFrame:		nil,       						currentEventFrame:		nil,       						fsm_private_context:	{	fsm:								nil,       																turtle:							1,       																level:							0,       																busy:							nil,       																waitView:						nil,       																waitAborted:				nil,       																isNewPendingState:		true,       																pendingState:				'Genesis,       																pendingEventQueue:		QueueTemplate:Instantiate(),       																pendingParamsQueue:	QueueTemplate:Instantiate(),       																currentState:				nil,       																currentEvent:				nil,       																currentParams:			nil,	},	};       	obj.currentStateFrame := {	_proto:		obj.fsm_private_states.Genesis,       												_parent:	obj,	};       	obj.fsm := obj.fsm_private_context.fsm := obj;       end,     dispose:       func()	// SELF should be the finite state machine instance frame       begin       	if not fsm_private_context then       		return;       	       	fsm_private_context.pendingEventQueue:Reset();       	fsm_private_context.pendingParamsQueue:Reset();       	foreach slot, value in fsm_private_context do fsm_private_context.(slot) := nil;       	fsm := currentStateFrame := currentEventFrame := fsm_private_context := nil;       	       	nil;	// guaranteed to return nil so that the caller can conveniently nil out the FSM container variable       end,     DoEvent_Loop:       func()	// SELF is the finite state machine instance frame       begin       	local x, ok, pendingStateFrame;       	repeat       		x := if kDebugOn then :?DoEvent_Check('|protoFSM:DoEvent_Loop|) else fsm_private_context;       		if not x then       			return;       		       		ok := nil;	//pendingStateFrame       		       		if x.pendingState then       			if fsm_private_states.(x.pendingState) then       				if fsm_private_states.(x.pendingState).(x.pendingEventQueue:Peek()) then       					ok := true;       				else       					begin       						if kDebugOn then :?DebugFSM('UnknownEvent, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());			// ignore if event not programmed       					end;       			else       				begin       					if kDebugOn then :?DebugFSM('UnknownState, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());			// error --> remain in current state       				end;       		else       			begin       				if kDebugOn then :?DebugFSM('NilState, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());					// machine halted       			end;       		       		if not ok then       			begin       				currentStateFrame := currentEventFrame := nil;       				x.isNewPendingState := true;       				       				x.pendingEventQueue:DeQueue();		// there is a problem with this state or event       				x.pendingParamsQueue:DeQueue();		// so remove the offending pending queue elements       			end;       		else       			begin       				x.currentState := x.pendingState;       				x.currentEvent := x.pendingEventQueue:DeQueue();       				x.currentParams := x.pendingParamsQueue:DeQueue();       				       				if x.isNewPendingState then       					begin       						x.isNewPendingState := nil;       						currentStateFrame :=	{	_proto:		fsm_private_states.(x.currentState),       																_parent:	self,	};       					end;       				       				currentEventFrame :=	{	_proto:		fsm_private_states.(x.currentState).(x.currentEvent),       														_parent:	currentStateFrame,	};       				       				if currentEventFrame.Action then       					begin       						if kDebugOn then :?TraceFSM('PreAction, x.currentState, x.currentEvent, x.currentParams);       						       						if x.level then x.level := x.level + 1; // !!!o. x zapped during :dispose?       						try       							Perform(currentEventFrame, 'Action, x.currentParams);       						onexception |evt.ex| do       							begin       								try       									:?ExceptionHandler(CurrentException());       								onexception |evt.ex| do       									nil;       							end;       						if x.level then x.level := x.level - 1;       						       						if kDebugOn then :?TraceFSM('PostAction, x.currentState, x.currentEvent, x.currentParams);       					end;       				       				if not currentEventFrame	// !!!o       				then return;              				if currentEventFrame.nextState then       					begin       						x.pendingState := currentEventFrame.nextState;       						x.isNewPendingState := (x.currentState <> x.pendingState);       					end;       				       				if kDebugOn then :?TraceFSM('NextState, x.pendingState, x.pendingEventQueue:Peek(), x.pendingParamsQueue:Peek());       			end;       		       		if x.waitView												// check for terminal state & exit waitView if necessary       		and x.pendingState       		and pendingStateFrame := fsm_private_states.(x.pendingState) then       			if pendingStateFrame.terminal then       				begin       					x.pendingEventQueue:Reset();       					x.pendingParamsQueue:Reset();       					AddDelayedCall(	func()       												if x.waitView then       													x.waitView:Close(), nil, 1	);       				end;       		       		x.busy := not x.pendingEventQueue:IsEmpty();       		       	until not(x.busy and currentEventFrame and currentEventFrame.nextNoIdle);              	if x.busy then       		AddDelayedSend(self, 'DoEvent_Loop, nil, x.turtle);              	nil;       end,     SetSpeed:       func(newSpeed)		// SELF is the finite state machine instance frame       begin       	fsm_private_context.turtle := newSpeed;       end,     IsBusy:       func()	// SELF is the finite state machine instance frame       begin       	fsm_private_context.busy;       end,     GetSpeed:       func()	// SELF is the finite state machine instance frame       begin       	fsm_private_context.turtle;       end,     GoToState:       // SELF is the finite state machine instance frame       // This function is for DEBUGGING USE ONLY ! ! !       // It is STRIPPED from the resulting package when kDebugOn = nil              func(newState)       begin       	local x := fsm_private_context;       	       	x.pendingState := newState;       	x.pendingEventQueue:Reset();       	x.pendingParamsQueue:Reset();       	       	nil;       end,     QueueTemplate:       {       	Instantiate:			func()									// This is a very simple First-In-First-Out queue       								{	_proto:		self,       									queue:		[],	},       	       	Reset:					func() SetLength(queue, 0),       	       	Peek:					func() if Length(queue) > 0 then queue[0],		// else nil       	       	DeQueue:				func()       								if Length(queue) > 0 then		// else nil       									begin       										local data := queue[0];       										RemoveSlot(queue, 0);       										data;       									end,       	       	EnQueue:				func(data)       								begin       									AddArraySlot(queue, data);       									nil;       								end,       	       	GetQueueSize:		func() Length(queue),       	       	IsEmpty:				func() Length(queue) = 0,       },     ProtoClone:       func(object)       begin       	local f :=        		func native(obj)       		begin       			if not IsFrame(obj) or IsFunction(obj) then       				Throw('|evt.ex.msg|, "ProtoClone only works with frames.");       			       			local new := {_proto: obj};       			foreach slot, value in obj do       				if IsFrame(value) and not IsFunction(value) then       					new.(slot) := call f with (value);       			new;       		end;       	       	call f with (object);       end,     WaitForTerminal:       func(options)       begin       	local x := fsm_private_context;       	       	if x.waitView       	or x.level <> 0       	or x.pendingEventQueue:IsEmpty() then       		return;       	       	x.waitView := BuildContext(waitViewTemplate);       	x.waitView:SetOwnerContext(x, options);       	x.waitView:ModalDialog();       	x.waitAborted;		// return the value of waitAborted (true = user aborted via the status slip, nil = FSM terminal state was reached normally)       end,     waitViewTemplate:       {	viewClass:				clView,       	viewFlags:				vVisible,       	viewFormat:				vfNone,       	viewBounds:				SetBounds(0,0,0,0),       	ReorientToScreen:		ROM_DefRotateFunc,	// !!!q       	statusView:				nil,       	statusViewOptions:		nil,        	fsmContext:				nil,        	aborted:				nil,        	       	SetOwnerContext:		func(owner, options)       							begin       								self.statusView := nil;       								self.statusViewOptions := options;		// frame of options the caller of WaitForTerminal is passing us (e.g.  progress messages, etc.)       								self.fsmContext := owner;				// the fsm_private_context slot of the FSM       								self.aborted := nil;       							end,       	       	viewIdleScript:			func()       							begin       								statusView := BuildContext(statusViewTemplate);       								statusView:SetOwnerContext(self, statusViewOptions);       								statusView:ModalDialog();       								nil;       							end,       	       	viewSetupDoneScript:	func()       							begin       								inherited:?ViewSetupDoneScript();       								if not statusViewOptions then       								:SetUpIdle(2000);       								else if statusViewOptions.delayUntilStatusVisible then       								:SetUpIdle(if statusViewOptions.delayUntilStatusVisible <= 0 then 1 else statusViewOptions.delayUntilStatusVisible);       							end,       	       	viewQuitScript:			func()       							begin       								if statusView then       									statusView:Close();       								fsmContext.waitAborted := aborted;       								fsmContext.waitView := nil;       							end,       	       	statusViewTemplate:		{	_proto:		protoStatusTemplate,       								initialSetup:						nil,       								waitView:							nil,       								delayUntilAbortTimer:		nil,       								delayUntilAbortVisible:		nil,       								abortButtonText:				nil,       											       								viewIdleScript:		func()       								begin       																						inherited:?viewIdleScript();       																						local contents :=	{	name:		'vBarber,       																														values:		{	barber:		true,	},	};       																						       																						if delayUntilAbortVisible then       																							begin       																								delayUntilAbortTimer := delayUntilAbortTimer + 300;       																								if delayUntilAbortTimer > delayUntilAbortVisible then       																									begin       																										delayUntilAbortVisible := nil;       																										contents.values.primary := {	text:			abortButtonText,       																																					script:		func()       																																									begin       																																										waitView.aborted := true;       																																										waitView:Close();       																																									end,	};       																										base:ViewSet(contents);       																										return 300;       																									end;       																							end;       																						       																						base:UpdateIndicator(contents);       																						300;       																					end,       											       											viewSetupDoneScript:		func()       																					begin       																						inherited:?ViewSetupDoneScript();       																						:SetUpIdle(100);       																						self.delayUntilAbortTimer := 0;       																					end,       											       											SetOwnerContext:				func(owner, options)       																					begin       																						self.waitView := owner;       																						self.delayUntilAbortVisible := if options then options.delayUntilAbortVisible else 8000;       																						self.abortButtonText := if options and options.abortButtonText then options.abortButtonText else "Abort";       												     									self.initialSetup := {	name:		'vBarber,        																														values:		{	icon:					ROM_routeUpdateBitmap,       																																			statusText:		if options then options.statusText else "Please wait...",       																																			titleText:			if options then options.titleText else nil,       																																			barber:				true,       																																			primary:			nil,       																																			closeBox:			nil,	},	};       												     								end,       										},       },     ExceptionHandler:       func(exception)       begin       	local x := fsm_private_context;       	local message :=	if x then       									"The following exception occured in event ("       									& x.currentEvent       									& ") of state ("       									& x.currentState       									& ") of finite state machine ("       									& x.fsm.declareSelf       									& "):  "       								else       									"The following exception occured:  ";       	       	local exceptionStr := "<unable to create string representation of exception frame>";       	try       		exceptionStr := :ObjectToString(exception);       	onexception |evt.ex| do       		nil;       	       	:ExceptionHandler_Notify(message & exceptionStr);       	nil;       end,     ObjectToString:       // Converts almost any NewtonScript data type into a string representation.       // Does NOT handle recursive/self-referencing frames.       // Does NOT follow _proto & _parent pointers.       // Does NOT check for out-of-memory conditions, bad object refs, et cetera.              func(obj)       begin       	local separator := ", ";       	local separatorLen := StrLen(separator);       	       	local p :=       		func(s)       		if EndsWith(s, separator) then       			StrMunger(s, StrLen(s) - separatorLen, nil, nil, 0, nil)       		else       			s;       	       	local f :=       		func(obj)       		begin       			(	if IsFunction(obj) then       					"func(" & NumberStr(GetFunctionArgCount(obj)) & (if GetFunctionArgCount(obj) = 1 then " arg)" else " args)")       				       				else if IsFrame(obj) then       					begin       						local s := "{";       						foreach slot, item in obj do       							s := s & SPrintObject(slot) & ": " &        								if slot = '_parent or slot = '_proto then       									"<ignored>" & separator       								else       									call f with (item);       						call p with (s) & "}";       					end       				       				else if IsArray(obj) then       					begin       						local s := "[";       						foreach item in obj do       							s := s & call f with (item);       						call p with (s) & "]";       					end       				       				else if IsString(obj) then       					$" & obj & $"       				       				else if IsSymbol(obj) then       					$' & obj       				       				else if IsNumber(obj) or IsInteger(obj) then       					NumberStr(obj)       				       				else if IsImmediate(obj) then       					if not obj then       						"nil"       					else if obj = true then       						"true"       					else       						SPrintObject(obj)       				       				else       					SPrintObject(obj)       			       			) & separator;       		end;       	       	call p with (call f with (obj));       end,     DoEvent_Check:       func(where)		// This routine checks to see if the FSM has been unexpectedly disposed.  That's especially bad if there's a delayed action/call/send about to trigger!       begin       	local x := fsm_private_context;       	if x then       		return x;       	       	if kDebugOn then       		:?ExceptionHandler_Notify("An active protoFSM object has mysteriously vanished!  Discovered in " & SPrintObject(where) & ".  You should consider resetting your Newton device now.");       	       	nil;       end,     ExceptionHandler_Notify:       func(message)       begin       	GetRoot():Notify(kNotifyAlert, kAppName, message);       	       	if kDebugOn then       		begin       			print(message);       			if GetGlobalVar('BreakOnThrows) then       				BreakLoop();       		end;       	       	nil;       end,     _proto: @218 /* protoStaticText */    };// After Script for _v218_0thisView := _v218_0;begin	if not kDebugOn	then RemoveSlot(thisView, 'DoEvent_Check);endconstant |layout_protoFSM| := _v218_0;// End of file protoFSM// Beginning of file HTTP FSMHTTP Machine :=    {     MGrabLinkCallback:       func(linkID, newStatus, error)       begin       	local statusSym := newStatus.linkStatus;       //if kDebugHTTP then begin Print("grabLink callback:" && statusSym); Print(newStatus); print(error); end;              	fLinkID := linkID;		// make sure it's set...       	fHTTPoptions.dispatchApp:?setStatus(       		"NIE:" && (if statusSym='connecting then LocObj("connecting", 'connectingMsg)       			 	else if statusSym='connected then LocObj("connected", 'connectedMsg)       				else statusSym)       		&& newStatus.infoText2 && newStatus.titleText);              	if error // and not nie20       	then :DoEvent('OpenLinkFailure, [error])              	else if statusSym = 'Connected       	then :DoEvent('OpenLinkSuccess, nil);       end,     dispatchCache:       func(entry)	// used in Genesis:newURL, Genesis:OpenConnectionClose, SendHTTPRequest:ReceiveCache       if isFrame(entry)       then begin       	//if kDebugHTTP then Print("dispatchCache");       	local options := fHTTPOptions;       //Write("dispatchCache: "); Print(options);       	local type := entry.type, content;       	if IsSoupEntry(entry)       	then begin       		local nentry := Clone(entry);	// avoid problems during Saving...       		EntryUndoChanges(entry);       		entry := nentry;       		end;              	if entry.bitmap       	then begin       		//if not type then       		type := kGIFMediaType; // don't want to redispatch, e.g., JPEG??       		content := entry.bitmap; // getPictObj called later...       		end       	else if entry.text       	then begin       		if not type	// !!!o       		then type := kHTMLMediaType;       		content := entry.text;       		end       	else if not options.error	// !!!k       	then options.error := LocObj("cache: not HTML or Image?", 'notHTMLimageErr);       		//:callbackError(LocObj("cache: not HTML or Image?", 'notHTMLimageErr), options);              	options.edata := entry.edata;       	options.cacheEntry := NIL;              //Write("dispatchCache: "); Print(fURLqueue);              	if content	// no content test       	then options.dispatchApp:?dispatchFile(type, Clone(entry.URL), content, call kFixOptions with (fURLqueue,options));	// Clone(url) for NewtPack; delay earlier       	end,     DebugFSM:       func(reason, state, event, params) // override protoFSM (more compact)       :PrintFSM("Reason = ", reason, state, event, params),     fLinkID: nil,     vBase: nil,     vHelperApp: nil,     NotifyMsg:       "unknown err" // default for kErrDoNextState       ,     popQueue:       func(options)	// used by addFile, newURL, cleanup       if (not fState or fState = 'Disconnected) and	// wait until in (or transitioning to) Genesis state       	fURLqueue and Length(fURLqueue) > 0       then begin       	local href := fURLqueue[0];       //if kDebugHTTP then       //Write("popQueue[" & Length(fURLqueue) & "]: "); Print(href);       	ArrayRemoveCount(fURLqueue,0,1);              	if IsEntryAlias(href)       	then begin       		if IsFrame(href := EntryFromObj(href))       		then begin       			options.cacheEntry := href;       			:DoEvent('newURL, [href.URL, kGet, nil, nil, nil, options]); //	? href.edata, href.data       			end       		else :popQueue(options);	// invalid entry (moved store, deleted?)       		end              	else if isString(href)       	then begin       		if options.checkCache and not options.cacheEntry       		then call kSendHTTP with (href, kGet, nil, nil, nil, options)       		else :DoEvent('newURL, [href, kGet, nil, nil, nil, options]) // usually a GIF       		end       	       /* currently, redirected graphics (except direct access) wouldn't work since       if it were retrieved, it wouldn't be via getURL, but rather call to kGetURLCache(ImageCache,...)       	and we'd just ignore the result rather than dispatch(display) since there were other URLs in queue       if it were cached, it wouldn't be found by scanImages/getPICTasBits under the old name (in source);       	so why bother getting it in first place. that's why just ignored here for now.       however, this should work fine for a cached or redirected HTML/GIF doc (last in queue)       */              	// moved out to see what happens...       	else if isArray(href)       	then begin	// redirect or !!!j deferred :getURL. //:DoEvent('newURL, href       		// this allows current book and cache to be checked before re-getting       		local app := options.dispatchApp;	// !!!j. save       		options := href[5];       		options.method := href[1];       		options.edata := href[3];       		options.data := href[4];       		app:?getURL(href[0], options); // GetRoot().(kAppSymbol) ?       		end              	else if Length(fURLqueue)=0	// only for last doc (either HTML or GIF)       	then if isFrame(href)       		then :dispatchCache(href);	// !!!k. usually cached doc, using current fHTTPoptions       	end              else begin	// !!!k       	local newtscape := GetRoot().(kAppSymbol);       	if options.autoLogout and options.noStatus and not Visible(newtscape)	// !!!n. was autoLogin       	then begin       		newtscape:?docDone(options,true);       		newtscape:?quit();       		end       	else if options.resetHTTP	// !!!e       	then newtscape:resetFSM();       	// note: if queue empty, last entry might not do :quit       	end,     fProtocol: nil,     fState: nil,     fHTMLtype: nil,     fRemoteIPAddress: nil,     vContent: nil,     vContentType: nil,     MCancelLinkCallback:       func(linkID, newStatus, error)       begin       	if not fHTTPoptions.error       	then fHTTPoptions.error := SPrintObject(newStatus.linkStatus);	// !!!k       	//:callBackError(SPrintObject(newStatus.linkStatus), fHTTPoptions);	// !!!j,,h. already done in Cancel              	if error       	then :DoEvent('CancelLinkFailure, [error])       	else :DoEvent('CancelLinkSuccess, nil);       end,     fHTTPData:       nil	// data frame (see fHTTPeData       ,     viewBounds: {left: 0, top: 0, right: 496, bottom: 496},     fOriginalHostName: nil,     fGrabLinkReceiver: nil,     _proto: _v218_0,     parseURL:       func(href) // copied from Project Data. used in NewURL event(s)       begin // returns array of fields       	local host, port := 80, file;       	local sposr := StrPos(href, "://", 0);		// protocol (possibly via string.url.http class???)       	local sposh := sposr+3; 					// host       	local sposp := CharPos(href, $:, sposh); 	// port       	local sposf := CharPos(href, $/, sposh); 	// file               	local protocol := SubStr(href, 0, sposr);       	if not sposf       	then begin       		sposf := StrLen(href);       		href := href & $/;       		end;       	file := SubStr(href, sposf, nil);              	if sposp and sposp < sposf       	then begin       		host := SubStr(href,sposh, sposp-sposh);       		port := call kGetInt with (SubStr(href,sposp+1, sposf-sposp-1), 80); // !!!b       		end       	else host := SubStr(href, sposh, sposf-sposh);               	[href, protocol, host, port, file];       end,     MNotifyError:       // where = string describing location of error       // error = NewtonScript object (e.g. integer, real number, exception frame, etc.) describing the error              func(where, error) // default       begin       	if not error       		or error = -16005       		or fAbort       	then return;              	local message := LocObj("An error occured in", 'errorOccurred) && where & ".  ";               	if IsNumber(error)       		and GetGlobalFn('InetGetErrorString)	// NIE 1.1       	then message := message & InetGetErrorString(error) & "  ";              	message := message & LocObj("Error", 'errorLabel) && $= && :ObjectToString(error);              	GetRoot():Notify(kNotifyAlert, kAppName, message); //:MNotify(       end,     PrintFSM:       func(label, thing, state, event, params) // shared by DebugFSM, TraceFSM       begin       	local s :=       		label & :ObjectToString(thing)       			& "\tState = " & :ObjectToString(state)       			& "\tEvent = " & :ObjectToString(event);       			//& "\tParams =" & :ObjectToString(params);	// might contain other big frames, e.g., options.dispatchApp, cacheHTML, cacheImages...       	//:MTrace(s);       	//Print(SubstituteChars(s, "\n", "\t"));       	Print(s);       end,     fConnectAction: nil,     fHTTPMethod: nil,     fConnectionSlipView: nil,     fOriginalPortNumber: nil,     MReleaseLinkCallback:       func(linkID, newStatus, error)       begin       //if kDebugHTTP then       //Print("releaseLink callback:" && newStatus.linkStatus);              	if error       	then begin       		//:MNotifyError("MReleaseLinkCallback", error);       		:callBackError("MReleaseLinkCallback" && error, fHTTPoptions); // !!!j,h. not an error at very end??       		end;       // ????              // since this is called just once and says "connected", ignore?       	//fHTTPoptions.dispatchApp:?setStatus("NIE:" && newStatus.linkStatus && newStatus.infoText2 && newStatus.titleText);              	//if nie20 then UnRegInetLinkStatusChange(kAppSymbol);       end,     nie20:       nil	// true if >= NIE 2.0       ,     getAuth:       func(hostName, options)	// !!!g. options just has to inherit from prefsEntry       if hostName       then begin       	local hostVal, fr, hostSym := Intern(hostName);       	// check permanent first       	if options and isFrame(fr := options.authentication) and hostVal := fr.(hostSym)       	then hostVal       	else if fAuthentication       	then fAuthentication.(hostSym);		// current session       	end,     quit:       func()       begin       	fHTTPoptions.error := fAbort := true;		// !!!o,k       	:DoEvent('Cancel, nil);       	//:DoEvent('Disconnect, nil);	// ???              //Print("NC:InetReleaseLink" && fLinkID);       //Print(fGrabLinkReceiver);       	if not fSerial and fGrabLinkReceiver and fLinkID       	then begin       		// doesn't do anything afterward       		if nie20	//GlobalFnExists('InetReleaseLinkVerbose)       		then InetReleaseLinkVerbose(fLinkID, fGrabLinkReceiver, 'MReleaseLinkCallback)       		else InetReleaseLink(fLinkID, fGrabLinkReceiver, 'MReleaseLinkCallback);              	end;              	AddDelayedCall(func()       	begin       	:WaitForTerminal(       		// this function returns NIL if FSM terminal state reached normally, TRUE if user aborted       		{statusText: LocObj("Please wait", 'waitMsg) & "É",	// message at top of status dialog       		titleText:	LocObj("HTTP FSM is executing toward terminal state", 'terminalMsg),	// message at bottom of status dialog       		delayUntilStatusVisible:2000,	// show status slip 2 seconds after entering WaitForTerminal       		delayUntilAbortVisible:	8000,	// show abort button 8 seconds after status dialog opens       		abortButtonText: LocObj("Go Away", 'goAwayLabel) & $!,	// text inside abort button       		});	              	:Dispose(); // for FSM. returns NIL       	end, nil, kCleanupDelay);       	NIL;       end,     addQueue:       func(items)	// !!!j       begin       if fURLqueue and IsArray(items)       then begin       	if fURLqueue <> items	// !!!p       	then ArrayMunger(fURLqueue,0,0, items,0,nil);	// !!!o. add to beginning. Length(fURLqueue)       	end       else begin       	fURLqueue := Clone(items);	// !!!k       	if fHTTPoptions       	then fHTTPoptions.fURLqueue := fURLqueue;       	end;       //Write("addQueue: "); Print(fURLqueue);       end,     fAbort: nil,     fEndpoint: nil,     fHTTPOptions: nil,     fHTTPCurArgs: nil,     fRemoteHostName: nil,     fTextFilter:       nil	// !!!f       ,     fLinkStatusView: nil,     declareSelf: '|WWW FSM|,     callbackError:       func(msg, options)	// !!!j. eventually remove (!!!k).moved to Cleanup       if options       then begin       //:MNotifyError(kAppName, msg);       //Print(msg);       	if options.InetStatus       	then options.dispatchApp:?errorStatus(msg);       	local helperApp := options.helperApp;       	if helperApp and helperApp.callBackError       	then begin       		if msg       		then helperApp:callBackError(msg, options);       		if isReadOnly(helperApp)       		then options.helperApp := helperApp := Clone(helperApp);       		helperApp.callBackError := NIL;       		end;       	end,     fDNSReceiver: nil,     fHTTPRequest: nil,     vHeader: nil,     fHTTPExtra: nil     ,     fURLqueue: nil,     fRemotePortNumber: nil,     fDNSaddresses: nil,     fAuthentication: nil,     fLocalPortNumber: nil,     fPowerOffState: nil,     fHTTPeData:       nil	// encoded data string for fHTTPData       ,     TraceFSM:       func(when, state, event, params) // share       :PrintFSM("When = ", when, state, event, params),     setAuth:       func(hostName, hostVal, prefsEntry, perm)	// !!!g       if hostName       then begin       	local fr, hostSym := Intern(hostName);       	if prefsEntry and not (fr := prefsEntry.authentication) and hostVal       	then fr := {};              	if fr       	then begin       		if perm and hostVal       		then begin       			fr.(hostSym) := hostVal;       			hostVal := nil;		// zap temporary       			end       		else RemoveSlot(fr, hostSym);       		prefsEntry.authentication := fr;	// add or dirty       		EntryChangeXmit(prefsEntry,nil);       		end;       	       	if not fAuthentication and hostVal       	then fAuthentication :={};       	if fAuthentication       	then if hostVal       		then fAuthentication.(hostSym) := hostVal       		else RemoveSlot(fAuthentication, hostSym);       	end,     myEndPoint:       {// made separate for eventHandler. moved here from newURL       _proto:	protoBasicEndpoint, // replace in Instantiate if encoding              //encoding: kMacRomanEncoding,	// default              premDisc: true, // try it once              eventHandler: func(event)       begin       	if kDebugHTTP       	then Print("Inet event! service:" && event.serviceID &&       		"eventCode:" && event.eventCode && "data:" && event.data);              	if kDebugHTTP and fSerial       	then begin       		:Output("serviceID:" && event.serviceID & crlf, nil, nil);       		:Output("eventCode:" && event.eventCode & crlf, nil, nil);       		:Output("data:" && event.data & crlf, nil, nil);       		end;              	if premDisc and       		(event.eventCode = kEventDisconnect or       		 event.eventCode = kEventRelease)       	then begin       		premDisc := nil;	// only once       		try :Input()       		onexception |evt.ex|       		do if kDebugHTTP then Print(currentException());       		end;       end,              inputCancel: func()	// !!!o       begin       	try :Cancel(premDisc := nil) onexception |evt.ex.comm| do nil;       	:SetInputSpec(nil);       end,       }    };Genesis :=    {viewBounds: {left: 8, top: 16, right: 112, bottom: 56},     terminal: true,     declareSelf: 'Genesis,     _proto: _v218_0    };AddStepForm(HTTP Machine, Genesis);newURL :=    {declareSelf: 'newURL,     action:       func(href, method, enctype, edata, data, options)       begin       /* called by: newtscape:DoEvent (kSendHTTP, addFile), popQueue              assumptions              methods:       [optional] :getPictObj [kNewtsCapeSymbol/GIF only?]       [required] :dispatchFile, :getURL (from protoNamePassword)       	:cancelRequest (for Stop)              Layouts: protoNamePassword (for authentication)              possible options (slots): (alphabetical)       allowHosts, base, cacheEntry, cacheHTML, cacheImages, cacheOnly, cookies,       dispatchApp, edata, header(?), httpProxy, httpNoProxy, icon,        InetStatus, loadImages, processOption, removeComments,         transferMode, trustHTML, trustImages,               constants/functions:       -- see HTTP Project Data       */              	nie20 := GlobalFnExists('InetGrabLinkVerbose);       	options.error := options.results := NIL;	// !!!k,j,i.  if set in DispatchCache?              	fHTTPCurArgs := [href, method, enctype, edata, data, fHTTPOptions := options]; // for POST redirect (fInputHeaderSpec)       	local entry := options.cacheEntry;       //print("newURL"); Print(options);       	if entry       		and not fLinkID	// !!!k. only if not connected. otherwise, do if-modified date       		and (//options.loadImages or		// for Update       		(if entry.bitmap       		then options.trustImages //or options.keepQueryImages       		else options.trustHTML   //or options.keepQueryHTML       		) or       		StrFilled(entry.edata) // call kTempCacheEntry with (entry)       		)       	then begin       		:dispatchCache(entry);	// !!!k       		return :popQueue(options);       		end;              	// The format of a URL is:       	// <protocol>://<host:port>[/][path][file]              	local ARRAY hurl := :parseURL(href);       	options.base := vBase := hurl[0]; // complete path, possibly with ending /       	fOriginalHostName := hurl[2];       	fOriginalPortNumber := hurl[3];       	local file := hurl[4], sym, val;              /*	if options.allowHosts       	then begin       		local allow := nil;       		foreach val in options.allowHosts       		do if StrFilled(val) and EndsWith(fOriginalHostName, val)       		then break allow := true;       //Print(fOriginalHostName);       		if not allow       		then return :popQueue(options);	// skip this. check other queued URLs (if any)       		end;       */       	if not GetGlobalFn('InetDisplayStatus)	// no NIE installed? (cache already handled)       	then return NIL;       	options.dispatchApp:?resetStatus();	// !!!j              	fHTTPExtra := call kMakeAttrib with (kAccept,       		if StrFilled(val := options.acceptAttr)	// !!!v       		then val       		else kAllMediaType); // for now (maybe explicit listing later?). nil;              	if StrFilled(val := options.acceptLangAttr)	// !!!v       	then fHTTPExtra := fHTTPExtra &       			call kMakeAttrib with (kAcceptLang, val);              	if val := :getAuth(fOriginalHostName,options)       	then fHTTPExtra := fHTTPExtra &       			call kMakeAttrib with (kAuthorization, kBasic && val);              	if entry and not options.reload and ((val := entry.modified) or (val := EntryModTime(entry))) // !!!k       	then fHTTPExtra := fHTTPExtra &       			call kMakeAttrib with (kIfModified, call kPrintDate with (val));              	// check/add cookie info       //if kDebugHTTP then begin Print("cookies:" && fOriginalHostName && file); Print(options.cookies); end;       	fHTTPExtra := fHTTPExtra &       		call kMakeAttrib with (kSendCookie, call kGetCookies with (options.cookies, fOriginalHostName, file, not HasSlot(options,'cookies)));              	if isFrame(val := options.extraHeader)       	then begin       		foreach sym,val in val       		do fHTTPExtra := fHTTPExtra & call kMakeAttrib with (sym, val);       		RemoveSlot(options, 'extraHeader);	// one-time?       		end;              	local proxy := options.httpProxy;               	//fSerial := NIL;       	if StrFilled(proxy)       	then if BeginsWith(proxy, kHTTP)       		then begin       			local proxylist, fn;       			if StrFilled(proxylist := options.httpProxyOnly)	// !!!j       			then begin // only keep proxy if it matches       				proxy := nil;       				fn := StrTokenize(proxylist, $;);       				while val := call fn with ()       				do  if StrFilled(TrimString(val)) and EndsWith(fOriginalHostName, val)       					then break proxy := options.httpProxy;	// reset again       				end;              			if proxy and StrFilled(proxylist := options.httpNoProxy)       			then begin	// skip proxy if it matches       				fn := StrTokenize(proxylist, $;);       				while val := call fn with ()       				do  if StrFilled(TrimString(val)) and EndsWith(fOriginalHostName, val)       					then break proxy := nil;       				end;       		       			if proxy       			then begin       				hurl := :parseURL(proxy);       				if val := :getAuth(hurl[2],options)		// any name/pw for proxy host (fRemoteHostName)?       				then fHTTPExtra := fHTTPExtra &       					call kMakeAttrib with (kProxyAuthorization, kBasic && val);       				end;       			end;       /*       		else if BeginsWith(proxy, "serial:") and       			val := StringToNumber(SubStr(proxy,7,nil))       		then fSerial := Floor(val);	       */              	// moved last to be after possible proxy authenticate       	fHTTPData := data;	// save the frame       	if (fHTTPeData := edata) and not StrEqual(method, kGet)	// POST (encoded) data, or PUT??       		and not StrEqual(method, kHead)       	then fHTTPExtra := fHTTPExtra &       			call kMakeAttrib with (kContentLength, StrLen(edata)) &       			call kMakeAttrib with (kContentType, enctype) &       			crlf & edata;              	//local protocol := Intern(hurl[1]);       	fRemoteHostName		:= hurl[2];       	fRemotePortNumber	:= hurl[3];       	fHTTPRequest 		:= if StrFilled(proxy) then vBase else file;       	fHTTPMethod 		:= UPCASE(Clone(method)); 	// GET, POST              	if kDebugHTTP then       		begin       		print("proxy:" && proxy); print("base:" && vBase);       		print("protocol:" && hurl[1]);       		print("host:" 	&& fRemoteHostName);       		print("port:" 	&& fRemotePortNumber);       		print("method:"&& fHTTPMethod);       		print("file:" 	&& fHTTPRequest);       		print("request:" && fHTTPExtra);       		end;              	fConnectAction := 'Connect;       	fState := 'Connecting;              	// fLinkID := fConnectionSlipView := fGrabLinkReceiver :=       	fPowerOffState := fAbort := fRemoteIPAddress := fLinkStatusView := fDNSReceiver := nil;              	//fRemoteIPAddressStr := "";       	fLocalPortNumber := 0;		// ephemeral port       	fProtocol := 1;				// 1 = TCP, 2 = UDP              /* moved to Instantiate (prevent cleanup if we never connect)       	fEndpoint := {       		_proto:		myEndpoint,       		_parent:	fsm,       		};       */              	RegPowerOff(kAppSymbol,       		func(what, why)			// we create the closure here so as to set up SELF as the state machine frame in the closure       		begin       			if what = 'okToPowerOff       			then begin       				if why <> 'idle						// keep the unit awake whenever we're connected       					or fsm.fState = 'Disconnected	// unless the user or an application explicitly       				then return true;					// wants it to sleep       				end       								       			else if what = 'powerOff       			then begin       				if why <> 'idle						// if we simply must go to sleep but we're still       					or fsm.fState <> 'Disconnected	// connected then begin the disconnect process       				then begin       					fsm.fPowerOffState := 'holdYourHorses;	// set a flag to indicate we're powering down       					:DoEvent('Cancel, nil);       					return 'holdYourHorses;       					end;       				end;       			nil;	// ALWAYS return nil here!       		end);              	// Connected -> SendHTTPRequest uses: fHTTPRequest, fHTTPMethod, fHTTPExtra               /* note: could do autoLogin to a specific link? but not documented by name?       currently,just assume true/non-empty as default       inetgetalllinksstatus()	// map thru names?       InetGetDefaultLinkID()       InetGetLinkEntry(5563)       */       	local val := options.autoLogin;       	if fSerial or (val and not IsString(val)) or StrFilled(val)	// e.g., schedule "delay"       	then :DoEvent('OpenConnectionConnect, nil)       	else begin       		// inline. use cache entry if not connected       		if fLinkId and InetGetLinkStatus(fLinkID) <> 'Connected       		then begin       if kDebugHTTP then Print("no longer connected!!");       			fLinkID := NIL;       			end;              		//:DoEvent('OpenConnectionSlip, nil);       		fConnectionSlipView := InetOpenConnectionSlip(fLinkID, self, 'MConnectionSlipCallback);       		end;       end,     viewBounds: {left: 8, top: 26, right: 96, bottom: 42},     MConnectionSlipCallback:       func(what)       begin       if kDebugHTTP then Print("connection callback:" && what);       	if what = 'Connect       	then :DoEvent('OpenConnectionConnect, nil)       	else if what = 'Close       	then :DoEvent('OpenConnectionClose, nil);       end,     _proto: _v218_0    };AddStepForm(Genesis, newURL);Open Connection Connect :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     declareSelf: 'OpenConnectionConnect,     action:       if fSerial       then func() :DoEvent('OpenLinkSuccess, nil)       else kDoNextState	// !!!b       ,     nextState: 'OpenLink,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Genesis, Open Connection Connect);Open Connection Close :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     declareSelf: 'OpenConnectionClose,     nextState: 'CleanUp,     action:       func()       begin       	local entry := fHTTPoptions.cacheEntry, len;       	if not entry and fURLqueue and (len := Length(fURLqueue)) > 0       	then entry := fURLqueue[len-1];       	:addQueue(NIL); 	// !!!j. // fHTTPoptions.loadImages ??       	if not fHTTPoptions.error	// !!!k       	then fHTTPoptions.error := "user cancelled";       	//:callBackError("user cancelled", fHTTPoptions);	// !!!j,h       	if entry       	then fHTTPoptions.results := [entry];       	:DoEvent('Cleanup, nil);	// nextState       end,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Genesis, Open Connection Close);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	if fConnectionSlipView       	then fConnectionSlipView:Close();              	fsm:addQueue(NIL);	// !!!j       	fHTTPoptions.results := [fHTTPoptions.cacheEntry];	// !!!k       	:DoEvent('CleanUp, nil);	// nextState       end,     nextState: 'CleanUp,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Genesis, Cancel);Genesis :=    {viewBounds: {left: 18, top: 74, right: 106, bottom: 90},     declareSelf: 'Genesis,     nextNoIdle: true,     action:       func()	// !!!h       if fHTTPoptions       then begin              	local arg, dispatchApp := fHTTPoptions.dispatchApp;       	dispatchApp:?setRun(nil);	// !!!g       	if arg := fHTTPoptions.error // !!!k       	then begin       //:MNotifyError(kAppName, msg);       		if arg <> true       		then begin       //Print("Genesis callback error:" && arg);       			if fHTTPoptions.InetStatus       			then dispatchApp:?errorStatus(arg);       			fHTTPoptions.helperApp:?callBackError(arg, fHTTPoptions);       			end;       		fHTTPoptions.error := NIL;       		end;              	if isArray(arg := fHTTPoptions.results)	// !!!k. moved from ReceiveText/BinarySuccess, ReceiveCache       	then begin       		if Length(arg)=1       		then :dispatchCache(arg[0])       		else PerformIfDefined(dispatchApp, 'dispatchFile, arg);	// !!!n       		// this may have added to queue       		fHTTPoptions.results := fHTTPoptions.cacheEntry := nil;	// !!!v. moved to end (otherwise, lost cacheEntry for .jpg)       		end;              //Write("Gen fURLqueue: "); Print(fURLqueue);       	fsm:popQueue(fHTTPoptions);		// !!!k. moved from Cleanup       end,     _proto: _v218_0    };AddStepForm(Genesis, Genesis);Open Link :=    {viewBounds: {left: 8, top: 176, right: 112, bottom: 312},     declareSelf: 'OpenLink,     _proto: _v218_0    };AddStepForm(HTTP Machine, Open Link);Open Link :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'OpenLink,     action:       func()       begin       	fHTTPoptions.dispatchApp:?setRun(true);	// !!!g              	if fLinkID // skip grab link if already set (since we don't release until :quit)       	then begin       if kDebugOn then Print("already open!");       		:DoEvent('OpenLinkSuccess, nil);       		end              	else begin       		fHTTPoptions.dispatchApp:?setStatus(LocObj("Opening link", 'openingLinkMsg));       		InetGrabLink(fLinkID, fGrabLinkReceiver := fsm, 'MGrabLinkCallback);       		end;       end,     statusChangeCallback:       func(linkID, statusFrame)	// unused? removed in afterScript       begin       	local what := statusFrame.infoStatus;       if kDebugHTTP then begin write("status callback: "); Print(what); end;       	if what = 'connected       	then :DoEvent('OpenLinkSuccess, nil)       	else if what <> 'connecting       	then begin	// Disconnect, Disconnecting, okToDisconnect       		:DoEvent('Cancel, nil);       		return what = 'okToDisconnect;       		end;       	nil;       end,     isRegistered:       kAppSymbol	// unused? removed in afterScript       ,     _proto: _v218_0    };AddStepForm(Open Link, Open Link);// After Script for Open LinkthisView := Open Link;begin	RemoveSlot(thisView, 'isRegistered);	RemoveSlot(thisView, 'statusChangeCallback);endOpen Link Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     nextState: 'GetAddress,     declareSelf: 'OpenLinkSuccess,     action:       func()       begin       	//fGrabLinkReceiver := nil;              	if fAbort       	then :DoEvent('Abort, nil)              	else if fSerial or       		(nie20 and       		(StrEqual(fRemoteHostName, "localhost") or StrEqual(fRemoteHostName, "127.0.0.1")) and	// !!!t       			fRemoteIPAddress := InetGetIPAddress('localAddress)) or       		(nie20 and InetIsValidIPAddressStr(fRemoteHostName) and				// e.g., 205.134.252.158       			fRemoteIPAddress := InetIPStringToAddress(fRemoteHostName)) or       		(fDNSaddresses and fRemoteIPAddress := fDNSaddresses.(Intern(fRemoteHostName)))	// cached earlier       	then :DoEvent('GetAddressSuccess, nil)              	else begin       		fHTTPoptions.dispatchApp:?setStatus(       			LocObj("Looking up host", 'lookupHostMsg) & $: && fRemoteHostName);       		:DoEvent('GetAddress, nil);       		end;       end,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Open Link, Open Link Success);Open Link Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     nextState: 'CleanUp,     declareSelf: 'OpenLinkFailure,     action: kErrDoNextState     ,     NotifyMsg: LocObj("Opening link", 'openingLinkMsg),     _proto: _v218_0    };AddStepForm(Open Link, Open Link Failure);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;       	if not fHTTPoptions.error	// !!!k       	then fHTTPoptions.error := LocObj("Cancelling Open Link", 'cancelOpenMsg);       	//:callbackError(LocObj("Cancelling Open Link", 'cancelOpenMsg), fHTTPoptions);	// !!!j,h       	InetCancelLink(fLinkID, fGrabLinkReceiver, 'MCancelLinkCallback);       end,     _proto: _v218_0    };AddStepForm(Open Link, Cancel);Cancel Link Success :=    {viewBounds: {left: 8, top: 80, right: 96, bottom: 96},     declareSelf: 'CancelLinkSuccess,     _proto: _v218_0    };AddStepForm(Open Link, Cancel Link Success);Cancel Link Failure :=    {viewBounds: {left: 8, top: 96, right: 96, bottom: 112},     declareSelf: 'CancelLinkFailure,     action: kErrDoNextState,     NotifyMsg: LocObj("Cancelling Open Link", 'cancelOpenMsg),     _proto: _v218_0    };AddStepForm(Open Link, Cancel Link Failure);Get Address :=    {viewBounds: {left: 8, top: 320, right: 112, bottom: 424},     declareSelf: 'GetAddress,     _proto: _v218_0    };AddStepForm(HTTP Machine, Get Address);Get Address :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'GetAddress,     action:       func()       DNSGetAddressFromName(fRemoteHostName, fDNSReceiver := self, 'MGetAddressCallback)     ,     MGetAddressCallback:       func(results, error)       begin       	if error       		or not results       		or Length(results) < 1       	then return :DoEvent('GetAddressFailure, [error]);       	       	if not fDNSaddresses	// our own session cache       	then fDNSaddresses := {};       	fDNSaddresses.(Intern(fRemoteHostName)) := fRemoteIPAddress := results[0].resultIPAddress;              	:DoEvent('GetAddressSuccess, nil);       end,     MCancelDNSCallback:       func()       :DoEvent('GetAddressFailure, [-666]),     _proto: _v218_0    };AddStepForm(Get Address, Get Address);Get Address Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     nextState: 'Instantiate,     declareSelf: 'GetAddressSuccess,     action:       func()       begin       	fDNSReceiver := nil;              	if fAbort       	then return :DoEvent('Abort, nil);              	local txt :=       		if fSerial then "Serial"       		else LocObj("IP Address", 'IPaddressMsg) & $: &&       			if nie20 //GlobalFnExists('InetIPAddressToString)       			then InetIPAddressToString(fRemoteIPAddress)       			else :MIPAddressToString(fRemoteIPAddress);       if kDebugHTTP then Print(fRemoteIPAddress);              	fHTTPoptions.dispatchApp:?setStatus(txt);              	:DoEvent('Instantiate, nil);       end,     MIPAddressToString:       func(address)	// Convert a 4 byte array to a "w.x.y.z" string. or use kNumToHostAddr(Inet Constant)?       begin       	if isArray(address)       	and Length(address) = 4 then       		NumberStr(address[0]) & $. & NumberStr(address[1]) & $. & NumberStr(address[2]) & $. & NumberStr(address[3])       	else       		"";       end,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Get Address, Get Address Success);Get Address Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     nextState: 'CloseLink,     declareSelf: 'GetAddressFailure,     action:       kErrDoNextState	// fDNSReceiver := nil in Cleanup       ,     NotifyMsg: LocObj("Looking up host", 'lookupHostMsg),     _proto: _v218_0    };AddStepForm(Get Address, Get Address Failure);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	if fDNSReceiver       	then DNSCancelRequests(fDNSReceiver, 'MCancelDNSCallback);       end,     _proto: _v218_0    };AddStepForm(Get Address, Cancel);Abort :=    {viewBounds: {left: 8, top: 80, right: 96, bottom: 96},     declareSelf: 'Abort,     action: kDoNextState,     nextState: 'closeLink,     _proto: _v218_0    };AddStepForm(Get Address, Abort);Instantiate :=    {viewBounds: {left: 120, top: 16, right: 224, bottom: 120},     declareSelf: 'Instantiate,     _proto: _v218_0    };AddStepForm(HTTP Machine, Instantiate);Instantiate :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       DefineGlobalConstant('kFixChars,       begin       	local ARRAY gASCIIToUnicode := '[ // from Q&A doc       		0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1,       		0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8,       		0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3,       		0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC,       		0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF,       		0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8,       		0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211,       		0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x2126, 0x00E6, 0x00F8,       		0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB,       		0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153,       		0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA,       		0x00FF, 0x0178, 0x2044, 0x00A4, 0x2039, 0x203A, 0xFB01, 0xFB02,       		0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1,       		0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4,       		0xF7FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC,       		0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7       		];       	local ARRAY ranges := '[	// to remap back to kCharNames       		// !!!g. do all except undef and remapped       		160,165,       		//166: brvbar	[remap]       		167,172,       		//173: shy		[remap]       		174,177,       		//178: sup2		[undef]       		//179: sup3		[undef]       		180,184,       		//185: sup1 	[undef]       		186,187,       		//188: frac14	[undef]       		//189: frac12	[undef]       		//190: frac34	[undef]       		191,207,       		//208: ETH		[undef]       		209,214,       		//215: times	[remap]       		216,220,       		//221: Yacute	[undef]       		//222: THORN	[undef]       		223,239,       		//240: eth		[undef]       		241,252,       		//253: yacute	[undef]       		//254: thorn	[undef]       		255,255              /*		192,207,       		209,214,       		216,220,       		223,239,       		241,246,       		248,252,       		255,255       */		];        	local INT i, r;       	local old, new, ch;              	// remap back to "original" chars: 160-255       	for r := 0 to Length(ranges)-1 by 2       	do  for i := ranges[r] to ranges[r+1]       		do begin       			old := old & Chr(gASCIIToUnicode[i-128]);       			new := new & Chr(i);       			end;              	// remap to other chars: 130-159; and 166,173,215       	foreach r,i in kCharExceptNames        	do  if IsCharacter(ch := kCharExceptValues[r])  // single chars w/o no overlap in ranges above (215?)       		then begin       			old := old & Chr(gASCIIToUnicode[i-128]);       			new := new & ch;       			end;              	ranges := '[	// !!!g       		1,8,	// tab(9),lf(10) ok       		11,12,	// return(13) ok       		14,31,       		];       	for r := 0 to Length(ranges)-1 by 2       	do  for i := ranges[r] to ranges[r+1]       		do begin       			old := old & Chr(i);       			new := new & $ ;       			end;              	if StrLen(old) <> StrLen(new)       	then Print("kFixChars old:" && old & "\nkFixChars new:" && new);       	[old, new];       end);                     func()       begin       	fTextFilter := NIL;	// !!!f       	local protoEncoding := call kInitGlobal with ('protos,{}).NTE_protoBasicEndPoint;       	if protoEncoding       	then begin       		myEndpoint := Clone(myEndpoint);       		myEndpoint._proto := protoEncoding;	// replace       		myEndpoint.NTEncoding := {	//GetAppPrefs(kAppSymbol, {}).NTEncoding       			prefs: fHTTPOptions.NTEncoding,       				// preference data for selecting encoding table.       				// this value must be set before call instantiate().       			defaultEncoding:	kDefaultEncoding,       				// default value will be used if prefs is nil.       			};       		end       /*       247 184 710 64258 8240 402 8249       "ÖüößäÄÜ"       "§"       */       	else if fHTTPOptions.fixISO	// !!!f       	then fTextFilter := kFixChars;	// for SubstituteChars in fInputTextSpec       		       		// or maybe do an Encoding???              		// I couldn't figure out how to make this work       		// filter: in fInputHeaderSpec, fInputTextSpec       		/*'{byteProxy: [       			{byte: $\D6, 	proxy: $\D6},	// 	$\F7       			{byte: $\FC, 	proxy: $\FC},	// 	$\B8       			{byte: $\F6, 	proxy: $\F6},	// 	$\u02C6       			{byte: $\DF, 	proxy: $\DF},	// §	$\uFB02       			{byte: $\E4, 	proxy: $\E4},	// 	$\u2030       			{byte: $\C4,	proxy: $\C4},	// 	$\u0192       			{byte: $\DC, 	proxy: $\DC},	// 	$\u2039       			],       		};*/              	fEndpoint := {	// moved here from newURL              	_proto:		myEndpoint,              	_parent:	fsm,            	};              	try       		fEndPoint:Instantiate(fEndPoint, :MBuildConfigOptions(fLinkID, fProtocol));       	onexception |evt.ex| do       		return :DoEvent('InstantiateFailure, [CurrentException()]);       	       	:DoEvent('InstantiateSuccess, nil);       end,     declareSelf: 'Instantiate,     MBuildConfigOptions:       func(linkID, protocol)       if fSerial       then [       {label:	kCMSAsyncSerial,	//kCMSMNPID 	MNP??       type:	'service,       opCode:	opSetRequired,       result:	nil,       },              {label:	kCMOSerialIOParms,       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data:	{       	arglist: [       		k1StopBits,		// 1 stop bit       		kNoParity,		// no parity bit       		k8DataBits,		// 8 data bits       		fSerial,		// data rate in bps		/**/       		],       	typelist: [       		'struct,       		'long,			// stop bits       		'long,			// parity       		'long,			// data bits       		'long,			// bps       		],       	},       },              {label:	kCMOInputFlowControlParms,       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data:	{       	arglist: [       		unicodeDC1, 	// xonChar       		unicodeDC3, 	// xoffChar       		true, 			// useSoftFlowControl       		nil, 			// useHardFlowControl       		0, 				// not needed; returned       		0,	 			// not needed; returned       		],       	typelist: [       		'struct,       		'byte,			// XON character       		'byte,			// XOFF character       		'boolean,		// software flow control       		'boolean,		// hardware flow control       		'boolean,		// hardware flow blocked       		'boolean,		// software flow blocked       		],       	},       },              {label:	kCMOOutputFlowControlParms,       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data: 	{       	arglist: [       		unicodeDC1, 	// xonChar	       		unicodeDC3, 	// xoffChar	       		true, 			// useSoftFlowControl	       		nil, 			// useHardFlowControl	       		0, 				// not needed; returned	       		0,	 			// not needed; returned	       		],       	typelist:	[       		'struct,       		'byte,			// XON character       		'byte,			// XOFF character       		'boolean,		// software flow control       		'boolean,		// hardware flow control       		'boolean,		// hardware flow blocked       		'boolean,		// software flow blocked       		],       	},       },              {label:	kCMOSerialBuffers,       type:	'option,       opCode:	opSetRequired,       form:	'template,		// not needed       result:	nil,			// not needed; returned       data: {       	arglist: [       		512, 			// use 512 (default) byte transmit buffer       		4096,	 		// use 4K byte receive buffer (this is larger than kTextXferSize & kBinaryXferSize)       		8, 				// remember up to 8 error characters ?       		],       	typelist: [       		'struct,       		'ulong,			// output buffer size in bytes       		'ulong, 		// input buffer size in bytes       		'ulong, 		// error characters to remember       		],       	},       },       /*       // MNP       {type:	'option,       label:	kCMOMNPDataRate,       opCode:	opSetRequired,       form:	'number,		       data:	fSerial,       },              {type:	'option,       label:	kCMOMNPCompression,       opCode:	opSetRequired,       form:	'number,		       data:	kMNPCompressionV42bis,	//kMNPCompressionMNP5, kMNPCompressionNone,       },       */       ]              else [       {label:	"inet",       type:	'service,       opCode:	opSetRequired,       result:	nil,       },              {label:	"ilid",			// set the link id       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data:	{       	arglist: [       		linkID, ],		/**/       	typelist:	[       		'struct,       		'ulong,       		],       	},       },       		       {label:	"itsv",			// set the transport protocol (TCP or UCP)       type:	'option,       opCode:	opSetRequired,       result:	nil,       form:	'template,       data: {       	arglist: [       		protocol,	],	/**/       	typelist: [       		'struct,       		'ulong,       		],       	},       },       ],     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Instantiate, Instantiate);Instantiate Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       func()       :DoEvent(if fAbort then 'Abort else 'Bind, nil),     declareSelf: 'InstantiateSuccess,     nextState: 'Bind,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Instantiate, Instantiate Success);Instantiate Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action: kErrDoNextState,     declareSelf: 'InstantiateFailure,     nextState: 'CloseLink,     NotifyMsg: LocObj("Instantiating", 'instantiatingMsg),     _proto: _v218_0    };AddStepForm(Instantiate, Instantiate Failure);Abort :=    {viewBounds: {left: 18, top: 58, right: 106, bottom: 74},     action: kDoNextState,     declareSelf: 'Abort,     nextState: 'CloseLink,     _proto: _v218_0    };AddStepForm(Instantiate, Abort);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       kDoCancelAbort	// fAbort := true;       ,     _proto: _v218_0    };AddStepForm(Instantiate, Cancel);Bind :=    {viewBounds: {left: 120, top: 128, right: 224, bottom: 232},     declareSelf: 'Bind,     _proto: _v218_0    };AddStepForm(HTTP Machine, Bind);Bind :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'Bind,     action:       func()       begin       /*	if fLinkStatusView       	then InetDisplayStatus(fLinkID, fLinkStatusView, {       		statusText: "Binding to port",       		icon: icon,       		});       */       	fEndPoint:Bind(:MBuildConfigOptions(       		fLocalPortNumber,       		fConnectAction = 'Connect),       		fCompletionSpec);       end,     fCompletionSpec:       {_proto: kCompletionSpec,       failEvent: 'BindFailure,       succEvent: 'BindSuccess,       }       /*{async:					true,       	reqTimeout:			kNoTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('BindFailure, [result]);       									else       										ep:DoEvent('BindSuccess, nil);       								end,	} */,     MBuildConfigOptions:       func(localPort, useDefaultPort)       if fSerial       then NIL              else [       {label:		"ilpt",				// set the local port       type:		'option,       opCode:		opSetRequired,       result:		nil,       form:		'template,       data:	{       	arglist:		[       		localPort,				// local port number /**/       		useDefaultPort,			// use default port	/**/       		],       	typelist:	[       		'struct,       		'short,       		'boolean,       		],       	},       },       ],     _proto: _v218_0    };AddStepForm(Bind, Bind);Bind Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     declareSelf: 'BindSuccess,     action: func() :DoEvent(if fAbort then 'Abort else 'Connect, nil),     nextState: 'Connect,     _proto: _v218_0    };AddStepForm(Bind, Bind Success);Bind Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     declareSelf: 'BindFailure,     action: kErrDoNextState,     nextState: 'Dispose,     NotifyMsg: LocObj("Binding to port", 'bindPortMsg),     _proto: _v218_0    };AddStepForm(Bind, Bind Failure);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       kDoCancelEP       /*func()       begin       	fAbort := true;       	       	try       		fEndPoint:?Cancel(nil);       	onexception |evt.ex.comm| do       		nil;       end*/,     _proto: _v218_0    };AddStepForm(Bind, Cancel);Abort :=    {viewBounds: {left: 8, top: 80, right: 96, bottom: 96},     declareSelf: 'Abort,     action: kDoNextState,     nextState: 'Dispose,     _proto: _v218_0    };AddStepForm(Bind, Abort);Connect :=    {viewBounds: {left: 120, top: 240, right: 224, bottom: 376},     declareSelf: 'Connect,     _proto: _v218_0    };AddStepForm(HTTP Machine, Connect);Connect :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'Connect,     action:       func()       begin       	fHTTPoptions.dispatchApp:?setStatus(LocObj("Connecting to port", 'connectingPortMsg) && fRemotePortNumber);              	if fConnectAction = 'Connect       	then fEndPoint:Connect(:MBuildConnectConfigOptions(fRemoteIPAddress, fRemotePortNumber, opSetRequired), fCompletionSpec_Connect);       end,     fCompletionSpec_Connect:       {_proto: kCompletionSpec,       failEvent: 'ConnectFailure,       succEvent: 'ConnectSuccess,       }       /*       {	async:					true,       	reqTimeout:			kNoTimeout,       	completionScript:	func(ep, options, result)       		if result then       			ep:DoEvent('ConnectFailure, [result]);       		else       			ep:DoEvent('ConnectSuccess, nil),       }       */,     MBuildConnectConfigOptions:       func(remoteAddr, remotePort, opcode)       if fSerial       then NIL              else [       {label:	"itrs",			// set the TCP remote socket       type:	'option,       opCode:	opcode, //*** opSetRequired, opGetCurrent(listen)       result:	nil,       form:	'template,       data:	{       	arglist: [       		remoteAddr[0],	// remote host addr - byte 1 	/**/       		remoteAddr[1],	// remote host addr - byte 2       		remoteAddr[2],	// remote host addr - byte 3       		remoteAddr[3],	// remote host addr - byte 4       		remotePort,		// remote port number 			/**/       		],		       	typelist: [       		'struct,       		'byte,       		'byte,       		'byte,       		'byte,       		'short,       		],       	},       }],     _proto: _v218_0    };AddStepForm(Connect, Connect);Connect Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       func()       begin       	/* // not nec since so ephemeral?       	if fHTTPoptions.InetStatus       	then InetDisplayStatus(fLinkID, fLinkStatusView,       		{statusText: "Connected",       		icon: icon,       		}); */              /*       Write("conn speed: "); Print(fEndPoint:Option([{       	type:		'option,       	label:		kCMOModemConnectSpeed,       	opCode:		opGetCurrent,       	form: 		'number,		       	data : 		0,       	}], nil));       */              	:DoEvent(fState := 'Connected, nil);       end,     declareSelf: 'ConnectSuccess,     nextState: 'Connected,     _proto: _v218_0    };AddStepForm(Connect, Connect Success);Connect Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action: kErrDoNextState,     declareSelf: 'ConnectFailure,     nextState: 'UnBind,     NotifyMsg: LocObj("Connecting to port", 'connectingPortMsg),     _proto: _v218_0    };AddStepForm(Connect, Connect Failure);Cancel :=    {viewBounds: {left: 8, top: 96, right: 96, bottom: 112},     declareSelf: 'Cancel,     action: kDoCancelEP,     _proto: _v218_0    };AddStepForm(Connect, Cancel);Abort :=    {viewBounds: {left: 8, top: 112, right: 96, bottom: 128},     declareSelf: 'Abort,     action: kDoNextState,     nextState: 'Unbind,     _proto: _v218_0    };AddStepForm(Connect, Abort);Connected :=    {viewBounds: {left: 232, top: 16, right: 336, bottom: 120},     declareSelf: 'Connected,     _proto: _v218_0    };AddStepForm(HTTP Machine, Connected);Connected :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Connected,     action:       func()       begin       /*	if fLinkStatusView       	then fLinkStatusView := InetDisplayStatus(fLinkID, fLinkStatusView, nil);       */              	:DoEvent(if fAbort then 'Disconnect else 'SendHTTPRequest, nil);	// fill-in args in event       end,     _proto: _v218_0    };AddStepForm(Connected, Connected);Disconnect :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	fHTTPoptions.dispatchApp:?setStatus(LocObj("Disconnecting port", 'disconnectingPortMsg));              	fState := 'Disconnecting;       	fAbort := true;              	try       		fEndPoint:?Disconnect(true, fCompletionSpec);       	onexception |evt.ex| do       		:DoEvent('DisconnectFailure, [CurrentException()]);       end,     declareSelf: 'Disconnect,     fCompletionSpec:       {_proto: kCompletionSpec,       failEvent: 'DisconnectFailure,       succEvent: 'DisconnectSuccess,       //reqTimeout:	2000,	// ?       }       /*       {	async:					true,       	reqTimeout:			kNoTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('DisconnectFailure, [result]);       									else       										ep:DoEvent('DisconnectSuccess, nil);       								end,	} */,     _proto: _v218_0    };AddStepForm(Connected, Disconnect);Disconnect Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       kDoNextState //func() :DoEvent('UnBind, nil)       ,     declareSelf: 'DisconnectSuccess,     nextState: 'UnBind,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Connected, Disconnect Success);Disconnect Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action: kErrDoNextState,     declareSelf: 'DisconnectFailure,     nextState: 'UnBind,     NotifyMsg: LocObj("Disconnecting port", 'disconnectingPortMsg),     _proto: _v218_0    };AddStepForm(Connected, Disconnect Failure);Cancel :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     declareSelf: 'Cancel,     action:       func()       if fPowerOffState       then :DoEvent('Disconnect, nil)              else begin       	fAbort := true;       	try       		fEndPoint:?Cancel(nil);       	onexception |evt.ex.comm| do nil;       	end,     _proto: _v218_0    };AddStepForm(Connected, Cancel);sendHTTPRequest :=    {viewBounds: {left: 18, top: 26, right: 106, bottom: 42},     action:       func()       :DoEvent('SendHTTPRequest, [ fHTTPRequest, fHTTPMethod, fHTTPExtra]) // set in newURL       ,     declareSelf: 'sendHTTPRequest,     nextState: 'SendHTTPRequest,     _proto: _v218_0    };AddStepForm(Connected, sendHTTPRequest);UnBind :=    {viewBounds: {left: 232, top: 240, right: 336, bottom: 344},     declareSelf: 'UnBind,     _proto: _v218_0    };AddStepForm(HTTP Machine, UnBind);UnBind :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'UnBind,     action:       func()       begin       // fHTTPoptions.dispatchApp:?setStatus("UnBinding");       	try       		fEndPoint:?UnBind(fCompletionSpec);       	onexception |evt.ex| do       		:DoEvent('UnBindFailure, [CurrentException()]);       end,     fCompletionSpec:       {_proto: kCompletionSpec,       failEvent: 'UnBindFailure,       succEvent: 'UnBindSuccess,       //reqTimeout:	2000,	// ?              }       /* {	async:					true,       	reqTimeout:			kNoTimeout,       	completionScript:	func(ep, options, result)       								begin       									if result then       										ep:DoEvent('UnBindFailure, [result]);       									else       										ep:DoEvent('UnBindSuccess, nil);       								end,	}*/,     _proto: _v218_0    };AddStepForm(UnBind, UnBind);UnBind Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       kDoNextState //func() :DoEvent('Dispose, nil)       ,     declareSelf: 'UnBindSuccess,     nextState: 'Dispose,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(UnBind, UnBind Success);UnBind Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action: kErrDoNextState,     declareSelf: 'UnBindFailure,     nextState: 'Dispose,     NotifyMsg: LocObj("UnBinding", 'unbindingMsg),     _proto: _v218_0    };AddStepForm(UnBind, UnBind Failure);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       kDoCancelEP       /*func()       begin       	fAbort := true;       	       	try       		fEndPoint:?Cancel(nil);       	onexception |evt.ex.comm| do       		nil;       end*/,     _proto: _v218_0    };AddStepForm(UnBind, Cancel);Dispose :=    {viewBounds: {left: 232, top: 352, right: 336, bottom: 456},     declareSelf: 'Dispose,     _proto: _v218_0    };AddStepForm(HTTP Machine, Dispose);Dispose :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	try       		fEndPoint:?Dispose();       	onexception |evt.ex| do       		return :DoEvent('DisposeFailure, [CurrentException()]);              	:DoEvent('DisposeSuccess, nil);       end,     declareSelf: 'Dispose,     _proto: _v218_0    };AddStepForm(Dispose, Dispose);Dispose Success :=    {viewBounds: {left: 8, top: 32, right: 96, bottom: 48},     action:       kDoNextState //func() :DoEvent('CloseLink, nil)       ,     declareSelf: 'DisposeSuccess,     nextState: 'CloseLink,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Dispose, Dispose Success);Dispose Failure :=    {viewBounds: {left: 8, top: 48, right: 96, bottom: 64},     action: kErrDoNextState,     declareSelf: 'DisposeFailure,     nextState: 'CloseLink,     NotifyMsg: LocObj("Disposing", 'disposingMsg),     _proto: _v218_0    };AddStepForm(Dispose, Dispose Failure);Cancel :=    {viewBounds: {left: 8, top: 64, right: 96, bottom: 80},     declareSelf: 'Cancel,     action:       kDoCancelAbort	// fAbort := true       ,     _proto: _v218_0    };AddStepForm(Dispose, Cancel);Close Link :=    {viewBounds: {left: 344, top: 16, right: 448, bottom: 152},     declareSelf: 'CloseLink,     _proto: _v218_0    };AddStepForm(HTTP Machine, Close Link);Close Link :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     declareSelf: 'CloseLink,     action: kDoNextState,     nextState:       'Cleanup	// none when using CloseLinkSuccess etc.       ,     nextNoIdle: true,     _proto: _v218_0    };AddStepForm(Close Link, Close Link);Clean Up :=    {viewBounds: {left: 344, top: 160, right: 448, bottom: 200},     declareSelf: 'CleanUp,     _proto: _v218_0    };AddStepForm(HTTP Machine, Clean Up);Clean Up :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       func()       begin       	if fPowerOffState       	then begin       		fPowerOffState := nil;       		PowerOffResume(kAppSymbol);       		end;       	UnRegPowerOff(kAppSymbol);              	// fLinkID := fGrabLinkReceiver := fReleaseLinkReceiver :=       	fDNSReceiver := fRemoteHostName:= fConnectAction :=       		fLocalPortNumber := fRemotePortNumber := fRemoteIPAddress :=       		fProtocol := fConnectionSlipView := nil;              	fState := 'Disconnected;       	:DoEvent('Genesis, nil);       end,     declareSelf: 'CleanUp,     nextState: 'Genesis,     _proto: _v218_0    };AddStepForm(Clean Up, Clean Up);Cancel :=    {viewBounds: {left: 28, top: 36, right: 116, bottom: 52},     action: func() :DoEvent('Cleanup, nil),     declareSelf: 'Cancel,     _proto: _v218_0    };AddStepForm(Clean Up, Cancel);Send HTTP Request :=    {viewBounds: {left: 344, top: 208, right: 448, bottom: 400},     declareSelf: 'SendHTTPRequest,     _proto: _v218_0    };AddStepForm(HTTP Machine, Send HTTP Request);Send HTTP Request :=    {viewBounds: {left: 8, top: 16, right: 96, bottom: 32},     action:       /* Request Header       Accept                   ; Section 14.1       Accept-Charset           ; Section 14.2       Accept-Encoding          ; Section 14.3       Accept-Language          ; Section 14.4       Authorization            ; Section 14.8       From                     ; Section 14.22       Host                     ; Section 14.23       If-Modified-Since        ; Section 14.24       If-Match                 ; Section 14.25       If-None-Match            ; Section 14.26       If-Range                 ; Section 14.27       If-Unmodified-Since      ; Section 14.28       Max-Forwards             ; Section 14.31       Proxy-Authorization      ; Section 14.34       Range                    ; Section 14.36       Referer                  ; Section 14.37       User-Agent               ; Section 14.42       */              func(dataFile, dataMethod, dataExtra) // called via CloseProgressSlip       begin       	if kDebugHTTP then print( "send request" );              	fEndPoint.fInputTextSpec	:= fInputTextSpec;       	fEndPoint.fInputBinarySpec	:= fInputBinarySpec;       	fEndPoint.fInputTextSpecLine:= fInputTextSpecLine;              	vContent := nil;       	vHeader := {};              	// do dataExtra init in newURL or here??       	local ap := GetAppParams(), val;       	local cmd := // assume dataFile fixed up properly in newURL       		dataMethod && dataFile && kHTTPver & crlf &		// e.g., GET / HTTP/1.0              		call kMakeAttrib with ("Host",       			fOriginalHostName & (if fOriginalPortNumber<>80 then $: & fOriginalPortNumber)) &              		call kMakeAttrib with (kUserAgent,       			(if val := fHTTPoptions.agentPrefix then val & $ ) &       			kBrowserName & $/ & kVersionString) &              		(if StrFilled(fHTTPoptions.agentSizeRes)       		then (if val := fHTTPoptions.bitsPerPixel       			then call kMakeAttrib with ("UA-color", "mono" & val)) &              			(if val := fHTTPoptions.pageSize       			then call kMakeAttrib with ("UA-pixels",       				if val := {help: "206x216", portrait: "240x320", landscape: "320x240"}.(val)       				then val       				else ap.appAreaWidth & $x & ap.appAreaHeight))) &              		dataExtra & crlf; // authentication, cookies, (post)data              //if kDebugHTTP then       //Print(cmd);       //Print(fsm);              	fHTTPoptions.dispatchApp:?setStatus(       		//LocObj("HTTP Command", 'sendingHTTPMsg) & $: &&       			dataMethod && vBase);       	fHTTPoptions.dispatchApp:?errorStatus("");              	fEndPoint:SetInputSpec(fInputHeaderSpec);       	fEndPoint:Output(cmd, nil, nil); // fOutputSpec unused       end,     declareSelf: 'SendHTTPRequest,     fInputHeaderSpec:       /*       1xx: Informational - Request received, continuing process (1.1 only)				; 10.1       100,	"Continue",       101,	"Switching Protocols",              2xx: Success - The action was successfully received, understood, and accepted		; 10.2       200,	"OK",       201,	"Created",       202,	"Accepted",       203,	"Non-Authoritative Information",       204,	"No Content",       205,	"Reset Content",       206,	"Partial Content",              3xx: Redirection - Further action must be taken in order to complete the request	; 10.3       300,	"Multiple Choices",       301,	"Moved Permanently",       302,	"Moved Temporarily",       303,	"See Other",       304,	"Not Modified",       305,	"Use Proxy",              4xx: Client Error - The request contains bad syntax or cannot be fulfilled			; 10.4       400,	"Bad Request",       401,	"Unauthorized",       402,	"Payment Required",       403,	"Forbidden"       404,	"Not Found"       405,	"Method Not Allowed",       406,	"Not Acceptable",       407,	"Proxy Authentication Required",       408,	"Request Time-out",       409,	"Conflict",       410,	"Gone",       411,	"Length Required",       412,	"Precondition Failed",       413,	"Request Entity Too Large",       414,	"Request-URI Too Large",       415,	"Unsupported Media Type",              5xx: Server Error - The server failed to fulfill an apparently valid request		; 10.5       500,	"Internal Server Error",       501,	"Not Implemented",       502,	"Bad Gateway",       503,	"Service Unavailable",       504,	"Gateway Time-out",       505,	"HTTP Version not supported"       */              /* Header Response Fields:       Age                     ; 14.6       Location                ; 14.30       Proxy-Authenticate      ; 14.33       Public                  ; 14.35       Retry-After             ; 14.38       Server                  ; 14.39       Vary                    ; 14.43       Warning                 ; 14.45       WWW-Authenticate        ; 14.46       */              /* Entity Header Fields:       Allow                    ; 14.7       Content-Base             ; 14.11       Content-Encoding         ; 14.12       Content-Language         ; 14.13       Content-Length           ; 14.14       Content-Location         ; 14.15       Content-MD5              ; 14.16       Content-Range            ; 14.17       Content-Type             ; 14.18       ETag                     ; 14.20       Expires                  ; 14.21       Last-Modified            ; 14.29       */              DefineGlobalConstant('kErrors400, [       	400, LocObj("Bad request", 'badRequestErr),       	401, LocObj("Unauthorized; request requires user authentication", 'unauthErr),       	403, LocObj("Forbidden for unspecified reason", 'forbiddenErr),       	404, LocObj("Not found", 'notFoundErr),       	]);              DefineGlobalConstant('kErrors500, [       	500, LocObj("Internal server", 'internalErr),       	501, LocObj("Not implemented", 'notImplementedErr),       	502, LocObj("Bad gateway; invalid response from gateway or upstream server", 'badGatewayErr),       	503, LocObj("Service temporarily unavailable", 'noServiceErr),       	]);              {async:			true,       reqTimeout:		120000,	// kNoTimeout, was 60000,24000       discardAfter:	3072, 	// many,long cookies? default was only 1024       form:			'string,       termination:	{endSequence: [unicodeCR&unicodeCR, crlf&crlf, unicodeLF&unicodeLF]},              inputScript:	func(ep, data, terminator, options)       begin       //Print("\n(header callback)"); Print(data);       	local fsm := ep._parent;       	if fsm.fAbort		// !!!o       	then return ep:inputCancel();              if kDebugHTTP then Print(data);       	//SubstituteChars(data, lf, cr); // just do sub for any lfs. but this would make a copy!       	StrReplace(data, lf, cr, nil);       if kDebugHTTP then begin Print("\n(header callback)"); Print(data); end;              	local host := fsm.fOriginalHostName;       	local inputSpec, href := fsm.vBase, errMsg1, errMsg2;       	options := fsm.fHTTPoptions; // reuse var       	fsm.tcontentRead := 0;              	// rewritten to gather all fields into vHeader       	local header := fsm.vHeader;       	local spos := 0, name, val, response := "", cookies, response1;       	local attrib := call kGetAttrib with (data, $ , unicodeCR, spos);              	if attrib and BeginsWith(name := attrib[0], kHTTPStr) // allow HTTP/1.x etc.       	then begin       		spos := attrib[2];       		header.(kHTTPSym) := name && response := attrib[1]; // display server ver       		response1 := response[0];              		while spos and attrib := call kGetAttrib with (data, $:, unicodeCR, spos)       		do begin       			name := Intern(attrib[0]);       			val := attrib[1];       			spos := attrib[2];       			if name = kSetCookieSym       			then begin	// may be multiple cookies       				if not isArray(cookies := header.(kSetCookieSym))       				then header.(kSetCookieSym) := cookies := [];       				AddArraySlot(cookies, val);       				end       			else header.(name) := val;       			end;       		end;              	if cookies and isArray(options.cookies)       	then begin       		local ARRAY args := [       			options.cookies,       			host,       			cookies,       			not HasSlot(options, 'cookies),	// inherited from prefsEntry?       			];       		if options.cookiesConfirm = 'ask	// display#?       		then options.dispatchApp:Confirm(		// !!!j. AsyncConfirm       				nil, // unused       				LocObj("Add Cookies?", 'addCookiesMsg),       				[{text: LocObj("Yes", 'yesLabel), value: args, 	keyValue: 'default}, // 'yesNo       				 {text: LocObj("No",  'noLabel),  value: nil,	keyValue: 'close}],       				kPutCookies)       			       		else call kPutCookies with (args); // add cookies w/o asking       		end;              	// cache/fixup some values       	local newurl := header.(kLocationSym);       	local ctype  := call kSubStr with (       		header.(kContentTypeSym0) := header.(kContentTypeSym), // save original       		0, ";", nil);	// for J,C encoding? reassign later       	local clen 	 := header.(kContentLengthSym);              	options.dispatchApp:?setStatus(       		header.(kHTTPSym) & $; && ctype & $: && if clen then clen else $?);       if kDebugHTTP then Print(header);              	if response1 = $3 //BeginsWith(response,"3")       	then begin       		// 300 Multiple Choices       		// 301 Moved Permanently       		// 302 Moved Temporarily       		// 304 Not Modified       		if BeginsWith(response,"304")       		then begin       			ep:SetInputSpec(nil);       			return fsm:DoEvent('ReceiveCache, nil);	// use what's cached       			end;              		if newurl // ??? differentiate between permanent and temporary?       			//and not StrEqual(newurl,href)       		then begin       			local curArgs := fsm.fHTTPCurArgs;       //if kDebugHTTP then       //Print("redirect" && response & $: && newurl); Print(header); //Print(curArgs);       			curArgs[0] := call kResolveURL with (href, newurl);       			//if BeginsWith(response, "303") then 		// see other -> GET.  1.1?       			// curArgs[1] := kGet;	// !!!s. allow POST?       			//curArgs[3]:= curArgs[4] := NIL;              			//options.cacheEntry := NIL;       			if not options.predirectedURL			// only once?       			then options.predirectedURL := href;              			fsm:addQueue([curArgs]);	// !!!o       			/*if fsm.fURLqueue	// see popQueue       			then ArrayInsert(fsm.fURLqueue, curArgs, 0) // insert       			else fsm.fURLqueue := [curArgs];*/       if kDebugHTTP then Print(fsm.fURLqueue);       			errMsg2 := LocObj("redirection", 'redirectionMsg) && newurl;       			end;       		end              	else if BeginsWith(response,"401") or BeginsWith(response,"407")       		then begin // Basic Authentication       			if BeginsWith(response, "407")       			then begin       				val := LocObj("Proxy", 'proxyLabel);       				host := fsm.fRemoteHostName;       				end       			else val := LocObj("Host", 'hostLabel);              			//fsm:setAuth(host,nil,newtscape.prefsEntry,true); 	// !!!g. wrong if there earlier       			//challenge := TrimString(call kSubstr with (data, kAuthenticate, " ", nil));       			//if not challenge then challenge := kBasic;       			// probably doesn't handle POST with doc properly???       			BuildContext({       				_proto:		GetLayout("protoNamePassword"),       				URL:		href,       				hostOrProxy:val,	       				host:		host,       				hosts:		[host],       				options:	options,       				newtscape:	GetRoot().(kNewtsCapeSymbol),       				fsm:		fsm,						// !!!g       				//cache:	fsm.fAuthentication,		// !!!g       				//credential (basic)??       				}):open();       			errMsg1 := "headSpec";       			errMsg2 := LocObj("requires user authentication", 'requireUserMsg);       			end              	else if response1 = $4 //BeginsWith(response,"4")       	then begin       		errMsg1 := LocObj("client", 'clientErr) && $[ & response & $];       		errMsg2 := call kLookupError with (kErrors400, Floor(StringToNumber(response)), nil);       		end              	else if response1 = $5 //BeginsWith(response,"5")       	then begin       		errMsg1 := LocObj("server", 'serverErr) & $[ & response & $];       		errMsg2 := call kLookupError with (kErrors500, Floor(StringToNumber(response)), nil);       		end              	else if BeginsWith(response, "204")       	then begin       		errMsg1 := "headSpec";       		errMsg2 := "No Content";       		end;              	if errMsg1 or errMsg2       	then begin       		ep:SetInputSpec(nil);       		return fsm:DoEvent('ReceiveFailure, [errMsg1, errMsg2]);       		end;              	// moved to after error handling       	if not ctype       	then ctype := kHTMLMediaType		// in case of 0.9 Simple or Serial:?       	else if EndsWith(href, kPKGextension) and	// see kBuiltInMediaTypes       		(BeginsWith(ctype, "application/")	// !!!u. StrEqual(ctype, kAppOctetMediaType)       		or StrEqual(ctype, kTextMediaType)       		or StrEqual(ctype, kAllMediaType)       		//or StrEqual(ctype, kWWWunknownMediaType)       		or (StrPos(ctype, "newton", 0) and EndsWith(ctype, "-pkg")))	// kNewtonPkgMediaType and others?       	then ctype := kNewtonPkgMediaType;	// fixup pkg type for older servers       	header.(kContentTypeSym) := ctype; 	// always reassign (nil, .pkg, ~J)              	fsm.vHelperApp := options.dispatchApp:?dispatchFile(ctype, href, NIL, options); // just lookup helperapp (& maybe set transferMode)       //if kDebugHTTP then Print('vHelperApp && fsm.vHelperApp);       	if not fsm.vHelperApp       	then begin       		ep:setInputSpec(nil);       		return fsm:doEvent('ReceiveFailure, [ctype, LocObj("unknown helper for", 'unknownHelperErr) && href]);       		end;              	// moved to after helper check       	header.(kContentLengthSym) := clen := call kGetInt with (clen, 0); // !!!b              	foreach name in [kDateSym, kLastModifiedSym, kExpiresSym]	// some dates       	do if val := header.(name)       	then header.(name) := call kReadDate with (val);              	options.header := header;       //if kDebugHTTP then Print(header);              	if StrEqual(fsm.fHTTPMethod, kHead)       	then begin       		ep:SetInputSpec(nil);       //if kDebugHTTP then Print(options);       		return fsm:DoEvent('ReceiveTextSuccess, [""]);       		end;              	//options.dispatchApp:?removeApp(true,true);       	local cacheEntry := options.cacheEntry;              	if options.transferMode = 'text or       		(BeginsWith(ctype, "text/") and options.transferMode <> 'binary)	       	then begin // text transfer type       		// might not know length (or length may contain lfs, which we want to replace/remove)       		fsm.vContent :=       			call kNewVBO with (       				if cacheEntry       				then EntryStore(cacheEntry)		// so on same store as entry       				else if IsString(options.HTMLstore)	// !!!g       				then LFetch(GetStores(),options.HTMLstore,0,'|str=|,'name),       				nil, "");       		inputSpec :=       			if clen=0 and fsm.nie20       				//and (val := header.(kServerSym)) and BeginsWith(val, "Apache") // also Netscape-Enterprise       			then ep.fInputTextSpecLine       			else if clen=0 or clen >= kTextXferSize // test inside _proto if adding filter       			then ep.fInputTextSpec       				/*{       				_proto: ep.fInputTextSpec,       				filter: ep.fTextFilter,	// see Instantiate for format       				}*/       			else {       				_proto: ep.fInputTextSpec,       				termination: {byteCount: clen},       				//filter: ep.fTextFilter,       				};       /*		if language<>'Japanese       		then inputSpec.filter := 	// doesn't work on 2.0?       				{byteProxy: ep.byteProxies := [{byte: chLF, proxy: chLF}, {byte: chNUL, proxy: nil}]};       */       		//fsm.fURLqueue := NIL;       		fsm.fHTMLtype := StrEqual(ctype, kHTMLMediaType);	// any encoding already scanned off       		end              	else //if clen > 0 then       		begin		// binary       //if clen=0 then begin Print("indef bin:"); Print(header); end;       		fsm.vContent :=       			call kNewVBO with (       				if cacheEntry and not options.rawImage       				then EntryStore(cacheEntry)		// so on same store as entry (since not converted)       				else if IsString(options.imageStore)	// !!!g. note even packages go here!       				then LFetch(GetStores(),options.imageStore,0,'|str=|,'name),       				'binary, clen);       		inputSpec := if clen >= kBinaryXferSize       			then ep.fInputBinarySpec       			else {       				_proto: ep.fInputBinarySpec,       				termination: {byteCount: if clen=0 then 1 else clen},	// !!!k       				//target: {data: fsm.vContent, offset: 0}       				};	       		end;              	ep.nextFlush := kVBOFlush;       	ep:SetInputSpec(inputSpec);       if kDebugHTTP then Print(ctype && "[length =" && (if clen then clen else "unknown") & $]);       	if not inputSpec       	then fsm:DoEvent('ReceiveFailure, ["headSpec", LocObj("no binary len?", 'noBinaryLenErr)]);       end,              completionScript:	func(ep, options, result)       begin       	if kDebugHTTP then print("receive failure in finputheaderspec");       	ep:DoEvent('ReceiveFailure, ["headSpec", result]);       end,       },     fInputBinarySpec:       {async:			true,       reqTimeout:		60000,	// kNoTimeout,       form:			'bytes, //'binary,	(note: system bug can't switch from header(text) to binary xfer)       //discardAfter:	kBinaryXferSize,       termination: 	{byteCount: kBinaryXferSize},              //target: {data: data, offset: 0},              inputScript:	func(ep, ARRAY data, terminator, options)       begin       	local fsm := ep._parent;       	if fsm.fAbort		// !!!o       	then return ep:inputCancel();              	options := fsm.fHTTPoptions; // reuse var       	local buffer := fsm.vContent;       	local INT contentLen := fsm.vHeader.(kContentLengthSym);       	local INT bytesRead := Length(data), i;       	local INT totRead := fsm.tContentRead; // before              	if contentLen=0       	then SetLength(buffer, totRead+bytesRead);              	for i := 0 to bytesRead-1	// inline copy (since data is an array due to sys bug)       	do StuffByte(buffer, totRead+i, data[i]);              	totRead := fsm.tContentRead := totRead + bytesRead;       //if contentLen=0 then Print("bytes read:" && bytesRead & "; total:" && totRead);              	options.dispatchApp:?setGauge(       		LocObj("Binary", 'binaryLabel) & $: &&       			totRead & $/ & if contentLen > 0 then contentLen else $?,       		totRead,contentLen);              	if totRead >= ep.nextFlush       	then begin       		ClearVBOCache(buffer);       		ep.nextFlush := ep.nextFlush + kVBOFlush;       		end;              	bytesRead :=       		if contentLen > 0       		then contentLen - totRead       		else if ep.premDisc	// !!!k. indef len       			then -1	// use same spec (1 more byte)       			else 0;	// stop       /*       		if contentLen=0 and (bytesRead < kBinaryXferSize or not ep.premDisc)	// must be done       		then 0       		else contentLen - totRead; // remaining to read (- for indeterminate length)       */       	if bytesRead = 0       	then begin	// all done       		if ep.premDisc       		then ep:inputCancel();	// !!!o       		fsm.vContent := NIL;       		// do something with gif or pkg or whatever       		fsm:DoEvent('ReceiveBinarySuccess, [buffer]);       		end              	else if ep.premDisc       	then begin	// more to read (still connected)       		if bytesRead > 0 and bytesRead < kBinaryXferSize       		then ep:SetInputSpec({       			_proto: ep.fInputBinarySpec,       			termination: {byteCount: bytesRead},       			//target: {data: buffer, offset: totRead},       			})       		// else same spec       		end              	else if kDebugHTTP	// more to read (but disconnected already)       	then Print("still need more bytes:" && bytesRead);       end,              completionScript: func(ep, options, result)       begin       	if kDebugHTTP       	then Print("[binary completionscript] failure:" && result);              	local fsm := ep._parent, content := fsm.vContent;       	//if result = -16009 then //kCommErrNotConnected       	if content       	then if Length(content)=0 or fsm.tContentRead < fsm.vHeader.(kContentLengthSym)       		then fsm:DoEvent('ReceiveFailure, ["binSpec", result])       		else fsm:DoEvent('ReceiveBinarySuccess, [content]);       end,       },     fInputTextSpec:       // note: fInputTextspecLine inherits this (but overrides lineMode, termination)       {async:			true,       reqTimeout:		60000,       //discardAfter:	kTextXferSize, // bigger for prem disconnect?  ignored? 6000, // default was only 1024 (lost chars in AltaVista results > ~5K w/ cr delim)       termination:	{byteCount: kTextXferSize},       //filter:		-- set in headerSpec/textSpec??       form:			'string,        lineMode:		NIL,              inputScript:	func(ep, data, terminator, options)       begin       	local fsm := ep._parent;       	if fsm.fAbort		// !!!o       	then return ep:inputCancel();              	options := fsm.fHTTPoptions; // reuse var       	local buffer := fsm.vContent, pos, str; // lfReplace;       	local INT contentLen := 0, bufferLen := Length(buffer), charsRead := StrLen(data);       	local INT totRead := fsm.tContentRead := fsm.tContentRead + charsRead;       	if not lineMode       	then begin       		contentLen := fsm.vHeader.(kContentLengthSym);       		if (pos := termination.byteCount - charsRead) > 0	// encoding may have returned fewer actual unichars       		then begin       			fsm.vHeader.(kContentLengthSym) := contentLen := contentLen - pos;       if kDebugHTTP then Print("fewer returned:" && pos & "; new contentLen:" && contentLen);       			end;       		end;              if kDebugHTTP then Print("chars read:" && charsRead & "; total:" && totRead);              	options.dispatchApp:?setGauge(       			LocObj("Text", 'textLabel) & $: && totRead & $/ & if lineMode then $? else contentLen,       			totRead, if not lineMode then contentLen);              if kDebugHTTP then Print("totRead:" && totRead);       if kDebugHTTP then Print("data:" && data);              	if fsm.fHTMLtype       	then begin       		if options.removeComments	// remove most now (except those that straddle)       		then call kRemoveComments with (data);       		if kFilterHTMLStrings       		then foreach str in kFilterHTMLStrings       			do StrReplace(data, str, "", nil);       		end;              	if str := fsm.fTextFilter	// !!!f. better to avoid this w/ proper encoding?       	then data := SubstituteChars(data, str[0], str[1]);              	// this is faster, more correct (cr-lf might be split across chunks)       	// default behavior is to remove/replace LFs here.       	// for subsequent transfers, do this in filter -- though there may be a delay?       	// except doesn't work on 2.x (unless set same len filter in all inputSpecs; header, binary)??       	if lineMode       	then begin       		// single (cr)(lf)?       		pos := StrLen(data)-1;       		if pos >= 0 and data[pos]=unicodeLF       		then if pos >= 1 and data[pos-1] = unicodeCR       			then StrMunger(data,pos,1, nil,0,nil)		// crlf -> cr       			else data[pos] := unicodeCR;				//   lf -> cr       		end       	else begin       		pos := 0;       		while pos := CharPos(data, unicodeLF, pos)       		do  if (if pos > 0 then data[pos-1] else ExtractChar(buffer,bufferLen-1)) = unicodeCR       			then StrMunger(data,pos,1, nil,0,nil)		// crlf -> cr	(lfReplace := 0)       			else data[pos] := unicodeCR;				//   lf -> cr	(lfReplace := unicodeCR)       		end;              	try         		BinaryMunger(buffer, bufferLen-2, 2, data, 0, nil) // replace prev null; keep null at end       	onexception |evt.ex|       	do begin       		if ep.premDisc       		then ep:inputCancel();	// !!!o       		return fsm:DoEvent('ReceiveFailure, ["textSpec", kHeapMsg]);       		end;              	if (totRead*2) >= ep.nextFlush       	then begin       		ClearVBOCache(buffer);       		ep.nextFlush := ep.nextFlush + kVBOFlush;       		end;              	charsRead :=	// remaining to read       		if contentLen > 0 or fsm.fHTMLtype       			//(fsm.fHTMLtype) and not StrPos(data, kHTMLStop, 0))       		then contentLen - totRead 	// - ok.       		else 0;	       	if charsRead = 0       	then begin	// stop immed rather than wait for timeout       if kDebugHTTP then Print("end Content-Len!");       		if ep.premDisc       		then ep:inputCancel();	// !!!o       		fsm.vContent := NIL; // to prevent calling twice?       		fsm:DoEvent('ReceiveTextSuccess, [buffer]);       		end              	else if ep.premDisc       	then begin	// more to read (still connected)       		if not lineMode and charsRead > 0 and charsRead < kTextXferSize       		then ep:SetInputSpec({       				_proto: ep.fInputTextSpec,       				termination: {byteCount: charsRead},       				//filter: ep.fTextFilter,       				});       		// else same spec              /*       		local inputSpec :=       			if charsRead > 0 and charsRead < kTextXferSize       			then {       				_proto: ep.fInputTextSpec,       				termination: {byteCount: charsRead},       				}       			else ep.fInputTextSpec;       		if language<>'Japanese and lfReplace	// if lfReplace nil, don't change       		then begin       			ep.byteProxies[0].proxy := if lfReplace<>0 then chCR; // replace (cr) or remove (nil)       			inputSpec.filter := {byteProxy: ep.byteProxies};       			end;       		ep:SetInputSpec(inputSpec);       */       		end              	// more to read(?) (but already disconnected)       	else if kDebugHTTP then Print("still need more chars:" && if charsRead > 0 then charsRead else "??");       end,              completionScript:	func(ep, options, result)       begin       	// could be a failure, but also end of file transfer...       if kDebugHTTP then Print("[textspec completionscript] failure:" && result);              	local fsm := ep._parent, buffer := fsm.vContent;       	// treat as "success" (for HTML type)       	//if result = -16009 then //kCommErrNotConnected       	if buffer       	then if fsm.fHTMLtype and StrLen(buffer) > 0       		then begin       			result := "textSpec" && LocObj("error", 'errorLabel) & $: && LocObj("disconnecting", 'disconnectingMsg);       			options := fsm.fHTTPoptions; // !!!g       			if options.InetStatus       			then fsm.dispatchApp:?errorStatus(result);              			//fsm:callBackError(result, options);	// !!!h. not nec an error?       			fsm:DoEvent('ReceiveTextSuccess, [buffer]);       			end       		else fsm:DoEvent('ReceiveFailure, ["textSpec", result]);       end,       },     fInputTextSpecLine:       // like fInputTextSpec, but just a line-at-a-time (for Apache, contentLen=0, NIE 2.0)???       {_proto: nil,	// set in afterScript to fInputTextSpec       termination:	{byteCount: kTextXferSize,	// !!!b1       				endSequence: [unicodeCR&unicodeLF, unicodeCR, unicodeLF,       					kHTMLStop, Downcase(Clone(kHTMLStop)),       					kBodyStop, Downcase(Clone(kBodyStop)),	// !!!b       					]},       lineMode:		TRUE,       //discardAfter:	6000,	// !!!b1       },     _proto: _v218_0    };AddStepForm(Send HTTP Request, Send HTTP Request);// After Script for Send HTTP RequestthisView := Send HTTP Request;begin	thisView.fInputTextSpecLine._proto  := thisView.fInputTextSpec;endReceiveTextSuccess :=    {viewBounds: {left: 18, top: 130, right: 106, bottom: 146},     action:       func(content)       begin       	local type := vHeader.(kContentTypeSym);       	// close the status view if it was open ??       	:DoEvent('Disconnect, vContent := nil);       	local errMsg, options := fHTTPoptions;              	options.predirectedURL := NIL;	// switch?              	if StrFilled(content)       	then begin       /*       		local protos := call kInitGlobal with ('protos,{}), protoEncoding := protos.NTE_protoBasicEndPoint;       		if protoEncoding and isFrame(options.NTEncoding) and options.NTEncoding.encodingSymbol <> '_none       		then begin       			// fixup content here (rather than interfering during xfer, esp. Apache)       			content := protoEncoding.NTE:code2uni(		// translate raw byte stream to unicode       				protos:NTE_uni2roman(content, nil),		// return strings to raw byte stream       				protoEncoding.NTE:GetPrefsNTEncoding(options.NTEncoding, kDefaultEncoding),       				nil);       if kDebugHTTP then begin Print(IsVBO(content)); Print(StrLen(content)); Print(content); end;       			end;       */              		ClearVBOCache(content);	gc();       		if (fHTMLtype or       				(options.cacheText and StrEqual(type, kTextMediaType)))	// !!!o. other text types also?       			and options.cacheHTML	// store all (even temporary) entries?       			and (StrEqual(fHTTPMethod,kGet) or StrEqual(fHTTPMethod,kPost))       		then begin       			if fHTMLtype and options.removeComments		// !!!o. (in case some straddled buffer boundaries)       			then call kRemoveComments with (content);       			local modDate := vHeader.(kLastModifiedSym);       			try call kPutURLCache with (       				GetVBOStore(content),	// !!!j       				options.cacheHTML,       				vBase, //if options.cacheURL then vBase := options.cacheURL else vBase,       				'text,       				options.cacheEntry,       				content,	// already compressed       				if modDate then modDate else vHeader.(kDateSym), vHeader.(kExpiresSym),       				options.edata := fHTTPeData,       				fHTTPData,       				type       				//options.labels       				)       			onexception |evt.ex| do errMsg := kHeapMsg;       			end;       		end;              	options.dispatchApp:?setGauge(nil,nil,nil);       	options.error :=	// !!!k       		if errMsg //and not options.error	       		then errMsg       		else true;              //if kDebugHTTP then Print("textSuccess:" && options.edata);              	if content       	then options.results := [type, vBase, content, call kFixOptions with (fURLqueue,options)];	// !!!o,n,k       end,     declareSelf: 'ReceiveTextSuccess,     nextState: 'Connected,     _proto: _v218_0    };AddStepForm(Send HTTP Request, ReceiveTextSuccess);ReceiveBinarySuccess :=    {viewBounds: {left: 8, top: 120, right: 96, bottom: 136},     action:       func (content)       begin       	local type := vHeader.(kContentTypeSym);       	:DoEvent('Disconnect, vContent := nil);       	local options := fHTTPoptions, pos;       	local errMsg, dispatchApp := options.dispatchApp;       //if kDebugHTTP then Print("bytes3:" && ExtractChar(content,0) & ExtractChar(content,1) & ExtractChar(content,2));       	ClearVBOCache(content);	gc();              	local href := options.predirectedURL;       	if href       	then options.predirectedURL := NIL;       	else href := vBase;              	if StrEqual(type, kGIFMediaType) and vHelperApp = kAppSymbol       		and (StrEqual(fHTTPMethod,kGet) or StrEqual(fHTTPMethod,kPost))       	then if call kByteBeginsWith with (content, kGIFStart, 0)       		then begin	// convert GIF here immediately       			content := dispatchApp:?convertImage(       						type,       						href, //if options.cacheURL then vBase := options.cacheURL else vBase,       						content, options, GIF.Decompress);       			if IsString(content)       			then errMsg := content;       			end       		else errMsg := LocObj("not a real GIF", 'notGIFerr)              	else if StrEqual(type, kNewtonPkgMediaType)       	then // is it a package ?       		// 1) bytes 0-7: should be "package0" or "package1"       		// 2) bytes 28-31: length of entire package       		// 3) bytes 72-75: 0x00000081       		if call kByteBeginsWith with (content, kPkgStart, 0)       		then SetClass(content, 'packageEntry)       		else if pos := call kBytePos with (content, kPkgStart, 0)       		then BinaryMunger(SetClass(content, 'packageEntry),0,pos,nil,0,nil)	// remove MacBinary header       		else errMsg := LocObj("not a package", 'notPkgErr);              	dispatchApp:?setGauge(nil,nil,nil);       	options.error :=	// !!!k       		if errMsg //and not options.error	       		then errMsg       		else true;              	if not errMsg and content       	then options.results := [type, href, content, call kFixOptions with (fURLqueue,options)];	// !!!n,k       end,     declareSelf: 'ReceiveBinarySuccess,     nextState: 'Connected,     _proto: _v218_0    };AddStepForm(Send HTTP Request, ReceiveBinarySuccess);ReceiveCache :=    {viewBounds: {left: 18, top: 146, right: 106, bottom: 162},     declareSelf: 'ReceiveCache,     nextState: 'Connected,     action:       func()       begin       	fHTTPoptions.error := true;	// !!!k       	:DoEvent('Disconnect, vContent := nil);       	fHTTPoptions.results := [fHTTPoptions.cacheEntry];	// !!!k       	fHTTPoptions.cacheEntry := nil;	// !!!k       end,     _proto: _v218_0    };AddStepForm(Send HTTP Request, ReceiveCache);ReceiveFailure :=    {viewBounds: {left: 8, top: 136, right: 96, bottom: 152},     declareSelf: 'ReceiveFailure,     nextState: 'Connected,     action:       func(msg, error)       begin       if kDebugHTTP then begin Print("Receive Failure"); print(msg); print(error); end;       	msg := (if msg then msg && LocObj("error", 'errorLabel) & ": ") &       		if not IsString(error) and GetGlobalFn('InetGetErrorString)              	then InetGetErrorString(error) else error;              	fHTTPoptions.dispatchApp:?setGauge("",nil,nil);               	if BeginsWith(msg, LocObj("redirection", 'redirectionMsg))       	then begin       		if fHTTPoptions.InetStatus       		then fHTTPoptions.dispatchApp:?errorStatus(msg);       		end       	else if not fHTTPoptions.error	// !!!k       	then fHTTPoptions.error := msg;              	:DoEvent('Disconnect, vContent := nil);       end,     _proto: _v218_0    };AddStepForm(Send HTTP Request, ReceiveFailure);Cancel :=    {viewBounds: {left: 8, top: 152, right: 96, bottom: 168},     declareSelf: 'Cancel,     action:       func()       begin       	fAbort := true;              	try       		fEndPoint:?Cancel(nil);       	onexception |evt.ex.comm| do       		nil;              	:DoEvent('Disconnect, nil);       end,     nextState: 'Connected,     _proto: _v218_0    };AddStepForm(Send HTTP Request, Cancel);// After Script for HTTP MachinethisView := HTTP Machine;begincall kFSMCleanUpFunc with (thisView);	// unused in protoFSM	RemoveSlot(thisView._proto, 'GetSpeed);	RemoveSlot(thisView._proto, 'SetSpeed);		// !!!i	RemoveSlot(thisView._proto, 'IsBusy);	if not kDebugOn	then begin		RemoveSlot(thisView, 'TraceFSM);		RemoveSlot(thisView, 'DebugFSM);		RemoveSlot(thisView, 'PrintFSM);		RemoveSlot(thisView, 'MNotifyError);	// !!!i		end;/* override ObjectToString?				else if IsString(obj) then // ?? SAW if too long, Inspector problems					$" & (if StrLen(obj) > 200 then SubStr(obj,0,200) else obj) & $"ProtoClone non-NATIVE?*/endconstant |layout_HTTP FSM| := HTTP Machine;// End of file HTTP FSM// Beginning of file myProtoInfoButton// Before Script for _v76_0DefConst('kFixupInfoItems, func(template)begin	local items := template.AppInfoItems := [];	if HasSlot(template, 'DoInfoAbout)	then AddArraySlot(items, LocObj("About", 'aboutItem));	if HasSlot(template, 'DoInfoHelp)	then AddArraySlot(items, LocObj("Help", 'helpItem));	if HasSlot(template, 'DoInfoPrefs)	then AddArraySlot(items, LocObj("Prefs", 'prefsItem));	local auxItems := template:?GenInfoAuxItems();	if isArray(auxItems) and Length(auxItems) > 0		and HasSlot(template,'DoInfoAux)	then begin		AddArraySlot(items, 'pickSeparator);		template.AuxOffset := Length(items);		ArrayMunger(			items, Length(items), 0,			auxItems, 0, nil);		end;end)_v76_0 :=    {icon: GetPictAsBits("info icon", nil),     viewBounds: {left: 6, top: 0, right: 19, bottom: 12},     viewFlags: 513,     viewFormat: 67109457,     viewJustify: 17446,     viewClickScript:       func(unit)       if :TrackHilite(unit)       then if kBuild20 or HasVariable(:Parent(),'PopupMenu)       	then :PopupMenu(AppInfoItems, {left: 0, top: 0})       	else begin       		local l := :LocalBox();       		DoPopUp(AppInfoItems, l.right+3, l.top, self);       		end,     pickActionScript:       func(index)       begin       	// MUST do this       	:Hilite(nil);              	if auxOffset and index >= auxOffset       	then :DoInfoAux(:GenInfoAuxItems(), index - auxOffset)       	else Perform(self, '{       		About:	DoInfoAbout,       		Help:	DoInfoHelp,       		Prefs:	DoInfoPrefs}.(Intern(AppInfoItems[index])), []);       end,     pickCancelledScript: func() :Hilite(nil),     AppInfoItems:       [] // set in afterScript       ,     auxOffset: nil,     viewClass: 76 /* clPictureView */    };// After Script for _v76_0thisView := _v76_0;/* // for NewtthisView.viewSetupFormScript := func()begin	if not IsReadOnly(self._proto)	then call kFixupInfoItems with (self._proto);	//inherited:?viewSetupFormScript();end*/constant |layout_myProtoInfoButton| := _v76_0;// End of file myProtoInfoButton// Beginning of file GIF.ntkc/*DefConst('GIF,PP: Ill-placed Blank{Decompress: {class: BinCFunction, code: <code>, numArgs: 4, offset: 4864},    version: {class: BinCFunction, code: <code>, numArgs: 0, offset: 6760}    });*/// End of file GIF.ntkc// Beginning of file HTMLParser.ntkc/*DefConst('HTMLParser,PP: Ill-placed Blank{ParseString: {class: BinCFunction, code: <code>, numArgs: 2, offset: 40},    version: {class: BinCFunction, code: <code>, numArgs: 0, offset: 3484}    });*/// End of file HTMLParser.ntkc// Beginning of file ScheduleLayout// Before Script for scheduleLayout/*the following are set before opening:overviewApp,schedName, schedDate, schedItems, schedFreq, schedNIE, schedLink	//userName, userPassword, */scheduleLayout :=    {viewBounds: {left: 8, top: -94, right: -8, bottom: -5},     viewJustify: 176,     host:       "x"	// so typing will start in nameInput       ,     ReorientToScreen: ROM_DefRotateFunc,     _proto: @180 /* protoFloatNGo */    };itemText :=    {viewBounds: {left: 5, top: 1, right: -110, bottom: 13},     viewSetupFormScript:       func()       begin       	local INT len := Length(schedItems);       	self.text := len && overviewApp.appObject[if len=1 then 0 else 1];       	       	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// !!!g. kFixTextFormScript       	then viewFont := newtscape.labelFontJ;              	inherited:?viewSetupFormScript();       end,     viewJustify: 8388656,     _proto: @218 /* protoStaticText */    };AddStepForm(scheduleLayout, itemText);levelPicker :=    {     labelCommands:       [       {item: kNoneItem,},	//value: nil},       {item: "1 level", 	value: 1},       {item: "2", 		value: 2},       {item: "3",			value: 3},       ],     text:       LocObj("Autolink", 'autoLinkLabel) // !!!a1       ,     viewBounds: {left: -110, top: 0, right: -2, bottom: 14},     alwaysCallPickActionScript: true,     textSetup:       func()       begin       	local pos := 0;       	if schedLink and not (pos := LSearch(labelCommands, schedLink, 1, '|=|, 'value))	// !!!w       	then pos := 1;	// !!!i. 0       	labelCommands[pos].item;       end,     labelActionScript:       func(cmd)       schedLink := labelCommands[cmd].value,     viewJustify: 8388640,     _proto: @190 /* protoLabelPicker */    };AddStepForm(scheduleLayout, levelPicker);// After Script for levelPickerthisView := levelPicker;begin // !!!g	if kNCfont	then begin		thisView.viewSetupFormScript := kFixPickerFormScript;		thisView.pickerSetup := kFixPickerSetup;		end;enddatetimePick :=    {viewBounds: {left: 2, top: 17, right: -2, bottom: 31},     label: kPopChar & LocObj("Start Date", 'startDateLabel),     viewSetupFormScript:       func()       begin       	self.date := schedDate;              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// !!!g       	then begin       		labelFont 	:= 	newtscape.labelFontJ;       		entryFont 	:= 	newtscape.dataFontJ;       		end       	else if language='Chinese       	then entryFont := kEspy10;  // ~C              	inherited:?viewSetupFormScript();       end,     pickActionScript:       func(newDate)       inherited:?pickActionScript(schedDate := newDate),     increment: 1,     viewJustify: 48,     _proto: @630 /* clView */    };AddStepForm(scheduleLayout, datetimePick);// After Script for datetimePickthisView := datetimePick;if kNIEthen thisView._proto := protoDateNTimeTextPicker;	// @630// Before Script for freqPicker/*maybe could use protoPeriodicAlarmEditoror protoRepeatPicker + protoRepeatView(except how to calculate "next" date?)*/freqPicker :=    {     labelCommands:       [       {item: kNoneItem,},					//value: nil},       {item: LocObj("immediately",'immedItem),			value: true},       {item: LocObj("once",'onceItem), 					value: 0},       {item: LocObj("hourly",'hourlyItem), 				value: 60},       {item: LocObj("twice daily",'twiceDailyItem),		value: 60*12},       {item: LocObj("daily",'dailyItem), 					value: kDayMin},       {item: LocObj("daily (except weekend)",'daily5Item),value: kDayMin-1},	// (see kUpdateFunc in schedButton)       {item: LocObj("weekly",'weeklyItem), 				value: kDayMin*7},       {item: LocObj("monthly", 'monthlyItem),				value: kDayMin*31},	// !!!a1,w       ],     text: LocObj("Frequency",'frequencyLabel),     viewBounds: {left: 2, top: 35, right: -2, bottom: 49},     alwaysCallPickActionScript: true,     textSetup:       func()       begin       	local pos;       	if not pos := LSearch(labelCommands, schedFreq, 0, '|=|, 'value)       	then pos := 1;	// !!!i. 0       	labelCommands[pos].item;       end,     labelActionScript:       func(cmd)       schedFreq := labelCommands[cmd].value,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(scheduleLayout, freqPicker);// After Script for freqPickerthisView := freqPicker;begin // !!!g	if kNCfont	then begin		thisView.viewSetupFormScript := kFixPickerFormScript;		thisView.pickerSetup := kFixPickerSetup;		end;endNIEpicker :=    {text: LocObj("NIE Setup",'NIEsetupLabel),     viewBounds: {left: 2, top: 53, right: -2, bottom: 67},     alwaysCallPickActionScript: true,     viewSetupFormScript:       func()       begin       	if GlobalFnExists('InetGetAllLinksStatus)	// !!!m. no NIE?       	then begin       		local status := InetGetAllLinksStatus();       		linkIds := ArrayMunger([nil,nil],2,0, status.linkIds, 0,nil);       		if not SetContains(linkIds, schedNIE)       		then schedNIE := nil; 	//InetGetDefaultLinkId();       		labelCommands := ArrayMunger([kDefaultItem,'pickSeparator],2,0, status.names,0,nil);              		if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// !!!g. kFixPickerFormScript       		then begin       			viewFont 			:= 	newtscape.labelFontJ;       			entryLine.viewFont 	:= 	newtscape.dataFontJ;       			end       		else if language='Chinese       		then entryLine.viewFont := kEspy10;  // ~C       		end;       	       	inherited:?viewSetupFormScript();       end,     labelActionScript: func(cmd) schedNIE := linkIds[cmd],     textSetup:       func() // known valid linkID (in viewSetupFormScript)       if linkIds	// !!!m       then labelCommands[SetContains(linkIds, schedNIE)]       else LocObj("none", 'noneItem),     viewJustify: 8388656,     labelCommands: [],     linkIds: nil,     _proto: @190 /* protoLabelPicker */    };AddStepForm(scheduleLayout, NIEpicker);// After Script for NIEpickerthisView := NIEpicker;begin // !!!g	if kNCfont	then begin		thisView.pickerSetup := kFixPickerSetup;		end;endauthenticateButton :=    {     buttonClickScript:       func()       begin       	//local newtscape := GetRoot().(kNewtsCapeSymbol);       	newtscape:DoEvent(NIL, [{}]);	// initialize fsm if not there       	local fsm := newtscape.wwwFSM, entry, host, href, hosts := [], sep;       	foreach entry in schedItems       	do begin       		href :=       			if IsString(entry)       			then entry       			else if IsFrame(entry := EntryFromObj(entry)) // !!!e. IsEntryAlias(entry) and       			then entry.URL;       		if IsString(href) and IsString(host := fsm:parseURL(href)[2]) and not LSearch(hosts,host,0,'|str=|,nil)       		then AddArraySlot(hosts, host);       		end;              	host := "";       	foreach entry in Sort(hosts, '|str<|, nil)       	do begin       		host := host & sep & entry;       		sep := "; ";       		end;       //Print(host); Print(hosts);       	BuildContext({       		_proto:	GetLayout("protoNamePassword"),       		newtscape: 	newtscape,       		fsm:		fsm,       		host:		host,       		hosts:		hosts,       		keep:		true,	// initially       		}):open();       end,     text: LocObj("Authenticate", 'authenticateLabel),     viewBounds: {left: 3, top: 72, right: 83, bottom: 84},     _proto: @226 /* protoTextButton */    };AddStepForm(scheduleLayout, authenticateButton);// After Script for authenticateButtonthisView := authenticateButton;begin	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;endscheduleButton :=    {     buttonClickScript:       DefineGlobalConstant('kUpdateFunc, []);	// moved here from scheduleLayout.viewQuitScript       ReplaceObject(kUpdateFunc, func(schedName, newTime, delay, items, setup, linkItems, schedLink) // !!!w,s,g       begin       //Print(["alarm", schedName, newTime, delay, items, setup]);       	// note: if no NIE, then setup=nil       	if setup and SetContains(InetGetAllLinksStatus().linkIds, setup)       	then InetSetDefaultLinkID(setup)       	else setup := nil; // InetGetDefaultLinkId();	 // deleted in interim       	       	local newtscape := GetRoot().(kNewtsCapeSymbol);       	if delay and delay > 0	// repeat       	then begin       		if delay = kDayMin-1       		then begin       			local df := Date(newTime), ndelay := kDayMin; //delay+1;       			if df.dayOfWeek=5			// Fri       			then ndelay := kDayMin*3	//ndelay*3       			else if df.dayOfWeek=6		// Sat       			then ndelay := kDayMin*2; 	//ndelay*2;       			newTime := newTime + ndelay;       			end       		else newTime := newTime + delay;       		AddAlarm(schedName, newTime, nil, kUpdateFunc,       			[schedName, newTime, delay, items, setup, linkItems]);	// !!!s,g        		end       	else if newtscape and newtscape.tempOverview       	then newtscape.tempOverview.overview:?RedoChildren();	// make alarm disappear              	//local folder := Substr(schedName,1,StrLen(schedName)-4);	//xXXXXX:NC       	newtscape:?DoEvent(NIL, [{       		cacheOnly: true,       		checkCache: true,	// !!!k       		autoLogin:  if delay then delay else newtscape.prefsEntry.autoLogin, // !!!z       		autoLogout: if delay then delay else newtscape.prefsEntry.autoLogin, // !!!z,n       		noStatus: delay,       		trustHTML: nil,       		trustImages: nil,       		fURLqueue: items,       		linkItems: Clone(linkItems),	// !!!w,s       		//labels: if folder and not StrEqual(folder,GetFolderStr(nil)) then Intern(folder),       		}]);       end);              func()       begin       	local linkItems, entry;       	if schedLink	// !!!s       	then begin       		linkItems :=       			if IsString(schedItems[0])	// bookmarks?       			then Clone(schedItems)       			else foreach entry in schedItems collect EntryFromObj(entry).URL;              		if schedLink > 1	// !!!w. add counter       		then linkItems :=       			foreach entry in linkItems collect [entry,schedLink];       		end;              	if schedFreq = nil			// none       	then begin       		// RemoveAlarm existing?       		end              	else if schedFreq = true	// immediately       	then begin       		overviewApp:close();       		// RemoveAlarm(schedName);	       		call kUpdateFunc with (schedName, nil, nil, schedItems, schedNIE, linkItems, schedLink);// now. !!!w,s,g       		end              	else if schedDate - Time() > 0	// later (once, or w/ repeat)       	then begin       		AddAlarm(schedName, schedDate, nil, kUpdateFunc, [schedName, schedDate, schedFreq, schedItems, schedNIE, linkItems, schedLink]);	// !!!w,s,g. userName, userPassword,        		overviewApp:RedoChildren();		// redisplay with alarm icons       		end;              	base:close();       end,     text: LocObj("Schedule", 'scheduleLabel),     viewBounds: {left: 123, top: 72, right: 176, bottom: 84},     _proto: @226 /* protoTextButton */    };AddStepForm(scheduleLayout, scheduleButton);// After Script for scheduleButtonthisView := scheduleButton;begin	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;endconstant |layout_ScheduleLayout| := scheduleLayout;// End of file ScheduleLayout// Beginning of file protoCacheBkmarkOverview// Before Script for CacheBkMarkbeginconstant kNCAlarmSuffix := ":NC";	// kGetSchedName, AbstractDefineGlobalConstant('kGetSchedName, func(soupName, folder)// keep it to 24 chars tops: [B/H/I]folder:NCsoupName[0] & SubStr(GetFolderStr(folder),0,20) & kNCAlarmSuffix	// !!!k);end/*get rid of bookmark picker elsewhere?*/CacheBkMark :=    {     URLscript:       func(target, targetView)       if target       then begin       	local entry := overview.selected[0];       	overviewApp:close();       	newtscape:displayURL(EntryFromObj(entry).URL);       	end,     GetTargetInfo:       func(reason) // reason could be 'routing, 'filing, or other symbols.       begin       	local sel := overview.selected;       	if (reason = 'filing or reason = 'routing) and       		isArray(sel) and Length(sel) > 0       	then begin       		local entry :=       			if Length(sel)=1 and IsEntryAlias(sel[0]) // only 1 or images?       			then EntryFromObj(sel[0])       			else CreateTargetCursor(kNewtsCapeSymbol, sel);       		{target: entry ,       		targetView: self,       		targetStore:       			if storesFilter       			then storesFilter       			else if IsSoupEntry(entry)       			then EntryStore(entry),       		};       		end       	else //inherited:?GetTargetInfo(reason);       		{target: nil,       		targetView: self,       		targetStore: nil};       end,     outlineScript:       func(target, targetView)       if target and GetDataDefs('list)       then begin       	local INT left := 28, top := 7, maxWid := GetAppParams().appAreaWidth - 4, ht;       	local ARRAY topics := [];       	local txt, entry, vf := GetUserConfig('userFont);       	// this uses existing popup items (after commands). avoids refetching/resorting       	foreach entry in overview.selected       	do begin       		entry := EntryFromObj(entry);       		txt := $< & entry.URL & $>;       		if itemName and not StrEqual(entry.name, entry.URL)	// actual label (not just URL)       		then txt := txt & entry.name;       		ht := TextBounds(txt,vf,RelBounds(0,0,maxWid-left,0)).bottom;       		AddArraySlot(topics, {       			//mtgDone: nil,       			styles: [StrLen(txt), vf],       			hideCount: 0,       			viewBounds: RelBounds(left,top,maxWid-left,ht),       			level: 1,       			text: txt,       			});       		top := top + ht + 6;       		end;              	GetUnionSoup(notesSoupName):AddFlushedXmit({       		viewStationery: kNotesSym,       		class: 'list,       		title: title, // from this overview       		height: top+60,       		data: NIL,       		topics: topics,       		timeStamp: Time(),       		}, 'entryAdded);       	end,     viewFormat: 67109713,     unlockScript:       func(target, targetView)       if target then overview:SetLock(nil)	// !!!g       ,     viewQuitScript:       func()       begin       	newtscape.tempOverview := NIL;       	//UnRegFolderChanged(kAppSymbol);	// ??       	inherited:?viewQuitScript();       end,     appAll:       LocObj("All", 'allLabel) && LocObj("items", 'itemsItem)	// default       ,     target: nil,     Submit:       nil	// !!!g       ,     storesFilter: nil,     viewFlags: 68,     doCardRouting: TRUE,     ReorientToScreen:       ROM_DefRotateFunc	// !!!q       ,     viewBounds: {left: 3, top: 3, right: -3, bottom: -3},     appObject:       [LocObj("item", 'itemItem), LocObj("items", 'itemsItem)] // default       ,     defaultScript: 'openScript,     _proto: @179 /* protoFloater */,     cancelUpdateScript:       func(target, targetView)       begin       	RemoveAlarm(schedName);       	overview:RedoChildren();       end,     lockScript:       func(target, targetView)       if target then overview:SetLock(true)	// !!!g       ,     caches: nil,     labelsFilter: nil,     bookmarkScript:       func(target, targetView)	// !!!e       if target and not (soupName and itemName)       then GetRoot().(kAppSymbol):AddBookmark(overview.selected, kAddBookmark)	// any non-empty string ok as 'URL'       ,     processScript:       func(target, targetView)       if target       then begin       	local pp := overviewApp:PopupMenu(	// avoid problems with protoActionButton.pickActionScript       		overviewApp.processCommands := [       			call kFixMenuItem with (kPkgItem, newtscape.NewtPack),       			call kFixMenuItem with (kNWitem, GetRoot().(kNewtworksSym)),       			],       		:GlobalBox());	// of action button              	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym       	then SetValue(pp, 'viewFont, newtscape.menuFontJ);	//{family: sym, face: kFaceBold, size: 10});       	end,     schedName: nil,     viewScrollDownScript:       func()       overview:viewScrollDownScript()       //overview:scroller(20)       ,     appSymbol:       kNewtsCapeSymbol	//?       ,     viewJustify: 240,     updateScript:       func(target, targetView)       if target       then begin       	//protoDateNTimePopup:New(Time(), 1, :GlobalBox(), overview)              	local alarmObj := GetAlarm(schedName), entry, params := if alarmObj then alarmObj.callbackParams;       	BuildContext({       		_proto: GetLayout("ScheduleLayout"),       		newtscape: newtscape,		// !!!g       		overviewApp: overviewApp,              		schedName: schedName,	// same as .callbackParams[0], .key       		schedDate: if params then params[1] else Time(),       		schedFreq: if params then params[2] else true,	// !!!k       		schedItems:       			if itemName	// bookmarks (just URLs), otherwise entry aliases       			then foreach entry in overview.selected       				 collect EntryFromObj(entry).URL       			else overview.selected,       		schedNIE:	if params then params[4], // !!!g. InetGetDefaultLinkId(),       		schedLink:	if params and Length(params) > 5       					then if Length(params) > 6       						then params[6]	// !!!w. schedLink(#)       						else params[5], // !!!s       		}):open();       	end,     viewScrollUpScript:       func()       overview:viewScrollUpScript()       //overview:scroller(-20)       ,     cacheSizeSym: nil,     deleteScript:       func(target, targetView)       if target       then begin       	local INT len := Length(overview.selected);       	newtscape:Confirm(	// !!!j. AsyncConfirm       		nil,	// unused		       		LocObj("Delete", 'deleteItem) && len &&	       		appObject[if len=1 then 0 else 1] & $?,       		overview, 'deleteItems) //!!!j 'yesNo, use localized Yes,No       	end,     soupName: nil,     querySpec: nil,     viewSetupFormScript:       /*       DefineGlobalConstant('kCheckFolderChanged, func(oldFolder, newFolder)       begin       	local folders := GetFolderList(kAppSymbol,nil);       	if SetContains(folders, Intern(newFolder)) and not SetContains(folders, Intern(oldFolder))       	then begin       		// go thru all items, fix labels/sortOn; scheduledSet (see FileThis)       		// but need to check anytime in All for invalid labels?       		end;       end);       */              func()       begin       	self.targetView := self.overviewApp := newtscape.tempOverview := self; // GetTargetInfo, :close, routescripts              	/*	// temp. for SEAN       	local x := call kGetInt with (newtscape.prefsEntry.overviewOffsetX, nil);       	local y := call kGetInt with (newtscape.prefsEntry.overviewOffsetY, nil);       	if x and y       	then viewBounds := SetBounds(x,y, -x,-y);       	*/              	if newtscape.nos21 and GetGlobalFn('InetGetIPAddress) and InetGetIPAddress('localAddress) // !!!b1,a1. 2.1 and connected       	then viewBounds := SetBounds(kFullOffset,0, -kFullOffset,-kFullOffset2);              	if prefSym       	then labelsFilter := newtscape.prefsEntry.(prefSym);              	if soupName       	then begin       		if isArray(itemName)	// !!!g. not submit       		then begin	// item(s) is default       			appObject := itemName;	// !!!d. also moved inside soupName test       			appAll := LocObj("All", 'allLabel) && appObject[1];       			end;              		local obj, rs;       		routeScripts := Clone(routeScripts);       		if obj := GetDataDefs('list)       		then begin       			routeScripts.outline := rs := Clone(routeScripts.outline);       			rs.icon := obj.icon;       			end;              		// this is basically constant (modified only in deleteScript)       		gc();       		soupCount := GetUnionSoupAlways(soupName):Query(nil):countEntries();              		//RegFolderChanged(kAppSymbol, kCheckFolderChanged);	// ??  or InstallScript?       		end              	else soupCount := Length(querySpec);	// !!!f,c. keep # of images/links/frames              	if newtscape.prefsEntry.overviewNoFloat       	then viewFlags := viewFlags - vFloating; 		// !!!c. turn off floating              	SetKeyView(self, 0);	// !!!f       	inherited:?viewSetupFormScript();       end,     routeScripts:       {load: {	// Images (only)       	icon: if kNIE then ROM_routeUpdateBitmap,       	GetTitle: 	func(target)       	begin       		local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       		if not overview.soupName       		then call kFixMenuItem with (LocObj("Load", 'loadItem), target)       		else if kSubmitQ and overview.submit	// !!!g       		then call kFixMenuItem with (LocObj("Submit", 'submitLabel), target);       	end,       	routeScript: 'loadScript,       	},              update: {       	icon: if kNIE then ROM_alarmIconTinyBitmap,       	GetTitle: 	func(target)       		if StrFilled(GetRoot().(kNewtscapeSymbol).tempOverview.schedName)	// GetRoot().(kNewtscapeSymbol).tempOverview.soupName       		then call kFixMenuItem with (LocObj("Schedule", 'scheduleLabel) & $É, target),       	routeScript: 'updateScript,       	},              cancelUpdate: {       	icon: if kNIE then ROM_cancelBitmap,       	GetTitle: 	func(target)       	begin       		local schedName := GetRoot().(kNewtscapeSymbol).tempOverview.schedName;       		if StrFilled(schedName)       		then call kFixMenuItem with (LocObj("Cancel Schedule", 'CancelSchedLabel), GetAlarm(schedName));       	end,       	routeScript: 'cancelUpdateScript,       	},              open: {       	icon: if kNIE then kNotesRouteItem.icon,       	GetTitle: 	func(target)       		if GetRoot().(kNewtscapeSymbol).tempOverview.soupName       		then call kFixMenuItem with (LocObj("Open", 'openItem), target),       	routeScript: 'openScript,       	},              process: {       	icon: if kNIE then call kGetResource with ("smallPkgIcon"),       	GetTitle: func(target)       		begin       			local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       			if overview.soupName and not overview.submit // !!!g	 caches only? and not overview.itemName       			then call kFixMenuItem with (kProcessOption, target);       		end,       	routeScript: 'processScript,       	},              URL: {       	icon: if kNIE then ROM_routePasteText, //ROM_handScrollBitmap,       	GetTitle: 	func(target)       	begin       		local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       		if overview.soupName and not overview.submit	// !!!g       		then call kFixMenuItem with (LocObj("Display URL", 'displayURLitem), target);       	end,       	routeScript: 'URLscript,       	},              outline: {       	icon: nil, 			// set in viewSetupFormScript if dataDef exists       	GetTitle: func(target)       	begin       		local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       		if overview.soupName and not overview.submit	// !!!g       		then call kFixMenuItem with (kSaveOutline, target and icon);       	end,       	routeScript: 'outlineScript,       	},                     bookmark: {	// !!!e       	icon: ROM_bookmarkBitmap,       	GetTitle: func(target)       		begin       			local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       			if not overview.submit	// !!!g       				and not (overview.soupName and overview.itemName)	// !!!k. not Bookmarks itself       			then call kFixMenuItem with (kAddBookmark, target);       		end,       	routeScript: 'bookmarkScript,       	},              lock: {       	icon: if kNIE then ROM_closedPadlockBitmap,       	GetTitle: func(target)       		begin       			local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       			if overview.soupName and not overview.itemName	// only caches       			then call kFixMenuItem with (LocObj("Lock", 'lockItem), target);       		end,       	routeScript: 'lockScript,       	},              unlock: {       	icon: if kNIE then ROM_openPadlockBitmap,       	GetTitle: func(target)       		begin       			local overview := GetRoot().(kNewtscapeSymbol).tempOverview;       			if overview.soupName and not overview.itemName	// only caches       			then call kFixMenuItem with (LocObj("Unlock", 'unlockItem), target);       		end,       	routeScript: 'unlockScript,       	},              delete: {       	icon: if kNIE then ROM_routeDeleteIcon,       	GetTitle: 	func(target)       		if GetRoot().(kNewtscapeSymbol).tempOverview.soupName       		then call kFixMenuItem with (LocObj("Delete", 'deleteItem) & $É, target),       	routeScript: 'deleteScript,       	},       },     newFilingFilter:       func(newFilterPath) //'storesChanged, 'labelsChanged ??       begin       	overview:resetCursor(true, true);       	if newFilterPath = 'labelsFilter and prefSym       	then newtscape:setPreference(prefSym, labelsFilter)       	else if newFilterPath = 'storesFilter       	then fileButton:update();       end,     FileThis:       func(target, labelsChanged, newLabels, storesChanged, newStore)       begin       	local cursor, oldSched, newSched, aname, params, schedItems, pos, oldStore;       	if TargetIsCursor(target)       	then begin       		cursor := GetTargetCursor(target, nil);       		target := cursor:entry();       		end;       	//else cursor := '{};              	while target       	do begin       		if oldSched := GetAlarm(aname := call kGetSchedName with (soupName, target.labels))       		then begin       			// remove old scheduled item (since it's in different folder or alias? changed)       			params := oldSched.callbackParams;       			schedItems := params[3];       			if (pos := if itemName       				then LSearch(schedItems,target.URL,0,'|str=|, nil)									// bookmarks       				else LSearch(schedItems,MakeEntryAlias(target),0,GetGlobalFn('IsSameEntry),nil))	// cache       			then begin       				// old item was scheduled. remove&update       				// note: overkill for bookmarks between stores (same folder) but simpler       				ArrayRemoveCount(schedItems, pos, 1);       				if Length(schedItems)=0       				then RemoveAlarm(aname)				// only item. remove alarm entirely       				else AddAlarm(aname, params[1], nil, oldSched.callBackFn, params); 	// update old alarm       				end       			else oldSched := NIL;	// item wasn't scheduled       			end;       		newSched := oldSched;		// default: reuse old alarm (if any)              		if labelsChanged       		then begin       			target.labels := newLabels;       			if itemName       			then target.sortOn := newLabels & $: & target.name;       			EntryChangeXmit(target, nil);              			if oldSched       			then if newSched := GetAlarm(aname := call kGetSchedName with (soupName, newLabels))       				then schedItems := (params := newSched.callbackParams)[3]	// add to existing alarm in new folder       				else begin							// no existing alarm for new folder       					newSched := oldSched;			// create using most old settings       					params := Clone(params);		// w/o modifying those       					params[0] := aname;				// new name       					params[3] := schedItems := [];	// new item list       					end;       			end;              		if storesChanged and newStore <> oldStore := EntryStore(target)       		then begin       			//:MoveTarget(target, newStore)       			local newSoup := newStore:GetSoup(soupName);       			if not newSoup       			then newSoup := newStore:CreateSoupXmit(soupName, GetSoupDef(soupName).indexes, nil);       			if oldStore:IsReadOnly()       			then begin       				EntryCopyXmit(target,newSoup,nil);       				soupCount := soupCount + 1;       				end       			else EntryMoveXmit(target,newSoup,nil)       			end;              		if newSched       		then begin       			AddArraySlot(schedItems, if itemName then target.URL else MakeEntryAlias(target));       			AddAlarm(aname, params[1], nil, newSched.callBackFn, params);       			end;       			       		target := cursor:?next();       		end;       	overview:resetCursor(nil, true);       end,     pickActionScript:       func(INT cmd)       begin       	local sel := processCommands[cmd];       	if sel = kPkgItem or sel = kNWitem	// valid entry, not (xxx)?       	then begin       		call kProcessNextCallback with ({       			processOption: kSavePkg + cmd,       			checkCache: true,					// !!!k       			callbackFn: kProcessNextCallback,       			processParams: [overview.selected],       			processMsg: LocObj("Process", 'processItem),	// !!!e       			start: 0,			// !!!g. for docs that don't contain <HTML>       			//noConfirm: true,	// !!!h. for packages       			});       		overviewApp:close();	// ok since delay       		end;       end,     loadScript:       func(target, targetView)       if target       then if kSubmitQ and submit	// !!!g       /* could use http queuing mechanism, but need edata which not saved? */       	then begin       		call kProcessNextCallback with ({       			//cacheOnly: true,       			//processOption: kCacheOnly,	// ???              			callbackFn: kProcessNextCallback,       			processParams: [overview.selected],       			processMsg: LocObj("Submit", 'submitLabel),       			});       		AddDeferredSend(overviewApp, 'close, nil);	// !!!d1       		end              	else begin       		local ARRAY sel := foreach entry in overview.selected collect entry.URL;       		if curDoc	// !!!c. after Images?       		then AddArraySlot(sel, curDoc);       		AddDeferredSend(overviewApp, 'close, nil);	// !!!d1       		newtscape:removeApp(true,true);       		newtscape:DoEvent(NIL, [{       			fURLqueue: sel,       			cacheOnly: not curDoc,	// !!!c. for links: like immed schedule       			trustHTML: nil,			// ??       			trustImages: nil,		// ??       			}]);       		end,     itemName: nil,     prefSym: nil,     anySelected:       func()       begin       	local sel := overview.selected;       	isArray(sel) and Length(sel) > 0;       end,     openScript:       DefineGlobalConstant('kSetSubmitDataFunc, func(options)	// !!!g       begin       	local entry := options.submitParams[0];       	// set form data to saved values       	call kInitGlobal with (Intern(entry.ISBN), {}).(EnsureInternal(Intern(entry.action))) := Clone(entry.data);       	GetRoot().(kBookReaderSymbol):ScrollPage(0);	// redisplay       end);                     func(target, targetView)       if target       then begin       	local entry := overview.selected[0];       	AddDeferredSend(overviewApp, 'close, nil);	// !!!d1              	if kSubmitQ and submit	// !!!g       	then begin       		entry := EntryFromObj(entry);       		// open original form, then redisplay with saved data       		local options := {       			callbackFn: kSetSubmitDataFunc,       			submitParams: [entry],       			};       		if call kFindBook with (entry.ISBN, nil)       		then begin       			GetRoot().(kBookReaderSymbol):openBook(entry.ISBN);       			AddDeferredCall(kSetSubmitDataFunc, [options]);       			end       		else newtscape:getURL(entry.docURL, options);       		end              	else newtscape:dispatchEntry(entry, {start: 0});	// !!!g. in case missing <HTML>       	end,     soupCount: 0    };folderTab :=    {     viewSetupFormScript:       func()       begin       	if soupName and not submit	// !!!g       	then begin       		title.viewBounds := SetBounds(4,1,-120,13);	// make wider. was -157,-135       		if not title.viewJustify	// !!!h. 2.0       		then title.viewJustify := vjParentFullH;       		if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym       		then begin // !!!j       			title.viewFont 		 := newtscape.dataFontJ;	//{family: sym, face: kFaceNormal, size: 10};       			showBarText.viewFont := newtscape.menuFontJ; 	//{family: sym, face: kFaceBold,   size: 10};       			showBarText.buttonClickScript := kFixButtonClickScript;       			end;       		end       	else viewFlags := 0;	// loadImages       	inherited:?viewSetupFormScript();       end,     _proto: @669 /* clView */    };AddStepForm(CacheBkMark, folderTab);StepDeclare(CacheBkMark, folderTab, 'folderTab);// After Script for folderTabthisView := folderTab;if kNIEthen thisView._proto := protoNewFolderTab;	// @669titleStr :=    {viewBounds: {left: 0, top: 0, right: 120, bottom: 16},     viewSetupFormScript:       func()       begin       	if soupName and not submit // !!!g       	then viewFlags := 0       	else if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := newtscape.menuFontJ;	//{family: sym, face: kFaceBold, size: 10};              	inherited:?viewSetupFormScript();       end,     _proto: @229 /* protoTitle */    };AddStepForm(CacheBkMark, titleStr);StepDeclare(CacheBkMark, titleStr, 'titleStr);overview :=    {cachedLine: nil,     SelectItem:       func(INT hitIndex)       begin       	if soupName       	then inherited:SelectItem(hitIndex) // protoSoupOverview w/ aliases       	else begin       		local entry := cursor:GetIndexEntry(hitIndex + cursPos - 1), pos;	// !!!j              		if selected and pos := SetContains(selected, entry) 	// = ok       		then ArrayRemoveCount(selected,pos,1)       		else if selected       		then AddArraySlot(selected, entry)       		else selected := [entry];       		// RedoChildren called in HitItem       		end;              	:updateTitle(nil);	// !!!g,f       end,     Reset:       func() // !!!g       begin       	cursPos := 1;       	cursor:reset();       	cursor;       end,     viewDrawScript:       func() // !!!k       begin       	inherited:?viewDrawScript();       	:DrawShape(cachedLine, {penPattern: vfNone, fillPattern: vfFillGray});       end,     stylep: nil,     updateTitle:       func(redo)	// !!!g,f       begin       	if redo       	then :RedoChildren();	// !!!g              	local txt := title, len := Length(selected), suffix :=       		(if numLines > 0 then $( & cursPos & $- & cursPos+numLines-1 & $))	 // none for empty folder       		&& (if len > 0 then $\uFC0B & len);              	if soupName and not submit       	then begin       		if cacheSizeSym       		then txt := txt && $[ & $² & newtscape.prefsEntry.(cacheSizeSym) & $]; //LocObj("Max.", 'maxLabel)       		txt := txt & $: && cursCount & $/ & soupCount;        		if folderTab	// !!!r. closed?        		then SetValue(folderTab.title, 'text, txt && suffix)       		end              	else if titleStr	// !!!r. closed?       	then begin       		titleStr:close();       		titleStr.title := txt & $: && soupCount && suffix;       		titleStr:open();       		end;       end,     Abstract:       DefineGlobalConstant('kCheckAlarm, func(aname,itemName,item,href)       begin       	local schedObj := GetAlarm(aname), schedItems;       	if isFrame(schedObj) and       		IsArray(schedItems := schedObj.callbackParams[3])       	then if itemName       		then LSearch(schedItems,href,0,'|str=|, nil)					// bookmarks       		else LSearch(schedItems,item,0,GetGlobalFn('IsSameEntry),nil);	// cache              		/*       		if IsEntryAlias(schedItems[0])       		then        			if itemName	// bookmark (but check scheduled cache items)       			then LSearch(schedItems,href,0,func(href,aentry) StrEqual(href,EntryFromObj(aentry).URL),nil)       			else LSearch(schedItems,item,0,GetGlobalFn('IsSameEntry),nil)	// cache       		else LSearch(schedItems,href,0,'|str=|, nil);					// bookmarks       		*/       end);              // if labelsfilter = '_all, then check validity of labels??              func(item,bbox)       begin       	local href := item.URL, txt := href, shape, line2;       	local ARRAY shapes := [];       	local INT top := bbox.top, left := bbox.left;       	if BeginsWith(txt, kHTTP)       	then txt := SubStr(txt, kHTTPlen, nil);              	if item.cached	// !!!k. View:Load*       		or (caches and	// Bookmarks       			(if caches[1] and call kImageExtension with (href)       			then call kGetURLCache with (caches[1], href, nil, nil, newtscape.prefsEntry.ignoreImageExpiration)       			else call kGetURLCache with (caches[0], href, nil, nil, newtscape.prefsEntry.ignoreHTMLExpiration)       			))       	then txt := kBullet && txt;	// bullet?              //Print("Abstract:" && href);       	if soupName and not submit and (       		(StrFilled(schedName) and call kCheckAlarm with (schedName,itemName,item,href))       		or (labelsFilter = '_all and       				begin       					local aname, result;       					foreach aname in GetAppAlarmKeys(kNCAlarmSuffix)       					do  if aname[0]=title[0] and	// H,I,B       							call kCheckAlarm with (aname,itemName,item,href)       						then break result := true;       					result;       				end)       		)       	then begin       		shape := MakeShape(ROM_alarmIconTinyBitmap);       //Print([top, bbox.bottom-lineHeight, bbox.bottom]);       		OffsetShape(shape, selectIndent-3,  top+2); // if itemName then 14 else 5);       		AddArraySlot(shapes, shape);       		end;              	if item.locked	// caches only       	then begin       		shape := MakeShape(ROM_closedPadlockBitmap);       		OffsetShape(shape, selectIndent, top+13);       		AddArraySlot(shapes, shape);       		end;       	if shape       	then bbox.left := left := selectIndent + 16; // ?3 + ROM_alarmIconTinyBitmap.bounds.right;              	if itemName       	then begin	// Bookmarks, Load*, Submit       		if not (line2 := item.name) or StrEqual(line2, href)	// !!!g       		then line2 := "";       		end              	else if soupName // caches       	then line2 := (EntrySize(item) div 1000)+1 & $K && $  && DateNTime(EntryModTime(item)) & // item.modified ?       			(if item.expires then "   (Expires:" && DateNTime(item.expires) & $) ) &&       			(if item.text then newtscape:fixString(call kGetTitle with (item.text), nil)); // !!!k,g,e              /* separate MakeText for 2 cols?       right align?       pad w/ spaces in front (same wid as digits?) zeros ugly       tab setting not recog */              	// !!!j       	AddArraySlot(shapes, MakeText(txt, left, top, bbox.right, top+13));	// url. bbox.bottom       	if StrFilled(line2) or labelsFilter = '_all       	then begin       		//if styleB then       		AddArraySlot(shapes, styleB);       		AddArraySlot(shapes, MakeText(       			line2 &&       			(if labelsFilter = '_all       			then $( &        				(if storesFilter then storesFilter else EntryStore(item)):GetName() & $: &       				GetFolderStr(item.labels) & $)),	// !!!k       			left, top+13, bbox.right, top+26	//bbox.bottom       			));       		//if styleP then       		AddArraySlot(shapes, styleP);       		end;              	shapes;              /*	shape :=       		if line2       		then MakeTextLines(       				StyledStrTruncate(Clone(txt), bbox.right - left, viewFont) &       				unicodeCR & line2 &&       				//(if item.edata then "POST") &&       				(if labelsFilter = '_all       				then $( &        					(if storesFilter then storesFilter else EntryStore(item)):GetName() & $: &       					GetFolderStr(item.labels) & $)),       				bbox, 13, viewFont)       		else MakeText(txt, left, top, bbox.right, bbox.bottom); // load images. 1-line              	if Length(shapes) > 0       	then SetAdd(shapes,shape,nil)       	else shape;       */       end,     viewBounds: {left: 3, top: 18, right: -1, bottom: -15},     _proto: @460 /* clView */,     deleteItems:       func(x)	// called via deleteScript(Confirm)       if x       then begin       	soupCount := soupCount - Length(selected);       	:ForEachSelected(GetGlobalFn('EntryRemoveFromSoup));	// 1-arg version       	:resetCursor(nil, true);       	end,     SetLock:       func(bool)	// !!!g. moved from main       begin       	:ForEachSelected(func(entry)	// !!!h       		begin       			entry.locked := bool;	// from closure       			EntryFlushXmit(entry,nil);       		end);	       	selected := [];					// !!!k              	/*       	local entry;       	foreach entry in selected       	do begin       		entry := EntryFromObj(entry);       		entry.locked := bool;       		EntryFlushXmit(entry,nil);	// !!!g       		entry := nil;       		end;       	*/              	:reset();			// !!!g. scroll back to top       	:updateTitle(true);	// !!!g.	:RedoChildren();       end,     cursor: nil,     Scroller:       func(INT numItems)	// !!!f       begin       	inherited:?Scroller(numItems);       	cursPos := max(1, min(cursCount, cursPos + numItems));       	:updateTitle(nil);	// !!!g       end,     SetupAbstracts:       func(curs) // redefine to handle large entries better?? removed in afterScript       begin       //Print("SetupAbstracts");       	local vb := :LocalBox(), entry, len;       	local INT i;       	self.maxLines := vb.bottom div lineHeight;       	vb.bottom := lineHeight;       	if not checkBoxVertOffset       	then checkBoxVertOffset :=       		if lineHeight       		then 2       		else max(lineHeight div 2 - 6, 0);              	self.pieces := Array(maxLines, nil);       	if checkScrollability       	then begin       		canScrollUp := (entry := curs:Prev()) and entry <> 'deleted;       		entry := nil;       		entry := curs:Next();       		end       	else entry := curs:Entry();              	for i := 0 to maxLines - 1       	do begin       		if not entry       		then break len := i;       		if entry <> 'deleted       		then begin       			pieces[i] := :GetTheRightShape(entry, vb);       			entry := nil;       			vb.bottom := (vb.top := vb.bottom) + lineHeight;       			end;       		entry := curs:Next();       		end;              	if checkScrollability       	then canScrollDown := (entry := curs:Entry()) and entry <> 'deleted;              	if len       	then SetLength(pieces, len);       	self.numLines := Length(pieces);       end,     cursPos: nil,     lineHeight: 28,     viewJustify: 240,     selected: nil,     resetCursor:       func(newCursor, redo)       begin       //Print("resetCursor: begin");       	selected := [];       	local entry;       	if newCursor       	then begin       		cursor := nil;       		cursPos := 1;	// !!!f       		cursor :=       			if not soupName and IsArray(querySpec)       			then {	// e.g., LoadImages       				_proto: fakeCursor,       				items: querySpec,       				itemLen: cursCount := Length(querySpec),	// !!!f       				}       			else begin       				if not querySpec       				then querySpec := {};       				if labelsFilter = '_all       				then RemoveSlot(querySpec, 'validTest)       				else querySpec.validTest := func(entry)       					entry.labels = labelsFilter;       					//or (EntryUndoChanges(entry) and nil);       //Print("resetCursor: before soup");       				local soup :=       					if storesFilter       					then storesFilter:GetSoup(soupName)       					else GetUnionSoupAlways(soupName);       //Print("resetCursor: before AddIndexXmit");       				if not itemName //querySpec.indexPath = '_modTime	// caches only. add in case it wasn't there       				then try soup:AddIndexXmit(kCacheSortIndex,nil)	       					 onexception |evt.ex| do RemoveSlot(querySpec,'indexPath);       //Print("resetCursor: before gc");       				gc();       //Print("resetCursor: before Query");       				soup:Query(querySpec);       				end;       		end              	else if not (entry := cursor:entry())       	then :reset()	// !!!g,f              	else if entry = 'deleted       		or (IsFrame(entry) and (       			(labelsFilter <> '_all and entry.labels <> labelsFilter)       			or (storesFilter and storesFilter <> EntryStore(entry))       			))       	then begin       		cursor:next();				// in case current top entry moved/gone       		//cursPos := cursPos+1;		// still same top pos?       		end;              //Print("resetCursor: before count");       	if soupName       	then begin       		cursCount := if labelsFilter = '_all then soupCount else cursor:countEntries(); // !!!f       		schedName :=       			if labelsFilter <> '_all and not submit	// !!!g       			then call kGetSchedName with (soupName, labelsFilter);       		end;              //Print("resetCursor: before redo");       	if redo       	then :RedoChildren();              	AddDeferredSend(self, 'updateTitle, '[nil]);	// !!!f. allow time for numLines to be set       //Print("resetCursor: after redo");       end,     styleb: nil,     viewSetupFormScript:       func()       begin       //Print("overview viewSetupFormScript");       	:resetCursor(true, nil);       /*       	if not soupName       	then begin // Images/Links       		if not itemName		// !!!d       		then lineHeight := 14;       		viewBounds := Clone(viewBounds);	// !!!c       		viewBounds.top := viewBounds.top - 2;       		end;       */       	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := newtscape.menuFontJ;	//{family: sym, face: kFaceNormal, size: 10};              	styleP := {       		font: viewFont,       		//, transferMode: modeOr       		};       	styleB := {	// for titles       		font: SetFontFace(viewFont, kFaceBold),	// !!!m. call kSetFont with (viewFont, nil, kFaceBold, nil),	//Bor(GetFontFace(viewFont),       		//transferMode: modeOr,       		};       	cachedLine := MakeRect(selectIndent-4, 0, selectIndent-3, :LocalBox().bottom); // !!!k              	//inherited:?viewSetupFormScript();       end,     HitItem:       func(index, x, y)       if x < selectIndent+5       then inherited:HitItem(index,x,y)       else begin       	local oldLen := if selected then Length(selected) else 0; // none before       	:SelectItem(index);       	if oldLen=0       	then Perform(:parent(), defaultScript, [true,nil])		//assumes script doesn't use target       	else if not soupName       	then :RedoChildren();	// checkmarks for Load Images, etc.       	TRUE;       	end,     cursCount: nil,     fakeCursor:       // for pseudo-soup (like Load Images,Links,Frames)       {items: nil,              itemLen: nil,              index: 0,              Entry: func()       	if index < itemLen       	then items[index],              Next: func()       	if index < itemLen-1       	then items[index := index + 1],              Move: func(INT delta)       	items[index := Min(Max(index + delta, 0), itemLen-1)],              Reset: func()       	index := 0,              Clone: func()       	{_proto: self,       	index: index,},	// !!!k. reset index?              GetIndexEntry: func(INT theIndex)       	items[theIndex],       	       /*       countEntries: func()       	itemLen,       */       },     viewFont:       kEspy9 //ROM_fontSystem9       ,     autoDeselect: true    };AddStepForm(CacheBkMark, overview);StepDeclare(CacheBkMark, overview, 'overview);// After Script for overviewthisView := overview;begin	if kNIE	then thisView._proto := protoSoupOverview;	// @460	RemoveSlot(thisView, 'setupAbstracts);endallButton :=    {     buttonClickScript:       func()       begin       	local sel := overview.selected;       	overview.selected := [];              	if not isArray(sel) or Length(sel) < overview.cursCount	// !!!h. if none/any, set all; Length(sel) = 0       	then begin       		sel := overview.selected;       		local cursor := overview:reset();	// !!!g,f       		local entry := cursor:entry();              		while entry       		do begin       			AddArraySlot(sel, if soupName then MakeEntryAlias(entry) else entry);       			entry := cursor:next();       			end;       		cursor:Reset();       		end;              	overview:updateTitle(true);	// !!!g,f.	overview:RedoChildren();       end,     viewBounds: {left: 3, top: -15, right: 38, bottom: -3},     viewJustify: 8388742,     text: $\uFC0B & LocObj("All", 'allLabel),     _proto: @226 /* protoTextButton */    };AddStepForm(CacheBkMark, allButton);// After Script for allButtonthisView := allButton;begin	// !!!h. NOS 2.1 only	// if kNIE	// then thisView._proto := newtCheckAllButton;	// @872 ?	if language <> 'English	then begin		thisView.viewBounds.right := thisView.viewBounds.right + 15;		end;	if kNCfont	then thisView.viewSetupFormScript := kFixButtonFormScript;endfileButton :=    {     viewSetupFormScript:       func()       begin       	if not soupName or submit	// !!!g       	then viewFlags := 0;		// loadImages, openSubmitQueue       	inherited:?viewSetupFormScript();       end,     pickIcon:       func()	// OVERRIDE version based on :GetTargetInfo       if not storesFilter or storesFilter = GetStores()[0]       then iconInt       else iconExt,     viewBounds: {left: -63, top: -15, right: -46, bottom: -2},     viewJustify: 166,     _proto: @176 /* protoFilingButton */    };AddStepForm(CacheBkMark, fileButton);StepDeclare(CacheBkMark, fileButton, 'fileButton);routeButton :=    {viewBounds: {left: -40, top: -15, right: -23, bottom: -2},     viewJustify: 166,     _proto: @209 /* protoActionButton */    };AddStepForm(CacheBkMark, routeButton);// After Script for routeButtonthisView := routeButton;begin	if kNCfont	then thisView.buttonClickScript := kFixActionClickScript;endCacheBkMark_v166_0 := {_proto: @166 /* protoCloseBox */};AddStepForm(CacheBkMark, CacheBkMark_v166_0);// After Script for CacheBkMarkthisView := CacheBkMark;begin	RemoveSlot(thisView, 'anySelected);	//RemoveSlot(thisView, 'appSymbol);	//RemoveSlot(thisView, 'FileThis);	//RemoveSlot(thisView, 'GetTargetInfo);	//RemoveSlot(thisView, 'target);	//RemoveSlot(thisView, 'newFilingFilter);	//RemoveSlot(thisView, 'labelsFilter);	//RemoveSlot(thisView, 'storesFilter);	//RemoveSlot(thisView, 'viewSetupFormscript);endconstant |layout_protoCacheBkmarkOverview| := CacheBkMark;// End of file protoCacheBkmarkOverview// Beginning of file MainLayoutNewtsCape :=    {curSource: nil,     fixFontsJ:       func(sym, size) // 2.x~J,~C,etc.  called by NC.vsfs, system(Family/Size)Picker       begin       	local redo := sym or size;	// !!!b1. nil for NC init       	if not sym       	then sym := prefsEntry.systemFontFamily;       	if not sym or not Fonts.(sym)	// use?: LSearch(call kGetAllFontsFunc with (),sym,0,'|=|,'screenSym)       	then prefsEntry.systemFontFamily := sym := kSystemFontSym;              	if not size       	then size := prefsEntry.systemFontSize;       	if not size       	then prefsEntry.systemFontSize := size := 9;       	if FrameDirty(prefsEntry)       	then EntryChangeXmit(prefsEntry,nil);              	self.labelFontJ :=       		if sym = kSystemFontSym       		then if size=9 then kEspy9B else kEspy10       		else {family: sym, face: kFaceBold, size: size};	// picker label, button label       	self.dataFontsJ :=       		if sym = kSystemFontSym       		then if size=9 then kEspy9 else kEspy10       		else {family: sym, face: kFaceNormal, size: size}; 	// aboutText, checkBox       	self.dataFontJ  :=       		if sym = kSystemFontSym       		then if size=9 then editFont10 else editFont12       		else {family: sym, face: kFaceNormal, size: if size=9 then 10 else 12}; // labelVal       	self.statusFontJ :=       		if sym = kSystemFontSym       		then if size=9 then userFont10 else userFont12       		else dataFontJ; // status       	self.entryFontJ :=       		if sym = kSystemFontSym       		then editFont12       		else {family: sym, face: kFaceNormal, size: 12};	// editable       	self.menuFontJ :=	// !!!j       		if sym = kSystemFontSym       		then ROM_fontSystem10Bold       		else {family: sym, face: kFaceNormal, size: 10};	// menu items              	if redo	// !!!b1       	then :redoChildren();       end,     scanLinks:       //constant kFileExtensions := '[".pkg", ".sit", ".sit.hqx", ".zip"];       constant wsattrib := "window.status=";	// !!!g              func(href, content, INT start, includeName, collectCacheH, collectCacheI, pview, poptions, except) // !!!k,c       if kNIE and href // scan doc for any HREF refs       then begin       	local bhref := call kGetBASE with (content);       	if not bhref then bhref := href;              	local queue := [], line, pos, ref, name, entry, pos2, pos3, tag, attrib, nattrib, ch, cached;       	local INT slen := StrLen(content);       	//local oldRun := :setRun('wait);              	if kNCfont and pview and prefsEntry.systemFontFamily <> kSystemFontSym	// !!!k       	then begin       		local ARRAY cf := pview:childViewFrames();       		SetValue(cf[2], 'viewFont, labelFontJ);	// statusText (top) ["title"]       		SetValue(cf[5], 'text, LocObj("Stop", 'stopLabel));       		SetValue(cf[5], 'viewFont, labelFontJ);	// Stop button       		SetValue(cf[4], 'viewFont, dataFontsJ);	// titleText (under gauge) ["status"]       		end;              	except :=	// !!!t       		if StrFilled(except)       		then call kCollectList with (except, $;);              	foreach entry in [			// !!!e       		//[kFrameStart, kSRC, kNAME], [kIFrameStart, kSRC, kNAME], [kBaseStart, kHREF,]       		[kLinkStart,kHREF, 	"REL"],       		["<A",		kHREF,	kALT],	// "ALT" for AREA or <A ..>.<IMG...</A>       		]       	do begin       		pos := start;       		tag := entry[0]; attrib := entry[1]; nattrib := entry[2];       		while (pos := StrPos(content, tag, pos))       			and pos2 := CharPos(content, $>, pos := pos + StrLen(tag))       		do begin       			if pview	// !!!k       			then begin       				poptions.titleText := tag;       				poptions.gauge := RIntToL(pos * 100 / slen);       				pview:SetStatus('vGauge, poptions);       				end       			else if :setGauge(tag,pos,slen)       			then RefreshViews();       			line := SubStr(content, pos, pos2-pos);              			if StrFilled(href := call kScanAttribute with (line, attrib))       //and (Print(href) or true)       				and (not (pos3 := CharPos(href, $#, 0)) or (pos3 > 0 and href := SubStr(href,0,pos3)))       				//and not LFetch(kFileExtensions, href, 0, GetGlobalFn('EndsWith), nil)	// !!!f,d       				and (ref := :ResolveURL(bhref, href := :fixString(href,true)))	// !!!g,f       				and BeginsWith(ref, kHTTP)       				and not StrEqual(bhref, ref)       				and not LSearch(queue, ref, 0, '|str=|, if includeName then 'URL)	// !!!s. not already queued       				// skip if host is in exception list              /*				and not (StrFilled(except) and (       							LFetch(kFileExtensions, ref, 0, GetGlobalFn('EndsWith), nil) or       							StrPos(except, call kSubStr with (ref, kHTTPLen, "/", nil), 0))) // !!!s       */       				and not (except and LSearch(except, ref, 0, kStrContains, nil))	// !!!u,t              				and (if call kImageExtension with (ref)	// already cached?       					then not (cached := call kGetURLCache with (cacheImages, ref, nil, nil, prefsEntry.ignoreImageExpiration))	// !!!k,f       							or collectCacheI       					else not (cached := call kGetURLCache with (cacheHTML,   ref, nil, nil, prefsEntry.ignoreHTMLExpiration))	// !!!k       							or collectCacheH       					)       			then if includeName       			then begin       				if name := call kScanAttribute with (line, wsattrib) // !!!f       				then :fixString(name,nil)       				else if not (((ch := content[pos-1]) = $A or ch = $a)	// LINK, AREA       						and isWhiteSpace(content[pos]))       				then if name := call kScanAttribute with (line, nattrib)       					then :fixString(name,nil)       					else name := href              				else if (pos3 := StrPos(content, "</A>", pos2))		// A       				then begin       					// name</A> -- simplest       					// <IMG ... ALT="name"...</A>       					// <x><y>name</y></x></A> -- messiest       					name := nil;       					while pos2 and (pos2 := pos2+1) < pos3       					do  if (ch := content[pos2]) = $<       						then if StrEqual(Substr(content,pos2+1,3),"IMG")       								and name := call kScanAttribute with (SubStr(content,pos2,pos3-pos2), nattrib) // ALT       							then break	// !!!g       							else pos2 := CharPos(content,$>,pos2)       						else if not isWhiteSpace(ch)       						then break name := call kMyTrim with (content, pos2, CharPos(content, $<, pos2));       					pos2 := pos3;       					if StrFilled(name) and StrFilled(name := SubstituteChars(name, "\n\t", "  "))       					then :fixString(name,nil)       					else name := href;       					end       				else name := href;              				AddArraySlot(queue, {       						name: if not StrEqual(name,ref) then name,       						URL: ref,       						cached: if cached then true}); // !!!k       				end       			else AddArraySlot(queue, ref);	// !!!s              			if pos2       			then pos := pos2+1       			else break;       			end;       		end;              	//:setRun(oldRun);       	if not pview 	// !!!k       	then :setGauge("",nil,slen);       	queue;       	end,     findHTMLentry:       func(soupname, htitle, htmlp, titleStart, titleStop) // :addIncludes, fileButton:openDoc,pickAction       begin       	local entry, res, htmlSource, titles, cursor;       	if isArray(htitle)       	then begin       		titles := htitle;       		htitle := NIL;       		end;              	if StrEqual(soupName, kPaperback) or (language='Japanese and StrEqual(soupName, kWabumiUni))       	then begin       		foreach entry in GetRoot()       		do if isFrame(entry) and       			(if language='Japanese and StrEqual(soupName,kWabumiUni)       			then entry.textData and entry.titleData       			else HasVariable(entry, 'PaperbackVers) and       				if entry.book       				then (if entry.PaperbackVers < 2100 or not entry.book.talps       						then entry := entry.book)       				else entry) and       			res := :matchHTMLtitle(entry, htitle, htmlp, titleStart, titleStop, nil)              			then if titles       				then AddArraySlot(titles, if kNIE then {item: res, value: entry} else res)       				else break htmlSource := res;       		end              	else if cursor := (if kNIE       		then begin gc(); GetUnionSoup(soupName):?Query(nil); end       		else Query(GetUnionSoup(soupName), '{type: index}))       	then begin       		entry := cursor:entry();       		while entry       		do begin       			if res := :matchHTMLtitle(entry, htitle, htmlp, titleStart, titleStop,       							if StrEqual(soupname, inboxSoupName) then cursor)       			then if titles       				then AddArraySlot(titles, if kNIE then {item: res, _alias: MakeEntryAlias(entry)} else res)       				else break htmlSource := res;       			entry := nil;       			entry := cursor:next();       			end;       		end;              	if titles       	then titles       	else htmlSource;       end,     newtletAttributes: nil,     disconnect:       func(fl) // added fl. called by viewQuitScript, </HTML>, fileButton, serialProtocol:inputLine       begin       	if commEndPt       	then begin       		NewtsCape:PRINT(LocObj("disconnecting", 'disconnectingMsg));       		commEndPt := GetRoot().(kSloupSymbol):?closeEndpoint(commEndPt, NewtsCape);       		end;              	if fl       	then newtscape:stopHTML();       end,     addStyle:       func (style) // called by getRun, newBook, P:get_Data.  NATIVE?       if style       then if SetContains(curBook.(kStylePath), style)       	then lastFont := style              	else if isFrame(style)       	then begin       		local s;       		foreach s in curBook.(kStylePath)       		do if isFrame(s) and s.face = style.face and s.size = style.size and s.family = style.family       			then return lastFont := s;              		// not there. clone so Pref not munged during Save       		AddArraySlot(curBook.(kStylePath), lastFont := if isReadonly(style) then style else Clone(style));       		end              	else AddArraySlot(curBook.(kStylePath), lastFont := style); // add int              else lastFont // e.g., BR ?       ,     saveBook:       func(curBook,libook,exbook) // added for invisible use?       if curBook and Length(curBook.(kContentsPath)) > 0       then begin       	local nData :=       		if kNIE       		then GetGlobalVar(kNewtSymbol)       		else GetGlobals().(kNewtSymbol);       	local isbn := curBook.isbn;       	if not curBook.appSymbol       	then curBook.appSymbol := Intern(isbn);       	local newtPkg := curBook._package;       	if not HasSlot(newtPkg, 'compressed)       	then newtPkg.compressed := optionsAPI.compressedPkg;              	// possibly some cleanup: e.g., remove GetUserConfig if Length(data)=4?       	// remove hrefScript if no pdata.scripts (except deferredObj)?              	curPkg := { // use NewtPack       		//_parent: self, // !!!a1. inheritance of :error       		_proto: nData.protos.protoPackage,       		//protoProgress: nData.protos.protoProgress, // unnec later       		appTemplate: curBook,       		smallPackage: not (kNIE or Functions.RestoreSegmentedPackage),	// kBuild20 or nos20       		newtscape: newtscape,	// !!!a1       		};               	//!!!a1       	//RemoveSlot(curPkg, '_parent);       	//curPkg.newtscape := newtscape;       	curPkg.SetStatus :=       		func(type, options)       		begin       			local txt := options.titleText;       			local len := StrLen(txt), pos := if kNIE then CharPos(txt,unicodeCR,0) else StrPos(txt,cr,0);       			if pos       			then if len > 0 and txt[len-1] >= $0 and txt[len-1] <= $9       				then txt := SubStr(txt,pos+1,nil) && SubStr(txt,0,pos) // swap msg and num       				else txt[pos] := $ ;       			// StrReplace(txt, cr, " ", nil);       			//newtscape:setStatus(txt);       //Print(options);       			len := options.maxGauge;	// sizeHint       			newtscape:setGauge(txt, if len then (options.gauge*len) div 100 else 0, len);       			AddProcrastinatedSend(Intern("pkg" & $: & kAppSymbol),       				newtscape, 'setGauge, '["",nil,nil], kDelay);       			RefreshViews();       		end;       	curPkg.error := func(str, errframe) newtscape:error(str, errframe); //GetRoot().(kAppSymbol)       	curPkg.progressView := curPkg;              	if not libook // current book never opened       		and (newtPkg.existingPackage := exbook or (exbook := call kFindBook with (isbn,nil)))       		and not optionsAPI.noConfirm       	then :Confirm(       			title,       			kReplacePkg & unicodeCR & exbook.appSymbol & "\n(isbn:" && isbn & $),       			self,       			'savePackageConfirm);       	else :savePackageConfirm(true);       	end,     fixVal:       func(val)       if isImmediate(val) or IsReadOnly(val)       	//(if kNIE then IsSymbol(val) else isInstance(val,'symbol))	// this blows up for [2: nil,...]       then val              else if isFrame(val)       then begin       	local slot, val1;       	if (if kNIE       		then IsFunction(val)       		else isInstance(val, '_function) or	// 2.x       			isInstance(val, 'CodeBlock) 	// 1.x        		)       	then begin	// moved inside frame test. should also recursively fixup array/frame       		local val1 := val.argFrame;       		if val1       		then val1._nextArgFrame := val1._parent := val1._implementor := NIL;       		RemoveSlot(val, 'DebuggerInfo); // if present, e.g., from 2.x compatibility       		end;              	foreach slot, val1 in val       	do val.(slot) := :fixVal(val1);       	val;       	end              else if isArray(val)       then begin       	local INT i;       	for i:= 0 to Length(val)-1       	do val[i] := :fixVal(val[i]);       	val;       	end              else val,     htmlSoup: nil,     viewSetupDoneScript:       func()       begin       	:Init(prefsEntry := NIL);	// force init (and set optionsAPI)              	if kNIE       	then begin       		RegPowerOff(kAppSymbol,       			func(what,why) Newtscape:powerOffScript(what));       		RegSoupChange(notesSoupName, 		kAppSymbol, kSoupChanged);       		RegSoupChange(inboxSoupName, 		kAppSymbol, kSoupChanged);              		RegSoupChange(kCacheHTMLSoupName,kAppSymbol, kSoupChanged);	       		RegSoupChange(kCacheImagesSoupName, kAppSymbol, kSoupChanged);       		//bookmarks := prefsEntry.bookmarkSoupName;	// moved to Init       		end              	else begin       		AddPowerOffHandler(self);       		GetRoot().(kExtrasSym):?close(); // undocumented???              		AddArraySlot(soupNotify, notesSoupName);       		AddArraySlot(soupNotify, kAppSymbol);       		AddArraySlot(soupNotify, inboxSoupName);       		AddArraySlot(soupNotify, kAppSymbol);       		end;              	local gData := call kInitGlobal with (nil,nil);       	gData.(kHistoryPath) := EnsureInternal([]);	// zap cache upon startup       	gData.(kHistoryPos)  := 0;	// !!!e              	if StrFilled(prefsEntry.startupURL)       	then if kNIE       		then AddDeferredSend(self, 'getURL, [prefsEntry.startupURL, nil])       		else AddDeferredAction(Functions.Perform, [self, 'getURL, [prefsEntry.startupURL, nil]]);              	if not prefsEntry.IPaid       	then if kNIE       		then AddDeferredSend(infoButton, 'DoInfoAbout, nil)       		else AddDeferredAction(Functions.Perform, [infoButton, 'DoInfoAbout, []]);              	inherited:?viewSetupDoneScript();       end,     bookTemplate:       func()       begin       	local ARRAY pageSizes :=	// !!!a1. see pageSizePicker.labelCommands,viewSetupFormScript       		if kBuild20       		then if nos21       			then '[help, portrait, landscape, /*classic,universal,*/ MP2K_2Up, eMate_2Up, full, full_fix4, full_fix] // !!!d1       			else '[help, portrait, landscape, full]       		else '[help, portrait];       	local INT plast := Length(pageSizes)-1;       	local ap := GetAppParams();       	local INT wid := ap.appAreaWidth, ht := ap.appAreaHeight;       	local size := SetContains(pageSizes, optionsAPI.pageSize);       	if not size       	then size := plast;	// !!!a1. full-/full/portrait  [last is default]              	local INT maxX := min((if kBuild20 then [206,240,320, /*240,202,*/ 202,224, wid,wid,wid-kFullOffset2+20] else '[206,240])[size],  wid);	// !!!d1,c1,a1       	local INT maxY := min((if kBuild20 then [216,320,240, /*304,282,*/ 282,284,  ht, ht, ht-kFullOffset2] else '[216,320])[size]-2, ht);	// !!!d1,a1       	local INT minX := if kBuild20 and nos21 and size=plast-1 then 4 else 0;	// !!!a1. old ROM kludge              	if wid := call kGetInt with (optionsAPI.pageWidth, nil)		// !!!b       	then maxX := wid;       	if ht  := call kGetInt with (optionsAPI.pageHeight, nil)	// !!!b       	then maxY := ht;       	// currently, don't know how to make portrait or landscape books draggable              	local bookTitle := call kGetStr with (optionsAPI.bookTitle, kUntitled);              	rootContainer := {	// !!!o. currentContainer :=        		_proto: kprotoContainer,       		left:	minX,       		top:	if size=0 then 0 else :SimpleTextHeight(bookTitle,maxX-(2*minX),tagDict.TITLE.font), // !!!a1. TITLE (none for help; 1-line default, <TITLE> may adjust)       		right:	maxX-minX,       		bottom:	maxY - if kStyleMeasure then 18 else 12,	// !!!o. for control bar/close box/Topics       		};       	currentContainer := rootContainer:setContainer(Clone(rootContainer));	// create separate       	currentContainer._container := NIL;		// don't want it to accidentally disappear (or use root)       	currentContainer._parent := NewtsCape;              	local user := Clone(if kNIE       			then GetUserConfig('name)       			else call kMyGetUserConfig with ('name));       	local standalone :=	optionsAPI.standAlone;              	local bkframe :=       		{version:	if kNIE then 2 else 1,	// for package/BookMaker.	was nos20       		flags: 		if kNIE then 64, 		// else nil,				was nos20       		isbn:  		call kGetStr with (optionsAPI.bookISBN, kUntitledISBN), // !!!b. supply via META       		title: 		bookTitle,	// !!!a1,b. supply via TITLE              		shortTitle: call kGetStr with (optionsAPI.bookShortTitle,kUntitled),// !!!b. for Extras. supply via META       		author:		user,       		copyright: 	$© && Date(Time()).year & $, && user, // for package       		publisher: 	user,       		publicationDate: Time(),       		//icon: 	bookIcon,              		// content data structure for book.  see :bookPage, :bookItem       		data:	{  // global stuff accessible via :BookData()       			form_hidden: {}, 		// for INPUT HIDDEN       			form_printnames: {}, 	// for FORM fields, including form_hidden       			base_href: call kGetStr with (optionsAPI.bookBase, NIL),		// !!!b. URL for BASE (used in kGotoHREF; set in kSendHTTP or doc)       			links: [],				// from LINK       			},       		styles: 	[],       		contents: 	[],       		browsers: 	[{name: LocObj("Contents", 'bookContentsTitle),  list: []}],	// !!!k. list of topics       		templates: 	[{	// Page Templates 'Default'       			nColumns:	1,       			column: 	'[{width: 12, type: 0}],       			scripts: [       				'hrefScript, 		if standalone       									then kGoToHREFclickShare// !!!e. kGoToHREFclick       									else kGoToHREFclickNC,	// non-standalone       				'viewClickScript, 	kNilFunc1, 				// so text editable       				//'mungeContentScript, func(acontent)		//???       				],       			}],       		rendering: 	[{       			pageSize: SetBounds(0, 0, maxX, maxY), 	// current Newt's Cape orientation       			pages: [], 	// list of pages       			}, ],              		appSymbol: NIL,  // for NewtPack save. set in META or saveBook       		_package: {       			//existingPackage: true/nil,  // for NewtPack save. set in saveBook       			//compressed	// via META or Pref       			},       		};              	if kBuild1x       	then bkframe.(kDataPath).GetUserConfig :=	// omit from 2.0 books (use GetUserConfig function)       		if standalone       		then kMyGetUserConfig       		else kMyGetUserConfigNC	// non-standalone       	else bkframe.(kDataPath).titleFormat := {};              	local ARRAY scripts := bkframe.(kScriptsPath);       	if size=0	// help book?       	then begin       		bkframe.help := true;       		// fill in ISBN, viewQuitScript later (1st refreshBook) for "invis"       		AddArraySlot(scripts, 'bookData);       		AddArraySlot(scripts, kHelpBookData);       		end              	else begin // regular book       		bkframe.icon := bookIcon;       		bkframe.(kStringHintsPath) := [];       		bkframe.rendering[0].contents := [[]];   // page hints       		AddArraySlot(scripts,'viewSetupDoneScript);       		AddArraySlot(scripts,       			if standalone       			then kBookOpenScript       			else kBookOpenScriptNC);       		AddArraySlot(scripts,'viewQuitScript);       		AddArraySlot(scripts,       			if optionsAPI.noStatus and not Visible(newtscape)       			then kBookCloseScriptInv       			else kBookCloseScript);       		// fill in ISBN later (1st refreshBook) for "invis"              /*		if kBuild20       		then begin       			AddArraySlot(scripts, 'sayPage); // see kBookOpenScript       			AddArraySlot(scripts, kSayPage);       			end;       */       		end;              	if kNIE       	then begin	// remove before save (savePackageConfirm)       		AddArraySlot(scripts, 'mungeContentScript);       		AddArraySlot(scripts, kMungeContentScript);       		//AddArraySlot(scripts, 'BookSearchScript); // not getting called at all. neither is FormSearchScript on individual item       		//AddArraySlot(scripts, kBookSearchScript);       		end;              	bkframe;       end,     Confirm:       if kNCfont       then begin       	constant kProtoConfirm := @544;       	DefineGlobalConstant('kButtonTemplateSetupScript, func()       		begin       			// std method uses ButtonStdWidth, which is wrong       			self.viewBounds := SetBounds(-(StrFontWidth(text,viewFont)+12),0,-7,0);       			if baseSlot       			then base.(baseSlot) := self;       		end);       	end;              func(apptitle, str, obj, msg) // apptitle is unused (per 1.x)       if kNIE       then begin       	local ARRAY buttons :=       		if isArray(obj)	// !!!j       		then obj       		else [{text: LocObj("Yes", 'yesLabel),	value: true,	keyValue: 'default},	// 'yesNo       		 	  {text: LocObj("No",  'noLabel),	value: nil,		keyValue: 'close},       			];       	local fn :=       		if IsFunction(msg)	// !!!j       		then msg       		else func(x) Perform(obj,msg,[x]);       	       	if kNCfont and prefsEntry and prefsEntry.systemFontFamily <> kSystemFontSym	// !!!j       	then begin       		// setvalue worked like Notify, except that buttons stayed too narrow       		// check that this works on 2.0, e.g., MP120???       		local ARRAY kids := Clone(kProtoConfirm.viewChildren);       		kids[0] := {_proto: kids[0], viewFont: statusFontJ};       		local view := BuildContext({       			_proto: kProtoConfirm,       			message: str,        			buttonList: buttons,       			viewQuitScript: func()	AddDeferredCall(fn, [view.confirmedValue]),       			viewChildren: kids,       			buttonTemplateClose: {       				_proto: kProtoConfirm.buttonTemplateClose,       				viewFont: labelFontJ,       				baseSlot: '_closeBox,       				viewSetupFormScript: kButtonTemplateSetupScript,       				},       			buttonTemplateDefault: {       				_proto: kProtoConfirm.buttonTemplateDefault,       				viewFont: labelFontJ,       				baseSlot: '_defaultButton,       				viewSetupFormScript: kButtonTemplateSetupScript,       				},       			buttonTemplate: {       				_proto: kProtoConfirm.buttonTemplate,       				viewFont: labelFontJ,       				baseSlot: nil,       				viewSetupFormScript: kButtonTemplateSetupScript,       				},       			});       		view:FilterDialog();       		view;       		end       	else AsyncConfirm(str, buttons, fn);       	end              else GetRoot():Confirm(apptitle, str, obj, msg),     imgMaps: nil,     sharewareFee: kSharewareFee,     setPreference:       func(sym,val)       begin       	if sym       	then prefsEntry.(sym) := val;       //Print(if not FrameDirty(prefsEntry) then "frame NOT dirty:" && sym);       	if kNIE       	then EntryChangeXmit(prefsEntry,nil)       	else EntryChange(prefsEntry);              	if kNIE and sym = 'kbdKeys       	then begin       		newtscape.mykbd:?close();	// !!!y       		newtscape.mykbd := nil;       		end;              	if sym = 'showLongURL or sym = 'showCmdStatus       	then begin       		newtscape:SyncView();       		newtscape:SyncChildren();	//RedoChildren();       		/*SetValue(newtscape, 'viewBounds, kBounds0);	// force re-display via viewSetupFormScript       		if sym = 'showLongURL       		then SetValue(URLpara, 'viewBounds, kBounds0);*/       		end;       end,     BASEFONT:       3	// !!!e       ,     matchHTMLtitle:       func(entry, title, htmlp, titleStart, titleStop, cursor) // findHTMLentry, openDoc       // if title=TRUE, return source(if valid) or NIL       // if title is "string", return source(if match) or NIL       // if title=NIL, return TITLE or NIL (if not HTML)       if isFrame(entry) or (if kNIE then IsString(entry) else isInstance(entry,'string))       then begin       	local spos, htitle, val;       	local htmlSource :=       		if (if kNIE then IsString(entry) else isInstance(entry, 'string))       		then entry       		else if (if kNIE then IsString(val := entry.text) else isInstance(val := entry.text, 'string))       		then val       		else if language='Japanese and IsString(val := entry.textData)	// WabumiUni       		then val       		else if entry.body.text exists       		then entry.body.text       		else if isArray(entry.data) and Length(entry.data) > 0       		then entry.(kSourcePath); // 1st para              	if htmlSource and       		(if kNIE       		then IsString(htmlSource) and not IsRichString(htmlSource) // copy to VBO in addFile       		else isInstance(htmlSource,'string))       		and (spos := if htmlp then call kIsHTML with (htmlSource) else 0) // skip until <HTML> or <!DOCTYPE ? !!!j. :skipHTML       	then begin       		if title <> true       		then begin       			htitle :=       				if (if kNIE then IsSymbol(titleStart) else isInstance(titleStart,'symbol))       				then entry.(titleStart)       				else :fixString(call kSubStr with (htmlSource, titleStart, titleStop,nil),nil); // <TITLE> or <LINK       			if title       			then if (if kNIE then IsString(htitle) else isInstance(htitle,'string)) and StrEqual(title,htitle)       					then htmlSource // continue       					else return NIL       			else return if htitle       				then htitle       				else if kNIE and titleStart=kTitleStart       				then kUntitled;       			end;              		// moved from findHTMLentry       		if cursor and (htitle := entry.title) and       			(if kNIE then IsString(htitle) else isInstance(htitle,'string)) and       			BeginsWith(htitle,"(1)")       		then begin // concatenate split messages in Inbox       			// ??? for now, assume they're contiguous, in order & no more than 9       			htitle := Clone(htitle);       			local INT mnum := Ord(htitle[1] := $2);       			if cursor=true	// from File:Open Inbox       			then begin       				gc();       				cursor := if kNIE       					then EntrySoup(entry):Query(nil)       					else Query(EntrySoup(entry), '{type: index});       				cursor:GoTo(entry);       				end;       			while (entry := cursor:next()) and       				(if kNIE then IsString(entry.title) else isInstance(entry.title,'string)) and       				StrEqual(htitle, entry.title)       			do begin       				StrMunger(htmlSource,StrLen(htmlSource),0, entry.text,0,nil);       				htitle[1] := Chr(mnum := mnum+1);       				end;       			end;       		htmlSource;       		end              	else if kNIE and isFrame(entry) and isFrame(val := entry.body)	// EETransfer       	then if IsString(htitle := val.title) and IsBinary(val := val.data)       		then if title=nil       			then htitle	// assume file ok?              			//else if not StrEqual(title, htitle)	//do filename match??       			//then NIL              			else if call kByteBeginsWith with (val, kGIFStart, 0)	// return args       			then [kGIFMediaType, htitle, val, nil]       				/*:convertImage(kGIFMediaType, htitle, val, {_proto: optionsAPI, cacheImages: nil, rawImage: nil}, nil),	// use default GIF.Decompress converter       				nil]*/              			else if call kByteBeginsWith with (val, kJPEGStart, 6) and       				:dispatchFile(kJPEGMediaType, htitle, nil, nil) // !!!a. plugin installed?       			then [kJPEGMediaType, htitle, val, nil]		// fix in dispatchFile              			//else if call kByteBeginsWith with (val, kPkgStart, 0)		// MacBinary?       			//then [kNewtonPkgMediaType, htitle, SetClass(val, 'packageEntry), nil]              			else begin       				if not optionsAPI then optionsAPI := {};	// !!!c1       				optionsAPI.inboxEntry := entry;				// !!!c1 (e.g., for AudInbox)       				local type, helperFrame, sym, helperApp;	// !!!x. see installHelperApp, View:Helpers       				foreach type,helperFrame in call kInitGlobal with ('helperApps, {})       				do  foreach sym,helperApp in helperFrame       					do  if isFrame(helperApp) and helperApp:?matchFile(htitle,val)       					 	then return [SPrintObject(type),htitle,val,nil];              				// assume HTML???       				htmlSource := call kCopyRawHTML with (val);       				[if call kIsHTML with (htmlSource) then kHTMLMediaType else kTextMediaType, // !!!j. :skipHTML       				htitle, htmlSource, nil];       				end;       	end,     viewFormat: 67109633,     fixHrefs:       func() // called by </HTML> if any includes       begin       	// remap HREFs. for now, just add shadows to data & assume NAMEs unique across books       	// later, could rewrite item.HREFs and item.NAME to be unique??       	local item, href, npos, inclpos, istr, pos1;       	local ARRAY hrefentry;              	foreach item in curBook.(kContentsPath)       	do  if isFrame(item) and item.hrefs       		then foreach hrefentry in item.hrefs       			 do begin       				href := hrefentry[0];       				npos := if kNIE then CharPos(href,$#,0) else StrPos(href,"#",0);       				pos1 := if BeginsWith(href, "./") then 2 else 0;	// !!!e       				if npos<>0 and not call kURLmatch with (href)       					and (istr := SubStr(href,pos1,if npos then npos-pos1))	// !!!e       					and if kNIE       						then (inclpos := LSearch(includes, istr, 0, '|str=|, nil)) or       							 (inclpos := LSearch(includes, $/ & istr, 0, '|str=|, nil))	// !!!e. for pre-1.6m       						else (inclpos := ArrayPos(includes, istr, 0, Functions.StrEqual)) or       							 (inclpos := ArrayPos(includes, $/ & istr, 0, Functions.StrEqual))       				then curbook.(kDataPath).(Intern(href)) :=       						if npos       						then SubStr(href,npos,nil)       						else "#PAGE#" & pageStarts[inclpos];       				end;       end,     debugFlag: nil,     viewQuitScript:       func()       begin       //Print("NC quitting");       	:disconnect(nil);              	// !!!g       	//aboutView:?close();       	//NIEPrefsView:?close();       	//TagPrefsView:?close();              	self.mykbd:?close();	// !!!b              //Print("removeApp");       	:removeApp(nil,nil);	// don't allow prevBook              	local i := 0;       	if NewtPack       	then call kRemoveAllSoupEntries with (kPkgSoupName);       	call kRemoveAllSoupEntries with (kHTMLSoupName);	// moved from :quit              	if kNIE       	then begin       		//:viewShowScript();	// get rid of task entry if still one somehow       		if self.hideObj	// !!!g       		then begin       			GetRoot().notifyIcon:?KillAction(hideObj);       			hideObj := NIL;       			end;       		UnRegSoupChange(notesSoupName, kAppSymbol);       		UnRegSoupChange(inboxSoupName, kAppSymbol);              		UnRegSoupChange(kCacheHTMLSoupName, kAppSymbol);       		UnRegSoupChange(kCacheImagesSoupName, kAppSymbol);       		UnRegPowerOff(kAppSymbol);       		end       	else begin // 1.x       		while i := ArrayPos(soupNotify, kAppSymbol, i, nil)       		do ArrayRemoveCount(soupNotify, i-1, 2);              		RemovePowerOffHandler(self);       		end;                     	if kNIE and prefsEntry       	then begin       //Print("cacheHTML");       		if cacheHTML	// remove all or just expired, query entries       		then if prefsEntry.emptyHTML       			then call kRemoveAllSoupEntries	with (cacheHTML)       			else call kCollectURLs with (cacheHTML, kDebugHTTP, prefsEntry.cacheHTML, nil, nil, prefsEntry.ignoreHTMLExpiration);		// was deferred. prefsEntry.keepQueryHTML       //Print("cacheImages");       		if cacheImages       		then if prefsEntry.emptyImages       			then call kRemoveAllSoupEntries	with (cacheImages)       			else call kCollectURLs with (cacheImages, kDebugHTTP, prefsEntry.cacheImages, nil, nil, prefsEntry.ignoreImageExpiration);	// prefsEntry.keepQueryImages              		//if bookmarks       		//then UnRegUnionSoup(prefsEntry.bookmarkSoupName, kAppSymbol);       		end;              	if kNIE and nos21	// get rid of all but most recent ~20 entries       	then begin       //Print("kbd");       		local root := GetRoot(), entries;       		root.(kLogicKbdSym):?RemoveKeyArray(kAppSymbol);       //Print("getOfflineBooks");       		for i:=0 to Length(entries := root.(kBookReaderSymbol):getOfflineBooks())-21       		do EntryRemoveFromSoupXmit(entries[i], nil);       		end;       		       //Print(":quit");       	:quit();       	// !!!i. optionsAPI := NIL;       //Print("done");       	inherited:?viewQuitScript();       end,     lastRadio: nil,     inputDictOrig:       DefineGlobalConstant('kVALUE_TYPE_NAMES,       	'["INT", "NUM", "DATE", "TIME",       	"PHONE", "FAX", "ADDRESS", "NAME",       	"COUNTRY", "CITY", "STATE", "PROVINCE",       	]);       DefineGlobalConstant('kVALUE_TYPE_FLAGS,       	[vNumbersAllowed, vNumbersAllowed, vDateField, vTimeField,       	vPhoneField, vPhoneField, vAddressField, vNameField,       	[vCustomDictionaries, kCountriesDictionary], [vCustomDictionaries, kLocalCitiesDictionary],       	[vCustomDictionaries, kLocalStatesDictionary], [vCustomDictionaries, kLocalStatesDictionary],       	]);                     {// types for INPUT form              TEXT_LABEL: {	// labelFont (for label) = TEXT.data.labelFont       	_proto: 'protoTagForm,       	//font:	kEspy9B,	       	},              TEXT: {       	_proto: 'protoTagForm,       	//height: 20, //??? should calculate height based on LABEL       	VALUE_TYPE:		"",       	// entryFont (for value) = TEXT.data.entryLine.viewFont       	font:	if kBuild20 then editFont12 else userFont12, //if language='Chinese then kEspy12 ?              	data: { // our own simple version of "protoLabelInputLine". also used by PASSWORD       		viewClass: clView,       		LABEL: "",       		NAME:  NIL,       		VALUE: "",       		MAXLENGTH: 	nil,		// no limit       		HREF: 		nil,       		//ACTION:  kUnkURL,       		//SCRIPT:  kPrintFunc,       		GetData: kGetData,       		SetData: kSetData,       		AllData: kAllData,		// used by GetData,SetData              		encode: NIL, 	// override for PASSWORD       		viewFlags: 513, // vVisible+vClickable       		width: 240,		// set in get_data       		entryFlags: NIL,       		dictionaries: NIL,       		indent:		NIL,	// for viewClickScript(HREF)       		//indent: 90,	// see labelWidth       		labelWidth: func()       			if StrLen(LABEL)=0       			then 0       			else max(30, min(StrFontWidth(LABEL, labelFont)+5, min(100,width div 2))),       		bottomInset: 0,	// !!!a              		labelFont:	kEspy9B,       		entryFont: nil,              		viewChildren: [viewChildren:       			{_proto: protoStaticText,       			//text:	LABEL,       			viewJustify: vjParentFullV + vjCenterV, // multiple lines, left justified, etc. added vjCenterV (for taller labelFont)       			//viewBounds: RelBounds(0,0,90,0), // indent       			viewSetupFormScript: func()       			begin       				self.text := LABEL;       				viewFont := labelFont;       					/*if HREF       						then Bor(labelFont, tsUnderline)       						else labelFont;*/       				self.viewBounds := RelBounds(0,0,:labelWidth(),0);       			end,       			},       			{_proto: protoInputLine,       			//viewBounds: SetBounds(90,0,0,0), // indent       			viewJustify: vjParentFullH+oneLineOnly+vjParentFullV,       			viewFormat: 256+80+12288+1, // vfPen*1 + vfFrameBlack + vfLinesGray + vfFillWhite       			//viewFont: editFont12,       			viewChangedScript: func(slot,view) // save a single STRING value. share w/ TEXTAREA       				if slot='text       				then begin       					if MAXLENGTH and StrLen(text) > MAXLENGTH       					then begin       						:SysBeep();       						return SetValue(self, 'text, StrMunger(text,MAXLENGTH,nil, nil,0,nil));       						end;       					local txt;       					if encode       					then begin       /*						local i;       						// if text is all coded, then no need to encode or dirty       						// this should also prevent recursion SetValue->viewChanged->SetValue...       						for i := StrLen(text)-1 to 0 by -1       						do if ORD(text[i]) <= kMaxPWChar       						then return SetValue(self, 'text, :encode(text, true)); // encode, redisplay, then setData       */       						if txt := :encode(text, true)	// not entirely encoded already?       						then return SetValue(self, 'text, txt);       						txt := :encode(text, nil); 	// decode value       						end       					else txt := text;              					:SetData(NAME,       						/*if kNIE and IsRichString(txt)       						then DecodeRichString(txt, viewFont).text       						else*/ txt);       					//if encode then :dirty();	// 1.x books still leave last char clear on 2.x       					:?SCRIPT(txt);       					end,              			viewSetupFormScript: func()	// share w/ TEXTAREA       			begin       				// font, linespacing based on Tag Prefs ???       				if entryFlags       				then self.viewFlags := entryFlags;       				if dictionaries       				then self.dictionaries := dictionaries;       				self.text :=       					if not NAME       					then kNoName       					else begin       						local txt := :GetData(NAME);       /*if encode and txt := :encode(Clone(txt),true)       then txt       else Clone(if txt then txt else VALUE);*/       						if not txt then txt := VALUE;       						local INT slen := StrLen(txt);       						txt := if MAXLENGTH and slen > MAXLENGTH       								then SubStr(txt, 0, slen := MAXLENGTH)       								else if kBuild20 and slen > 2000	// long TEXTAREA, e.g., www.newmail.net       								then call kNewVBO with (nil,nil,txt)       								else Clone(txt);       						if encode and slen > 0 then :encode(txt,true) else txt;       						end;              				if entryFont       				then begin       					local fht := FontHeight(viewFont := entryFont); // (viewFont set directly by TEXTAREA)       					if fht > viewLineSpacing       					then viewLineSpacing := fht;       					end;              				/*if encode       				then begin       					//self.viewFormat := viewFormat+1; // vfLtGray       					//self.viewFont := 0x00002403;       					end;*/              				if labelWidth // nil for (short) TEXTAREA       				then self.viewBounds := SetBounds(:labelWidth(), 0, 0, bottomInset);	// !!!a              				// only set key view for first TEXT/PASSWORD (or TEXTAREA) on a page       				// maybe do at create time (except book needs to be open/displaying. tables,savepkg,...?)       				local pfield1 := call kInitGlobal with (Intern(ISBN), {}).(kFirstFieldsFlag), pnum;       				if isArray(pfield1)       				then begin       					if Length(pfield1) < pnum := :currentPage()       					then SetLength(pfield1, pnum);       					if (not pfield1[pnum-1] and pfield1[pnum-1] := NAME) or pfield1[pnum-1] = NAME       					then SetKeyView(self, StrLen(text));       					end;              				inherited:?viewSetupFormScript();       			end,       			},       			],       		//viewClickScript       		},              	copyAttrib: {NAME: 'formName, SCRIPT: 'compile, LABEL: 'string, VALUE: 'string, MAXLENGTH: 'int, HREF: 'string,       		entryFlags: 'nil, dictionaries: 'nil,       		//labelFont: 'compile, entryFont: 'compile,       		},              	get_data: func()       	if _data       	then self       	else begin       		local iobj, pos, val;       //Print(VALUE_TYPE);       		// default: vCharsAllowed + vNumbersAllowed + vGesturesAllowed + vClickable + vVisible       		if StrFilled(VALUE_TYPE)       		then if isFrame(iobj := curBook.(kDataPath).(Intern(VALUE_TYPE))) // user defined proto       				and (HasSlot(iobj, '_proto) or HasSlot(iobj, 'viewClass) or iobj := nil)       			then begin       				// user proto with additional methods       				iobj.GetData := kGetData; iobj.SetData := kSetData; iobj.AllData := kAllData; // store (once) in proto directly       				data := {_proto: iobj};       				//data := {_proto: iobj, GetData: kGetData, SetData: kSetData, AllData: kAllData};       				// optional slots, e.g., MINVALUE (for slider)       				if not HasSlot(self, 'HEIGHT) and iobj.HEIGHT       				then self.HEIGHT := iobj.HEIGHT;       				if isFrame(iobj.copy_Attributes)       				then copyAttrib := call kAppendFrame with (Clone(iobj.copy_Attributes), copyAttrib);       				end       			else if pos := (if kNIE       					then LSearch (kVALUE_TYPE_NAMES, VALUE_TYPE, 0, GetGlobalFn('BeginsWith), nil)       					else ArrayPos(kVALUE_TYPE_NAMES, VALUE_TYPE, 0, Functions.BeginsWith)) // !!!h       			then begin       				val := kVALUE_TYPE_FLAGS[pos];       				if isArray(val)       				then begin       					self.dictionaries := val[1]; // copied to dproto via addAttrib       					val := val[0];       					end;       				self.entryFlags := val + vGesturesAllowed + vClickable + vVisible; // copied to dproto via addAttrib       //Print("entryFlags:" && entryFlags);       				end;              		local dproto := :addAttrib(data, self), txt;       		width := :getWidth(dproto);       		height := :fixAttribute(height, 'int, height);	// same as protoTagForm (esp. for iobj)       		if not iobj       		then begin       			dproto.width := width;       /*       			if (kFontFix and not HasSlot(dproto,'labelFont))       				or (kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym)       			then begin       				if self.HREF       				then begin       					dproto.labelFont := Clone(labelFontJ);       					dproto.labelFont.face := kFaceBold+kFaceUnderLine;       					end       				else dproto.labelFont := labelFontJ;       				dproto.entryFont := entryFontJ;       				end       			else if self.HREF       			then dproto.labelFont := Bor(dproto.labelFont, tsUnderLIne);       */              			local font2 := inputDict.TEXT_LABEL.font;       			if self.HREF       			then dproto.labelFont :=       					if isFrame(font2)       					then call kAddEmphasis with (font2, kFaceUnderline)       					else Bor(font2, tsUnderline)       			else if font2 <> inputDictOrig.TEXT_LABEL.font       			then dproto.labelFont := Clone(font2);	// !!!c1. avoid NewtPack error              			if font <> inputDictOrig.TEXT_VALUE.font       			then dproto.entryFont := Clone(font);	// !!!c1       			local INT wid := if StrFilled(dproto.LABEL) then dproto:labelWidth() else 0;       			local INT eht := max(height, FontHeight(font)); // save              			if StrFilled(txt := dproto.VALUE)       			then height := max(height, :SimpleTextHeight(txt, currentContainer:getWidth() - wid, font));              			if wid > 0 // label?       			then height := max(height,       						((eht-1 + :SimpleTextHeight(LABEL, wid, font2))       						div eht) * eht       						);	// (in case shrunk, e.g., missing intslider??)       //Print(height);       			end;       		//if self.HREF then dproto.HREF := HREF;	// or via copyAttrib?       		:initData(dproto, dproto.VALUE);              		_data := {       			type:	'form,       			data: 	dproto,       			};       		self;       	end,       	},              PASSWORD: {       	_proto: 'TEXT,       	data: {       		_proto: NIL, //inputDict.TEXT.data, // set in afterScript       		encode: kEncodeFunc,       		},       	},              CHECKBOX: {       	_proto: 'protoTagForm,       	height: 12,       	CHECKED: NIL,       	font:	kEspy9,	// viewFont (for label)              	getWidth: func(obj)       	min(currentContainer:getWidth() - 8, 30 + StrFontWidth(obj.LABEL, obj.viewFont)), // full width              	data: {       		_proto: protoCheckBox,       		LABEL: "",       		NAME: NIL,       		HREF: NIL,       		VALUE: "x", // buttonValue=symbol       		//ACTION: kUnkURL,       		//SCRIPT: kPrintFunc,       		GetData: kGetData,       		SetData: kSetData,       		AllData: kAllData,       		//viewFont:	kEspy9,       		viewJustify: vjTopV, // for multi-line labels       		indent: 16, // apparent indent where text starts       		valueChanged: func() // add to an ARRAY of STRINGS       		begin       			local a := :GetData(NAME);       			if isArray(a)       			then begin       				local pos :=       					if kBuild1x and Functions.ArrayPos exists       					then ArrayPos(a,VALUE,0,Functions.StrEqual)       					else  LSearch(a,VALUE,0,'|str=|,nil);       				if viewValue       				then begin       					if not pos       					then AddArraySlot(a,EnsureInternal(VALUE));       					end       				else if pos then ArrayRemoveCount(a,pos,1);       				end;       			:?SCRIPT(if viewValue then VALUE);       		end,              		viewSetupFormScript: func()       		begin       			self.text := if NAME then LABEL else kNoName;       			//if HREF then viewFont := Bor(viewFont, tsUnderline);       			self.buttonValue := Intern(VALUE);       			local a := :GetData(NAME);       			self.viewValue :=       				if a and       					(if kBuild1x and Functions.ArrayPos exists       					then ArrayPos(a, VALUE, 0, Functions.StrEqual)       					else  LSearch(a, VALUE, 0, '|str=|, nil))       				then buttonValue;       		end,              		viewClickScript: func(unit)	// share with RADIO, TEXT       		begin       			local obj;       			if HREF and //GetPoint(firstX, unit) > (:GlobalBox().left + indent)       				begin       					local INT clickX := GetPoint(firstX, unit), leftX := :GlobalBox().left, cf;       			 		if HasSlot(self, 'textIndent)	// SELECT       					then (clickX < leftX + textIndent) and (obj := self)       					else if indent       					then clickX > leftX + indent	// CHECK,RADIO       					else Length(cf := :childViewFrames()) > 0 and       							clickX < leftX + (obj := cf[0]).viewBounds.right;	// TEXT       				end       			then begin       				if not obj       				then obj := :childViewFrames()[0];       				obj:Hilite(true);        				local newtscape := call kFindApp with (kAppSymbol), bdata := :BookData();       				// use latest version if possible       				newtscape:?gotoHREF(self,if bdata then bdata else {},LABEL, 0,0,HREF,nil);              				if call kViewIsOpenFunc with (obj)       				then obj:Hilite(nil); //:scrollPage(0); // turn off highlight (if still open, e.g., NewtATut?) help???       				TRUE;       				end       			else inherited:?viewClickScript(unit);       		end,              		viewChildren: [viewChildren: // override built-in 1-line only label       			{viewClass: 98,        			viewFlags: 3,        			viewJustify: vjParentFullV + vjParentFullH, //8388852, -oneLineOnly -vjCenterV. removed vjCenterV. m. added vjCenterV       			viewBounds: SetBounds(16,0,0,0), // indent       			}],       		},              	//dataR: NIL,	// see afterScript for protoRCheckBox              	get_data: func()       	if _data       	then self       	else begin       		local dproto := :addAttrib(       			/*if HasSlot(self,'VALUE_TYPE) and StrEqual(VALUE_TYPE,"RIGHT")       			then dataR       			else*/ data, self);       		local vals := :initData(dproto,[]);       		if CHECKED       		then AddArraySlot(vals, dproto.VALUE);       		if isArray(_value)       			and (if kNIE then IsString(_value[1]) else isInstance(_value[1],'string))       		then dproto.LABEL := _value[1];	// call kGetStr with (...,nil)?       /*       		if (kFontFix and not HasSlot(dproto,'viewFont))       			or (kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym)       		then if self.HREF       			then begin       				dproto.viewFont := Clone(dataFontsJ);       				dproto.viewFont.face := kFaceUnderLine;       				end       			else dproto.viewFont := dataFontsJ       		else if self.HREF       		then dproto.viewFont := Bor(dproto.viewFont, tsUnderLine);       */       		if self.HREF       		then begin       			dproto.HREF := HREF;	// (or via copyAttrib?)       			dproto.viewFont :=       				if isFrame(font)       				then call kAddEmphasis with (font, kFaceUnderline)       				else Bor(font, tsUnderline);       			end       		else if font <> inputDictOrig.CHECKBOX.font       		then dproto.viewFont := Clone(font);	// !!!c1              		width := :getWidth(dproto);       		height := max(height,       			:SimpleTextHeight(dproto.LABEL, width - dproto.indent, dproto.viewFont));              		_data := {       			type:	'form,       			data: 	dproto,       			};       		self;       	end,       	},                     RADIO: {       	_proto: 'protoTagForm,       	height: 14, // rbdata height + offset       	above: 0,       	below: 0,       	CHECKED: nil,       	font: kEspy9,	// viewFont (for label)              	rcData: {       		_proto: protoRadioCluster,       		NAME: nil,       		//ACTION: kUnkURL,		       		//SCRIPT: kPrintFunc,       		GetData: kGetData,       		SetData: kSetData,       		AllData: kAllData,              		clusterChanged: func() // change VALUE       		begin       			local val := SPrintObject(clusterValue); // clusterValue       			:SetData(NAME, val);       			:?SCRIPT(val);       		end,              		viewSetupFormScript: func()       		begin       			local val := :GetData(NAME);       			self.clusterValue := if val then Intern(val);       		end,       		},              	rbData: {       		_proto: protoRadioButton,       		LABEL: "",       		//NAME: nil, // unused locally       		VALUE: "",       		HREF: nil,       		//ACTION: kUnkURL, // inherit from cluster	       		//SCRIPT: nil, // if present, copied to cluster       		indent: 16,       		//viewBounds: RelBounds(0,4,236,12), // cluster width&height adjusted in getData.       		viewJustify: 0, // for multi-line labels. vjSiblingBottomV // 8192              		viewSetupFormScript: func()       		begin       			self.text := if NAME then LABEL else kNoName;       			/*viewFont :=       				if HREF       				then Bor(radioFont, tsUnderline)       				else radioFont;*/       			self.buttonValue := if VALUE then Intern(VALUE);       		end,       		//viewClickScript	// copy from CHECKBOX in afterScript       		//viewChildren: 	// copy from CHECKBOX in afterScript       		},              	//getWidth: func(tag,obj) // share with CHECKBOX (afterScript)              	noRefresh: true, // otherwise, incorrect default is set              	get_data: func()       	if _data       	then self       	else begin       		// either add a radiobutton to an existing cluster or create a new cluster       		local rb := :addAttrib(rbData, self);       		if CHECKED       		then :initData(rb, rb.VALUE);              /*       		if (kFontFix and not HasSlot(rb,'viewFont))       			or (kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym)       		then if self.HREF       			then begin       				rb.viewFont := Clone(dataFontsJ);       				rb.viewFont.face := kFaceUnderline;       				end       			else rb.viewFont := dataFontsJ       		else if self.HREF       		then rb.viewFont := Bor(rb.viewFont, tsUnderline);       */       		if self.HREF       		then begin       			rb.HREF := HREF;		// (or via copyAttrib?)       			rb.viewFont :=       				if isFrame(font)       				then call kAddEmphasis with (font, kFaceUnderline)       				else Bor(font, tsUnderline);       			end       		else if font <> inputDictOrig.RADIO.font       		then rb.viewFont := Clone(font);	// !!!c1              		width := :getWidth(rb);	// moved after font setting       		height := max(height,       			:SimpleTextHeight(rb.LABEL, width-rb.indent, rb.viewFont));              /* three situations:       1) first radio button w/ NAME -- create a cluster object       2) already added to book (explicit <P> or other object in-between) -- add via addBlock       3) in a large P or table cell -- add via addBlock       */       		if lastRadio and lastRadio._data and       			(rc := lastRadio._data.data) and       			rc.NAME = rb.NAME and       			rc.ACTION = rb.ACTION	// !!!v       		then begin       			//self.lastRadio := newtscape.lastRadio;	// (it might be set to NIL if FORM ends inside cell)       			_data := {addChild: rb}; 	// same cluster. save for addBlock       			end       		else :newCluster(rb);			// create new radio cluster       		self;       		end,              	newCluster: func(rb)       	begin       		_data := {       			type: 'form,       			data: {       				_proto: rcData,       				NAME: 	rb.NAME,       				ACTION: rb.ACTION,       				stepChildren: [stepChildren: rb],       				},       			};       		if rb.SCRIPT       		then _data.data.SCRIPT := rb.SCRIPT;              		RemoveSlot(rb, 'NAME);	// access in rc       		RemoveSlot(rb, 'ACTION);       		rb.viewBounds := SetBounds(0,0,width,height);	// top=4?       		above := 3;       		self.bounds := NIL;	// set in regular addBlock       		lastRadio := self; // self.lastRadio := newtscape.lastRadio := self;	// self assigned in addBlock       	end,              	addBlock: func()       	if HasSlot(_data, 'addChild)       	then // radio cluster has already been added to book       		if lastRadio and lastRadio.bounds and height <= currentContainer:getHeight() // moved       		then begin       			// there's room on current page for additional rb       			local ARRAY bnd := lastRadio.bounds;	// modify block directly       //Print(bnd); Print(height);       			local INT top := currentContainer.top; // !!!a1. :getTop();	       //Print(top);        			bnd[2] := max(bnd[2], indent+width);       			bnd[3] := top + height;       //Print(bnd); Print(below);       			local rb := _data.addChild;       //Print(rb);        			RemoveSlot(rb,'NAME); RemoveSlot(rb,'ACTION);       			rb.viewBounds := RelBounds(0, top-bnd[1], width, height);       			currentContainer:addTop(height+below);       			AddArraySlot(lastRadio._data.data.stepChildren, rb);       			NIL;	// all done       			end              		else :newCluster(_data.addChild)	// make this 1st in cluster for new page              	else begin       		lastRadio := self;		// (re)set here, i.e., TD       		inherited:addBlock();	// e.g., for 1st radio button (radiocluster)       		end;       	},                     HIDDEN: {       	_proto: 'protoTagForm,       	//NAME: nil,       	VALUE:	"",	// e.g., my.excite.com       	get_data: func()       	begin       		if NAME and VALUE 	// kinda like META       		then begin       			local action := formAttributes.ACTION;       			AddArraySlot(curBook.(kFPrintPath).(Intern(action)), NAME);       			:initData({ACTION: action, NAME: Intern(NAME)}, VALUE);       			end       		else :error("HIDDEN:" && LocObj("missing NAME or VALUE", 'missingNameValErr),nil);       		NIL;       	end,       	},                     IMAGE: {       	_proto: 'protoTagForm,       	SRC: nil,		// these are needed for IMG       	ALT: nil,       	HREF: nil,       	//NAME: nil,       	USEMAP: nil,       	ISMAP: nil,              	initDefault: nil,       	addAttrib: func(pframe, obj) // was shared inputDict.SUBMIT.addAttrib       	begin // add any formAttributes (ACTION, METHOD, ENCTYPE)        		local dproto := inherited:addAttrib(pframe, formAttributes); //add FORM first to pframe       		inherited:addAttrib(dproto, obj);       	end,              	copyAttrib: {NAME: 'formName, SCRIPT: 'compile, METHOD: 'string},       	get_dataIMG: NIL, 	//tagDictOrig.IMG.get_data, 		// set in afterScript       	get_data: func()       	if _data       	then self       	else begin // a combo of IMG & SUBMIT       		// IMG: {data:, height:, width:,}       		if not GetSlot(self,'height)       		then height := NIL;	// override protoTagForm default so IMG will work       		local obj := :get_dataIMG();       		if isArray(obj)       		then obj := obj[0];       		bm := obj._data.data;	// only thing used from IMG (no conflict with NAME, viewJustify, etc.)       		if ((if kNIE then IsString(bm) else isInstance(bm ,'string)) and self.VALUE := bm) or		// Paragraph(ALT)       			(bm = noPicture and self.VALUE := "IMAGE:" && NAME)	// missing icon        		then begin // mutate into SUBMIT button (preserve attrib but...)       			obj := Clone(self);       			obj._proto := inputDict.SUBMIT;       			obj._data := NIL;				// diff obj       			RemoveSlot(obj, 'height);		// use button ht       			return obj:get_data();       			end;              		// protoTagForm       		local dproto := :addAttrib(data,self); // extra stuff, incl. ACTION       /*       		dproto.ICON := bm;       		_data := {       			type:	'form,       			data: 	dproto,       			};       */       		_data := {	// use IMG object (allow scroll) rather than 'form       			data: 	bm,       			scripts:	[	       			'viewClickScript,	dproto.viewClickScript,       			'NAME, 				dproto.NAME,       			'METHOD,			dproto.METHOD,       			'ENCTYPE, 			kDefaultEncType,       			'ACTION,			dproto.ACTION,       			'SCRIPT,			dproto.SCRIPT,       			'scale,				obj._data.scale,       			//'GetData,			kGetData,       			'SetData,			kSetData,       			'AllData,			kAllData,       			'RegisterCardSoup,	kMyRegCardSoup,       			'UnRegisterCardSoup, kMyUnRegCardSoup,       			'makeNote,			kMakeNote,       			'postSoup,			kPostSoup,         			'postNotes,			kPostNotes,        			'postMail,			kPostMail,       			]};       		self;       	end,              	data: {       /*       		viewClass: clPictureView,       		viewFlags: 513, // vVisible+vClickable       		//GetData: 	kGetData,       		SetData:	kSetData,       		AllData: 	kAllData,       		RegisterCardSoup:	kMyRegCardSoup,		// kRegisterCardSoupFunc,       		UnRegisterCardSoup: kMyUnRegCardSoup,	// kUnRegisterCardSoupFunc,       		makeNote:	kMakeNote,       		postSoup:	kPostSoup,         		postNotes:	kPostNotes,        		postMail:	kPostMail,       */       		NAME: 		NIL,       		METHOD:		kDefaultMethod,       		ENCTYPE:	kDefaultEncType,       		//ACTION: 	kUnkURL,       		SCRIPT: 	NIL, //inputDict.SUBMIT.data.SCRIPT,               		viewClickScript: func(unit)       		begin       			:Hilite(true);       			local gb	:= :GlobalBox();       			local INT x := RIntToL((GetPoint(firstX,unit) - gb.left) / scale);       			local INT y := RIntToL((GetPoint(firstY,unit) - gb.top)  / scale);       			       	//Print([x,y]);       			:SetData(NAME, {x: x, y: y});       			if :SCRIPT(:AllData(TRUE))       			then //:AllData(NIL)  why delay??? (SUBMIT doesn't have)       				if kBuild1x and Functions.AddDeferredAction exists       				then AddDeferredAction(Functions.Perform, [self, 'AllData, '[nil]])       				else AddDeferredSend  (self, 'AllData, '[nil]);       			:Hilite(nil);	// (returns true)       			//TRUE;       		end,       		},       	},                     SUBMIT: {       	_proto: 'protoTagForm, // centered???       	height: 12,       	getWidth: func(but)       		min(inherited:getWidth(but), 7 + StrFontWidth(but.VALUE, but.viewFont)),	// was 5+, no min       	//font              	copyAttrib: {NAME: 'formName, SCRIPT: 'compile, METHOD: 'string, VALUE: 'string, TYPE: 'symbol,       		LABEL: 'string, 	// !!!y. for WAPWML (to store local HREF)       		//viewFont: 'compile,       		},       	initDefault: nil,       	addAttrib: func(pframe, obj)       	begin // add any formAttributes (ACTION, METHOD, ENCTYPE)        		local dproto := inherited:addAttrib(pframe, formAttributes); //add FORM first to pframe       /*       		if (kFontFix and not HasSlot(dproto,'viewFont))       			or (kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym)       		then dproto.viewFont := labelFontJ;       */              		inherited:addAttrib(dproto, obj);              		if font <> inputDictOrig.SUBMIT.font	// do in get_data?       		then dproto.viewFont := Clone(font);	// !!!c1       /*	to justify wrt parent, would need (16=center) or (32=right) and redo bounds!       		if currentContainer.align <> 0       		then dproto.viewJustify := dproto.viewJustify + currentContainer.align;       */       		height := max(:fixAttribute(height, 'int, height), :SimpleTextHeight(dproto.VALUE, currentContainer:getWidth()-4, font));       		dproto.text := dproto.VALUE;	// !!!b       		dproto;       	end,              	data: {       		_proto:		protoTextButton,       		viewJustify: vjCenterH + vjCenterV, // - oneLineOnly       		VALUE: 		LocObj("Submit", 'submitLabel),		// !!!g       		NAME: 		NIL,       		METHOD: 	kDefaultMethod,       		ENCTYPE: 	kDefaultEncType,       		//ACTION: 	kUnkURL,       		//SCRIPT: 	kPrintFunc, // see below       		GetData:	kGetData,	// !!!x. include       		SetData: 	kSetData,       		AllData: 	kAllData,              		//viewSetupFormScript: func()	// !!!b       		//	self.text := VALUE,              		buttonClickScript: func()       		begin       			:SetData(NAME, if type='IMAGE then {x: 5, y: 5} else VALUE);	// pseudo-IMAGE map       			if :SCRIPT(:AllData(TRUE))       			then :AllData(NIL);       		end,              		RegisterCardSoup: 	kMyRegCardSoup,		// kRegisterCardSoupFunc,       		UnRegisterCardSoup: kMyUnRegCardSoup,	// kUnRegisterCardSoupFunc,       		postSoup: 	kPostSoup,       		makeNote: 	kMakeNote,         		postNotes:	kPostNotes,        		postMail: 	kPostMail,              		SCRIPT: func(fdata)       		begin       			local bdata := :BookData(), btitle := :BookTitle(), act := ACTION, spos;       			//spos := if kBuild20 then CharPos(act, $_, 0) else StrPos(act, "_", 0);       			act := call kSubStr with (act, "_", nil, nil); 	// for uniqueness       			local iact := Intern(act), nact := bdata.(iact);       			local root := GetRoot();              			if (if kBuild20 then IsString(nact) else isInstance(nact,'string))       			then nact := bdata.(iact := Intern(act := nact));              			if (if kBuild20       				then IsFunction(nact)       				else isInstance(nact,'_function) or isInstance(nact,'CodeBlock))       			then Perform(bdata, iact, [self,btitle,act,fdata])              			else if (spos := if kBuild20 then CharPos(act,$/,0) else StrPos(act,"/",0)) and       				(iact := Intern(SubStr(act,0,spos))) and       				call kFindApp with (iact) and       				HasVariable(root.(iact), nact := Intern(SubStr(act,spos+1,nil)))       			then Perform(root.(iact), nact, [fdata])              			else if call kURLmatch with (act)	// !!!s. BeginsWith(act, kHTTP)       			then :postMail(btitle,act,fdata)              			else if BeginsWith(act, "Print()")       			then Print(fdata) // returns NIL              			else if StrEqual(act, notesSoupName)       			then :postNotes(btitle, bdata.form_printnames.(Intern(ACTION)), fdata)              			else if nact := call kSubStr with (act, kMailTo, nil, true)       			then :postMail(btitle,nact,fdata)              			else if nact := call kSubStr with (act, kSoupDir, nil, true)       			then :postSoup(btitle, nact, fdata)              			else if nact := bdata.base_href       			then :postMail(btitle, call kResolveURL with (nact, act), fdata)              			else :postSoup(btitle,act,fdata);	// ???       		end,       		},       	},              RESET: {       	_proto: 'protoTagForm,  // centered???       	height: 12,       	getWidth: NIL, //inputDict.SUBMIT.getWidth       	//font              	addAttrib: func(pframe, obj)       	begin       		local dproto := inherited:addAttrib(pframe, obj);       /*       		if (kFontFix and not HasSlot(dproto,'viewFont))       			or (kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym)       		then dproto.viewFont := labelFontJ;       */       		if inputDict.SUBMIT.font <> inputDictOrig.SUBMIT.font	// share. do in get_data?       		then dproto.viewFont := Clone(inputDict.SUBMIT.font);	// !!!c1       		height := max(:fixAttribute(height, 'int, height), :SimpleTextHeight(dproto.VALUE, currentContainer:getWidth()-4, dproto.viewFont));       		dproto.text := dproto.VALUE;	// !!!b              		dproto;       	end,              	data: {       		_proto: 	protoTextButton,       		viewJustify: vjCenterH + vjCenterV, // - oneLineOnly       		VALUE: 		LocObj("Reset", 'resetLabel),		// !!!g       		//ACTION:	kUnkURL,       		//SCRIPT: 	kPrintFunc,       		//GetData: 	kGetData,       		//SetData: 	kSetData,       		AllData: 	kAllData,              		//viewSetupFormScript: NIL, // !!!b. inputDict.SUBMIT.data.viewSetupFormScript       		buttonClickScript: func()       		begin       			:?SCRIPT(:AllData(TRUE));       			:AllData(NIL);       		end,       		},       	},       },     viewDrawScript:       func() // 1.x       begin       constant y := 0;       local INT x := (viewBounds.right - viewBounds.left) div 2;       :DrawShape(       	MakeOval(x-kDragRadius, y-kDragRadius, x+kDragRadius, y+kDragRadius), // left,top,right,bottom       	{transferMode: modeCopy,       	fillPattern: vfFillWhite,       	penSize: 2,       	});       end,     scanFixFrame:       func(fentry, href, content, INT start) // !!!m,e       if kNIE and href and not BeginsWith(content, kFixedFrame)	// fixup FRAME doc with absolute refs       then begin       	local bhref := call kGetBASE with (content);       	if not bhref then bhref := href;              	local line, pos, pos2, ref, entry, tag, attrib, nextFlush;       	local INT slen := StrLen(content);       	//local oldRun := :setRun('wait);              	foreach entry in [       		// BASE kHREF (full already)       		// META DATA.ICON (not in web docs?)						       		// FRAME kSRC (not in frame part)	// scanFrames              		["<INPUT",	 kSRC], ["<IMG", kSRC],	// scanImages       		["<FORM", 	"ACTION="],       		[kLinkStart, kHREF], ["<A",kHREF], 	// scanLinks       		]       	do begin       		pos := start; nextFlush := kVBOFlush;       		tag := entry[0]; attrib := entry[1];       		while (pos := StrPos(content, tag, pos))       			and pos2 := CharPos(content, $>, pos := pos + StrLen(tag))       		do begin       			if :setGauge(tag,pos,slen)       			then RefreshViews();       			line := SubStr(content, pos, pos2-pos);              			if StrFilled(href := call kScanAttribute with (line, attrib))       //and (Print(href) or true)       				and not call kURLmatch with (href)	// full http: or other protocol (note: JS will fall thru)       				and not BeginsWith(href, kJavaScript)	// !!!m       				and (ref := :ResolveURL(bhref, href := :fixString(href,true)))	// !!!g       			then StrMunger(content, pos+StrPos(line,href,0), StrLen(href), ref,0,nil);              			pos := pos2+1;       			if (pos*2) >= nextFlush       			then begin       				ClearVBOCache(content);       				nextFlush := nextFlush + kVBOFlush;       				end;       			end;       		end;              	//:setRun(oldRun);       	:setGauge("",nil,slen);       	StrMunger(content,0,0, kFixedFrame,0,nil);	// mark it       	ClearVBOCache(content);              	EntryFlushXmit(fentry,nil);	// !!!k       	//entry;       	end,     addHTML:       func(line, results)	// called by parseProgress, protoSerial(1.x)       begin       	if not parseJob       	then if (if kNIE then CharPos(line,$<,0) else StrPos(line,"<",0))       		then :startHTML()       		else return NIL;              	lineNum := lineNum+1;              	try parseJob:ProcessLine(line, results)       	onexception |evt.ex| // note: line may already be partially munged       	do return :error(line, currentException());	// LocObj("process", 'processErr) & $: &&        	NIL;       end,     includes: nil,     displayURL:       func(txt)       if txt and URLpara //and Visible(newtscape) // !!!g. might not be open       then SetValue(URLpara, 'text, Clone(txt))	// same for setStatus. clone in case modified       ,     AddLocale:       func()	// called by InstallScript (removed for non-NIE)       begin       	// get current the locale title, and save       	local currentLocale := GetLocale();       	local newLocale := EnsureInternal({		// minimize copying       		_proto: 		nil,       		title: 			kHTTPlocaleName,        		localeSym: 		kAppSymbol,			// kHTTPlocaleSym       		longDateFormat: nil,       		timeFormat:		nil,       		});              	// Set proto's so get the built-in system slots and all the defaults       	newLocale._proto := currentLocale;              	newLocale.longDateFormat 		:= Clone(kHTTPlocale.longDateFormat);       	newLocale.longDateFormat._proto := currentLocale.longDateFormat;              	newLocale.timeFormat 		:= Clone(kHTTPlocale.timeFormat);       	newLocale.timeFormat._proto := currentLocale.timeFormat;              	// Done creating the locale, so add it to the system collection, then set       	call kAddLocaleFunc with (newLocale);       	//SetLocale(kHTTPlocaleName);	// done in kReadDate, kPrintDate       end,     addFile:       DefineGlobalConstant('kInstallPkg2, func(oldPkg, newPkg, blessedSym)	// !!!m       try begin       	if oldPkg       	then SafeRemovePackage(oldPkg);              	local root := GetRoot(), newtscape := root.(kAppSymbol); // what if NC removed?       	try GetDefaultStore():SuckPackagefromBinary(newPkg,       		{callbackFreq: kPkgUpdateSize,	// callbackFrequency wrong in docs!              	callBack: func(callbackInfo)              	begin              		local INT pos := callbackInfo.amountRead, len := callbackInfo.packageSize;       			if newtscape:?setGauge(       				LocObj("Installing Package", 'installingPackage) && pos & $/ & len,       				pos,len)       			then RefreshViews();	// !!!m       			// since not necessarily called at very end (pos=len)       			AddProcrastinatedSend(Intern("pkg:" & kAppSymbol),       				newtscape, 'docDone, [newtscape.optionsAPI,true], kDelay);	// !!!m       		end,       		})       	onexception |evt.ex|       	do  begin       		local x;       		if (x := currentException().error) <> 666       		then //newtscape:?errorStatus(LocObj("Installation Failed", 'installErr) && x);       			:Notify(kNotifyAlert, LocObj("Installation Failed", 'installErr), SPrintObject(x));       		end;              	if blessedSym	// !!!m       	then root:BlessApp(blessedSym);       	end       onexception |evt.ex|       do newtscape:?errorStatus(LocObj("Installation Failed", 'installErr))       );                     DefineGlobalConstant('kInstallPkg, func(oldPkg, newPkg, pkgName)       begin       	local pkgSym := Intern(pkgName), root := GetRoot(), blessedSym;       	if oldPkg and GetUserConfig('blessedApp) = pkgSym       	then begin       		root:BlessApp(kExtrasSym);		// close current, open a built-in one (Extras?)       		blessedSym := pkgSym;			// !!!m       		end       	else root.(pkgSym):?close();       	AddDelayedCall(kInstallPkg2, [oldPkg, newPkg, blessedSym], 3000); // !!!m. allow some time for things to close?       end);                            func(type, href, content, options) // generalized version of addImage. called by dispatchFile, addIncludes       begin       //Write("addFile: "); Print(type); Print(href); Print(content); Print(options);              	if kNIE and StrEqual(type, kNewtonPkgMediaType)       	then begin       		local pkgName := BinaryMunger(	// from Q&A. see PkgInfo       				Clone(""), 0, 0,       				content,       				52 + (ExtractLong(content,48)*32) + ExtractWord(content,24),       				ExtractWord(content, 26) - 2);              		local INT newPkgVersion := ExtractLong(content, 16), i;       		local newPkgDate := 0;       		for i := 32 to 35 	/* (Mac) date has seconds */       		do newPkgDate := (newPkgDate*256) + (ExtractByte(content,i) / 60);       		newPkgDate := Floor(newPkgDate);              		local oldPkg, oldPkgRef, oldPkgVersion, oldPkgDate;       		if oldPkg := call kFindPkg with (pkgName)	// existing package?       		then begin       			oldPkgRef := GetPkgRefInfo(oldPkg); // easier than extracting       			oldPkgVersion := oldPkgRef.version;       			oldPkgDate := oldPkgRef.creationDate;       			end;              		if not options.noConfirm       		then :Confirm(	// !!!j. AsyncConfirm (fix fonts)       			nil, // unused       			href & unicodeCR &       			pkgName & unicodeCR &       			(if oldPkg then LocObj("old version", 'oldVersionLabel) & $: && oldPkgVersion &       			$, && LocObj("created", 'createdLabel) & $: && DateNTime(oldPkgDate) & unicodeCR) &       			LocObj("new version", 'newVersionLabel)& $: && newPkgVersion &       			$, && LocObj("created", 'createdLabel) & $: && DateNTime(newPkgDate) & unicodeCR &       			if oldPkg       			then kReplacePkg       			else LocObj("Do you want to install package?", 'installPackage),       			[{text: LocObj("Yes", 'yesLabel),	value: true, keyValue: 'default},	// 'yesNo       			 {text: LocObj("No",  'noLabel),	value: nil,  keyValue: 'close},       			 {text: LocObj("Inbox",'inboxItem), value: 'Inbox},       			 ],       			func(x)       			if x = 'Inbox	// undocumented!! fake a beam (from helppkgi.htm)       			then try GetUnionSoup(inboxSoupName):AddFlushedXmit({	// !!!s. GetStores()[0]:GetSoup       					needsResolve:	TRUE,       					class: 			'ioItem,        					typeBeam: 		"Icon",       					xlabels: 		'[_unfiled, _new],       					currentFormat:	'exFrameFormat,       					category: 		'|beam:newton|,       					appSymbol: 		kExtrasSym,       					title: 			href,				/**/						       					body:  			{package: content,	/**/       									class: 'packageFrame},       					timestamp: 		Time(),       					labels: 		NIL,       					fromRef: 		pkgName,			/**/       					state: 			'Received,       					}, 'entryAdded)       				onexception |evt.ex|       				do :Notify(kNotifyAlert, LocObj("Inbox Error", 'inboxErr), currentException().error)       			else call kInstallPkg with(oldPkg, content, pkgName)       			)       		else if not oldPkg or (newPkgVersion >= oldPkgVersion and newPkgDate > oldPkgDate)       		then call kInstallPkg with(oldPkg, content, pkgName);       		// else don't install same/old version              		return TRUE; // assume we handled (since asynch)       		end;              	local curQueue := [], tmpQueue, entry; // !!!m              	if kNIE and options.cacheOnly	// (may be set temporarily by textSuccess/binarySuccess if there's a queue)       	then begin // use :addQueue?       //Print("addFile(cacheOnly):" && href);        		if wwwFSM and href  // !!!m,a       		then begin       			if options.loadFrames       				and (tmpQueue := :scanFrames(href, content, 0, nil, nil)) // !!!i,g       				and Length(tmpQueue) > 0	// !!!o       			then begin       				//ArrayMunger(curQueue, Length(curQueue), 0, tmpQueue, 0, options.loadFrames := nil) // !!!m,g. turn off temporarily??       				curQueue := tmpQueue;       				//options.loadFrames := nil; // prevent rescan? (only nec later?)       				end              			// don't load images here if loading frames for a FRAMESET page       			// load images for those when they're cached       			// load images for FRAMESET page when finally processed (possibly merged)       			else begin       				if cacheImages       					and (tmpQueue := :scanImages(nil, href, content, 0, options, nil, nil, nil, nil))  // !!!m,d       				then curQueue := tmpQueue;	//ArrayMunger(curQueue, Length(curQueue), 0, tmpQueue, 0, nil);              				// is current doc in original list? (prevent recursion)       				local linkItems := options.linkItems, linkLevel;       				if IsArray(linkItems)	//and LSearch(linkItems, href, 0, '|str=|, nil) // !!!s       				then foreach entry in linkItems	// !!!w       					 do if (if IsString(entry) then StrEqual(href,entry) else StrEqual(href,entry[0]))       					   		and (tmpQueue := :scanLinks(href, content, 0, nil, nil, nil, nil, nil, options.linkExcept))       					   	then begin       							ArrayMunger(curQueue, Length(curQueue), 0, tmpQueue, 0, nil);       							if IsArray(entry)       							then if (linkLevel := entry[1]) = 2       								then ArrayMunger(linkItems,Length(linkItems),0, tmpQueue,0,nil)       								else if linkLevel > 2       								then foreach entry in tmpQueue       									 do AddArraySlot(linkItems, [entry, linkLevel-1]);       							break;       							end;       				end;       			wwwFSM:addQueue(curQueue);	// !!!o,m. this adds to beginning of queue       //Print("curQueue(cacheOnly):");Print(curQueue);       			end;       		return TRUE;       		end;              	if StrFilled(href) and not options.frameStart	// !!!e       	then :displayURL(options.base := href);       //Print([optionsAPI.pageWidth, optionsAPI.pageHeight]);       	if not parseJob or not (options.frameStart or options.noStop) 	// parseJob. !!!e. frameStart       	then :startHTML();              	local htmlApp := parseJob.htmlApp, obj;       	if not options.htmlApp	// !!!e. for frameStart?  see startHTML       	then options.htmlApp := htmlApp;              	if StrEqual(type, kTextMediaType)       	then obj := {_tag: 'PRE, _value: content}              	else if kNIE and (StrEqual(type, kGIFMediaType) or StrEqual(type, kJPEGMediaType) or call kImageExtension with (href))	// !!!a       	then begin       //if kDebugHTTP then begin Print("addFile[image]: "); Print(content); end;       	obj := {       		_tag: 'IMG,       		SRC: if IsBinary(content) and	 // raw?       				(if StrEqual(type, kGIFMediaType)	// !!!a       				then call kByteBeginsWith with (content, kGIFStart, 0)       				else if StrEqual(type, kJPEGMediaType)       				then call kByteBeginsWith with (content, kJPEGStart, 6))       			then :convertImage(type, href, content,       					if options.rawImage       					then {_proto: options, cacheImages: nil, rawImage: nil}       					else options, // !!!c. e.g., for direct JPEGs       					options.convertImageFn)	// !!!a       			else content,       		_value: true,	// getPictObj called later       		ALT: LocObj("Image conversion err?", 'ImageConvertErr) & "",       		};       		end              	else if BeginsWith(type, kHTMLMediaType)       	then begin // former :parseHTML       		if kNIE       		then begin       			if not IsString(content) or CharPos(content,$\uF700,0) or CharPos(content,$\uF701,0) // !!!d1. IsRichString(content)       			then return NIL;       			if not (isReadOnly(content) or isVBO(content)) and not curSourceBuf       			then content := call kNewVBO with (nil, nil, content); // copy to temporary VBO to save heap       			end       		else if not isInstance(content,'string)       		then return NIL;              		curSource := content;       		curSourcePos := options.start;       		if (if kNIE then IsString(curSourcePos) else isInstance(curSourcePos, 'string))	// !!!e. e.g., <BODY       		then curSourcePos := StrPos(content, curSourcePos, 0);       		if not curSourcePos       		then curSourcePos := call kIsHTML with (content);	// !!!j. :skipHTML(content);       //Print("curSourcePos:" && curSourcePos);              		if kNIE       		then begin       			local htag := :frameHeading(options.frameTag), pos;	// !!!i. 'H1       			if options.frameStart	// !!!e       			then htmlApp:addHTMLitem({       				_tag: htag,       				_value: [[{_tag: 'A, HREF: href}],       					//options.processMsg & $:	&& // !!!j,g       					if obj := call kGetTitle with (content)	// !!!m,g. diff for each doc (otherwise processItem?)       					then :fixString(obj,nil)       					else call kGetFileName with (href)],       				}, nil);       /*       Print("addFile:" && href);       Print(options.loadFrames); Print(:scanFrames(href, content, curSourcePos, nil, nil));       Print(options.mergeFrameSource); Print(options.includeFrames);       Print(StrPos(content,  kHeadStop,  curSourcePos));       Print(:scanFrames(href, content, curSourcePos, nil, true));       */       			// !!!j. scan for frames first. if none, maybe merge source       			if options.loadFrames       				and (tmpQueue := :scanFrames(href, content, curSourcePos, nil, nil))       				and Length(tmpQueue) > 0	// !!!n       			then ArrayMunger(curQueue,Length(curQueue),0, tmpQueue,0, options.loadFrames := nil) // !!!g. some to autoload. turn off temporarily              			else if options.mergeFrameSource       				//and options.loadFrames       				and StrFilled(options.includeFrames)       				and (tmpQueue := :scanFrames(href, content, curSourcePos, nil, true))       				and Length(tmpQueue) > 0       				and ((pos := StrPos(content, kHeadStop,  curSourcePos)) and pos:=pos+7)       					 // or ((pos := StrPos(content, kTitleStop, curSourcePos)) and pos:=pos+8))       			then begin       //Print("merging");       				local furl, fcontent, ftitle, newContent;       				// truncate after </HEAD>. add <BODY>       				newContent := kBigStringObj:new(call kNewVBO with (GetVBOStore(content), nil, ""));       				newContent:append(content,0,pos);       				StrReplace(newContent:contents(), kTitleStart, kTitleStart & $*, nil);       				newContent:append(kBodyStart & $>,0,nil);       				foreach furl in tmpQueue // append each (fixed) frame doc       				do begin       					if entry := call kGetURLCache with (cacheHTML, furl, nil, nil, nil)       					then fcontent := entry.text       					else break newContent := NIL;	// !!!m. missing frame? leave original content alone              					// add FRAME "heading"       					newContent:append(       						unicodeCR & $< & htag & $>       						& (if ftitle := call kGetTitle with (fcontent)	// !!!m       						then :fixString(ftitle,nil)       						else call kGetFileName with (furl))       						& "</" & htag & $> & unicodeCR, 0, nil);              					// make URLs absolute if nec       					:scanFixFrame(entry, furl, fcontent, 0);	// !!!k       // if not Issoupentry(entry) then break newcontent := nil ???       					// append BODY (only) to main doc       					if (pos := StrPos(fcontent, kBodyStart, 0))       						and (pos := CharPos(fcontent, $>, pos))       						and (obj := StrPos(fcontent, kBodyStop, pos := pos+1))       					then newContent:append(fcontent, pos, obj-pos);       					end;              				if newContent	// !!!m       				then begin       					// add: </BODY></HTML>       					newContent:append(kBodyStop & kHTMLStop & unicodeCR, 0,nil);       					// update main entry itself       					entry := call kGetURLCache with (cacheHTML, href, nil, nil, nil);       					entry.text := curSource := content := newContent:contents();       //Print(entry.text);       					EntryFlushXmit(entry,nil);       					end;       //Print(content);       				// now scan for images...?       				end;       /*       Print("tmpQueue:"); Print(tmpQueue); Print("curQueue:"); Print(curQueue);       Print("loadImages:"); Print(options.loadImages);       */       			if cacheImages and Length(curQueue)=0 and not curSourceBuf	// !!!n. wait if frames to be loaded       				and (tmpQueue := :scanImages(nil, href, content, 0, options, nil, nil, nil, nil)) // !!!o. curSourcePos       			then curQueue := tmpQueue;       				//ArrayMunger(curQueue,Length(curQueue),0, tmpQueue, 0, nil); // !!!m,d       //Print("curQueue:"); Print(curQueue);       			if Length(curQueue) > 0       			then begin	// add (cached) doc as last item, start up       				if wwwFSM and (tmpQueue := wwwFSM.fURLqueue) and Length(tmpQueue) > 0	// !!!o       				then begin       					// technically this shouldn't happen? since queue should be empty (else, cacheOnly earlier)       //Print("existing cache:"); Print(tmpQueue);       					ArrayMunger(curQueue,Length(curQueue),0, tmpQueue,0,nil);       					wwwFSM:?addQueue(NIL);	// replace queue via DoEvent below       					end       				else AddArraySlot(curQueue, {URL: href, text: content}); // same doc at end (see popQueue)              //Print("curQueue(DoEvent):"); Print(curQueue);       				curSource := options.cacheEntry := NIL;       				options.fURLqueue := curQueue;       				// !!!m. in case open. to avoid losing 1st item in dueling popQueues?       				AddDelayedSend(self, 'DoEvent, [NIL, [options]], 500);	// !!!m. initialize FSM, options. do popQueue       				return TRUE; // handled       				end;       			end;              		if options.noDelay       		then Newtscape:parseProgress(NIL)              		else if kNIE       		then AddDeferredSend(NewtsCape, 'parseProgress, '[nil])	// !!!g. moved out of visible test              		else if Visible(Newtscape)       		then NewtsCape:setupIdle(kLineDelay)              		else AddDeferredAction(       			Functions.Perform, [NewtsCape, 'parseProgress, '[nil]]);       		return TRUE;       		end;              	if not obj       	then begin       		:Notify(kNotifyAlert, kAppName, type & $: && kNoHelper && href);       		return NIL;       		end;              	htmlApp:addHTMLitem(kTagHTML, nil); // sets BASE via kSendHTTP (optionsAPI.base)       	local val := Clone(options.bookISBN);	// !!!c1, y       	entry := if href then call kGetFileName with (href);              	if StrFilled(val) or val := entry       	then htmlApp:addHTMLitem({	// !!!y,x       		_tag: 'META,       		_value: true,       		name: "ISBN",       		content: val,       		}, nil)       	else entry := nil;              	htmlApp:addHTMLitem({       		_tag: 'TITLE,       		_value: if StrFilled(val := options.bookTitle) then Clone(val)	//!!!y,x       			else if entry then entry       			else LocObj("Untitled", 'untitledLabel)       		}, nil);              	htmlApp:addHTMLitem(obj, nil);              	if htmlApp=NewtsCape       	then :stopHTML()       	else htmlApp:addHTMLitem('{_tag: HTML, _value: nil}, nil);       	TRUE;       end,     convertImage:       func(type, href, content, options, convFn)	// called at end of ReceiveBinarySucess, or later via kGetURLCache (if raw GIF cached)       begin		// or perhaps by a plugin (e.g., JPEG:addFile)       	local cacheEntry := options.cacheEntry;       	local store := GetVBOStore(content);	// !!!j              	if not options.rawImage       	then try begin       //Print("before image conversion"); Print(content);       		local bpp := options.bitsPerPixel;       		if not bpp or bpp=0       		then bpp := 1;       		local thresh := options.threshold;       		if not thresh or thresh <= 0 or thresh >= 255       		then thresh := 128;       if kDebugHTTP then Print([thresh,bpp]);       		if not convFn       		then convFn := GIF.Decompress;              		// call GIF (or whatever) convert function       		content := call convFn with (content, thresh, bpp, options.convAnim);       				// , if cacheEntry then EntryStore(cacheEntry) else GetDefaultStore() ???              		// mutate result into Copperfield & 1.x compatible format       		// i.e., b&w = {bounds: ShapeBounds(content), bits: content.data}              		local pic, bits, pics := if content.frames then content.frames else [content];       		pics := foreach pic in pics       			collect begin       				// reduce to 1.x 16-byte header       				bits := BinaryMunger(pic.data,16,8, nil,0,nil);       				SetClass(bits, if bpp=1 then 'bits else 'cbits);	// moved from kFixBitmap       				// !!!g. not nec. since GIF converter used DefaultStore, move to same store as existing cacheEntry       				//if cacheEntry and EntryStore(cacheEntry) <> GetVBOStore(bits)       				//then pic.data := call kNewVBO with (EntryStore(cacheEntry), ClassOf(bits), bits);       				call kFixBitmap with (pic, nil, bpp);       				end;       		content :=       			if Length(pics) = 1       			then pics[0]       			else //if Length(pics) > 1 then       				begin       				pic := Clone(pics[0]);       				pic.pics := pics;       				pic.delays := content.delays;       				if content.loops > 0       				then pic.loops := content.loops; // otherwise nil       				pic;       				end;       //Print("after image conversion"); Print(content);       		end       		onexception |evt.ex|       		do begin       			//if kDebugHTTP then       			Print(currentException());       			return LocObj("Image conversion err?", 'ImageConvertErr);       			end;       	// note: there's a problem if cacheOnly and binary obj isn't really a valid GIF, JPEG, whatever              	if IsString(options.cacheImages)	// !!!d       	then try begin       		local header := options.header, modDate;       		if not header then header := {};       		call kPutURLCache with (       			store, options.cacheImages, href, 'bitmap, cacheEntry, // !!!j       			content,       			if (modDate := header.(kLastModifiedSym)) then modDate else header.(kDateSym),       			header.(kExpiresSym),       			nil,       			nil,       			type       			//options.labels       			);       		end       		onexception |evt.ex|       		do return kHeapMsg;              	content; // frame(bitmap) or string(error)       end,     lastSelect: nil,     currentContainer: nil,     RegisterCardSoup:       kMyRegCardSoup // non-standalone       ,     currentURL:       func(requireHTTP)       begin       	local stext;       	local INT slen;       	if StrFilled(stext  := URLpara.text)       		and (slen := StrLen(TrimString(stext))) > 0       	then begin       		if stext[0] = $< and stext[slen-1] = $>							// <http://>       		then begin       			StrMunger(stext,slen-1,1, nil,0,nil);       			StrMunger(       				stext,0, if BeginsWith(stext, "<URL:") then 5 else 1, 	// <URL:http//>       				nil,0,nil);       			slen := StrLen(stext);       			end;              		if (not requireHTTP and slen > 0 and not StrEqual(stext, kHTTP))       			or (slen > 5 and BeginsWith(stext, kHTTP) and slen > kHTTPlen)       		then return stext;       		end;              	if kNIE and curBook       		and StrFilled(stext := curBook.(kBasePath))       	then if not requireHTTP or (StrLen(stext) > kHTTPlen and BeginsWith(stext, kHTTP))       		then return stext;       end,     viewFlags: 545,     linenum: 0,     NetworkChooserDone:       func(host, zone)       begin       	//prefsEntry.hostADSP := host;       	//:setPreference('zoneADSP, zone);       	:connect(actionNum, host, zone);	// saved in openDoc       end,     setRun:       func(newStatus)       GoStopButton:?setStatus(newStatus),     myPopup:       func(list, autosel, maxwid)       /*if autosel and autosel = Length(list)-1       then begin       	:pickActionScript(autosel);       	NIL;       	end       else*/ if Length(list) > 0       then if kNIE       	then begin       		local pp := :PopupMenu(list, nil), font; //{left: 0, top: 0}), font;	// not readonly       		if maxwid       		then begin       			//pp:close();       			//pp.pickTextItemHeight := 12;	// 13       			pp.pickMaxWidth := GetAppParams().appAreaWidth-10;       			font := pp.viewFont;	// !!!j. kEspy9; // {family: espy, face: kFaceBold, size: 10}       			//pp:open();       			end;       		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       		then font := menuFontJ;	// !!!j. {family: sym, face: kFaceBold, size: 10};              		if font       		then SetValue(pp, 'viewFont, font);       		pp;       		end       	else DoPopup(list, 0, 0, self),     compileVal:       func(str)       if optionsAPI.allowCompile = 'compile       then begin       	local val, err;       	local compileContext := {       		_parent: {       			_parent: {       				_parent: evalContext,       				_proto: NewtsCape,       				},       			_proto: curBook,       			},       		_proto: curBook.(kDataPath),       		};              	local oldCompilerCompatibility := vars.CompilerCompatibility;       	if kNIE and kBuild1x // not kBuild20 and nos20       	then vars.(EnsureInternal('CompilerCompatibility)) := 0;              	try compileContext._tempMeth := Compile(str)       	onexception |evt.ex|       	do :print(LocObj("compile err", 'compileErr) & $: && err := str);              	if kNIE and kBuild1x // not kBuild20 and nos20       	then vars.CompilerCompatibility := oldCompilerCompatibility;       	if err then return NIL;              	try val := compileContext:_tempMeth()       	onexception |evt.ex|       	do begin       		:print(LocObj("eval err", 'evalErr) & $: && str);       		:print(currentException());       		return NIL;       		end;              	// expunge parent refs etc.       	:fixVal(val);       	end,     GetUserConfig:       kMyGetUserConfig // for non-standalone access       ,     curPkg: nil,     viewIdleScript:       func()       :parseProgress(NIL),     resetStatus:       func()	// !!!h.	if Visible(newtscape) then       begin       	:setGauge("",nil,nil);       	:errorStatus("");       end,     dispatchEntry:       func(entry, options)	// used by overview:openScript, :processScript       begin       	if kNIE and IsEntryAlias(entry)	// !!!f       	then entry := EntryFromObj(entry);       	local href := Clone(entry.URL), edata := entry.edata;       	if edata       	then if options       		then options.edata := edata       		else options := {edata: edata}              	else if kSubmitQ and edata := entry.data	// !!!g. submitQueue       	then begin       		options.data := edata;       		options.method := entry.method;       		options.dataNames := entry.dataNames;       		end;              	if entry.text       	then :dispatchFile(if entry.type then entry.type else kHTMLMediaType, href, entry.text, options)	// !!!o. HTML Cache       	else if entry.bitmap       	then :dispatchFile(kGIFMediaType, href, entry.bitmap, options)	// Image Cache (dont' actually want to dispatch, e.g., reconvert JPEG)       	else :getURL(href, options);									// Bookmarks?       end,     GetSound:       func(src)       if src       then begin       	if isFrame(src) and isInstance(src.samples, 'samples)       	then return src;              	local entry := if curBook then curBook.(kDataPath).(Intern(src));  // in :BookData()       	if (if kNIE then IsString(entry) else isInstance(entry,'string))       	then entry := curBook.(kDataPath).(Intern(src := entry));              	if isFrame(entry) and isInstance(entry.samples, 'samples)       	then entry              	else :GetNamedResource(src, '[name], '[sound]);       	end,     resetFSM:       func()       if kNIE and wwwFSM       then wwwFSM := wwwFSM:quit(),     ReorientToScreen:       func()       begin       	//@588 //ROM_DefRotateFunc -- does quit/setupform       	//reorienting := TRUE;       	local size := prefsEntry.pageSize;       	if not (size = 'help or (nos21 and (size = 'portrait or size='landscape)))       	then :removeApp(NIL,nil);       	if self.mykbd	// !!!x       	then begin       		mykbd:?close();       		mykbd := nil;       		end;       	:SyncView();       	:RedoChildren();  		// :SyncChildren() ?        	//reorienting := NIL;       end,     Notify:       func(level,headerStr,messageStr)	// !!!j. only for kNCFont       begin       	if kNCfont and prefsEntry and prefsEntry.systemFontFamily <> kSystemFontSym	// !!!j       	then AddDelayedCall(func(font)       		begin       			local child;       			foreach child in GetView('viewFrontMost):childViewFrames()[0]:childViewFrames()	// text labels       			do SetValue(child, 'viewFont, font);       		end, [labelFontJ], 100);              	GetRoot():Notify(level,headerstr,messageStr);       end,     formAttributes: nil,     bookIcon: GetPictAsBits("HTMLbookIcon", nil),     Init:       func(options)       // this called by getURL, viewSetupDoneScript, or kSendHTTP(optionsAPI.noStatus)       if prefsEntry       then optionsAPI := :fixOptions(options)              else begin // very first time after opened       //Print("NC:init");       	local root := GetRoot(), newtscape := root.(kAppSymbol);       	       	optionsAPI := :fixOptions(options);              	newtscape.newtscape := newtscape; // handy ref              	/*** NOTE: if Functions frame not compatible in future,       	there may be problems running 1.x versions on 2.0.       	***/       	newtscape.nos20 := kNIE or Functions.IsVBO exists; 		// copied here from viewSetupFormScript       	if kNIE then newtscape.nos21 := GlobalFnExists('PackRGB);	// eMate/MP2K              	local nData :=       		if kNIE       		then GetGlobalVar(kNewtSymbol)       		else GetGlobals().(kNewtSymbol);       	newtscape.NewtPack := nData and nData.protos.protoPackage exists;              	//:ResetFSM(); // done 1st time in :doEvent if necessary              	local evalTemp, fr, val;       	evalTemp := newtscape.evalContext := {_parent: root}; //nData:getEvalContext();       	if nData       	then begin       		foreach fr in nData.constants       		do evalTemp := evalTemp._parent :=       			{_parent: evalTemp._parent, _proto: fr};              		if nData.protos.errorCodes exists       		then errorCodes := nData.protos.errorCodes;       		end;              	local opt := optionsAPI.processOption;       	if opt and opt <= kProcessMax // check NewtPack, cacheOnly??       	then processOption := opt       	else if not processOption       	then processOption := kProcessDefault;              	if kNIE       	then begin       		newtscape.cacheHTML :=	// removed extra tests (pref entry should be correct?)       			if prefsEntry.cacheHTML > 0		// don't always open. # (optionsAPI = string?)       			then kCacheHTMLSoupName; 		// RegUnionSoup(kAppSymbol, kCacheHTMLSoupDef);       		newtscape.cacheImages :=       			if prefsEntry.cacheImages > 0	// don't always open	(optionsAPI = string?)       			then kCacheImagesSoupName; 		// RegUnionSoup(kAppSymbol, kCacheImagesSoupDef);       		newtscape.bookmarks := prefsEntry.bookmarkSoupName;	// moved from viewSetupDoneScript       		end;              	//:setPreference(nil,nil);	// flush any changes       	:resetPrefs();				// tag prefs       	optionsAPI;					// return       	end,     optionsAPI: nil,     viewBounds: {left: 3, top: 3, right: 237, bottom: 179},     Print:       func(val)       if not commEndPt       then Print(val)              //else if GetRoot().(kNewtSymbol)       //then GetRoot().(kNewtSymbol):PrintObject(val,commEndPt,99,true,"",cr)              else begin       	local s, slot, v;       	if isArray(val)       	then begin       		s := $[;       		foreach v in val       		do s := s && v;       		s := s & $];       		end       	else if isFrame(val)       	then begin       		s := ${;       		foreach slot,v in val       		do s := s && slot & $: && v;       		s := s & $};       		end       	else if val=nil       	then s := "NIL"       	else if val=true       	then s := "TRUE"       	else s := val; //SPrintObject(val);       	StrReplace(s := s & unicodeCR, cr, crlf, nil);              	commEndPt:Output(s, nil);	// assume Sloup handles for 2.x/1.x       	end,     progressOptions: nil,     fixOptions:       func(options)       begin       	// this makes sure prefsEntry is initialized       	if not prefsEntry       	then begin	// former getPrefsEntry       		prefsEntry := :myGetAppPrefs(kPackageName);	// !!!k       /* !!!k       		if not HasSlot(prefsEntry, 'convAnim)	// really old version       		then begin       			local val := prefsEntry;       			prefsEntry := Clone(kDefaultPrefs);       			if kNIE       			then EntryReplaceXmit(val, prefsEntry, nil)       			else EntryReplace(val, prefsEntry);       			end;       */       		if not prefsEntry.prefNames	// !!!k       		then begin       			prefsEntry.curPrefTag	:= kPackageName;       			prefsEntry.prefName		:= kDefaultPrefName;       			:setPreference('prefNames, [kDefaultPrefName]); // change/update       			end;       //Print("current pref:" && prefsEntry.curPrefTag);       		if not StrEqual(prefsEntry.curPrefTag, kPackageName)       		then prefsEntry := :myGetAppPrefs(prefsEntry.curPrefTag);       		end;       					       	// this makes sure options is non-nil, and inherits from prefsEntry (now avail)       	if not options       	then options := {}       	else if IsReadonly(options)		// !!!k       	then options := Clone(options);	              	if not HasSlot(options, '_proto)       	then options._proto := prefsEntry;	              	options;       end,     Wabumiuni_Titles: nil,     _proto: @180 /* protoFloatNGo */,     curbook: nil,     DoEvent:       func(event, ARRAY args) // called by kSendHTTP, :addFile       begin       	// copy some stuff so need to access newtscape & prefsEntry from FSM       	local options := :Init(args[Length(args)-1]); // for httpProxy, httpNoProxy, loadImages, trustHTML, trustImages              	if not wwwFSM       	then begin       		wwwFSM := GetLayout("HTTP FSM"):Instantiate(); // :resetFSM();       		//wwwFSM:setSpeed(2);				// allow a little more time? see fsm.afterScript       		wwwFSM.fHTTPoptions := options;       		end;              	if not HasSlot(options,'cacheHTML)       	then options.cacheHTML := cacheHTML;              	if not HasSlot(options,'cacheImages)       	then options.cacheImages := cacheImages;              	if not HasSlot(options, 'processOption)       	then options.processOption := processOption;       	if not HasSlot(options, 'cacheOnly)       	then options.cacheOnly := options.processOption = kCacheOnly;              	if not HasSlot(options, 'dispatchApp)       	then options.dispatchApp := NewtsCape;              	if not HasSlot(options, 'InetStatus)       	then options.InetStatus := true;              	if options.fURLqueue and Length(options.fURLqueue) > 0       	then begin       //Print("NC DoEvent: ");        		wwwFSM:addQueue(options.fURLqueue);	// !!!j       		RemoveSlot(options, 'fURLqueue);       		// don't want to turn on cacheOnly (that's done temporarily elsewhere if necessary)       		// if state machine busy, queue gets checked at Cleanup; otherwise, immediate newURL or dispatch       //Write("NC DoEvent: "); Print(options);       		wwwFSM:popQueue(wwwFSM.fHTTPoptions := options);	// set options       		end              	else if event       	then wwwFSM:DoEvent(event, args);       end,     newBook:       func()       begin       	curBook := :bookTemplate();       	libook := exbook := newtletAttributes := htmlSoup :=       		formAttributes := lastSelect := lastRadio := NIL;       	if kNIE       	then all_AREA := [];	// !!!g,f	all_HREF := [];       	imgMaps := {};       	includes := [];       	:addStyle(tagDict.P.font);       	lastH := actionNum := lineNum := 0;       	baseFont := 3;	// !!!e              	:resetStatus();	// !!!h       	if kNIE       	then if optionsAPI.processOption = kSaveNW       		then (self.tempNewtworks := BuildContext(kDummyTx)):open()       		else call kRemoveAllSoupEntries with (htmlSoup := kHTMLSoupName)	// always put results in soup if possible              	else if optionsAPI.processOption = kSavePkg       	then begin // ????       		local defStore := call kGetDefaultStoreFunc with ();       		htmlSoup := defStore:GetSoup(kHTMLSoupName);       		if htmlSoup       		then call kRemoveAllSoupEntries with (htmlSoup)       		else htmlSoup :=       			defStore:CreateSoup(kHTMLSoupName, kHTMLIndexes);       		end;              	:newPage();       end,     myGetAppPrefs:       func(tag)	// !!!k       if prefsEntry and StrEqual(prefsEntry.tag, tag)       then prefsEntry       else if kNIE       then begin       	gc();       	GetAppPrefs(Intern(tag), kDefaultPrefs);       	end       else begin       	local sysSoup := GetStores()[0]:GetSoup(sysSoupName);       	local prefs := Query(sysSoup, {type: 'index, indexPath: 'tag, startKey: tag}):entry();       	if prefs and StrEqual(prefs.tag, tag)       	then prefs       	else sysSoup:Add(Clone(kDefaultPrefs));       	end,     rootContainer: nil,     savePackageConfirm:       func(fl)       if fl       then begin       	local pkg := curPkg, appTemplate := pkg.appTemplate, newtPkg := appTemplate._package;       	exbook := curPkg := nil;              	if newtPkg.existingPackage       	then begin       		local sym := appTemplate.appSymbol, bpkg;       		if kNIE and bpkg := call kFindPkg with (SPrintObject(sym))       		then newtPkg.sizeHint := Length(bpkg);       		bpkg := newtPkg := nil;       		:RemovePackage(sym);       		end;              	// cleanup moved to removeApp       	:removeApp(true,nil);              	pkg:savePackage();       	//if kNIE	// was pkg:savePackage()       	//then AddDeferredSend(pkg, 'savePackage, nil)       	//else AddDeferredAction(Functions.Perform, [pkg, 'savePackage, '[]]);       	end       else curPkg := nil,     progressView: nil,     _CloseFrontView:       func(view)	// !!!f       call kHideNewtsCape with ()	// !!!g. GetRoot().(kAppSymbol):hide()       ,     addIncludes:       func()       begin       	local isbn, book, page, s, v;       	local template := curbook.(kTemplatePath);       	local ARRAY pagehints := curbook.(kHintPath), oldhints;       	local ARRAY pages := curbook.(kPagePath), lastblocks;       	local ARRAY toc := curbook.(kTOCpath), oldtoc;       	local INT plen, i, removelen, bookstart, oldhint;       	NewtsCape.pageStarts := [];       	local soupname, oldSource := curSource, oldSourcePos := curSourcePos, oldOptions := Clone(optionsAPI);              	foreach isbn in includes       	do begin       		plen := Length(pages);       		if plen > 0 and       			Length(pages[plen-1].blocks)=0 // zap any empty last page (esp. initial)       		then SetLength(pages, plen := plen-1); // only worry about "credits" later?       		bookstart := plen; // len of cumulative book for hint offset       		AddArraySlot(pageStarts, plen+1); // for HREF("top") mapping              		if (book := call kFindBook with (isbn, nil)) // add another book?       		then begin       			// eliminate extraneous numeric codes?       			curbook.(kStylePath) := SetUnion (curbook.(kStylePath), book.(kStylePath), TRUE);              			// append pages (but use current book template)       			foreach page in book.(kPagePath)       			do AddArraySlot(pages, {template: template, blocks: page.blocks});              			// zap last page if empty (or top is named "Credits")       			plen := Length(pages);       			lastblocks := pages[plen-1].blocks;       			removelen := Length(lastblocks);       			if removelen=0 // zap any empty last page (esp. initial)       				or ((s := lastblocks[0].item.name) and StrEqual(s, "Credits"))       			then SetLength(pages, plen := plen-1)       			else removelen := 0;              			ArrayMunger(       				curBook.(kStringHintsPath), Length(curBook.(kStringHintsPath)), 0,       				book.(kStringHintsPath), 0, Length(book.(kStringHintsPath)) - removelen);       			ArrayMunger(       				curbook.(kContentsPath), Length(curbook.(kContentsPath)), 0,       				book.(kContentsPath), 0, Length(book.(kContentsPath)) - removelen);              			// TOC stuff (copy hints & headings)       			oldhints := book.(kHintPath);       			oldtoc := book.(kTOCpath);       			for i:=0 to Length(oldhints) - 1       			do if (oldhint := oldhints[i]+bookstart) <= plen       				then begin       					AddArraySlot(pagehints, oldhint); // length of cum. book for offset       					AddArraySlot(toc, oldtoc[i]);       					end       				else break;       				       			foreach s,v in book.(kDataPath)       			do  if s = 'form_hidden or s = 'form_printnames       				then call kAppendFrame with (curBook.(kDataPath).(s), v)       				else if s <> 'base_href       				then curbook.(kDataPath).(s) := v;       			end              		// add source from Notes to current book?       		else if (s := if kNIE then CharPos(isbn,$/,0) else StrPos(isbn,"/",0)) // soup       			and soupname := SubStr(isbn,0,s)       		then :addFile(kHTMLMediaType, nil,       				:findHTMLentry(       					soupname, SubStr(isbn,s+1,nil), nil,       					if StrEqual(soupname,notesSoupName) then "<LINK NAME=\"" else 'name, "\""),       				:Init({start: 0, noStop: true, noDelay: true}));       		end;              	if (plen := Length(pages)) > 0       	then begin       		if IsReadonly(lastblocks := pages[plen-1].blocks)	// allow additions to last page       		then pages[plen-1].blocks := lastblocks := Clone(lastblocks);       		if (i := Length(lastblocks)) > 0					// add below last item       		then currentContainer.top := lastblocks[i-1].bounds[3] + currentContainer.below; // !!!a. :setTop       		end;       	if (i := Length(toc)) > 0		// avoid Hx gaps       	then lastH := toc[i-1].level;       	curSource := oldSource; curSourcePos := oldSourcePos; optionsAPI := oldOptions;       end,     stopHTML:       func()	// called by CancelRequest, disconnect, parseProgress       if parseJob and optionsAPI	// !!!g       then begin       	//if not kCParser then       	try parseJob:?WrapUp()       	onexception |evt.ex|       	do  if :error('stopHTML, currentException())       		then return parseJob := NIL;              	local htmlApp := parseJob.htmlApp;       	if not optionsAPI.frameStart		// !!!e       	then begin       		parseJob := NIL;       		currentContainer := rootContainer;       		end;       	curSource := NIL; // curSourcePos       	if kNIE and curSourceBuf       	then curSourceBuf := curSourceBuf:?close();              if kDebugHTTP then Print("elapsed:" && (ticks() - NewtsCape._ticks) / 60);       if kProfileOn then EnableProfiling(nil);       	:resetPrefs();              	local invis := optionsAPI.noStatus and not Visible(NewtsCape), obj := NewtsCape, msg, tmp, args := '[];       	if invis       	then msg := 'quit;              	if optionsAPI.processOption = kSavePkg // Save Package. was htmlSoup       	then begin       		msg := 'saveBook;       		args := [curBook,libook,exbook];       		if invis       		then begin       			tmp := htmlSoup;	// save tmp       			// NewtPack := nil;	// prevent removal of entries during quit (!!!i. only needed for viewQuitScript)       			:quit();			// curBook, libook, Newtscape, htmlSoup nil-ed (but saved locally here)       			htmlSoup := tmp;	// restore       			end       		else :SetRun(nil);		// !!!g. turn off hand (normally via docDone)       		end              	else begin       		:docDone(optionsAPI, not invis and (curBook or htmlApp <> NewtsCape)); // allow sound for other htmlApp              		if curBook and htmlApp = NewtsCape       		then begin       			local blen := Length(curBook.(kContentsPath)), refresh, bhref := curBook.(kBasePath);              			:setStatus(       				LocObj("Lines", 'linesLabel) & $: && linenum & $; &&       				LocObj("Items", 'itemsLabel) & $: && blen & $; &&       				LocObj("Pages", 'pagesLabel) & $: && Length(curBook.(kPagePath))       				);              			if optionsAPI.processOption = kSaveNW       			then begin       				call kAppendNewtWorksObj with (tempNewtworks, unicodeCR & bhref);       				call kNewtWorksSaveDoc with (tempNewtworks, curBook.title, not invis);       				tempNewtworks := NIL;       				end       			else if blen > 0 and (       				(tmp := optionsAPI.hrefname)       				or not (processOption = kDisplayPage1 // !!!d       					and call kViewIsOpenFunc with (GetRoot().(kBookReaderSymbol))))	// !!!g       			then :refreshBook(if tmp then tmp else 1);              			if kNIE and       				((refresh := curBook.NewtonRefresh) or refresh := curBook.refresh)       				//and not options.includeFrames		???       			then begin       				local pos, delay, url;       				if  ((pos := CharPos(refresh, $;, 0)) or       					 (pos := CharPos(refresh, $,, 0))) and       					(delay := StringToNumber(SubStr(refresh,0,pos))) and       					(url := call kGetAttrib with (refresh, $=, nil, pos+1)) and       					StrEqual(url[0], kURL)       				then        					// should this do "Reload" (remove url[1] from cache first?)       					/*AddDelayedSend(self, 'getURL,       						[:resolveURL(curBook.(kBasePath), url[1]), optionsAPI], Floor(delay)*1000);*/       					AddProcrastinatedCall(       						Intern(bhref),       						func(curURL, newURL, options)       						begin       							local newtscape := GetRoot().(kAppSymbol), curBook;       							if newtscape and isFrame(curBook := newtscape.curBook) and       								StrEqual(curBook.(kBasePath), curURL)       							then begin // still in original book       								if StrEqual(curURL, newURL) // reload?       								then call kGetURLCache with (newtscape.cacheHTML, curURL, '_delete, curBook.(kEdataPath), nil);       								newtscape:getURL(newURL, options);       								end;       						end, [bhref, :resolveURL(bhref, url[1]), optionsAPI], Floor(delay)*1000);       				end;       			end;       		end;              	if optionsAPI.callbackFn       	then begin       		if msg       		then Perform(obj,msg, args);       		call optionsAPI.callbackFn with (optionsAPI);       		end              	else if msg // quit(invis) or saveBook       	then if kNIE       		then AddDelayedSend(obj, msg, args, kDelay)       		else AddDelayedAction(Functions.Perform, [obj, msg, args], kDelay);       	       	//optionsAPI := {};	// nil?       end,     protoSerialProtocol:       DefineGlobalConstant('kProtoInputSpec,       if kNewEndPoint       then {       	form:			'string,       	termination:	{endSequence: unicodeCR},	// replaced by Sloup if Unix       	discardAfter: 	kLineLength,       	//inputScript:	func(ep, data, terminator, options)	-- provide in Sloup       	}       else {       	InputForm: 		'string,       	endCharacter: 	unicodeCR,		// replaced by Sloup if Unix       	discardAfter: 	kLineLength,       	//InputScript: 	func(ep, data) -- provide in Sloup       	}       );              constant kTempSize := 2048;	// was 4096. size of heap string before adding to VBO              {       exceptionHandler: func(exception) // usually called during :abort       	if exception.data <> -16005       	then GetRoot().(kAppSymbol):PRINT(exception),              otherSpecs: '[waitLine],	// fixed up in firstLineSpec for Unix if necessary              waitLine: { // for Mac, DOS, Unix       	_proto: 		kProtoInputSpec,	       	lineScript: 	func(ep, data)       		ep:inputLine(data),       	},              tempStr: nil,              inputLine: func(s) // define here to take advantage of context/inheritance       	if tempStr <> 'aborted		// after disconnect?       	then begin       /* omit since we're not using old protoEndpoint       		if kAddEncoding and not kNewEndPoint // protoEndPoint version?       		then begin       			// return strings to raw byte stream       			local bin := call NTE_uni2roman with (s, nil);	// (input strings, option spec)       		       			// translate raw byte stream to unicode       			s := NTE_methods:code2uni(bin, NTE_methods:GetPrefsNTEncoding(prefsEntry.NTEncoding, kDefaultEncoding), nil);	// (byte stream, encoding table, option spec)       			end;       */       		if kNIE       		then begin       			local INT charsRead := StrLen(s), clen;       			local ctype, isHTML, href, attrib, name, val, rc;       			:displayLine(s);	// also removes lf. preserve cr       //Print("not curSource");       			if not curSource	// 1st line?       			then begin       				optionsAPI.header := commEndPt.header := {};	// save any header fields       				commEndPt.totRead := header.(kContentLengthSym)	:= 0;       				if BeginsWith(s, kContentType)						// Content-Type on 1st line?       				then totRead := nil									// read header instead       				else header.(kContentTypeSym) := kHTMLMediaType;	// default              				curSource := kBigStringObj:new(	// !!!j       					call kNewVBO with (       					if IsString(name := optionsAPI.HTMLstore)	// !!!g       					then LFetch(GetStores(),name,0,'|str=|,'name),       					nil, ""));       				//commEndPt.nextFlush := kVBOFlush;       				tempStr := nil;       				end;       //Print("totRead");       			if totRead	// content       			then begin       				rc := prefsEntry.removeComments;       				clen := curSource:length();	// !!!j. StrLen(curSource);       				isHTML := BeginsWith(ctype := header.(kContentTypeSym), kHTMLMediaType);       				if isHTML and clen > 0 and rc // assume BASE if any was in initial kTempSize       				then call kRemoveComments with (s);       				totRead := totRead + charsRead;	// includes comments if any       				if tempStr       				then StrMunger(tempStr, StrLen(tempStr), 0, s, 0, nil)       				else tempStr := s;       				if StrLen(tempStr) > kTempSize       				then begin       					if isHTML and clen=0 and rc       					then begin // save BASE (if in initial kTempSize)       						if not header.(kContentBaseSym)       						then header.(kContentBaseSym) := call kGetBase with (tempStr);       						call kRemoveComments with (tempStr);       						end;       					curSource:append(tempStr,0,nil);	// !!!j       					/*StrMunger(curSource, clen, 0, tempStr, 0, nil);       					if Length(curSource) >= nextFlush       					then begin       						ClearVBOCache(curSource);       						nextFlush := nextFlush + kVBOFlush;       						end;*/       					tempStr := nil;       					end;       				end       			else if StrFilled(s)	// header       			then begin // Content-Type, Content-Length, Content-Base       				if attrib := call kGetAttrib with (s, $:, unicodeCR, 0)       				then begin       					val := if StrEqual(name := attrib[0], kContentLength)       						then clen := call kGetInt with (attrib[1], 0)	// !!!b       						else begin       							if BeginsWith(name, kContentType)       							then name := call kSubStr with (header.(kContentTypeSym0) := name, 0, ";", nil);       							attrib[1];       							end;       					header.(Intern(name)) := val;       					end;       				end       			else totRead := 0;	// empty line -> end header. next: start content              			clen := header.(kContentLengthSym);       			if (if clen > 0       				then totRead >= clen       				else StrPos(s, kHTMLStop, 0) and EndsWith(TrimString(s), kHTMLStop)) // continue if text or another tag after       			then begin       				//RefreshViews();	// so can see final line immed?       				:SetInputSpec(nil);       				if tempStr       				then //StrMunger(curSource, StrLen(curSource), 0, tempStr, 0, nil);       					curSource:append(tempStr,0,nil);       				//ClearVBOCache(curSource);       				tempStr := nil;       				curSource := curSource:contents();       				href  := header.(kContentBaseSym);       				if isHTML       				then begin       					if not href       					then href := call kGetBase with (curSource);       					if rc	// remove now (after BASE extracted!)       					then call kRemoveComments with (curSource);       					end;       				if (isHTML or prefsEntry.cacheText)	// !!!o       					and href and BeginsWith(href, kHTTP) and prefsEntry.cacheDesktop and cacheHTML       				then try begin       					local cacheEntry := call kGetURLCache with (cacheHTML, href, nil, nil, prefsEntry.ignoreHTMLExpiration);       					// copy to correct store (didn't know href/cacheEntry when curSource created)       					if cacheEntry and EntryStore(cacheEntry) <> GetVBOStore(curSource)       					then curSource := call kNewVBO with (EntryStore(cacheEntry), nil, curSource);       					call kPutURLCache with (       						GetVBOStore(curSource), // !!!j       						cacheHTML, href, 'text, cacheEntry, curSource, nil, nil, nil, nil, ctype); // !!!o. kHTMLMediaType       					end       					onexception |evt.ex| do :setStatus(kHeapMsg);       				if processOption = kCacheOnly       				then curSource := NIL;              				if kNewEndpoint       				then NewtsCape:disconnect(nil)       				else AddDeferredSend(NewtsCape, 'disconnect, '[nil]); // don't do stopHTML              				if curSource       				then AddDelayedSend(Newtscape,       					'dispatchFile,       					[ctype, if href then href else "", curSource, optionsAPI],       					kDelay);	// + kCleanupDelay       				end;       			end              		else if NewtsCape:addHTML(StrMunger(s,StrLen(s)-1,1, nil,0,nil), nil)	// line-at-a-time with no status (unknown len)       		then AddDeferredAction(Functions.Perform, [NewtsCape, 'disconnect, [tempStr := 'aborted]]);       		end,       },     wwwFSM: nil,     Notes_Titles: nil,     addHTMLitem:       func(tag, results)       // tag = frame {_tag: 'symbol, _value: <str, array, true, nil>}       // results = frame or nil       begin       	if debugFlag		// optionsAPI.debugFlag ??       	then begin       		Write("\ntag: "); 	Print(tag);       		Write("results: "); Print(results);       		end;              	if not curBook       	then :newBook();              	if results and prefsEntry.showCmdStatus       	then begin       		local pos := results.bytesSoFar, slen := results.sourceLength;       		:setGauge(       			pos & $/ & slen && Upcase(SPrintObject(tag._tag)),       			pos, slen);	       		end;              	local obj := :getObj(tagDict, tag, nil); // tag now a frame, part of obj       	if kDebugHTTP then       	newtscape.curObj := obj;              /* implementation notes:              addFile -> parseProgress -> addHTML -> processLine ->              htmlApp:addHTMLitem(obj,results)       	obj = {_tag: , _value: ...}       	attributes from parser              container:addItem(obj)       	obj = {_tag:, _value: ..., _proto:, _parent:...}       	plus inheritance context. add obj immediately or save (table)              obj:get_data()       	container has correct size       	returns obj = {..., _data: {}, height:...} or list of objs or NIL              obj:addBlock()       	returns obj {... dataOffset: , dataLen:...} if paginated or NIL       */              	if not obj and optionsAPI.unknownTag	// !!!a1       	then begin       		local val := tag._value;       		local err := //${ & LocObj("UNKNOWN TAG", 'unknownTagErr) & $: && tag._tag & "}\n";       			"?<" & (if not val then $/) & tag._tag & ">?";	// !!!z       		if isArray(val)       		then ArrayMunger(val,0,0, [kATagP, err],0,nil)       		else val := err & val;       		obj := :getObj(tagDict, kTagP, val);       		end;              	if obj	// !!!a1       	then currentContainer:addItem(obj);       	       /*       	try currentContainer:addItem(obj)       	onexception |evt.ex|       	do return not :error(	// TRUE if out of heap/store; NIL for other errors       		LocObj("process", 'processErr) & $: && if results then results.bytesSoFar, currentException());       	TRUE;       */       end,     SimpleTextHeight:       func(text, INT width, font) // use same args as platform function       call kMySimpleHeightFunc with (text, 0, nil, width, font)	// !!!o. measure all by default.       // use kMySimpleHeightFunc directly if entire length isn't needed (just enough for page break?)       ,     refreshBook:       func(pnum)       // pnum = nil. don't refresh current page unless kDisplayItem       // pnum = true. refresh current page       // pnum = "string". goto/refresh page with href#name       // pnum = <num>. refresh page#       if curBook and not exbook       	and (pnum or optionsAPI.processOption=kDisplayItem)       	and not isFrame(htmlSoup)       then begin       	local isbn := curBook.isbn, libentry, wasOpen;        	local INT plen := Length(curBook.(kPagePath));       	local viewer := GetRoot().(kBookReaderSymbol), openMsg := 'openBook, openArg := isbn, help := curBook.help;              	if prevBook       	then begin       		Apply(kBookCleanup2, prevBook);       		prevBook := NIL;       		end       	else wasOpen := Visible(viewer);              	if help       	then begin       		openMsg := 'openManual;       		viewer := call kHelpViewerSetup with (openArg := curBook);       		end;              	if libook       	then Perform(viewer, openMsg, [openArg])              	else if exbook := call kFindBook with (isbn,nil)       	then begin       		if not optionsAPI.noConfirm       		then return :Confirm(       			title,       			kReplacePkg & unicodeCR & exbook.appSymbol & "\n(isbn:" && isbn & $),       			NewtsCape,       			'removePackage);       		end              	else begin       		if exbook	// noConfirm       		then :removePackage(exbook.appSymbol);              		libook := {book: curBook};       		if help       		then libook.help := TRUE;              		try BookAvailable(libook, 0)       		onexception |evt.ex| do nil; //:Print(currentException());              		if (not help or       				if kNIE then begin viewer:RegisterBookRef(isbn, libook); NIL; end else TRUE)       			and libentry := call kFindBook with (isbn,TRUE)       		then begin       			libentry.curPage 					:= 1; 									// in case deleted??       			libentry.isbn 						:= EnsureInternal(Clone(isbn)); 		// in case messed up       			libentry.title 						:= EnsureInternal(Clone(curBook.title));// in case messed up       			libentry.(EnsureInternal('data))	:= EnsureInternal({});					// reset (do also in removeApp?)       			if kNIE       			then libentry.InkMarks 				:= EnsureInternal([[]]);       			libentry.(EnsureInternal('marks))	:= EnsureInternal(if kNIE then [[]] else []);       			end;              		local invis := optionsAPI.noStatus and not Visible(newtscape), scripts;       		if invis and not help       		then begin // add isbn for existing temporary quitScript (for cleanup)       			scripts := curBook.(kScriptsPath);       			AddArraySlot(scripts, 'isbn);       			AddArraySlot(scripts, isbn);       			end;              		Perform(viewer,openMsg,[openArg]);              		if invis and help       		then begin // add isbn, script for cleanup to viewer directly       			scripts := viewer.contentArea;       			scripts.isbn := isbn;       			scripts.viewQuitScript :=       				if kNIE		// kBuild20 or nos20       				then kHelpBookCloseScriptInv2       				else kHelpBookCloseScriptInv1x;       			end;       		end;              	if help       	then return       		if (if kNIE then IsString(pnum) else isInstance(pnum,'string)) and       			StrFilled(pnum)       		then viewer:openHelpTo(pnum);              	local maxpage := viewer:countPages(), num;       	if (if kNIE then IsString(pnum) else isInstance(pnum,'string))       	then if num := call kSubStr with (pnum,"PAGE#",nil,true) // see end of kGoToHREF       		then viewer:TurnToPage(min(call kGetInt with (num,maxpage), maxpage))	// !!!b       						//if num := StringToNumber(num) then min(Floor(num),maxpage) else maxpage)       		else if StrFilled(pnum)       		then viewer:TurnToContent('name,pnum)       		else viewer:TurnToPage(1)              	else if pnum=true or (num := viewer:currentPage()) = (if pnum then pnum else pnum := plen)       		or (kNIE and viewer.pagesShowing and num+viewer.pagesShowing = pnum)	// !!!d1       	then (if not wasOpen then viewer:scrollPage(0)) // assumed patched in bookOpenScript for 2.0              	else viewer:TurnToPage(min(pnum, maxpage));       	end,     newtscape: nil,     resetPrefs:       func()       begin       	local s, v, dict;       	newtscape.tagDict 	:= {_proto: tagDictOrig};       	newtscape.inputDict := {_proto: inputDictOrig};       	foreach s, v in prefsEntry       	do if (HasSlot(tagDictOrig, s) and dict := tagDict)       		or (HasSlot(inputDictOrig, s) and dict := inputDict)       		then begin       			v := Clone(v);       			v._proto := dict.(s); // actually from orig       			dict.(s) := v;       			end;       end,     error:       func(str, errframe)       begin       	:print(str);       	if isFrame(errframe)       	then begin       		local errcode := errframe.error, errcode2 := errframe.name, errmsg, stop;       		if errcode       			or (errframe.data and errcode := errframe.data.errorCode)       		then begin       			if not (errmsg := call kLookupError with (ROM_errorTable,errcode,errcode2))       			then if not (errorCodes and errmsg := call kLookupError with (errorCodes,errcode,errcode2))       			then errmsg := if errcode       				then if kNIE and errcode <= -60000 and GetGlobalFn('InetGetErrorString) // -60501?       					then InetGetErrorString(errcode)       					else errcode       				else errcode2;       			end       		else errmsg := errframe;              		:print(errmsg);       		:errorStatus(LocObj("Lines", 'linesLabel) & $: && linenum & $; && str && errmsg);              		if SetContains('[666, -10007, -48216, -7000, -14002, -10612, -10617, ], stop := errcode)       			or (stop := errcode2) = '|evt.ex.outofmem| or errcode2 = '|evt.ex.fr.store|       		then begin	// !!!g       			newtscape:cancelRequest(stop);       			return TRUE;       			end;       		end              	else if errframe then :print(errframe);              	NIL;       end,     gotoHREF:       func(bk,bdata,hrefstr, x1,y1,href,item) // called via kGoToHREFclickShare, kPickHREFfunc, "RADIO/TEXT", "Open Location"       begin       	:Init(nil);       	//optionsAPI.extraHeader := {Referer: bdata.base_href};       	curSource := NIL;	// !!!g. just in case still processing? (stops parseProgress)       	call kGoToHREF with (bk,bdata,hrefstr, x1,y1,href,item);       end,     appSymbol:       kAppSymbol	// The symbol identifying the application       ,     viewJustify: 0,     icon:       MakePixFamily(           GetResourceFromFile({filename:                 "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc", resource:                 148}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc",                   resource: 148}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u'\u00C4",                   resource: }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u'\u00C4",                   resource: }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u'\u00C4",                   resource: }),             bitDepth: 8}]);,     lastMap: nil,     title: kVersion,     lastFont: nil,     powerOffScript:       func(what)       what = 'okToPowerOff and not commEndPt,     curSourcePos: nil,     addBlock:       func()       begin       	if kDebugHTTP then newtscape.curObj := self;       	if kDebugHTTP then newtscape.curData := _data;       //Print(_data);       	local pdd := _data.data;       	local slen := if (if kNIE then isString(pdd) else isInstance(pdd,'string)) then StrLen(pdd);              	if kNIE and optionsAPI.processOption = kSaveNW       	then begin       		if _data.type <> 'form       		then begin       			call kAppendNewtWorksObj with (tempNewtworks, if slen then _data else pdd);       			call kAppendNewtWorksObj with (tempNewtworks, cr);       			end;       		return NIL;       		end;              	local ARRAY pages := curBook.(kPagePath);       	if Length(pages)=0 then :newPage();	// shouldn't occur?              // maybe above,below only from obj, not container???       	local iabove := above;       	if (if kNIE then isString(iabove) else isInstance(iabove,'string))       	then iabove :=       		if StrEqual(iabove,"TOP")       		then 'top       		else call kGetInt with (iabove, nil);	// !!!b       		//if (iabove := StringToNumber(iabove))       		//then iabove := Floor(iabove);       	if not iabove       	then iabove := currentContainer.above;	// in obj or page??              	if (if kNIE then IsInteger(iabove) else isInstance(iabove, 'int))       		and currentContainer.top > rootContainer.top	// !!!g       	then currentContainer:addTop(iabove);       	local INT availHeight := currentContainer:getHeight();       //Print("availHeight:" && availHeight);              	local splitTag := if slen then split;       	local splitBlock := splitTag and height > availHeight and availHeight >= kSplitHeight; // at least 1 line!       	local INT plen := Length(pages), pos;       	if IsReadOnly(pages[plen-1]) or       		(Length(pages[plen-1].blocks) > 0 // non-empty page?       		and (iabove='TOP       				or (not splitBlock and (height > availHeight))))       	then return self; // start a new page       //Write("splitBlock: ") ;Print(splitBlock);              	local nextData, nextObj, dataLen, hrefs;       	local pfont := _data.viewFont;       	local ofont :=       		if kStyleMeasure and _data.styles	// !!!m       		then _data.styles       		else if pfont       		then pfont       		else if not kStyleMeasure and maxFont       		then maxFont       		else font;              	if splitBlock and       		(pos := call kSplitTextHeightFunc with (pdd, [dataOffset, min(slen-dataOffset,kScreenChars)], width, ofont, availHeight)) < slen // !!!o       	then begin       		dataLen := pos + (if pos >= 0 and isWhiteSpace(pdd[pos]) then 0 else 1) - dataOffset; // last char visible?       		pos := pos+1;	// !!!n. do once&early       		nextHeight := call kMySimpleHeightFunc with (pdd, pos, max(0,min(slen-pos,kScreenChars)), width, ofont);	// !!!o       //if kStyleMeasure and newtscape.debugHeight then        //if Length(pages) < 10 then Print("page:" && Length(pages) & "; split:" && pos & "; availHeight:" && availHeight & "; nextHeight:" && nextHeight);       		height := availHeight;              		nextData := Clone(_data);       		if _data.hrefs       		then begin       //Print("split"); Print(_data.hrefs); Print(pos-dataOffset);        			local ARRAY hrefs2 := call kSplitRuns with (_data.hrefs, 0, pos-dataOffset, true); // !!!m       //Print(pdd); Print(hrefs2[0]); Print(hrefs2[1]);       			if (hrefs := hrefs2[0]) and (Length(hrefs) > 2 or (Length(hrefs) > 0 and hrefs[1]))       			then _data.hrefs := hrefs // last char may be wrong???       			else RemoveSlot(_data, 'hrefs);       //Print(_data.hrefs);       			if (hrefs := hrefs2[1]) and (Length(hrefs) > 2 or (Length(hrefs) > 0 and hrefs[1]))       			then nextData.hrefs := hrefs       			else RemoveSlot(nextData, 'hrefs);       //Print(nextData.hrefs);       			end;       		//else nextData := _data;       		end              	else if dataOffset > 0       	then dataLen := slen - dataOffset              	else begin       		if height > availHeight	// for IMG       		then height := availHeight;       		local availWidth := currentContainer:getWidth();	// rootContainer ?       //if kDebugHTTP then Print(['addBlock, width, availWidth]);       		width := min(width, availWidth+7);       		end;              //if _data.hrefs then begin Print(pdd);PRINT(['dataOffset,dataOffset,'dataLen,dataLen]);Print(_data.hrefs);end;              	if _data.hrefs and       		_data.hrefs := call kGetHrefRegions with(       			pdd, dataOffset, if dataLen then dataLen else slen, width, height, ofont, _data.hrefs)       	then _data.scripts := call kAppendObj with (_data.scripts, if slen then kAHREF else kAHREFG); // !!!y. add to existing scripts (if any). SHARE text/graphics versions              	if isFrame(pdd) and pdd.delays	// animated graphics       	then _data.scripts := call kAppendObj with (_data.scripts, kImgAnim);              	local ARRAY bcontents := curBook.(kContentsPath);       	local INT clen := Length(bcontents); // old length (0-based)              	// make item virtual via soup?       	if htmlSoup and not isReadOnly(pdd) and       		not curBook.help and       		not (kNIE and isVBO(pdd)) and       		(slen // string?       			or (:getPictObj(pdd,nil) //  bitmap,PICT       				and not _data.usemap))       	then if dataOffset > 0 // save same (previous) ref       		then if isFrame(prevData)        			then _data.data := prevData.data       			else _data := prevData              		else if kNIE and optionsAPI.processOption <> kSavePkg	// 2.x display (Find, headings)       		then begin       			if slen and (slen > 12 and not level)	// leave graphics alone       			then begin       				local soup := GetUnionSoupAlways(htmlSoup);       				_data.data := MakeEntryAlias(soup:AddFlushedXmit({data: pdd}, nil));       				if (hrefs := _data.hrefs) and Length(hrefs) > 1       				then _data.hrefs := MakeEntryAlias(soup:AddFlushedXmit({data: hrefs}, nil));       				end;       			end              	// Save Package       		else if slen and       			not hrefs and	// not splitting a para w/ diff hrefs       			((if kNIE then IsInteger(pfont) else isInstance(pfont, 'int)) or       			(_data.styles and // all integers in styles array?       			if kNIE       			then not LSearch(_data.styles, nil, 0, '|=|, GetGlobalFn('IsInteger))       			else call kAllType with (_data.styles, 'int)))       		then begin // save entire entry (frame) {data: , }. ok since not displaying       			RemoveSlot(_data, 'scripts);       			_data :=       				if kNIE	// for mungeContentScript       				then MakeEntryAlias(GetUnionSoupAlways(htmlSoup):AddFlushedXmit(       					{appSymbol: kAppSymbol, appMsg: 'fixPkgHREF, data: _data}, nil))       				else       					//htmlSoup:add({contentID: clen, data: _data});       					//_data := [deferredPackageObject: kGetHTMLFunc, clen];       					[deferredPackageObject: kGetHTMLFunc, EntryUniqueId(htmlSoup:add({data: _data}))];       			end              		// save just entry data: string, graphic       		else _data.data :=       			if kNIE	       			then if slen	// leave graphics (animated GIFs) alone (assuming they're already ROM or VBOs?)       				then MakeEntryAlias(GetUnionSoupAlways(htmlSoup):AddFlushedXmit({data: pdd}, nil))       				else pdd       			else       				//htmlSoup:add({contentID: clen, data: pdd});       				//_data.data := [deferredPackageObject: kGetHTMLFunc, clen];       				[deferredPackageObject: kGetHTMLFunc, EntryUniqueId(htmlSoup:add({data: pdd}))];                     /* if I add both above and below to height itself, then table borders should work for multiple items;       however, then form objects should have 0 above/below (though still funny if other columns have taller height!       */              	local INT curLeft := currentContainer.left, curTop := currentContainer.top; 	//!!!a1. :getLeft, :getTop;       	local vj := if not slen and isFrame(_data) then _data.viewJustify;	// for graphics, form?       	if vj       	then RemoveSlot(_data, 'viewJustify);       	local INT curRight := currentContainer.right, curBot := curTop + height;	// !!!a1. :getRight       	local block := {       			bounds: if vj=1 	// right       				then [curRight-width, curTop, curRight, curBot]       				else if vj=2	// center       				then [curLeft := (curLeft + curRight - width) div 2, curTop, curLeft + width, curBot]       				else [curLeft := curLeft + indent, curTop, curLeft + width, curBot],	// default (left)       			item: _data,       			};              	self.bounds := block.bounds; // just for RADIO?       	currentContainer:addTop(height + if below then below else currentContainer.below);       //Print("top:" && curTop);       	if dataOffset=0 	//not dontadd       	then begin       		AddArraySlot(bcontents, _data);       		if not curBook.help       		then AddArraySlot(curBook.(kStringHintsPath), if slen then TRUE);       		end       	else block.dataOffset := dataOffset;       	if dataLen       	then block.dataLen := dataLen;       	AddArraySlot(pages[plen-1].blocks, block);              	if level       	then begin       		if not slen //did a graphic/form obj sneak in here...       		then block := {item: {data: $[ & LocObj("non-text object", 'graphicHeading) & "?]"}};        		block.level := level; // e.g., H1-H6 for TOC       /* not aliased       		if kNIE and slen       		then block.name := pdd;	// duplicated but otherwise displays as empty during development       */       		AddArraySlot(curBook.(kTOCPath), block);       		if not curBook.help       		then AddArraySlot(curBook.(kHintPath), plen); // current page# to hints       		end;       //PRINT(block);              	if not noRefresh // RADIO, OPTION       	then :refreshBook(nil);              	if nextData and pos < slen       	then begin       		nextObj :=       			if splitTag=true       			then Clone(self)       			else :getObj(tagDict, splitTag, _value);       		nextObj.indent := indent;       		nextObj.height := nextHeight;       		nextObj.width := width;       		nextObj.dataOffset := pos;       		nextObj._data := nextData;       		nextObj.prevData := _data;       		end;       	nextObj;       end,     CancelRequest:       func(reason) // for InetDisplayStatus(obs?). Stop/GoStop button       begin       	newtscape:?stopHTML();       	if kNIE       	then begin       //Print("NC:cancelRequest:" && reason & "; status:" && if wwwFSM then wwwFSM.fState);       		local options;              		if reason <> kStopError       		then wwwFSM:?addQueue(NIL);	// !!!k,j       		if wwwFSM and wwwFSM.fState and wwwFSM.fState<>'Disconnected       		then begin       			if not (options := wwwFSM.fHTTPoptions)	// !!!k       			then wwwFSM.fHTTPoptions := options := {};       			options.error := reason;		// !!!k       			wwwFSM:DoEvent('Cancel, nil);       			end       		else if newtscape and (options := newtscape.optionsAPI) and not options.error // !!!k,i,h       		then options.helperApp:?callbackError(options.error := reason, options);       		end;       end,     parseJob: nil,     installHelperApp:       func(contentType, sym, helperApp)       begin       //Print("NC:installHelperApp:begin:" && if helperApp then "install" else "uninstall");       	local helperApps 	:= call kInitGlobal with ('helperApps, {});       	local icontentType	:= EnsureInternal(Intern(contentType));       	local helperFrame 	:= helperApps.(icontentType), app;              	if isFrame(helperApp)       	then begin // install       		if not helperFrame       		then helperApps.(icontentType) := helperFrame := EnsureInternal({});       		if HasVariable(helperApp,'addFile) or       			((app := GetRoot().(sym)) and HasVariable(app,'addFile))       		then helperFrame.(EnsureInternal(sym)) := helperApp; // add/replace       		end       	else if helperFrame // un-install       		and Length(RemoveSlot(helperFrame,sym))=0       	then RemoveSlot(helperApps, icontentType);       //Print("NC:installHelperApp:end");       end              /* for direct install (instead of using installHelperApp):       with less error checking.              installScript:       ...       local gData := GetGlobalVar(kNewtsCapeSymbol);       if gData       then begin       	if not gData.helperApps       	then gData.(EnsureInternal('helperApps)) := {};       	end       else DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal({cache: [], htmlApps: {}, helperApps: {}, }));              gData.helperApps.(contentType).(sym) := helperApp       ...              removeScript:       ...       local gData := GetGlobalVar(kNewtsCapeSymbol);       if gData and gData.helperApps       then RemoveSlot(gData.helperApps.(contentType), sym);       ...       */,     removeApp:       func(isbn,softremove)       // method named same as Newt's ??       // called from Remove button, also Save (from NewtPack)?       // from viewQuitScript, startHTML (with nil)       begin              if prevBook       then begin       if kDebugHTTP then Print("prevBook");       	Apply(kBookCleanup2, prevBook);       	prevBook := NIL;       	end;              if isFrame(curBook)       then begin       	local fl := isbn;       	if (if isbn and (if kNIE then IsString(isbn) else isInstance(isbn,'string))       			then Visible(newtscape)       			else isbn := curBook.isbn)       	then begin       if kDebugHTTP then Print("removeApp: libook" && fl);       if kDebugHTTP then Print([fl, softremove, isbn, optionsAPI, curBook.help]);       		if libook       		then if softremove and optionsAPI and optionsAPI.noClose       			then prevBook := [isbn, curBook.help, kNIE]	// later (in 1st refreshBook)       			else call kBookCleanup2 with (isbn, curBook.help, kNIE)       		else // remove global data (free up heap) [necessary if no libook???]       			RemoveSlot(call kInitGlobal with (nil,nil), Intern(isbn));              		if fl // not for :startHTML & :viewQuitScript       		then if kNIE       			then begin       if kDebugHTTP then Print("cleanup");       				local ARRAY scripts := curBook.(kScriptsPath); // moved from savePackageConfirm (mostly for help books)       				local pos := SetContains(scripts, 'mungeContentScript);       				if pos       				then ArrayRemoveCount(scripts,pos,2);	// mungeContentScript - kmungeContentScript       				AddDeferredSend(self, 'resetStatus, nil);	// !!!h       				end       			else AddDeferredAction(Functions.Perform, [self, 'resetStatus, '[]]);	// !!!h       if kDebugHTTP then Print("resetStatus");       		end;              	:resetStatus();	// !!!h       	end;       curBook := libook := exbook := parseJob := lastRadio := lastSelect := NIL;       end,     updateSet:       func(oldPrefs, cmd, newPrefs, mainPrefs, more)       begin       	local minorChange :=	// !!!n. cache and bookmarks prefs are compatible between two PrefSets       		not kNIE or cmd='duplicate       		or (((oldPrefs.cacheHTML = newPrefs.cacheHTML) or (oldPrefs.cacheHTML and newPrefs.cacheHTML)) and       		 	((oldPrefs.cacheImages = newPrefs.cacheImages) or (oldPrefs.cacheImages and newPrefs.cacheImages)) and       			((oldPrefs.bookmarks = newPrefs.bookmarks) or       				(IsString(oldPrefs.bookmarks) and IsString(newPrefs.bookmarks)       					and StrEqual(oldPrefs.bookmarks, newPrefs.bookmarks)))       			);              //Print("update(" & (if minorChange then "small" else "big") & $) && newPrefs.tag);              	if not minorChange       	then :close();              	if mainPrefs       	then if kNIE       		then EntryChangeXmit(mainPrefs, nil)       		else EntryChange(mainPrefs);              	if kNIE       	then begin       		if cmd='delete       		then EntryRemoveFromSoupXmit(oldPrefs,nil)       		else if cmd='replace       		then EntryReplaceXmit(oldPrefs,newPrefs,nil);       		end       	else if cmd='delete       	then EntryRemoveFromSoup(oldPrefs)       	else if cmd='replace       	then EntryReplace(oldPrefs,newPrefs);              	if minorChange       	then begin       		// quick fixup w/o close/open for Duplicate       		// and (under certain compatible conditions): Delete, Reset All, changing PrefSets       		local val;       		prefsEntry := newPrefs;       		if val := optionsAPI       		then val._proto := newPrefs;       		if kNIE and wwwFSM and val := wwwFSM.fHTTPoptions       		then val._proto := newPrefs;              		if more	// except for Duplicate       		then begin       			if curBook then :removeApp(true,nil);	// !!!o       			:SyncView();       			:SyncChildren();	// for triangles?  see setPreference (opened)       			:resetPrefs();		// for tagDict, etc. if not Init via Sync??       			end;       		end       	else GetRoot().(kAppSymbol):open();       end,     RemovePackage:       func(asym)       begin       	if asym // true/nil from RefreshBook(Confirm), symbol from NewtPack:savePackage       	then begin       		local pkg := call kFindPkg with (SPrintObject(if asym=true then exbook.appSymbol else asym));       		if pkg       		then if kNIE       			then SafeRemovePackage(pkg)       			else RemovePackage(pkg)       		else if exbook       		then begin       			:Print(LocObj("no package", 'noPackageErr));       			BookRemoved(exbook);       			end;       		end;       	exbook := NIL;       end,     connect:       func(type, host, zone)	// called by openDoc, NewtworkChooserDone       if not commEndPt and type and       	commEndPt := GetRoot().(kSloupSymbol):?openEndpoint(type, host, zone, newtscape, type)       then begin // connected       	// copy inputSpecs, etc.       	call kAppendFrame with (commEndPt, protoSerialProtocol);              	:Init(nil);       	:PRINT(LocObj("connected", 'connectedMsg));       	newtscape:startHTML();       	end,     geturl:       func(url, options)       if kNIE and wwwFSM and wwwFSM.fState and wwwFSM.fState<>'Disconnected // !!!j. see cancelRequest       then begin       //Write("NC:getURL(queued): "); Print(url); Print(options.method && options.data);       	options := :fixOptions(options);	// :Init would set optionsAPI       	wwwFSM:addQueue([[url, options.method, nil, nil, options.data, options]]);	// add       	end              else begin       //Write("NC:getURL: "); Print(url); Print(options.method && options.data);       	options := :Init(options);	// sets optionsAPI, etc.       	if isArray(url)       	then if Length(url) > 0       		then begin       			options.fURLqueue := Clone(url);	// popped in NC:DoEvent       			if not HasSlot(options,'checkCache)	// !!!h       			then options.checkCache := true;	// for cache lookups (otherwise, assumes web)       			url := url[0];						// for normal checking       			end       		else url := "";              	if options.content and options.(kContentTypeSym)       	then :dispatchFile(options.(kContentTypeSym), url, options.content, options)              	else if options.data and options.method       	then call kPostData with (       		url, options.subject, options.method, options.data, options.dataNames, options)              	else call kGoToHREF with ( //(bk,bdata,hrefstr, x1,y1,href,item)       		nil, options, nil, 0,0,url,{});       end,     quit:       func()       // called by viewQuitScript and stopHTML(optionsAPI.noStatus)       begin       //Print("NC:quit");       	if kNIE       	then begin       		if prefsEntry       		then call kGetCookies with (prefsEntry.cookies, NIL, NIL, true); // expire any cookies (with no expiration)              		:resetFSM();       		end;              	local sym;       	// anything else???       	foreach sym in '[       		//curBook, exbook, libook, prevBook, optionsAPI, // leave alone. nil-ed in removeApp/viewQuitScript       		actionNum, curHeight, curIndent, curPkg, curSource, curSourcePos,	//allOptions,       		errorCodes, evalContext, formAttributes, htmlSoup, imgMaps, Inbox_Titles, includes,        		lastMap, lastSelect, lastRadio, lastFont, lastH, //maxX, maxY, minY, nestObjs,       		newtletAttributes, NewtPack, newtscape, Notes_Titles, pageStarts,		// nos20,       		parseJob, prefsEntry, tableRow, tagDict, //processOption,  !!!i. progressOptions, progressView,	       		rootContainer, currentContainer, inputDict,        		// base, commEndPt, linenum,       		// flushActive, NIEPrefsView, URLpara, aboutView,       		// tagPrefsView, viewBounds, viewclipper, viewFlags              		fileButton,       		statusGauge, viewButton, goButton, // !!!f       		statusPara, errorPara,       		Paperback_Titles,		// !!!k       		]       	do self.(sym) := NIL; //RemoveSlot(self,sym);       	//self.statusPara := self.errorPara := NIL;       	optionsAPI := {};	// !!!i. (rather than NIL in viewQuitScript)              	if kNIE       	then begin       		foreach sym in '[       			cacheHTML, cacheImages, wwwFSM, bookmarks,       			// |HTMLCache:NewtsCape_Titles|, |ImageCache:NewtsCape_Titles|,       			bookmarkButton,	mykbd,       			all_AREA, //all_HREF,		// !!!g,f       			]       		do self.(sym) := NIL;       		if language='Japanese       		then self.WabumiUni_Titles := NIL;       		curSourceBuf := curSourceBuf:?close();       		if self.tempNewtworks       		then begin       			tempNewtworks:close();       			tempNewtworks := NIL;       			end;       		end;       end,     setPrefsEntry:       func(newPrefsEntry)	// !!!k. e.g., after Reset All, Delete       begin       	EntryChangeXmit(newPrefsEntry, nil);       	newtscape:close();       	GetRoot().(kAppSymbol):open();	// re-creates. (might be needed for caches)       end,     errorStatus:       func(txt)       if (if kNIE then IsString(txt) else isInstance(txt, 'string))	// !!!k       then begin       	if optionsAPI       	then optionsAPI.helperApp:?errorStatus(txt);	// !!!h              	if Visible(newtscape) and prefsEntry.showCmdStatus	// !!!k. errorPara exists and errorPara and prefsEntry and        	then SetValue(errorPara, 'text, txt);       	end,     commEndPt: nil,     appName: kAppNameL,     getPictObj:       func(obj, bnd)       // used in :GetPictAsBits, :addBlock, :dumpBook, IMG:getData       if obj       then begin       	if isInstance(obj, 'bitmap)				// 2.x bitmap (only if scaled?)       	then if bnd       		then ShapeBounds(obj)       		else obj              	else if isFrame(obj) and (obj.bits or obj.colordata) 	// direct (1.x) bitmap?       	then if bnd       		then if isFrame(obj.bounds) then obj.bounds else ShapeBounds(obj)       		else obj              	else if not (if kNIE then IsString(obj) else isInstance(obj,'string)) and       			isBinary(obj) // PICT?       	then if bnd       		then ShapeBounds(MakeShape(obj))       		else obj;       	end,     Paperback_Titles: nil,     installHTMLApp:       func(sym,htmlApp)       begin       	// installs an htmlApp to be available to Process picker       	local htmlApps := call kInitGlobal with ('htmlApps,{});              	if (if kNIE then IsSymbol(sym) else isInstance(sym,'symbol))       	then begin       		if isFrame(htmlApp) and HasSlot(htmlApp,'item)       			/*(or (HasVariable(htmlApp,'item) and       				not isReadonly(htmlApp) and       				htmlApp.item := htmlApp.item)       			)*/       		then htmlApps.(EnsureInternal(sym)) := htmlApp       		else RemoveSlot(htmlApps, sym);       		end       	else htmlApps; // optionsButton.processCommands       end,     errorCodes: [],     prevBook: nil,     viewSetupFormScript:       func()       begin       	self.NewtsCape := self; // handy ref       	if kNIE then self.nos21 := GlobalFnExists('PackRGB);	// eMate/MP2K              	local ap := GetAppParams(), errMsg, immClose; 	// bounds of current screen       	local INT aWid := ap.AppAreaWidth, aHt := ap.AppAreaHeight;       	if aWid < kAppWidth or aHt < kAppHeight // screen too small       	then errMsg := immClose :=       			LocObj("Screen smaller than", 'screenSmallErr) && kAppWidth & $x & kAppHeight;              	if kExpiringVersion       	then if call kRegExpired with (0)       		then errMsg := immClose := "This version of Newt's Cape has expired. Thanks for trying it."       		else if call kRegExpired with (kRegNagMin)       		then errMsg := "This version of Newt's Cape will expire within" && kRegNagDays && "days. Please register";       		       	optionsAPI := :fixOptions(nil);	// inits prefsEntry       	if kNCfont       	then :fixFontsJ(nil,nil);       	local INT ht := kTBmargin +        		(kLineSpacing * if prefsEntry.showLongURL then kURLlines else 1) + // see URLpara.viewLineSpacing       		kmidmargin + kNewUIbuttonHeight +        		(if prefsEntry.showCmdStatus then kmidmargin + (kLineSpacing * 2) else 0) +       		kTBmargin + (if kNIE and not nos21 then -1 else 0);	// (to line up close box with bottom buttons?)       	self.viewBounds := SetBounds(kThick, aHt-ht-kThick, aWid-kNewUIinsetR, aHt-kThick);       //Write("setupForm: "); Print(viewBounds);              	if errMsg       	then :Notify(kNotifyAlert, EnsureInternal(title), EnsureInternal(errMsg));       /* (from QA)       - Call Notify to tell the user why your application cannot run.       - Set the base view's viewBounds so it does not appear, use       			RelBounds(-10, -10, 0, 0) so the view will be off-screen.       - Possibly set (and check) a flag so expensive startup things do not happen.       - Possibly set the base view's viewChildren and stepChildren slots to NIL.       - call AddDeferredSend(self, 'Close, nil) to close the view.       */       	if immClose       	then return if kNIE       			then AddDeferredSend(self, 'close, nil)       			else AddDeferredAction(Functions.Perform, [self, 'close, []]);              	// unnec, plus it sometimes removes viewBounds after Rotate!       	//inherited:?viewSetupFormScript();       end,     scanFrames:       func(href, content, INT start, includeName, collectCache)       if kNIE and href and IsString(content) // scan doc for any FRAME refs       then begin       	local bhref := call kGetBASE with (content);       	if not bhref then bhref := href;              	local ARRAY queue := [];       	local line, pos, pos2, ref, name, entry, tag, attrib, nattrib, cached;       	local INT slen := StrLen(content);       	//local oldRun := :setRun('wait);              	foreach entry in [		// !!!g       		[kFrameStart,	kSRC, kNAME],       		[kIFrameStart,	kSRC, kNAME],       		]       	do begin       		pos := start;       		tag := entry[0]; attrib := entry[1]; nattrib := entry[2];       		while (pos := StrPos(content, tag, pos))       			and pos2 := CharPos(content, $>, pos := pos+StrLen(tag))       		do begin       			if :setGauge(tag,pos,slen)       			then RefreshViews();       			line := SubStr(content, pos, pos2-pos);               			if StrFilled(href := call kScanAttribute with (line, attrib))       				and (ref := :ResolveURL(bhref, href := :fixString(href,true))) // !!!g,f       				and BeginsWith(ref, kHTTP)       				and not LSearch(queue, ref, 0, '|str=|, if includeName then 'URL)	// !!!g. not already queued       				and (not (cached := call kGetURLCache with (cacheHTML, ref, 'text, nil, prefsEntry.ignoreHTMLExpiration)) 	// !!!g. already cached?       					or collectCache)       			then AddArraySlot(queue,        					if includeName	// !!!g       					then {       						name: if name := call kScanAttribute with (line, nattrib)       							then :fixString(name,nil)	// !!!f       							else if not StrEqual(href,ref) then href,	// !!!g       						URL: ref,       						cached: if cached then true,	// !!!k       						}       					else ref);       			pos := pos2+1;       			end;       		end;              	//:setRun(oldRun);       	:setGauge("",nil,slen);       	queue;       	end,     newPage:       func()       begin       	local ARRAY pages := curBook.(kPagePath);       	AddArraySlot(       		pages,       		{template: curBook.(kTemplatePath), blocks: []});              	currentContainer.top := rootContainer.top;	// !!!a1 :setTop. anything else?              	local INT plen := Length(pages), popt;              	// note: page 1 will not display while progress box is active (see addHTMLitem)       	// it will appear if progress box closed; 2-n will appear fine       	if plen > 1       	then :refreshBook(       		if  (popt := optionsAPI.processOption) = kDisplayPage or       			(popt = kDisplayPage1 and plen = 2)       		then plen-1       		);       	// else wait for possible HEAD stuff like title, isbn       end,     BookOpenScript:       func(obj) // non-standalone       call kBookOpenScriptShare with (       	obj, kDummyButton,       	if not optionsAPI or not optionsAPI.noStatus	// Visible(newtscape) or (... and...)       	then kShowNCButton else kHistoryButton,       	kBackButton, kForwardButton),     noPicture: GetPictAsBits("MissingPictureIconSmall", nil),     prefsEntry: nil,     scanImages:       func(cacheField, href, content, INT start, options, includeName, collectCache, pview, poptions) // !!!k       if kNIE and href and options.loadImages	and IsString(content) // assumes cacheImages already checked (except during debugging)       then begin // check if any uncached images need to be retrieved       	local bhref := call kGetBASE with (content);       	if not bhref then bhref := href;              	local queue := [], line, pos, pos2, ref, name, entry, tag, attrib, nattrib, wid, ht, cached;       	local imgCount := 0, imgMax := options.loadImages, anyData := StrPos(content, "\"DATA.", 0);       	options.loadImages := nil; 	// prevent recursion              	local INT slen := StrLen(content);       	//local oldRun := :setRun('wait);              	if kNCfont and pview and prefsEntry.systemFontFamily <> kSystemFontSym	// !!!k       	then begin       		local ARRAY cf := pview:childViewFrames();       		SetValue(cf[2], 'viewFont, labelFontJ);	// statusText (top) ["title"]       		SetValue(cf[5], 'text, LocObj("Stop", 'stopLabel));       		SetValue(cf[5], 'viewFont, labelFontJ);	// Stop button       		SetValue(cf[4], 'viewFont, dataFontsJ);	// titleText (under gauge) ["status"]       		end;              	foreach entry in [		// !!!e       		["<META NAME=\"ICON\"", "CONTENT=", nil],       		["<IMG", 				kSRC, 	kALT],       		["<INPUT", 				kSRC, 	kNAME],       		]       	do begin       		pos := start;       		tag := entry[0]; attrib := entry[1]; nattrib := entry[2];       		while (pos := StrPos(content, tag, pos))       			and (pos2 := CharPos(content, $>, pos := pos + StrLen(tag)))       			and (not IsInteger(imgMax) or (imgCount := imgCount+1) <= imgMax)       		do begin       			if pview	// !!!k       			then begin       				poptions.titleText := tag;       				poptions.gauge := RIntToL(pos * 100 / slen);       				pview:SetStatus('vGauge, poptions);       				end       			else if :setGauge(tag,pos,slen)       			then RefreshViews();       			line := SubStr(content, pos, pos2-pos);              			if StrFilled(href := call kScanAttribute with (line, attrib))	// URL       				and not (anyData and StrPos(content, "\"DATA." & href & $", 0))       				and not :GetNamedResource(href, '[name, title], '[bitmap, icon])       				and (ref := :ResolveURL(bhref, href := :fixString(href,true))) // !!!g,f       				and BeginsWith(ref, kHTTP)       				and not LSearch(queue, ref, 0, '|str=|, if includeName then 'URL) // !!!f. not already queued       				and (not (cached := call kGetURLCache with (cacheImages, ref, cacheField, nil, options.ignoreImageExpiration)) // already cached?       					or collectCache)       			then AddArraySlot(queue,       					if includeName       					then begin       						if nattrib and name := call kScanAttribute with (line, nattrib)       						then :fixString(name,nil)       						else name := if not StrEqual(href,ref) then href;		// !!!g              						if (wid := call kScanAttribute with (line, "WIDTH="))	// !!!g       							and ht := call kScanAttribute with (line, "HEIGHT=")       						then name := name && $[ & wid & $x & ht & $];              						{name: name,       						URL: ref,       						cached: if cached then true,	// !!!k       						};       						end       					else ref       					);       			pos := pos2+1;       			end;       		end;              	//:setRun(oldRun);       	if not pview 	// !!!k       	then :setGauge("",nil,slen);       	queue;       	end,     GetNamedResource:       func(src, ARRAY nameSlots, ARRAY fields) // see Newt version?       begin       	local sstart, pos, soup, soups, ixs, resourceSymbol, entry, cursor, nameSlot;       	if (if kNIE then IsString(src) else isInstance(src, 'string)) and       		StrLen(src) > 0       		and (sstart := if src[0]=$/ then 1 else 0)       		and (pos := if kNIE then CharPos(src,$/,sstart) else StrPos(src,"/",sstart))       		and (soup := GetUnionSoup(SubStr(src,sstart,pos-sstart)))       		and (soups := if kNIE       				then soup:GetSoupList()       				else soup.soupList)		// undocumented              		and (ixs := soups[0]:getIndexes())        	then foreach nameSlot in nameSlots       		do if (entry :=						// only if it has an index (nameSlot)       				if kNIE       				then LFetch(ixs, nameSlot, 0, '|=|, 'path)       				else call kLFetch with (ixs, nameSlot, 0, Functions.|=|, 'path, nil))       			and ((resourceSymbol := entry.type='symbol) or entry.type='string) // nameSlot a symbol or string?       			then break cursor := if kNIE       				then begin gc(); soup:Query({type: 'index, indexPath: nameSlot}); end       				else Query(soup, {type: 'index, indexPath: nameSlot});       		       	if cursor       	then begin       		local obj, field, key := SubStr(src,pos+1,nil); //StrMunger(src,0,pos+1,nil,0,nil)       		if (if resourceSymbol       			then ((entry := cursor:GoToKey(key := Intern(key))) and entry.(nameSlot)=key)       			else ((entry := cursor:GoToKey(key)) and StrEqual(entry.(nameSlot), key))       			)       		then foreach field in fields       			do  if (obj := entry.(field))       				then return       					if isInstance(obj, 'bitmap)       					then call kFixBitmap with (DeepClone(obj), nil, nil)       					else obj;       		end;       	NIL;       end,     getObj:       func(dict, tag, val)       begin       	local pr;              	if isFrame(tag)       	then begin       		pr := dict.(tag._tag);       		if isReadOnly(tag)       		then tag := Clone(tag);       		end       	else begin	// symbol       		pr := dict.(tag);       		tag := {_tag: tag};       		end;              	if pr       	then begin       		tag._parent := NewtsCape; //currentPage;       		tag._proto	:= pr;       		if val       		then tag._value := val;       		tag;       		end;       end,     viewClickScript:       func(unit) // 1.x       self=NewtsCape       and ABS(GetPoint(firstY, unit) - :GlobalBox().top) <= kDragRadius       and ABS(GetPoint(firstX, unit) - :GlobalBox().left - ((viewBounds.right - viewBounds.left) div 2)) <= kDragRadius       and :Drag(unit,nil),     AddBookmark:       func(btitle, url /*, edata*/) // called by bookmarkButton or bookmarksButton, HTMList       begin       	local inited := prefsEntry and Length(prefsEntry) > 0;	// !!!j,i       	if not inited       	then :Init(nil);       	local addEntries :=       		if IsArray(btitle)       		then btitle       		else if StrFilled(url)			// !!!i       		then [{name: btitle, URL: url}];// !!!e              	if IsArray(addEntries) and Length(addEntries) > 0 and bookmarks			// !!!j,i       	then begin       		local bookmarkSoup := GetUnionSoupAlways(bookmarks);	// !!!j              		local store :=	// !!!j       			if IsString(optionsAPI.BookmarkStore)	// !!!j       			then LFetch(GetStores(),optionsAPI.BookmarkStore,0,'|str=|,'name);       		if not store       		then store := GetDefaultStore();              		gc();       		local cursor := bookmarkSoup:?Query(nil), entry, addEntry;              		foreach addEntry in addEntries // !!!e       		do begin       			if IsEntryAlias(addEntry)	// !!!f       			then addEntry := EntryFromObj(addEntry);	// in case alias       			url := addEntry.URL;       			btitle := addEntry.name;       			if not btitle       				//and addEntry.text       				//and not btitle := :matchHTMLtitle(addEntry, NIL, nil, kTitleStart, kTitleStop, nil) // e.g., HTML Cache	       			then if btitle := call kGetTitle with (addEntry.text)	// !!!k       				then :fixString(btitle,nil)       				else btitle := url;       			// preserve labels except if not present in Bookmarks??              			entry := cursor:?reset();       			while entry and not StrEqual(url, entry.URL)	//call kCacheEqual(url, entry.URL, edata, entry.edata)       			do entry := cursor:next();              			if entry       			then begin       				entry.sortOn := $: & (entry.name := btitle);       				entry.labels := nil;       				EntryFlushXmit(entry, nil);		// !!!j       				end              			else bookmarkSoup:AddToStoreFlushedXmit(	// !!!j. AddToDefaultStoreXmit       				// format compatible with Shuffler       				// http://lthmtek.msek.lth.se/~cim93hf4/ShuffAPI.htm       				{name: btitle,		// string (ix)       				URL: url,			// string       				//edata: edata,		// string       				labels: nil,		// symbol (or nil=Unfiled)       				type: 'http,		// symbol (ix)       				created: Time(),	// int       				//modified: Time(),	// int       				valid: NIL,			// int       				sortOn: $: & btitle,// string (ix).  labels:name       				}, store, nil);       			end;       		end;       	if not inited	// !!!i       	then :quit();       end,     hrefScriptG:       kGoToHREFclickShare	// non-standalone       ,     exbook: nil,     lastH: nil,     getRun:       DefineGlobalConstant('kFontNames, 	'[ // redundant with fontNames ?       	{item: "Geneva", 	family: geneva},	//Simple       	{item: "New York", 	family: newYork},	//Fancy       	{item: "Espy", 		family: espy},		//System	// !!!j (was just names)       	]);       DefineGlobalConstant('kSYFontNames, '["Verdana", "Chicago", "Espy"]); // to Espy/System. !!!d1       DefineGlobalConstant('kSSFontNames, '["Arial", "Helvetica", "Geneva", "Sans-Serif", "Sans Serif", "Impact"]); // to Simple. !!!d1,f       DefineGlobalConstant('kFFFontNames, '["Times", "New York", "Palatino", "Georgia"]); // to Fancy. !!!d1,u       DefineGlobalConstant('kHWFontNames, '["Comic Sans", "Handwriting"]); // to Casual. !!!d1       DefineGlobalConstant('kTTFontNames, '["Courier", "Monaco", "Terminal", "Andale", "Trebuchet", "Typewriter"]); // to TT/PRE  !!!d1,f              DefineGlobalConstant('kHtags, '[H6,H5,H4,H3,H2,H1,_H0]);                     func (ARRAY val, pfont)       begin       //Print('getRun); Print(tag); Print(val);       	local ptext := kBigStringObj:new(Clone("")), ptext1, tmp, tag1, obj1, href, aname, src, entry, fontNames; // !!!j       	local INT i, hlen := 0, tlen, ilast := Length(val);	//plen := 0,        	local INT styleLen := 0, hrefLen := 0, nextFlush;       	local ARRAY styles := Array(ilast, NIL), hrefs := Array(ilast, NIL), attrib;       	local pfamily	:= call kGetFontFamily with (pfont), pfamily1, color;       	local pface	  	:= if kNIE then GetFontFace(pfont) else call kGetFontFace with (pfont), pface1, sizeinc;       	local INT psize := if kNIE then GetFontSize(pfont) else call kGetFontSize with (pfont), psize1, bsize;       	local curStyle 	:= pfont;	// was :addStyle(pfont) -- already done in P.get_data              	if not kStyleMeasure	// !!!m       	then begin       		local anyBold;       		local INT maxHeight := FontHeight(self.maxFont := curStyle);       		end;              	for i := 0 to (ilast := ilast-2) by 2       	do if (	(if kNIE       			then IsString(ptext1 := val[i+1])       			else isInstance(ptext1 := val[i+1], 'string)) and              			((tlen := StrLen(ptext1)) > 0) /* or       			((attrib := if kNIE	// allow 0 length A NAME. (test like findStyle)       				then LFetch  (val[i], 'A, 0, '|=|, '_tag)       				else call kLFetch with (val[i], 'A, 0, Functions.|=|, '_tag, nil)       				)       			and attrib.NAME and not aname := attrib.NAME) // assign but skip branch!       			*/)       		or (isFrame(ptext1) and ptext1._tag = 'BR and (ptext1 := cr) and tlen := 1)       	then begin       		/*       		if kNIE and IsVBO(ptext1)	// e.g., from parse:AddContentItem (PRE)       		then if plen > 0       			then ptext := StrMunger(ptext1,0,0, ptext, 0, nextFlush := plen)       			else begin       				ptext := ptext1;       				nextFlush := tlen;       				end       		else StrMunger(ptext, plen, 0, ptext1, 0, tlen);       		plen := plen + tlen;       		*/              		ptext:append(ptext1, 0, tlen);	// !!!j       		val[i+1] := ptext1 := href := NIL;              		/*       		if kNIE and plen > kMinVBOlen       		then if not isVBO(ptext)       			then begin       				ptext := call kNewVBO with (nil, nil, ptext); // temporary VBO       				nextFlush := kVBOFlush;       				end       			else if (plen*2) >= nextFlush       			then begin       				ClearVBOCache(ptext);       				nextFlush := nextFlush + kVBOFlush;       				end;       		*/              		pfamily1:= pfamily;       		pface1 	:= pface;       		psize1	:= psize;       		bsize	:= baseFont;	// !!!e,d.              		foreach attrib in val[i]       		do if (tag1 := attrib._tag) <> 'P       			then begin       				if tag1 = 'A       				then begin       					if href := attrib.HREF       					then begin       //Print(attrib);       						tag1 := '[pathExpr: A, HREF];       						if attrib.SRC       						then src := attrib.SRC;	// graphic for ALT (assign to pdata later)       						end;       					if tmp := attrib.NAME       					then aname := tmp;       					end;              				obj1 := tagDict.(tag1);       //if tag1='FONT then Print(val[i]);       				if isInstance(tmp := obj1.family, 'symbol)		// e.g., TT -> PRE. !!!n. moved outside FACE       				then pfamily1 := call kGetFontFamily with (tagDict.(tmp).font)              				else if (tmp := GetSlot(attrib,'FACE)) //avoid inh. g. i.e., family       					and (fontNames or fontNames :=       							if StrFilled(optionsAPI.ignoreFontFace) then '[]	// !!!u       							else call kCollectFontNames with ()) // cache: System, Fancy, Simple, Casual       				then pfamily1 := // !!!u       					if (if kNIE	// !!!j       						then  (entry := LFetch (fontNames, tmp, 0, kStrContains, 'item))       							or entry := LFetch(kFontNames, tmp, 0, kStrContains, 'item)       						else  (entry := call kLFetch with (fontNames, tmp, 0, kStrContains, 'item, nil))       							or entry := call kLFetch with(kFontNames, tmp, 0, kStrContains, 'item, nil)       						)       					then entry.family              					else if (if kNIE	// !!!f,e       						then LSearch (kSSFontNames, tmp, 0, kStrContains, nil)       						else ArrayPos(kSSFontNames, tmp, 0, kStrContains)       						)       					then 'geneva	// !!!m,j,b.       		       					else if (if kNIE	// !!!u       						then LSearch (kFFFontNames, tmp, 0, kStrContains, nil)       						else ArrayPos(kFFFontNames, tmp, 0, kStrContains)       						)       					then 'newYork              					else if (if kNIE	// !!!d1       						then LSearch (kSYFontNames, tmp, 0, kStrContains, nil)       						else ArrayPos(kSYFontNames, tmp, 0, kStrContains)       						)       					then 'espy              					else if kNIE and Fonts.handwriting	// !!!d1       						 and LSearch (kHWFontNames, tmp, 0, kStrContains, nil)       					then 'handwriting              					else if (if kNIE       						then LSearch (kTTFontNames, tmp, 0, kStrContains, nil) and tmp := 'PRE	// !!!f       						else ArrayPos(kTTFontNames, tmp, 0, kStrContains) and tmp := 'PRE       						)       					then call kGetFontFamily with (tagDict.(tmp).font)       					       					else pfamily;	// !!!o              				if tmp := obj1.face       				then pface1 := BOR(pface1, tmp);              				// !!!d       				if sizeinc := obj1.size	// BIG/SMALL. already int       				then begin	// !!!r. adjust wrt to current tag (if H6-H1)       					if psize = psize1 and tmp := SetContains(kHtags, _tag)       					then bsize := tmp+1; // only change base 1st time (no size change yet) to allow cumulative <SMALL><SMALL>       					end       				else if tag1 = 'FONT       				then if StrFilled(tmp := attrib.|POINT-SIZE|) and tmp := StringToNumber(tmp)	// !!!e       					then psize1 := min(24, max(8, Floor(tmp)))       					else if StrFilled(tmp := attrib.SIZE) and       						(tmp[0]=$- or (tmp[0]=$+ and tmp:=SubStr(tmp,1,nil)) or bsize := 0) and 	// +/-.  remove + for compile. otherwise abs       						tmp := StringToNumber(tmp)       					then sizeinc := Floor(tmp);       				if sizeinc       				then begin       					bsize := min(7, max(1, bsize + sizeinc));       					psize1 := call kGetFontSize with (tagDict.(kHtags[bsize-1]).font)       					end;              				if tag1 = 'FONT and attrib.COLOR and StrEqual(attrib.COLOR, "#FFFFFF")       				then color := 32;	// hilite done via .look. to get grays, would have to create own text object       				end;              		if curStyle <> (tmp := if kNIE       			then MakeCompactFont(pfamily1, psize1, pface1)       			else call kSetFont with (pfont, pfamily1, pface1, psize1))       		then curStyle := :addStyle(tmp);              		if styleLen > 0 and curStyle = styles[styleLen-1]       		then styles[styleLen-2] := styles[styleLen-2] + tlen // extend same style run       		else if tlen > 0 and ilast > 0 // omit empty runs       		then begin // new style       			styles[styleLen] 	:= tlen; 		//AddArraySlot(styles, tlen);       			styles[styleLen+1]	:= curStyle;	//AddArraySlot(styles, curStyle);              			if not kStyleMeasure	// !!!m       			then begin       				if not anyBold and       					kFaceBold = (if kNIE then GetFontFace(curStyle) else call kGetFontFace with (curStyle))       				then anyBold := true;       				if maxHeight < tmp := FontHeight(curStyle) // !!!m       				then begin       					maxHeight := tmp;       					maxFont := curStyle;       					end;       				end;       			styleLen := styleLen + 2;       			end;              		if href       		then begin       			if hlen > 0       			then begin       				hrefs[hrefLen] := hlen; // AddArraySlot(hrefs, hlen);       				//AddArraySlot(hrefs, nil);       				hrefLen := hrefLen + 2;       				hlen := 0;       				end;       			if hrefLen > 0 and hrefs[hrefLen-1] and StrEqual(hrefs[hrefLen-1], href)       			then hrefs[hrefLen-2] := hrefs[hrefLen-2] + tlen       			else begin       				hrefs[hrefLen] 		:= tlen;	// AddArraySlot(hrefs, tlen);       				hrefs[hrefLen+1]	:= href;	// AddArraySlot(hrefs, href);       				hrefLen := hrefLen + 2;       				end;       			end       		else hlen := hlen + tlen;       		end;              	ptext := ptext:contents();	// !!!j       	local pdata :=       		if styleLen <= 2       		then 	{data: ptext,       				viewFont: if ilast < 0 then pfont else if ilast=0 then curStyle else styles[1]}       		else 	{data: ptext,        				styles: SetLength(styles, styleLen)};       	if aname then pdata.name := aname;       	if src then pdata.src := src;       	if color then pdata.look := color;              	if hrefLen > 0       	then begin       		if hlen>0       		then begin       			hrefs[hrefLen] := hlen; // AddArraySlot(hrefs, hlen);       			//AddArraySlot(hrefs, nil);       			hrefLen := hrefLen + 2;       			end;       		SetLength(hrefs, hrefLen);       		pdata.hrefs := hrefs;       		end;              	if not kStyleMeasure and anyBold	// !!!m       	then if isFrame(maxFont)       		then begin       			maxFont := Clone(maxFont);       			maxFont.face := Bor(maxFont.face, kFaceBold);       			end       		else maxFont := Bor(maxFont, tsBold);              	pdata;       end,     fixString:       DefineGlobalConstant('kHexMap, '[0,1,2,3,4,5,6,7,8,9,58,59,60,61,62,63,64,10,11,12,13,14,15]);       DefineGlobalConstant('ch0 , 	Ord($0));              /*       getroot().|newtscape:newtscape|:fixstring("abcde", nil)       getroot().|newtscape:newtscape|:fixstring("ab&amp;&gt;&lt;", nil)       getroot().|newtscape:newtscape|:fixstring("ab&amp &gt &lt", nil)       getroot().|newtscape:newtscape|:fixstring("ab&amp&gt&lt", nil)       getroot().|newtscape:newtscape|:fixstring("ab&#99;&#123def", nil)       getroot().|newtscape:newtscape|:fixstring("ab&#123 def", nil)       getroot().|newtscape:newtscape|:fixstring("ab%44%45xyz", nil)       getroot().|newtscape:newtscape|:fixstring("ab%44%45xyz", true)       getroot().|newtscape:newtscape|:fixstring("ab&#173&ldots&trade;&copy;xyz", nil)       */              func(obj, href) // obj is string       if (if kNIE then IsString(obj) else isInstance(obj,'string))       then begin       // substitute escape sequences, e.g., &amp; &#99;       // assumes ok to destructively modify str or array; no leading spaces; trailing spaces ok.       // return obj       //if kDebugHTTP then Print(obj);              	local spos, epos := 0, sub, entity, charCode, cpos, s1 := Clone("*");       	local INT slen, i;              	if href       	then begin       		if (slen := StrLen(obj)) > 1 and obj[0] = $' and obj[slen-1]=$'	// e.g., cnnfn.com       		then begin       			StrMunger(obj,slen-1,1, nil,0,nil);       			StrMunger(obj,0,1, nil,0,nil);       			end       		else if BeginsWith(obj, sub := "javascript:openwin(")	// !!!g       		then obj := call kScanAttribute with (obj, sub);       		TrimString(obj);	// !!!g       		end;              //Print(obj);       	while epos < slen := StrLen(obj)       	do begin       		spos := /*if href       			then call kStrPosAny with (obj,       					if kNIE then [$%, $&] else ["%", "&"], epos, true, kNIE)       			else*/ if kNIE then CharPos(obj, $&, epos) else StrPos(obj, "&", epos);              		if not spos or spos+1 >= slen       		then break; // !!!f. return obj              		entity := charCode := NIL;              		/*if href and obj[spos]=$%		// %AB       		then begin       			charCode :=       				kHexMap[Ord(Upcase(obj[spos+1]))-ch0]*16 +       				kHexMap[Ord(Upcase(obj[spos+2]))-ch0];       			epos := spos+2;       			end              		else*/ begin	// &#123, &amp;, &amp , & , &amp&amp       			epos := call kStrPosAny with (obj,       						if kNIE then [$;, $ , $&] else [";", " ", "&"], spos+1, true, kNIE);       			if obj[spos+1]=$#       			then begin // assume max of 3 digits. !!!g. default to 3 if no ;, but allow up to 4       				if (obj[spos+2] = $x or obj[spos+2] = $X) and epos // !!!g. hex. always 4 digits?       				then begin       					sub := 0;       					for i:=spos+3 to epos-1       					do sub := (sub*16) + kHexMap[Ord(Upcase(obj[i]))-ch0]; // CharPos(kHex,Upcase(obj[i]),0)       					charCode := Chr(sub);       					end       				else charCode := call kGetInt with (entity := SubStr(obj, spos+2, if epos and epos <= spos+7 then epos-(spos+2) else 3), nil); // !!!t. up to 5. !!!b. !!!g < spos+5              				if not epos       				then epos := spos+4	// &#nnn. assume only 3 if no ; ?       				else if obj[epos] <> $;	// reduce replace range (preserve sp, &)       				then epos := epos-1;       				end              			else begin       				entity := call kMyTrim with (obj, spos+1, epos);	// !!!e. TrimString(SubStr(obj, spos+1, if epos then epos-(spos+1))); // omit &,;,spaces       				// note: FindStringInArray ~3x LSearch(..., GetGlobalFn('StrExactCompare),..       				charCode :=       					if StrLen(entity)=0       					then $&       					else if cpos := FindStringInArray(kCharNames, entity) // lt, gt, quot,amp? case sensitive comparison       					then kCharCodes[cpos]       					else if cpos := FindStringInArray(kCharNames160, entity) // long, contiguous list of others        					then 160+cpos       					else if cpos := FindStringInArray(kCharSpecialNames,entity) // dots,space,greek?       					then kCharSpecialValues[cpos];       				if not epos       				then epos := slen       				else if obj[epos] <> $;	// reduce replace range (preserve sp, &)       				then epos := epos-1;       				end;       			end;              		if (if kNIE then IsCharacter(charCode) else isInstance(charCode,'char))       		then (sub := s1)[0] := charCode       		       		else if (if kNIE then IsString(charCode) else isInstance(charCode,'string))       		then sub := charCode              		else if not charCode       		then sub := $& & entity 	// unknown entity name              		else if charCode <= 0 or charCode > 255 // check "unused"??? (0-8, 11-12, 14-31, 127-159)       		then sub := "&#" & charCode // code out of range              		else       			// the character mapping corresponds almost exactly to unicode sequence.       			if charCode >= kCharExceptNames[0] and       				cpos := SetContains(kCharExceptNames,charCode)       		then begin       			sub := entity := kCharExceptValues[cpos];       			if (if kNIE then IsCharacter(entity) else isInstance(entity, 'char))       			then (sub := s1)[0] := entity;       			end       		else (sub := s1)[0] := CHR(charCode); 	// unicode char directly as string              		StrMunger(obj, spos, epos-spos+1, sub, 0, nil);       		epos := spos + StrLen(sub);       		end;              	if href       	then begin       		StrReplace(obj," ","+",nil);	// !!!a1. e.g., for palmzip files with spaces. general encode??       		if kNIE and IsArray(sub := GetSlot(self,'all_HREF))	// !!!g,f. for sharing. NIL in scan*; [] in startHTML       		then if href := LFetch(sub,obj,0,'|str=|,nil)       			then obj := href       			else AddArraySlot(sub, obj);       		end;       	obj;       	end       else obj,     dispatchfile:       DefineGlobalConstant('kAddFile, func(app, type, href, content, options)       begin       	if (if kNIE then IsSymbol(app) else isInstance(app,'symbol))       	then app := call kFindApp with (app); // lookup. possibly thaw              	/*local newtscape;       	if options.noStatus       		and (newtscape := GetRoot().(kAppSymbol))       		and not call kViewIsOpenFunc with(newtscape)       	then begin       		newtscape:quit();       		newtscape.optionsAPI := {};       		end;*/              	app:?addFile(type, href, content, options);       end);                     func(type, href, content, options)       begin       // {... |type/subtype|: [ [".ext1", ".ext2"], 'appSymOrFrame ], ],              /*       if content=nil, return any(first) helperApp       otherwise, try app(s) in the following order:       - options.helperApp (if present)       - installed helperApp(s)       - Newt's Cape              helperApp is called with :addFile. returns TRUE if handled.       */       	options := :Init(options);       if kDebugHTTP then begin Write("dispatchFile: "); Print(options); end;              	local helperApp := options.helperApp;       	if helperApp and       		(not content or call kAddFile with (helperApp, type, href, content, options))       	then return helperApp;              	local helperApps := call kInitGlobal with ('helperApps, {}), helperFrame;       	local filename := if href then call kGetFileName with (href), sym, exts, mtype;       	foreach mtype in [type, call kSubStr with (type,0,"/",nil) & "/*", kAllMediaType]	// !!!u. e.g., application/*, */*       	do if isFrame(helperFrame := helperApps.(Intern(mtype)))// some apps installed?       	   then foreach sym,helperApp in helperFrame			// see :installHelperApp       			do if not (exts := helperApp.extensions)		// all?       				or (filename and if kNIE					// match specific ext? !!!h       						then LSearch (exts, filename, 0, GetGlobalFn('EndsWith), nil)       						else ArrayPos(exts, filename, 0, Functions.EndsWith))       				then begin       					if not HasSlot(options, 'transferMode)       					then options.transferMode := helperApp.transferMode;	// maybe 'binary or 'text override       					if not HasVariable(helperApp,'addFile)       					then helperApp := sym;       					if not content or       						call kAddFile with (helperApp, mtype, href, content, options)       					then return helperApp;       					end;              	// default to Newt's Cape for these       	if  BeginsWith(type,kHTMLMediaType) or       		StrEqual(type,kTextMediaType) or       		StrEqual(type,kGIFMediaType) or       		StrEqual(type,kNewtonPkgMediaType)       	then if not content       			or :addFile(type, href, content, options)       		then return kAppSymbol;              	if content       	then :Notify(kNotifyAlert, kAppName, type & $: && kNoHelper && href)       	else NIL;       end,     libook: nil,     Bookmarks: nil,     frameHeading:       func(str)	// !!!i       if StrFilled(str) and tagDictOrig.(str := Intern(str))       then str       else 'H1,     nos20: nil,     Inbox_Titles: nil,     GetPictAsBits:       func(src)       if src       then begin       	local entry;              	if entry := :getPictObj(src,nil)		// direct bitmap or unconverted GIF       	then return entry;              	TrimString(src := Clone(src));       	if BeginsWith(src, "./")       	then StrMunger(src, 0, 2, nil, 0, nil);              	local bdata := if curBook then curBook.(kDataPath);       	entry := if bdata then bdata.(Intern(src));  // in :BookData()       	if (if kNIE then IsString(entry) else isInstance(entry,'string))       	then entry := bdata.(Intern(src := entry));              	if entry and entry := :getPictObj(entry,nil)       	then entry              	else if kNIE and bdata and cacheImages and       		entry := :getPictObj(call kGetURLCache with (       			cacheImages, :ResolveURL(curBook.(kBasePath), src), 'bitmap, NIL, prefsEntry.ignoreImageExpiration), nil)       	then entry              	else Clone(:GetNamedResource(src, '[name, title], '[bitmap, icon]));       	end,     NewtPack: nil,     processOption:       kProcessDefault // set in optionsButton       ,     viewShowScript:       func()	// !!!f       begin       	if kNIE and newtscape.hideObj       	then begin       		GetRoot().notifyIcon:?KillAction(hideObj);	// !!!g       		hideObj := NIL;								// !!!g       		end;       	SetKeyView(URLpara, StrLen(URLpara.text));	// !!!g       	inherited:?viewShowScript();       end,     soupChanged:       func(soupName)       begin       	//print(soupName);       	self.(Intern(soupName & kTitles)) := NIL; // uncache Notes, Inbox, HTMLCache, ImageCache       end,     tagDictOrig:       constant kScrollBottom := 20000;	// for TEXTAREA              DefineGlobalConstant('kRomanFunc, func(INT n, upper)		// !!!e. OL/LI       begin       	local lets := if upper       		then "MDCLXVI" 	//'[  $M,  $D,  $C, $L, $X, $V, $I]	// !!!a1       		else "mdclxvi";	//'[  $m,  $d,  $c, $l, $x, $v, $i];       	local ARRAY nums :=       			 '[1000, 500, 100, 50, 10,  5,  1];       	local INT i, j, curUnit, diff, numsLen := Length(nums);       	local str := "", curLet;       	for i:=0 to numsLen-1       	do begin       		curUnit := nums[i];       		curLet := lets[i];       		for j:=1 to n div curUnit       		do str := str & curLet;       		n := n mod curUnit;       		if n = 0       		then break;              		for j := numsLen-1 to i+1 by -1       		do  if n >= (diff := curUnit - nums[j])       			then begin       				if diff = nums[j] then break;       				str := str & lets[j] & curLet;	// e.g., IV       				break n := n - diff;       				end;       		end;       	str;       end);                     DefineGlobalConstant('kLetterFunc, func(INT n, INT upper)		// !!!e. OL/LI       begin       	local str := "";       	while n > 0       	do begin       		n := n-1;       		str := Chr(upper + (n mod 26)) & str;       		n := n div 26;       		end;       	str;       end);              DefineGlobalConstant('kAddFrames, func(options, msg, ARRAY newIncludes)	// !!!g       begin       	// assume FRAMESET and IFRAME aren't mixed in same doc; but maybe multiple IFRAME?       	local oldIncludes;       	options.start := kBodyStart;       	options.frameStart := true;       	options.callbackFn := kProcessNextCallback;       	if IsArray(oldIncludes := options.processParams) and isArray(oldIncludes := oldIncludes[0])       	then ArrayMunger(oldIncludes,Length(oldIncludes),0, newIncludes,0,nil)       	else options.processParams := [newIncludes];       	options.processMsg := msg;       end);                     {// fix any _proto: ' in afterScript              /*	// different uses of "data"       _data:		// ready for book       get_data:	// create/check _data [may be called again if split]              data:		// proto for form object       initData:	// init data       {data:..}	// for book (usually _data: {data:..})              GetData:	// for form object lookup of values              book.data	// user defined meta data. slots/methods, form_hidden, etc.              ----              uses of "value"              _value		// initial object value              VALUE		// form object value              */                     HTML: {       	get_data: func()       	if _value       	then begin       		//:newBook();       		// just in case no BASE,TITLE,HEAD,BODY tag?       		if optionsAPI.base       		then curBook.(kBasePath) := optionsAPI.base;       		optionsAPI.base := nil;       		end       	else begin       		if Length(includes) > 0 then :?fixHREFs();       		if not kNIE then :disconnect(nil);	// was always (true)       		NIL;       		end,       	},                     |!DOCTYPE|: 'HTML,                     TITLE: {       	get_data: func()       	begin       		if isArray(_value) then _value := _value[1];       		if (if kNIE then IsString(_value) else isInstance(_value, 'string)) and StrFilled(_value) // !!!a1       		then begin       			curBook.TITLE := _value;       			if not curBook.help       			then begin       // note: assuming there were a way to specify COLOR(invert) via i:Appearance       // there doesn't seem to be a way to set title obj (viewFormat: 5, viewTransferMode: 3) directly       				if font <> 0x00102402 	// font <> tagDictOrig.TITLE.font       				then curBook.(kDataPath).titleFormat.viewFont := Clone(font);	// !!!c1       				if kBuild20 and align <> 2			// align <> tagDictOrig.TITLE.align       				then curBook.(kDataPath).titleFormat.viewJustify := 48+align;       				local INT ht := :SimpleTextHeight(_value, rootContainer:getWidth(), font) - rootContainer.top; // !!!a1,g. offset for original estimate       				currentContainer:addTop(ht);	// !!!g. was setTop. avoid problem if TITLE occurs after BODY, but only if title single line (to replace earlier Untitled)       				rootContainer:addTop(ht);		// !!!g       				end;              			// some docs don't have </HEAD> (also :addImage)       			:getObj(tagDict, kTagBODY, true):get_data(); 	// just to update BASE, status       			end       		// else NIL;       	end,       	font: 0x00102402,       	ALIGN: 2,			// center       	},              // these are standard OEB properties       /* also: MANIFEST, SPINE, ITEM, ITEMREF, TOUR, GUIDE, REFERENCE ??       |dc:Title|: 'TITLE,              |dc:Creator|: {       	bookSlot: 'Author,       	get_data: func()       	begin       		if isArray(_value) then _value := _value[1];       		if (if kNIE then IsString(_value) else isInstance(_value, 'string))       		then curBook.(bookSlot) := _value;       		// else NIL;       	end,       	},       |dc:Identifier|: {       	_proto: '|dc:Creator|,       	bookSlot: 'ISBN,       	},       |dc:Publisher|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Publisher,       	},       |dc:Rights|: {       	_proto: '|dc:Creator|,       	bookSlot: 'copyright,       	},       |dc:Date|: {       	get_data: func()       	begin       		if isArray(_value) then _value := _value[1];       		if IsString(_value)       		then curBook.publicationDate := call kReadDate with (_value);       		// else NIL;       	end,       	},              // these are extra OEB properties       |dc:Description|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Description,       	},       |dc:Type|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Type,       	},       |dc:Format|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Format,       	},       |dc:Source|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Source,       	},       |dc:Language|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Language,       	},       |dc:Relation|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Relation,       	},       |dc:Coverage|: {       	_proto: '|dc:Creator|,       	bookSlot: 'Coverage,       	},       */              META: {       	NAME:	nil,       	CONTENT: nil,              	get_data: func()       	if _value       	then begin       		local attrib := NAME, sym, prop := CONTENT;	// is VALUE common?       		if (attrib or attrib := self.|HTTP-EQUIV|) and prop       		then if StrEqual(attrib,"TITLE")	// !!!b1       			then return :getObj(tagDict, 'TITLE, prop):get_data()	// measure height etc.              			else if sym := call kSubStr with (attrib, "data.", nil, true)       			then begin       				//attrib := [pathExpr: 'data, Intern(sym)];       				//prop := :compileVal(prop); // slot or method       				if optionsAPI.allowCompile = 'compile       				then curBook.(kDataPath).(Intern(sym)) := :compileVal(prop);       				end              			else if sym := call kSubStr with (attrib, "pref.", nil, true)       			then begin       				attrib := Intern(sym);       				prop := :compileVal(prop);       				local dict := tagDict;       				if  (HasSlot(tagDictOrig, attrib) or       					(HasSlot(inputDictOrig, attrib) and dict := inputDict))       				then begin       					// moved here. otherwise, if error in frame, :setPreference(...,nil)!       					if isFrame(prop) 	// prop=nil if not 'compile       					then begin        						prop._proto := dict.(attrib); // default or current user settings       						dict.(attrib) := prop;       						end       					end       				else if optionsAPI.allowCompile = 'compile	// other prefs       				then :setPreference(attrib, prop); 		//:PRINT("UNRECOGNIZED PREF" && attrib);       				end              			else if (sym := call kSubStr with (attrib, "scripts.", nil, true)) // bookOKClose, bookHideScript, bookShowScript       				and (prop := :compileVal(prop))	//  prop=nil if not 'compile       				and if kNIE       					then IsFunction(prop)       					else (isInstance(prop, '_function) or isInstance(prop, 'CodeBlock))       			then begin       				local ARRAY scripts := curBook.(kScriptsPath);       				AddArraySlot(scripts, Intern(sym));       				AddArraySlot(scripts, prop);       				end              			else if (sym := call kSubStr with (attrib, "package.", nil, true)) or       					(sym := call kSubStr with (attrib, "_package.", nil, true))       			then curBook._package.(Intern(sym)) := :compileVal(prop)	// nil if not 'compile              			else begin       				attrib := Intern(attrib);       				if attrib='ISBN and prop       				then prop := call kMaxString with (prop, kMaxISBN);              				else if attrib='APPSYMBOL       				then prop := Intern(prop)              				else if attrib='PUBLICATIONDATE       				then prop := :compileVal(prop)		//nil if not 'compile       /*       					begin       					prop := :compileVal(prop);		//nil if not 'compile       					if (if kNIE then IsString(prop) else isInstance(prop, 'string))	// ?       					then prop := StringToDate(prop);       					end       */       				else if SetContains(	// ignore copperfield/Newt's Cape(_package) specific slots       					'[version, flags, data, styles, contents, browsers, templates, rendering, _package], attrib)       				then prop := nil              				else if attrib='ICON       				then prop := :GetPICTasBits(prop)              				else if attrib='htmlApp // switch to another viewer       					and isFrame(prop := :compileVal(prop))	//nil if not 'compile       				then begin       					if not HasVariable(prop, 'addHTMLitem)              				then prop.addHTMLitem := kAddHTMLitem;       					parseJob.htmlApp := prop;	// won't do anything for kCparser       					return prop:addHTMLitem(kTagHTML,nil);       					end;              				// otherwise string       				if prop       				then curBook.(attrib) := prop;              				if prop and attrib = 'NewtonRefresh       				then :disconnect(true);       				end       		else :error('META, attrib);       		NIL;       		end,       	},                     HEAD: {       /*	get_data: func() // in case !DOCTYPE but no HTML       	if not _value       	then begin       		if Length(includes) > 0 then :?addIncludes();       		:getObj(tagDict, kTagBODY, true):get_data();	// update status       		end,       	// else NIL       */       	_proto: kprotoContainer,	// !!!a1        	get_data: func()       	begin       		inherited:get_data();	// add/remove container       		if not _value       		then begin       			if Length(includes) > 0 then :?addIncludes();       			:getObj(tagDict, kTagBODY, true):get_data();	// update status       			end;       		NIL;       	end,              	addItem: func(obj)	// ignore all contents except specific tags       	if SetContains('[HEAD,TITLE,META,LINK,BASE,ISINDEX,SCRIPT,OBJECT], obj._tag)       	then inherited:addItem(obj),       	//else NIL       	},              BASE: {       	HREF: nil,              	get_data: func()       	begin       		if HREF       		then :displayURL(curBook.(kBasePath) := HREF);       		NIL;       	end,       	},                     BASEFONT: {	// !!!e       	get_data: func()       	begin       		if self.SIZE       		then newtscape.baseFont := call kGetInt with (SIZE, 3);       		NIL;       	end,       	},                     ISINDEX: {	// !!!b       	HREF: nil,       	PROMPT: "Keywords",       	get_data: func()       	begin       		:addHTMLitem({_tag: 'FORM, _value: true, ACTION: call kGetStr with (HREF, curBook.(kBasePath))}, nil);       		:addHTMLitem({_tag: 'P, _value: [       			kATagP, PROMPT,       			kATagP, {_tag: 'INPUT, NAME: ""},       			kATagP, {_tag: 'INPUT, TYPE: "SUBMIT", VALUE: "Search"},       			]}, nil);       		:addHTMLitem({_tag: 'FORM, _value: nil}, nil);       	end,       	},              LINK: {       	HREF: nil,       	REL: "none",              	get_data: func()       	begin       		if HREF       		then if StrEqual(REL, "INCLUDE")       			then AddArraySlot(includes, HREF)       			else AddArraySlot(curBook.(kLinkPath), {item: REL, value: HREF});       		NIL;       	end,       	},                     BODY: {// to share code, and in case doc starts with BODY (no HTML,TITLE)       	get_data: func()       	if _value       	then begin       		local bhref := optionsAPI.base;       		if StrFilled(bhref)       		then curBook.(kBasePath) := bhref       		else bhref := curBook.(kBasePath);       		optionsAPI.base := nil;              		local filename := if bhref then call kGetFileName with (bhref);       		local title := curBook.TITLE;       		if not StrFilled(filename)       		then filename := title;              		if isReadonly(title) and bhref       		then :getObj(tagDict, 'TITLE, title := filename):get_data(); // !!!b1. measure ht etc. curBook.TITLE := title := filename;              		if isReadOnly(curBook.ISBN) 		// default?       		then curBook.ISBN := call kMaxString with (filename, kMaxISBN);              		if isReadOnly(curBook.SHORTTITLE) 	// default?       		then curBook.SHORTTITLE := call kMaxString with (title, if kBuild20 then 18 else 9);              		if not StrFilled(bhref)       		then :displayURL(curBook.ISBN);              		NIL;       		end,       	},                     FORM:	{       	METHOD:	kDefaultMethod,       	ACTION: kUnkURL,              	get_data: func()       	if _value       	then begin       		formAttributes := self;		// save for input objects (esp. ACTION)       		lastSelect := NIL;	// lastRadio :=        		local isbn := curBook.isbn, bhref := curBook.(kBasePath);       		if not HasSlot(self,'ACTION)       		then self.ACTION := if bhref then bhref else isbn;       		ACTION := (actionNum := actionNum+1) & $_ & ACTION;	// for uniqueness       		local iaction := Intern(ACTION);       		curBook.(kFHiddenPath).(iaction) := {};       		curBook.(kFPrintPath).(iaction) := [];       		call kInitGlobal with (Intern(isbn),{}).(iaction) := {};       		NIL;       		end              	else if formAttributes       	then begin       		RemoveSlot(       			call kInitGlobal with (Intern(curBook.isbn),{}),       			Intern(formAttributes.ACTION));       		formAttributes := lastSelect := NIL;	// lastRadio :=        		end,       	},              _H0: {	// !!!d. for FONT SIZE=7       	font: tsBold + (24 << tsSizeShift),       	},              // HEADINGS       H1: { // pp. 22-23       	_proto: 'P,       	font: 	tsBold + (18 << tsSizeShift), //0x00104800  18B. {family: 'espy, face: kFaceBold, size: 18}       	above: 	6, //'Top,       // below: 	3,       	level:	1,       	split: nil,       	missing: "", // kMissing,       	       	get_data: func()       	if _data       	then self       	else if lastH+1 < level       	then begin	// fill in missing levels       		local INT h;       		local ARRAY hxs := [];       		local hs, hobj;       		for h := lastH+1 to level-1       		do begin	       			lastH := level; // prevent problem for multiple missing levels?       			hs := $H & h;       			hobj := :getObj(tagDict, Intern(hs), nil);       			hobj._value := ParamStr(hobj.missing, [hs]);       			AddArraySlot(hxs, hobj:get_data());       			end;       		lastH := level;       		call kAppendObj with (hxs, inherited:get_data()); // return array of Hx objects					       		end       	else begin       		lastH := level;       		inherited:get_data();	// return just this (single) Hx object       		end,       	},                     H2: {       	_proto: 'H1,       	font:	tsBold + (14 << tsSizeShift),       	above:	6,       // below:	3,       	level:	2,       	},                     H3: {       	_proto: 'H1,       	font:	tsBold + (12 << tsSizeShift),       	above:	6,       // below:	3,       	level: 	3,       	},                     H4: {       	_proto: 'H1,       	font:	tsBold + (10 << tsSizeShift),          above:	4,       // below:	3,       	level:	4,       	},                     H5: {       	_proto: 'H1,       	font:	tsBold + (9 << tsSizeShift),       	above:	3,       //	below:	3,       	level:	5,       	},                     H6: {       	_proto: 'H1,       	font:	tsBold + (9 << tsSizeShift),	// !!!e. 8?  !!!d. tsItalic + (9 <<       	above: 	3,       //	below:	3,       	level:	6,       	},                     // BLOCKS       P: {       	font:		0x00002801, // 10P. {family: 'newYork, face: kFaceNormal, size: 10}       	face:		kFaceNormal, // in case this gets used as a "phrase"       	above: 		3, // 'top for H1       	below: 		3,       	indent: 	0,       	indentR:	0,       	prefix: 	NIL,	// LI       	maxFont: 	NIL,	// set in :getRun       	height: 	NIL,       	width:		NIL,       	level:		NIL,	// Hx       	noRefresh: 	NIL,	// SELECT       	split: 		true,	// in general       	ALIGN: 		0,	// ""       	dataOffset: 0,       	_data:		NIL,              	getWidth: 	func(dproto)       		width := currentContainer:getWidth() - indent - indentR,	// !!!a1 (for BLOCKQUOTE, formObj)              	fixAttribute: 	kProtoContainer.fixAttribute,       	renderObj:		kProtoContainer.renderObj,              	getAlign:	func()	// render time       	begin       		if kNIE       		then (if IsString(ALIGN)       			then return LSearch(kAlign, ALIGN, 0, '|str=|, nil))       		else if isInstance(ALIGN, 'string)       			then return ArrayPos(kAlign, ALIGN, 0, Functions.StrEqual);       		if currentContainer.align <> 0       		then currentContainer.align       		else ALIGN;       	end,              	get_data: func()       	if _data       	then self       	else begin       		local pfont := :addStyle(font), val := self._value;       		local ARRAY objs := [];              		if (if kNIE then IsString(val) else isInstance(val,'string))       		then _data := {data: val, viewFont: pfont}              		else if isArray(val)       		then begin       			local INT i := 1, remove, vlen;       			local itag, ival, type, prop, lab, flush, obj, tmp;       			while i < (vlen := Length(val))       			do if isFrame(ival := val[i]) and       				ival._tag <> 'BR		// handle in :getRun       			then begin       				flush := remove := 2;	//flush := true       				lab := itag := tmp := nil;              				if ival._tag = 'INPUT or ival._tag = 'SELECT	// (treat SELECT as 'TEXT)       				then begin       					type := if ival.TYPE then Intern(ival.TYPE) else 'TEXT; // no obj yet              					if type = 'TEXT or type = 'PASSWORD       					then begin       						if i > 1       						 then begin       							itag := val[i-3];       							lab	 := val[i-2];	// don't auto decr now (e.g., BR)       							if isInstance(lab, 'string) and StrLen(lab) > 30	// prevent too long (unintended) label, esp. for SELECT?       							then lab := nil;       							end;       						end              					else if type = 'RADIO or type = 'CHECKBOX       					then begin       						if i+2 < vlen       						then begin       							itag := val[i+1];       							lab  := val[i+2];       							end;       						end              					else if type = 'HIDDEN       					then flush := NIL;              					//else if type = 'IMAGE or type = 'SUBMIT or type = 'RESET       					//then flush := true;              					if lab and ((if kNIE then IsString(lab) else isInstance(lab,'string)) or       						lab := if isFrame(lab) then lab.ALT)       					then begin       						if itag :=	// copy possible A HREF for TEXT/PASSWORD or RADIO/CHECKBOX       							if kNIE       							then LFetch(itag, nil, 0, GetGlobalFn('|<>|), 'HREF)       							else call kLFetch with (itag, nil, 0, Functions.|<>|, 'HREF, nil)       						then ival.HREF := itag.HREF;              						ival.LABEL := lab;       						if type = 'TEXT or type = 'PASSWORD       						then i := i-2;       						if i=1 or not val[i-3][0]._prefix       						then remove := 4       						else begin       							StrMunger(lab,0,0, val[i := i-2],0,nil);       							remove := 6;       							end;       						end;       					end              				else if ival._tag = 'IMG       /* new code for adding URL inline       				then if ival.USEMAP or (tmp := :GetPictAsBits(ival.SRC))       					then begin // an actual image       						if tmp then ival.SRC := tmp; // cache for use by IMG       						itag :=	// copy possible A info       							if kNIE       							then //LFetch(val[i-1], nil, 0, GetGlobalFn('|<>|), 'HREF)       								LFetch(val[i-1], 'A, 0, '|=|, '_tag)       							else //call kLFetch with (val[i-1], nil, 0, Functions.|<>|, 'HREF, nil)       								call kLFetch with (val[i-1], 'A, 0, Functions.|=|, '_tag, nil);       						if itag and prop := itag.HREF then ival.HREF := prop;       						if itag and prop := itag.NAME then ival.NAME := prop;       						end       					else begin       						val[i] := if ival.ALT then ival.ALT else "no ALT";	// permute into text       						// kludge text to be on separate line for now       						if i > 1 and       							(if kNIE then IsString(val[i-2]) else isInstance(val[i-2], 'string))	// beginning or prev string ?       						then val[i-2] := val[i-2] & unicodeCR;       						tmp := ival.SRC;       						ArrayMunger(val, i+1, 0,       							[kATagP, ". IMG: ",       							if tmp then [{_tag: 'A, HREF: tmp}] else kATagP,       							if tmp then tmp else "no SRC",       							kATagP, '{_tag: BR}],       							0,       							if i+2 < vlen and       								(if kNIE then IsString(val[i+2]) else isInstance(val[i+2], 'string))	// string next?       							then 6 else 4);              						remove := 0;       						flush := nil;       						end       */              				then begin       					itag :=	// get possible A info       						if kNIE       						then //LFetch(val[i-1], nil, 0, GetGlobalFn('|<>|), 'HREF)       							LFetch(val[i-1], 'A, 0, '|=|, '_tag)	// !!!d       						else //call kLFetch with (val[i-1], nil, 0, Functions.|<>|, 'HREF, nil);       							call kLFetch with (val[i-1], 'A, 0, Functions.|=|, '_tag, nil);	// !!!d       					if (ival.ALT or StrFilled(ival.ALT := optionsAPI.missingIMG))	// !!!j,i  "IMG: no ALT"       						and not ival.USEMAP       						and not tmp := :GetPictAsBits(ival.SRC)       					then begin       						val[i] := ival.ALT;	// permute into text       						// kludge text to be on separate line for now       						if i > 1 and       							(if kNIE then IsString(val[i-2]) else isInstance(val[i-2], 'string))	// beginning or prev string ?       						then val[i-2] := val[i-2] & unicodeCR;       						if i+2 < vlen and       							(if kNIE then IsString(val[i+2]) else isInstance(val[i+2], 'string))	// string next?       						then ArrayMunger(val, i+1, 0, [val[i+1], '{_tag: BR}], 0, nil);       						       						if not itag or not itag.HREF // !!!d. add fake link if necessary (unnec code for this in IMG?)       						then begin       							itag := {_tag: 'A, HREF: ival.SRC, NAME: if itag then itag.NAME};	// !!!d       							if val[i-1] = kATagP       							then val[i-1] := [itag]       							else AddArraySlot(val[i-1], itag);       							end;       						itag.SRC := ival.SRC;       						//if itag then itag.SRC := ival.SRC;	// for use in getRun       						remove := 0;       						flush := nil;       						end       					else begin       						if tmp       						then ival.SRC := tmp;	// cache       						if itag       						then begin       							ival.HREF := itag.HREF;       							if prop := itag.NAME       							then ival.NAME := prop;       							end;       						end;       					end       				else Print("P:" && LocObj("unknown val", 'unknownValErr) & $: && ival._tag);              				if flush and i > 1       				then begin       					obj := Clone(self);       					obj._data := NIL;       					obj._value := ArrayMunger([], 0, nil, val, 0, i-1);       					call kAppendObj with (objs, obj:get_data());       					remove := remove + i - 1;       //Print("flushing:" && i-1 & "; removing:" && remove);       					i := 1;       					end;              				if remove = 0       				then i := i+2       				else begin       					obj := :getObj(tagDict,ival,true);       					if level       					then obj.level := level;       					call kAppendObj with (objs, obj:get_data());       					if i+remove < vlen and       						isFrame(val[i+remove]) and val[i+remove]._tag = 'BR       					then remove := remove+2;       //Print("adding:" && type && lab & "; removing:" && remove);       					ArrayRemoveCount(val, i-1, remove);       					end;       				end       			else i := i+2;              			if vlen=0       			then return objs; // done              			_data := :getRun(val, pfont);	// combine this with loop above??       			if kStyleMeasure and _data.styles		// !!!m       			then pfont := _data.styles       			else if _data.viewFont       			then pfont := _data.viewFont       			else if not kStyleMeasure and maxFont	// !!!m       			then pfont := maxFont;       			end              		else return NIL; // true/nil structural tag?              		width	:= :getWidth(_data);       		height	:= //:SimpleTextHeight(_data.data, width, pfont);       			call kMySimpleHeightFunc with (_data.data, 0, if StrLen(_data.data) > 2*kScreenChars then kScreenChars, width, pfont); // !!!o              //Print(_data);       //Print(_data.data); Print(width); Print(pfont); Print(height);              		// LEFT, RIGHT, CENTER, JUSTIFY ?       		local al := :getAlign(); // int or string       		if al and al<>0 and (kBuild20 or not _data.hrefs)       		then _data.viewJustify := al;              		if Length(objs) > 0       		then SetAdd(objs, self, nil)	// !!!o       		else self;       	end,       	},                     PRE: {       	_proto: 'P, // fix in afterScript       	font: 	0x00002402, // {family: 'geneva, face: kFaceNormal, size: 9}       	},              XMP: 'PRE,		// share appearance pref?                     BLOCKQUOTE: {       	_proto: 'P, // fix in afterScript       	font: 0x00202800, // 10I. {family: 'espy, face: kFaceItalic, size: 10}       	indent: 10,       	indentR: 5,		// !!!b1       	//prefix: ">", 	//???       	},		              ADDRESS: {       	_proto: 'BLOCKQUOTE,	// !!!b1       	indent: 5,       	},              Q: 'BLOCKQUOTE,		// !!!w.  actually should be a phrase emphasis?                     UL: {       	_proto: kprotoContainer,       	//above: 	1,       	indent: 8,       	prefix: "\u2022", // bullet char       	COMPACT: nil,              	get_data: func()       	// add/remove item from page stack to affect prefix, above/below, etc.       	begin       		if _value and COMPACT       		then above := below := 0;       		inherited:get_data();	// do container thing       	end,       	},                     OL: {       	_proto: 'UL,       	prefix: 0, 		// numbered sequence       	START: 	nil,	// !!!e       	TYPE: 	"1",	// !!!e. numeric default              	get_data: func()// !!!e       	// add/remove item from page stack to affect prefix, above/below, etc.       	begin       		if _value and START       		then prefix := call kGetInt with (START,1) -1;       		inherited:get_data();	// do container thing       	end,       	},                     DIR: {       	_proto: 'UL,       	prefix: ">",        	// columns: true, // should do something with x or width ???       	},                     MENU: {       	_proto: 'UL,       	prefix: "-",       	above: 0, // "more compact"       	below: 0,       	},                     DL: {       	_proto: 'UL,       	prefix: "",       	},                     LI: {       	_proto:	'P,       	above: 1,       	below: 1,       	//above: NIL, // use value set by OL,UL, etc. ???       	//below: NIL,       	split: 'P,       	heading: nil,       	VALUE: NIL,	// !!!e              	get_data: func() // #?       	if _data       	then self              	else if isArray(_value) and Length(_value) > 0 and _value[0][0]._prefix	// avoid mult prefixes       	then inherited:get_data()              	else if _value       	then begin       		// add a prefix (¥, 1) to an item, typically LI       		local addprefix := currentContainer.prefix, val;       		if (if kNIE then IsInteger(addprefix) else isInstance(addprefix, 'int)) and not heading       		then begin       			currentContainer.prefix := addprefix := if VALUE then call kGetInt with (VALUE,addprefix+1) else addprefix+1;	// !!!e. reset or incr #. 1,2,3       			val := currentContainer.TYPE[0];	// !!!e. 1,a,A,i,I;       			addprefix := (       				if val=$A or val=$a			// alphabetic       				then call kLetterFunc with (addprefix, Ord(val))       				else if val=$I or val=$i	// Roman numerals       				then call kRomanFunc with (addprefix, val=$I)       				else //if val=$1 then		// numeric       					addprefix       				) & $.;       			end;              		indent := currentContainer.indent;              // somewhere fix so that TEXT, RADIO prefixes work (though CHECKBOX already does!)???              		if not heading and StrFilled(addprefix)  // !!!e. addprefix and StrLen(addprefix) > 0       		then if (if kNIE then IsString(_value) else isInstance(_value, 'string))       			then _value := addprefix && _value       			else if isArray(_value)       			then /*if Length(_value) >=2 and isInstance(val := _value[1], 'string)       				then _value[1] := addPrefix && val              				else if and isFrame(val := _value[1]) and       						val._tag = 'INPUT and val.TYPE and (StrEqual(val.TYPE, "RADIO") or StrEqual(val.TYPE, "CHECKBOX"))       						and isInstance(val := _value[3], 'string)       				then _value[3] := addPrefix && val              				else*/       				 ArrayMunger(_value,0,0, [[{_tag: 'P, _prefix: true}], addprefix && nil],0,nil); // insert prefix w/ sp as separate object in default font       				// maybe prepend directly onto existing string or ALT (or does getRun do right thing) ???       		inherited:get_data();       		end,       	},                     LH:	{	// !!!e       	_proto: 'LI,	// for bold       	font: kEspy10B, // like DT {family: 'espy, face: kFaceBold, size: 10}       	heading: true,	// no prefix       	},              DT: {       	_proto: 'LI,       	font: kEspy10B, // {family: 'espy, face: kFaceBold, size: 10}       	above: 4,       	below: 0,       	},                     DD: {       	_proto: 'LI,       	above: 0,       	below: 4,       	},              TABLE: {       	_proto: kprotoContainer,       	above: 3,       	below: 3,       	BORDER: nil,       	width: nil,       	//_tableLevel: 1,	// + for <TABLE>, - for </TABLE>       	widths: NIL,		// array of widths       	lastRowSpan:	nil,              	addItem: func(obj)	// override default container def.       	begin       		local tag := obj._tag, val := obj._value;       //if kDebugHTTP then Print("TABLE:" && tag && if val then "start" else "stop");       		if tag = 'TR or tag = 'CAPTION       		then begin       			if val       			then begin       				if tag = 'CAPTION       				then return inherited:addItem(obj);	// add immediately       				_contents := [obj];	// keep only single row.  AddArraySlot(_contents, obj);       				obj:get_data();		// setup row container       				end       			//else ignore </TR>?       			end              		else if tag = 'TABLE // and not val       		then begin       			// end current table. (maybe) start a new one       			_value := NIL;       			:get_data();	// end this table       			if val       			then currentContainer:addItem(obj);	// start a new one       			end              		else if val       		then begin // shouldn't happen normally...       			:addItem(:getObj(tagDict, 'TR, true));	// (always) add implicit TR       			if kDebugHTTP and tag <> 'TD and tag <> 'TH       			then Print("TABLE: unexpected tag:" && tag);       			currentContainer:addItem(obj);			// add to row (if not TD/TH, TR creates)       /*       			if tag = 'TD or tag = 'TH		// ignore </TD>, </TH>, others       			then begin       //Print(currentContainer._tag);       				:addItem(:getObj(tagDict, 'TR, true));	// add implicit TR       //Print(currentContainer._tag);       				currentContainer:addItem(obj);			// add to that       				end;       */       			end;       	end,              	getWidths: func(ARRAY cells)       	begin       		border := if border=true then 1 else min(1, :fixAttribute(border, 'int, 0)); // max 1 for now              		local INT ncols := 0, cols, col, i := 0, cellwid, colwid;       		local INT containerWidth := :getWidth();       		local INT availWidth := :fixWidth(width, containerWidth, containerWidth);       		local INT origWidth := availWidth, sumWidth := 0;       		local cell;              		// ncols = total number of columns (including colspan)       		foreach cell in cells       		do ncols := ncols + cell:getCols();       //Print("ncols:" && ncols); Print("availWidth:" && availWidth);       		widths := Array(ncols,NIL);              		// calculate width for each column       		foreach cell in cells       		do if (cols := cell:getCols()) > 0       		then begin       			//colwid := if isFrame(cell._contents[1]) then cell._contents[1].width;       			colwid :=       				if cell.width       				then cell:fixWidth(cell.width, availWidth, containerWidth)       				else (availWidth div ncols) * cols; //(availWidth div (ncols-i)) * cols;              			cellwid := colwid div cols;       			for col := i to i+cols-1       			do sumWidth := sumWidth + widths[col] := cellwid;       			//availWidth := availWidth - colwid;       			i := i + cols;       			end;       		//if availWidth > 0       		//then sumWidth := sumWidth + AddArraySlot(widths, availWidth);              if kDebugHTTP then begin Write("TABLE widths: "); Print(widths); end;       		if sumWidth > origWidth       		then begin       			local scale := origWidth / sumWidth;       //Print("cols=" & ncols & ". needed width(" & sumWidth &") > origWidth(" & origWidth & ") -- rescaling by" && scale);       			for col := 0 to ncols-1       			do widths[col] := Floor(widths[col] * scale);       //Write("new TABLE widths: "); Print(widths);       			end;       	end,              	addRow: func(ARRAY cells)       	if Length(cells) > 0       	then begin       /* this should (but doesn't) cache rows if ROSWPAN or embedded table */       //Print("cells#:" && Length(cells));       //Print("starting top:" && top);       		if not widths       		then :getWidths(cells);              		if lastRowSpan and lastRowSpan <> cells[0]       		then if kNIE       			then ArrayInsert(cells, lastRowSpan, 0)       			else cells := ArrayMunger([lastRowSpan],1,nil, cells, 0, nil);       		if cells[0]:getRows() > 1       		then begin       			lastRowSpan := cells[0];       			lastRowSpan.ROWSPAN := lastRowSpan.ROWSPAN - 1;       			end       		else lastRowSpan := NIL;              		local INT i:= 0, col, cnum, cols, wid, curLeft := left, lastCol := Length(cells)-1;       		local INT availHeight := :getHeight(), containerWidth := :getWidth(), availWidth := containerWidth;       		local INT maxHeight := 0, saveTop := top, lastBottom, widLen := Length(widths);       		local cell, pagebreak, lastObj, excep;              		// setup cell containers, calculate max height of each cell       		foreach cnum,cell in cells       		do if (cols := cell:getCols()) > 0       		then begin       			if excep and cnum=lastCol	// remaining width for last col       			then wid := availWidth              			else if cols=1 and cell.width	// (for colspan). specific cell width override in pixels/percentage?       			then wid := excep := cell:fixWidth(cell.width, if i < widLen then widths[i] else containerWidth, containerWidth) // availWidth              			else if cols=1 and i < widLen		// default (from 1st row) for single cell       			then wid := widths[i]              			else begin			// add defaults for colspan       				wid := 0;       				for col:=i to min(i+cols, widLen)-1       				do wid := wid + widths[col];       				end;       			i := i + cols;       			availWidth := availWidth - wid;              			// set cell as current container and adjust dimensions       			top := saveTop;       			currentContainer := :setContainer(cell);	// move to cell container       			cell.left := cell.colLeft := curLeft;		// !!!a1. :setLeft. cache for addBlocks       			curLeft := curLeft + wid;       			cell.right := cell.colRight := curLeft - 2;	// !!!a1. :setRight       			cell:get_data2();       			maxHeight := max(maxHeight, cell:get_height2());       			currentContainer := cell:setContainer(nil);	// return to table container       			end;              		// if row too high, force a page break (if not at top already)       		// rather than split row (unless row is bigger than a page anyway)       /*       		if maxHeight > availHeight and top > rootContainer.top //and maxHeight > rootContainer:getHeight()       		then begin       			:newPage();       			saveTop := top;       			availHeight := :getHeight();       			end;       */              		lastBottom := saveTop + min(maxHeight, availHeight);       //Write("maxHeight, availHeight, lastBottom: "); Print([maxHeight, availHeight, lastBottom]);              		// render contents of each cell       		foreach cnum,cell in cells       		do if cell:getCols() > 0       		then begin       			top := saveTop;       			currentContainer := :setContainer(cell);	// move to cell container       			cell.left  := cell.colLeft;					// !!!a1. :setLeft. used cached L/R values       			cell.right := cell.colRight;				// !!!a1. :setRight              			lastObj := cell:addBlocks(border, cnum=0, lastBottom);       			currentContainer := cell:setContainer(nil);	// return to table container       			pagebreak := pagebreak or lastObj;       			end;              //Write("pagebreak,top,currentContainer? "); Print([pagebreak and true, top, self=currentContainer]);       // did a page break still occur? (extra tall row even on new page)       		if pagebreak       		then begin       			:newPage();       			:addRow(cells);	// add remainder       			end       		else begin       			top := lastBottom + (border * 3);       //Print("new top:" && top);       			end;       	end,       	},                     TR: {       	_proto: kprotoContainer,              	addItem: func(obj)       	begin       		local tag := obj._tag;       //if kDebugHTTP then Print("TR:" && tag && if obj._value then "start" else "stop");       		if SetContains('[TR, TABLE, CAPTION], tag)       		then begin       			_value := NIL;       			:get_data();						// end this row       			currentContainer:addRow(_contents);	// omit this when using :flushRows??       			currentContainer:addItem(obj);		// table will handle or hand off       			end              		else if tag='TD or tag='TH //SetContains('[TD, TH], tag)       		then begin       			if obj._value		       			then begin       				AddArraySlot(_contents, obj);	// add to row       				obj:get_data();					// create cell container       /*       				if newobj       				then begin       //Print(newobj); Print(currentContainer = obj);       					currentContainer:addItem(:getObj(tagDict, 'P, newobj));       //Print(currentContainer);       					end;       */       				end;       			// else ignore </TD>, </TH>       			end              		else begin       if kDebugHTTP then Print("TR: unexpected tag:" && tag);       			:addItem(:getObj(tagDict, 'TD, true));	// add implicit cell       			currentContainer:addItem(obj);			// add obj to cell       			end;       	end,       	},                     TD: {       	_proto: kprotoContainer,       	width: nil,       	addItem: func(obj)       	begin       		local tag := obj._tag;       //if kDebugHTTP then Print("TD:" && tag && if obj._value then "start" else "stop");       		if SetContains('[TD,TH,TR,CAPTION,TABLE], tag) // or (tag = 'TABLE and not obj._value)       		then begin       			_value := NIL;       			:get_data();					// end this cell (and start next?)       			currentContainer:addItem(obj);	// row will handle or hand off       			end       		else begin       //if kDebugHTTP then Print("TD adding:" && tag);       			AddArraySlot(_contents, obj);       /*       			if tag = 'TABLE					// embed a table!       			then begin       				obj._embedTable := TRUE;       				obj:get_data();       				end;       */       			end;       	end,              	get_data2: func()	// maybe this could be get_data?       	if _contents       	then begin	// call :get_data for each obj and collect/append results       //if kDebugHTTP then Print("get_data2 _contents:" && Length(_contents));       		local obj;       		local ARRAY newcontents := [];       		if Length(_contents) = 0		// only need to do this if border???       		then AddArraySlot(newcontents, :getObj(tagDict, kTagP, Clone("")):get_data())              		else foreach obj in _contents       			do begin       				if kDebugHTTP then newtscape.curObj := obj;       				if obj       				then call kAppendObj with (newcontents, obj:get_data());       				end;       		_contents := newcontents;       //if kDebugHTTP then Print("get_data2 new_contents:" && Length(_contents));       		self;       		end,              	get_height2: func()       	if _contents //and Length(_contents) > 0       	then begin       		//_contents[0].above := 0;       		//_contents[Length(_contents)-1].below := 0;       //Print("get_height2 len:" && Length(_contents));       		local INT ht := 0;       		local obj, objabove;       		foreach obj in _contents       		do begin       			if kDebugHTTP then newtscape.curObj := obj;       			objabove := obj.above;	// might be 'top       			if not (if kNIE then IsInteger(objabove) else isInstance(objabove, 'int))       			then objabove := 3;       			ht := ht + obj.height + objabove + obj.below;	// calc total height       			end;       		ht;       		end       	else 0,              	addBlocks: func(INT border, firstCol, INT lastBottom)       	if _contents       	then begin       //Print("addBlocks len:" && Length(_contents));       		local INT i, last := Length(_contents)-1, bordfudge, ht, bordbits, wid := right-left;       		local firstObj := true, obj;       		foreach i, obj in _contents       		do if obj       		then begin       			if border > 0       			then begin       				ht := obj.height;       				wid := right-left;       				if i=last       				then obj.height := ht := max(ht, lastBottom-top);       				bordfudge := 1;       				wid := wid + if firstCol then 3 else 4;       				obj.indent :=       					if firstCol then 0 else -border;              				if firstObj       				then if i=last or lastRadio       					then begin       						bordbits := 0xF00;	// 1111. all sides       						bordfudge:= 4;       						end       					else bordbits := 0xB00	// 1011. all except bottom       				else if i=last       				then bordbits := 0xE00		// 1110. all except top       				else begin       					bordbits := 0xA00;		// 1010. just sides (no top or bottom)       					bordfudge:= 0;       					end;              				obj._data.look :=       					if obj._data.look       					then Bor(obj._data.look, bordbits)	// in case already set, e.g., FONT COLOR       					else bordbits;	// bits: right,bottom,left,top       				if bordfudge > 0       				then obj.height := ht + bordfudge;       //if kDebugHTTP then Print(['addBlocks, width, wid]);       				obj.width := wid;              				firstObj := nil;       				end;              //print("top before add:" && top);       			if _contents[i] := obj := obj:addBlock()       			then return obj;	// a page break occurred       			//else top := top;       //print("top after add:" && top);       			end;       		_contents := NIL;	// all done       		end,                     	//_proto: 'P,       	above: 1,       	below: 1,       	split: nil,       	COLSPAN: nil,       	ROWSPAN: nil,              	getCols: func()       		COLSPAN := :fixAttribute(COLSPAN, 'int, 1),       	getRows: func()       		ROWSPAN := :fixAttribute(ROWSPAN, 'int, 1),       	},                     TH: {       	_proto: 'TD,       	ALIGN: 2,	// "CENTER"       	},                     CAPTION: {       	_proto: 'P,       	font:	tsBold + (10 << tsSizeShift),       	ALIGN: 2,       	},                     BR: {       	_proto: 'P,       	font: NIL, // use default (lastFont)       	above: 0, // if separate?       	below: 0,       	},              // typographic elements       B: {       	face:	kFaceBold,       	},                     I: {       	face:	kFaceItalic,       	},                     TT: {       	face: NIL,       	family:	'PRE, // was 2. Geneva. see :getRun       	},                     U: {       	face:	kFaceUnderline,       	},                     SUP: { // HTML 3.0       	face: kFaceSuperScript,       	size: -1,	// !!!r       	},                     SUB: { // HTML 3.0       	face: kFaceSubScript,       	size: -1,	// !!!r       	},                     BIG: { // HTML 3.0       	face: NIL,       	size: 1,       	},                     SMALL: { // HTML 3.0       	face: NIL,       	size: -1,       	},              FONT: {       	face: NIL,       	//size: 0,	// override via SIZE attribute       	},                     S: {       	face: kFaceOutline, // for now       	},              SPAN:	'FONT,	// !!!a1. for now?                     // idiomatic elements       // just share typographic elements for now              CITE: 	'I,       CODE: 	'TT,       EM:		'I,       KBD:	'TT,       SAMP:	'TT,       STRONG:	'B,       VAR:	'I,       DFN:	'I,       STRIKE:	'S,		// ??       ABBR:	'B,		// !!!b1       ACRONYM:'B,		// !!!b1              A: {       	face: NIL,       	HREF: nil, //tagDictOrig.U,       	},                     protoTagForm: {       	_proto: 	'P,       	height: 	20,       	//above:	3,       	below:		2,       	//width:	236,       	indent: 	2,       	indentR:	2,       	font:	kEspy9B,	// ROM_fontSystem9Bold. for inheriting by form obj              	NAME: 	nil,	// for inheriting       	VALUE:	nil,              	// !!!a1. getWidth: func(dproto) currentContainer:getWidth() - indent - indentR,	// do this in P ???              	get_data: func()  // #?. this default used by: HR, CHECKBOX, SELECT       	// instance should define either data slot or get_data method       	if _data       	then self       	else begin       		local dproto := :addAttrib(data, self);	// data obj       		height 	:= :fixAttribute(height, 'int, height);       		width := :getWidth(dproto);       		_data := {       			type:	'form,       			data:	dproto,       			};       		self;       		end,              	copyAttrib:	// copy only these from obj to form proto       		{NAME: 'formName, SCRIPT: 'compile, LABEL: 'string, VALUE: 'string, // + ACTION       		//viewFont: 'compile,       		},              	initDefault: true,	// nil for SUBMIT, IMAGE       	addAttrib: func(pframe, obj) // #?       	// add NAME, VALUE, etc. to object frame (modifying via _proto if necessary)       	begin       		if isReadonly(pframe)       		then pframe := {_proto: pframe};       		pframe.ACTION :=	// don't depend on NAME set       			if formAttributes       			then formAttributes.ACTION       			else kUnkURL;	// only if outside <FORM>...</FORM> ???              		local attrib, val, type;       		foreach attrib,type in copyAttrib       		do if val := GetSlot(obj, attrib)       		then begin       			if type='formName // and attrib='NAME       			then begin       				local ARRAY pnames := curBook.(kFPrintPath).(Intern(pframe.ACTION));       				if not (if kNIE // render time       						then  LSearch(pnames, val, 0, '|str=|, nil)       						else ArrayPos(pnames, val, 0, Functions.StrEqual))       				then AddArraySlot(pnames,val);  // store printname       				pframe.NAME := val := Intern(val);       				:initData(pframe, nil); // create slot if doesn't exist. init value elsewhere       				end              			else if type='symbol       			then val := Intern(val)              			else if type='int       			then val := call kGetInt with (val, 0)	// !!!b       				//if val := StringToNumber(val) then val := Floor(val) else val := 0              			else if type='compile       			then val := :compileVal(val);	//nil if not 'compile              			// avoid setting values already in _proto, e.g., METHOD="POST", VALUE=""  = or StrEqual ??       			if val       			then pframe.(attrib) := val;       			end;       		pframe;       	end,              	initData: func(dproto, val)       	if dproto.NAME // null name?       	then begin       		local iaction := EnsureInternal(Intern(dproto.ACTION)), iname := dproto.NAME;       		local oldval := curBook.(kFHiddenPath).(iaction).(iname);       		// don't overwrite radio(checked), select values       		if (val and not isArray(val)) or not oldval       		then begin       			if initDefault        			then  // initialize the field in form_hidden (book init)       				if isArray(oldval)	// !!!g. HIDDEN providing later default (for CHECKBOX,SELECT)       				then ReplaceObject(oldval, [val])       				else begin       					curBook.(kFHiddenPath).(iaction).(iname) := val;       					// also set in the user global. like setData but more direct since this is only temporary (see /FORM)       					call kInitGlobal with (Intern(curBook.ISBN), {}).(iaction).(iname) := val;       					end;       			val;       			end       		else oldval;       		// return val or oldval       		end       	else :error(kNoName, nil),              	errObj: func()       		:getObj(tagDict, kTagP, _tag && self.NAME && LocObj("not inside FORM", 'notFormErr))       	},                     // OBJECTS/FORMS       HR: {       	_proto: 'protoTagForm,       	//height: 2,       	SIZE: nil,       	NOSHADE: nil,       	//data: protoBorder,              	get_data: func()       	if _data       	then self       	else begin       		local dproto := :addAttrib(data, self);	// data obj       		width 	:= :fixAttribute(WIDTH, 'int, :getWidth(dproto));       		height 	:= :fixAttribute(SIZE,  'int, 2);       		RemoveSlot(dproto, 'ACTION);       		if not NOSHADE       		then dproto.viewFormat := vfFillDkGray; // otherwise default = vfFillBlack              		// ALIGN??              		_data := {       			type:	'form,       			data:	dproto,       			};       		self;       		end,       	},                     IMG: {       	_proto: 'protoTagForm,       	indent: 0,       	SRC: 	nil,       	ALT: 	nil,       	HREF: 	nil,       	//NAME: 	nil,       	USEMAP: nil,       	ISMAP: 	nil,       	WIDTH:	nil,       	HEIGHT: nil,       	ALIGN:	nil,       	scale: 1,              	get_data: func()       	if _data       	then self       	else begin       		if not StrFilled(ALT) and not SRC	// !!!j       		then ALT := "IMG: SRC?";              		local bm, entry, noPic;       		local SRCstr := if kNIE then IsString(SRC) else isInstance(SRC, 'string);       		if entry := :GetPICTasBits(SRC)       		then bm := entry              		else if StrFilled(ALT)	// !!!j       		then begin // add text, possibly with href       /*			if HREF or NAME       			then begin       				bm := Clone(self);       				bm._tag := 'A;       				ALT := [[bm], ALT];       				end;       			noPic := ALT;       */       			bm := Clone(self);       			bm._tag := 'A;       			if SRCstr and not bm.HREF	// create a fake link for popup       			then bm.HREF := SRC;       			noPic := ALT := [[bm], ALT];       			end       		else begin       			bm := noPic := noPicture;       			if SRCstr and not HREF		// create a fake link for popup       			then HREF := SRC;       			end;       /*       		else  noPic := [	// ALT. IMG: SRC  (ALT, SRC may have HREFs)       				if HREF or NAME       				then begin bm := Clone(self); bm._tag := 'A; [bm]; end       				else kATagP,       				if StrFilled(ALT) then ALT else "no ALT",       				kATagP,       				". IMG: ",       				if SRC then [{_tag: 'A, HREF: SRC}] else kATagP,       				if SRC then SRC else "no SRC",       				];       */              /*       if IMG is ALT/noPicture (noPic),       - if IMG followed MAP, AREA text needs to be added here.       - if IMG precedes MAP, indicate this in imgMaps via noMap (handled in AREA later)              if IMG is picture       - if IMG followed MAP, add hrefs (added earlier by AREA) below       - if IMG precedes MAP, hrefs added in AREA later       */       		local objs, hrefs, mapSym :=       			if StrFilled(USEMAP) and USEMAP[0]=$#       			then Intern(SubStr(USEMAP,1,nil));              //Print(['noPic, noPic, USEMAP, mapSym, imgMaps]);       		if noPic       		then begin       			objs := [if noPic = noPicture then self else :getObj(tagDict, kTagP, noPic):get_data()];       			if mapSym       			then if lastMap := imgMaps.(mapSym)		// MAP occurred earlier. convert AREA to text       				then begin       					foreach entry in lastMap._data.hrefs       					do AddArraySlot(objs, :getObj(tagDict, kTagP,       						[[{_tag: 'A, HREF: entry[0]}], "AREA:" && entry[0]]):get_data());       					RemoveSlot(imgMaps, mapSym);       					lastMap := NIL;       					//otherwise, finish fixing _data for noPicture       					end       				else imgMaps.(mapSym) := {noMap: true};	// MAP/AREA later       			if noPic = noPicture       			then mapSym := NIL	 		// prevent href munging below       			else return objs;			// return ALT text, and maybe AREA text       			end;              		// bitmap bounds       		local bnd 	  := :getPictObj(bm, true);       		local INT bwidth := bnd.right  - bnd.left, bheight := bnd.bottom  - bnd.top;       		// "page" width, height       		local INT availWidth  := currentContainer:getWidth();       		//local INT pageWidth := rootContainer:getWidth();       		local INT availHeight := rootContainer:getHeight();              		// user supplied width, height       		width := :fixAttribute(width, 'int,       			if al and al<>0 then availWidth else bwidth);       		//if width > availWidth then width := availWidth;       		// but want width := availWidth in table cell ???       //if kDebugHTTP then Print(['IMG, width, availWidth]);       		height := :fixAttribute(height, 'int, bheight);       		// adjust height to min(availHeight,... )? (newPage will provide that amount later?)              //Print(['IMG, width, bwidth, availWidth, height, bheight, availHeight]);       		local scale := 1;       		if optionsAPI.scaleImage and (kBuild20 or isFrame(bm))       			and (width > availWidth or height > availHeight)       			and (width <= bwidth or height <= bheight) // don't scale up?       		then begin       			scale := min(availWidth/width, availHeight/height);       			width  :=  bwidth  := Floor(width *scale);	// was RIntToL       			height :=  bheight := Floor(height*scale);       			if isFrame(bm) and bm.pics and Length(bm.pics) > 1	// animated?   assumes bitmap (not PICT)       			then begin       				bm.bounds := RelBounds(0,0,width,height);       				bm.pics :=       					foreach entry in bm.pics       					collect begin       						bnds := call kScaleBounds with (entry.bounds, scale);       						call kFixBitmap with (ScaleShape(MakeShape(entry), nil, bnds), bnds, nil);        						end;       				end       			else begin // 1.x PICT not viewable if scaled       				bnds := RelBounds(0,0,width,height);       				bm := call kFixBitmap with (ScaleShape(MakeShape(bm), nil, bnds), bnds, nil);       				end;       			end;              		if kBuild20 and isFrame(bm) and not bm.bits and bm.colordata.cbits exists and not isReadonly(bm)       		then bm.bits := bm.colordata.cbits;	// seems to be nec to prevent gratuitous scrollers              		_data := { // 2D scroller appears if too large (width or height)       			data:	bm,       			scale:	scale,       			};              		// LEFT, RIGHT, CENTER, JUSTIFY ?       		local al := :getAlign(); // int or string       		if al and al <> 0 // and not mapSym       		then _data.viewJustify := al;              		if mapSym       		then if lastMap := imgMaps.(mapSym)       			then begin	// MAP earlier       				hrefs := lastMap._data.hrefs;       				if scale <> 1       				then foreach entry in hrefs       					do begin       						bnds := call kScaleBounds with (ShapeBounds(entry[3]), scale);       						ScaleShape(entry[3], nil, bnds);	// ok for 1.x (hit testing only)???       						end;              //Print("IMG:" && mapSym); Print(hrefs); Print(HREF);       				if HREF       				then AddArraySlot(hrefs, [HREF, 0, nil, 0, 0, bwidth, bheight]); // see kGetHrefRegions       				RemoveSlot(imgMaps, mapSym);       				lastMap := NIL;       				end       			else begin	// MAP later       				imgMaps.(mapSym) := self;       				if htmlSoup then _data.useMap := useMap;	// for addBlock (prevent soup entry)       				end;              		if HREF or hrefs or mapSym       		then begin       			_data.hrefs := if hrefs then hrefs else [[HREF, 0, nil, 0, 0, bwidth, bheight]]; //[nil, HREF];       			_data.look 	:= 0xF00; 		//3840; //??       			height 		:= height + 4;       			width		:= width  + 5;	// kludge to un-inset? ???       //if kDebugHTTP then Print(['IMG_HREF, width]);              			if SRCstr       			then _data.SRC	:= SRC;		// for popup menu       			if ISMAP       			then _data.ISMAP := true;	// (see kGoToHREFclickShare)       			end;              		if NAME       		then _data.name := NAME;              		if objs			// noPicture, w/ AREA text?       		then objs       		else self;       	end,       	},                     INPUT: {       	_proto: 'protoTagForm,       	TYPE: "TEXT",              	get_data: func()		       	if _data       	then self       	else if formAttributes       	then begin // let the TYPE handle it       		local iobj, newobj := Clone(self);       		//newobj._data := NIL; // unnecessary?       		newobj._proto :=       			if iobj := inputDict.(Intern(TrimString(TYPE)))	// !!!g       			then iobj       			else inputDict.TEXT;       		newobj:get_data();       		end       	else :errObj():get_data(),       	},              SELECT_LABEL: { // viewFont (for label)       	_proto: 'protoTagform,       	//font:	kEspy9B, // protoLabelPicker.viewFont       	},              SELECT_MENU: { // 2.x: menuFont (for popup menu)       	_proto: 'protoTagForm,       	font: kEspy10B,       	},              SELECT: {       	_proto: 'protoTagForm,       	height: 16,       	noRefresh: true,       	OPTIONS: nil,       	copyAttrib:	// only copy these from obj to form proto       		{NAME: 'formName, SCRIPT: 'compile, LABEL: 'string, MULTIPLE: 'value, OPTIONS: 'value,       		HREF: 'string,       		//viewFont: 'compile, entryFont: 'compile, menuFont: 'compile,       		},       	// entryFont (for value)       	font: if kBuild20 then editFont10 else userFont10, // if language='Chinese then kEspy10?              	data: {       		_proto: 	protoLabelPicker,       		LABEL: 		"",       		NAME: 		nil,       		HREF: 		nil,       		//ACTION: 	kUnkURL,       		OPTIONS: 	[],       		//SCRIPT: 	kPrintFunc,       		MULTIPLE: 	nil,       		GetData: 	kGetData,       		SetData: 	kSetData,       		AllData: 	kAllData,              		viewJustify: 0,	//removed vjCenterV, was oneLineOnly. for taller viewFont       		//viewFont: kEspy9B,       		entryFont: nil,       		menuFont: kEspy10B,       		//viewClickScript	// see afterScript       		pickerSetup: func()       		begin       			//if kNCfont and viewFont <> ROM_fontSystem9Bold // _proto.viewFont ?       			//then AddDeferredCall(kFixPicker, [{family: GetFontFamilySym(viewFont), face: kFaceNormal, size: 10}, nil]);       			//if menuFont <> kEspy10B	then       			AddDeferredCall(kFixPicker, [menuFont, true]);       			TRUE;       		end,       		curLabelCommand: 0,       		viewSetupFormScript: func()       		begin       			self.text := LABEL;       			self.labelCommands :=       				if MULTIPLE and NAME       				then begin       					local ARRAY a := :GetData(NAME);       					local item;       					local findFn := if kBuild1x and Functions.ArrayPos exists then Functions.StrEqual;       					foreach item in OPTIONS       					collect       						{item: item.item,       						value: item.value,       						mark: if (if kBuild1x and findFn // run time       									then ArrayPos(a, item.value, 0, findFn)       									else  LSearch(a, item.value, 0, '|str=|, nil))       							 then kCheckMarkChar       							 else if kBuild1x	// !!!f       							 then $ ,       						};       					end       				else OPTIONS;       			if entryFont then entryLine.viewFont := entryFont;       			inherited:viewSetupFormScript();       		end,              		textSetup: func()       		if not NAME       		then kNoName       		else if Length(labelCommands) > 0       		then begin       			local ARRAY a := :GetData(NAME);       			local lab :=       				if Length(a) > 0       				then if kBuild20       					then LFetch(labelCommands, a[0], 0, '|str=|, 'value)       					else call kLFetch with (labelCommands, a[0], 0, Functions.StrEqual, 'value, nil);       			if lab       			then lab.item       			else "";       			end       		else "",              		labelActionScript: func(i)       		begin       			local ARRAY a := :GetData(NAME);       			local lab := labelCommands[i], val := lab.value, pos;              			if MULTIPLE       			then if pos := (if kBuild1x and Functions.ArrayPos exists // run time       								then ArrayPos(a,val,0,Functions.StrEqual)       								else  LSearch(a,val,0,'|str=|,nil))       				then begin       					ArrayRemoveCount(a,pos,1);       					lab.mark := NIL;       					end       				else begin       					AddArraySlot(a, EnsureInternal(val));       					lab.mark := kCheckMarkChar;       					end       			else a[0] := val;              			:updateText(if MULTIPLE and pos then :textSetup() else lab.item);       			//:SetData(NAME, val);       			:?SCRIPT(val);       		end,       		},              	get_data: func()       	// almost same as default -- add OPTIONS initialization to tag       	if _data       	then self       	else if _value       	then if formAttributes       		then begin       			if not OPTIONS       			then self.OPTIONS := [];       			local obj := inherited:get_data(), dproto := obj._data.data;       			:initData(dproto, if dproto.MULTIPLE then [] else [""]);       /*       			if (kFontFix and not HasSlot(dproto,'viewFont))       				or (kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym)       			then begin       				dproto.viewFont := labelFontJ;       				dproto.entryFont:= dataFontJ;       				dproto.menuFont	:= menuFontJ;       				end;       */       			local font2 := tagDict.SELECT_LABEL.font;       			if self.HREF       			then dproto.viewFont :=       					if isFrame(font2)       					then call kAddEmphasis with (font2, kFaceUnderline)       					else Bor(font2, tsUnderline)       			else if font2 <> tagDictOrig.SELECT_LABEL.font       			then dproto.viewFont := Clone(font2);	// !!!c1. direct       			if font <> tagDictOrig.SELECT.font       			then dproto.entryFont := Clone(font);	// !!!c1. viewSetupFormScript       			if kNIE and (font2 := tagDict.SELECT_MENU.font) <> tagDictOrig.SELECT_MENU.font       			then dproto.menuFont := Clone(font2);	// !!!c1. pickerSetup              			lastSelect := self;	// do this via a container???       			NIL;				// complete when </SELECT>       			end       		else :errObj():get_data()              	else if lastSelect       	then begin       		/* if htmlSoup -> addBlock??       			then begin       				local INT clen := Length(curBook.(kContentsPath))-1;       				htmlSoup:add({contentID: clen, data: lp.options});       				lp.options := [deferredPackageObject: kGetHTMLFunc, clen];       				end; */       		local lp := lastSelect;       		lastSelect := NIL;       		RemoveSlot(lp._data.data, 'ISBN);       		lp;       		end,       	},                     OPTION: {       	_proto: 'protoTagForm, // for now, assume SIZE=1, no multiple choice, short list ???       	//VALUE: nil,       	SELECTED: nil,              	get_data: func()       	if lastSelect       	then begin       		local lp := lastSelect._data.data;       		if isArray(_value) then _value := _value[1];       		if not VALUE       			or (kNIE and StrExactCompare(VALUE,_value) = 0)	// share       		then VALUE := _value;       		local item := {item: _value, value: VALUE};       		if (SELECTED or (not lp.MULTIPLE and Length(lp.OPTIONS)=0))       			and lp.NAME       		then begin       			lp.isbn := curBook.isbn; // so inheritable by kAllData       			local ARRAY a := lp:GetData(lp.NAME);       			if lp.MULTIPLE       			then begin       				AddArraySlot(a, VALUE);       				item.mark := kCheckMarkChar;       				end       			else a[0] := VALUE; // default to first option or replace with selected       			end;       		AddArraySlot(lp.OPTIONS, item);       		NIL;       		end       	else begin       		:PRINT('[OPTION, "SELECT?"]);       		NIL; // nothing to add       		end,       	},                     TEXTAREA: {       	_proto: 'protoTagForm,       	//COLS: nil,	// ???       	ROWS: nil,       	font: if kBuild20 then editFont12 else userFont12, // viewFont (for value). if language='Chinese then kEspy12?              	data: {       		viewClass: clView,		// !!!b       		viewFlags: vVisible,       		NAME: nil,       		VALUE: "",       		//ACTION: kUnkURL,       		//SCRIPT: kPrintFunc,       		GetData: kGetData,       		SetData: kSetData,       		AllData: kAllData,              		bottomInset: 0,	// for scrolling, and init flag also       		// in order to share viewChangedScript, viewSetupFormScript w/ INPUT TEXT       		labelWidth: func() 0,       		encode: NIL,       		entryFlags: NIL,       		maxLength:	NIL,       		entryFont:	NIL,       		dictionaries: NIL,              		//allocateContext:       		viewChildren: [viewChildren:       			{viewClass: clView,	// this is just a scrollable container for textAreaEdit       			viewFlags: vVisible,       			viewBounds: kBounds0,       			viewJustify: vjParentFullH + vjParentFullV,       			viewOriginY: 0,       						       			scroll: func(INT numLines)       				begin       					local INT lineht := textAreaEdit.viewLineSpacing;       					:SetOrigin(0,       						max(0, min(textAreaEdit:textHeight() - lineht,       								viewOriginY - (max(1, :LocalBox().bottom div (2 * lineht)) * numLines * lineht)))); // !!!d       				end,       			viewSetupFormScript: func()       				if bottomInset > 0       				then viewFlags := vVisible + vClipping,	// scrolling: turn on clipping (and lose frame)       			preallocatedContext: 'textAreaScroll,       			//allocateContext:       			viewChildren: [viewChildren:       				{viewClass: clParagraphView,       				viewFlags: 14849, 	// vVisible+vClickable+vCharsAllowed+vNumbersAllowed+vGesturesAllowed       				viewFormat: 256+80+1+12288, // vfPen*1 + vfFrameBlack + vfFillWhite + vfLinesGray       				viewLineSpacing: 20,       				//viewBounds: kBounds0,	// set in viewSetupFormScript (using labelWidth,bottomInset)       				viewJustify: vjParentFullH + vjParentFullV,       				viewFont: nil,	// set via entryFont in viewSetupFormScript       				preallocatedContext: 'textAreaEdit,       				textHeight: func()	// return height of text in box (adjusting for line spacing)       					(call kMySimpleHeightFunc with (text, 0, nil, :LocalBox().right, viewFont)	// !!!o,m       						div FontHeight(viewFont)) * viewLineSpacing,       				viewChangedScript: func(slot,view)       				begin       					:viewChangedScript2(slot,view); // same as TEXT.viewChangedScript       					if bottomInset=0 and :textHeight() > :LocalBox().bottom       					then begin // turn on scrolling       						bottomInset := kScrollBottom;       						if kBuild20 // !!!t       						then AddDeferredSend(textAreaScroll:parent(), 'RedoChildren, nil)       						else AddDeferredAction(Functions.Perform, [(textAreaScroll:parent()), 'RedoChildren, []]); // !!!y       						//(textAreaScroll:parent()):RedoChildren();       						end;       				end,       				//viewChangedScript2       				//viewSetupFormScript       				},       				],       			},              			{_proto: protoPictureButton,       			icon: ROM_upBitmap,       			viewBounds: RelBounds(-18,-8,18,12),       			viewJustify: vjCenterH+vjCenterV + vjParentRightH+vjParentCenterV,       			viewFormat: vfNone,       			lines: 1,       			buttonClickScript: func()       				textAreaScroll:scroll(lines),       			viewSetupFormScript: func()       			begin       				if bottomInset=0       				then viewFlags := vNoFlags;	// no scrolling: hide       				inherited:?viewSetupFormScript();       			end,       			},       			{_proto: protoPictureButton,       			icon: ROM_downBitmap,       			viewBounds: RelBounds(-18,8,18,12),       			viewJustify: vjCenterH+vjCenterV + vjParentRightH+vjParentCenterV,       			viewFormat: vfNone,       			lines: -1,       			//buttonClickScript: 	// share       			//viewSetupFormScript: // share       			},       			],       		},              	get_data: func()       	if _data       	then self       	else if formAttributes       	then begin       		local dproto := :addAttrib(data,self);       		if isArray(_value)	// not a string?       		then begin       			local ARRAY strs := _value;       			local INT i;       			_value := strs[1];       			for i := 3 to Length(strs)-1 by 2       			do StrMunger(_value,StrLen(_value),0, strs[i],0,nil);       			end;       		if kNIE and StrLen(_value) > 2000	// for long value (see viewSetupFormScript). kMinVBOlen?       		then _value := call kNewVBO with (nil,nil,_value);       		:initData(dproto, _value);              		// customize font,linespacing from Tag Prefs ???       		width := :getWidth(dproto);	// was -4       		dproto.entryFont := if font <> tagDictOrig.TEXTAREA.font then Clone(font) else font; // !!!c1       		local INT fht := FontHeight(font), sp := max(20,fht);       		local INT tht := :SimpleTextHeight(_value, width, font); // !!!a              		height := min(//currentContainer:getHeight() div sp,       					rootContainer:getHeight() div sp,       					if ROWS	// !!!d. respect rows attrib       					then :fixAttribute(ROWS, 'int, 1)       					else max(1, tht div fht)       					) * sp;       		if tht > height       		then dproto.bottomInset  := kScrollBottom;	// !!!b. turn on scrolling              //Print("TEXTAREA wid,ht:" && width & $, & height);       		_data := {       			type: 'form,       			data: dproto,       			};       		self;       		end       	else :errObj():get_data(),       	},                     APPLET: {       	_proto: 'protoTagForm,       	indent: 1, // for app border?       	copyAttrib: {       		NAME: 'symbol,	// not 'formName       		CODEBASE: 'string, CODE: "string", ALT: "string",       		HEIGHT: 'int, WIDTH: 'int, HSPACE: 'int, VSPACE: 'int,       		},              	data: {       		viewClass: clParagraphView,       		CODEBASE: "", 	// base URL of newtlet       		CODE: 	"",		// URL of newtlet       		HEIGHT: 50,		// height of newtlet display area       		WIDTH:  50,		// width of newtlet display area       		NAME: 	nil, 	// appSymbol of newtlet in GetRoot() (or Newt's Cape global ?)       		ALT:"a newtlet",// text string       		HSPACE:	0,		// reserved space around applet (top/bottom margin)       		VSPACE:	0,		// reserved space around applet (left/right margin)       		       		viewFlags: 513, //vVisible+vClickable       		viewFont: userFont9, //0x00002800, // same as P       		viewLineSpacing: 14,       		viewFormat: 1, //vfFillWhite.  256+80+1, // vfPen*1 + vfFrameBlack +        		viewClickScript: func(unit)       		begin       			local newtlet := call kFindApp with (NAME);       			// run the newtlet if installed (and closed)?       			if newtlet       			then newtlet:toggle()       			else if StrFilled(CODEBASE) and BeginsWith(CODEBASE,kHTTP) and       				CODEBASE[StrLen(CODEBASE)-1] = $/ and //EndsWith(CODEBASE,"/") and       				EndsWith(CODE, kPKGextension)       			then GetRoot().(kAppSymbol):?getURL(CODEBASE & CODE, nil);	// reload option?       			NIL;       		end,              		viewQuitScript: func()       			if NAME       			then GetRoot().(NAME):?close(),              		viewSetupFormScript: func()       		begin       			self.text := "APPLET:" && if NAME then NAME else if StrFilled(CODE) then CODE else ALT; //else kNoName       			local newtlet;       			if newtlet := call kFindApp with (NAME)       			then begin       				local s, v, params := :BookData().form_hidden.(NAME);              				if HasVariable(newtlet,'openNewtlet)       				then return newtlet:openNewtlet(viewBounds,params);       				local ap := GetAppParams();       				local INT aht := ap.appAreaHeight;       				local INT awd := ap.appAreaWidth;       				local INT vj := newtlet.viewJustify;       				//local INT vbl := viewBounds.left,  vbt := viewBounds.top;       				//local INT vbr := viewBounds.right, vbb := viewBounds.bottom;       //print("viewJustify:" && vj);       //write("newtlet viewBounds: "); print(newtlet.viewbounds);       //write("page viewBounds: "); print(viewBounds);              				local INT ydiff :=       					if Band(vjParentBottomV, vj) <> 0       					then aht       					else if Band(vjParentCenterV, vj) <> 0       					then (aht - HEIGHT) div 2       					else 0;       //print("ydiff" && ydiff);       				       				local INT xdiff :=       					if Band(vjParentRightH, vj) <> 0       					then awd       					else if Band(vjParentCenterH, vj) <> 0       					then (awd - WIDTH) div 2       					else 0;       //print("xdiff" && xdiff);              				newtlet:close();       				newtlet.(EnsureInternal('viewBounds)) :=       					SetBounds(       						viewBounds.left 	+ HSPACE - xdiff,	// left       						viewBounds.top		+ VSPACE - ydiff,	// top       						viewBounds.right	+ HSPACE - xdiff,	// right       						viewBounds.bottom 	+ VSPACE - ydiff);	// bottom              				// copy params to app       				foreach s,v in params       				do newtlet.(EnsureInternal(s)) := EnsureInternal(v);       				if kBuild1x and Functions.AddDeferredAction exists // run time       				then AddDeferredAction(Functions.Perform, [newtlet, 'open, []])       				else AddDeferredSend(newtlet, 'open, nil);       				end;       		end,       		},              	get_data: func()       	if _data       	then self       	else if _value       	then begin       		local dproto := :addAttrib(data, self), iname := dproto.NAME;       		newtletAttributes := {name: iname}; // for PARAM       		if iname       		then curBook.(kFHiddenPath).(iname) := {}; // params              		below 	:= max(below, 2 * dproto.VSPACE);       		height	:= dproto.HEIGHT;       		width	:= dproto.WIDTH;              		// indent?       		_data := {       			type: 	'form,       			data: 	dproto,       			};       		self;       		end,       	},              OBJECT:	'APPLET,	// !!!a1              PARAM: { // kinda like META,FORM       	NAME: nil,       	VALUE: nil,              	get_data: func()       	if _value and newtletAttributes       	then begin       		local iname	:= newtletAttributes.NAME;       		if NAME and VALUE and iname       		then curBook.(kFHiddenPath).(iname).(Intern(NAME)) := :compileVal(VALUE); //nil if not 'compile       		NIL;       		end,       	},                     MAP: {       	NAME: nil,              // this is a little complicated since there may be multiple maps, and IMG may follow. see IMG       	get_data: func()       	if _value and NAME       	then begin       		local sym := Intern(NAME);       		if lastMap := imgMaps.(sym)	// earlier IMG       		then begin       			// in case original IMG had a client cgi href, save (make last later)       			lastMap.origHrefs := lastMap._data.hrefs; // save! maybe empty if no global/server HREF       			lastMap._data.hrefs := [];       			lastMap.scale := lastMap._data.scale;       			end       		else lastMap := imgMaps.(sym) := {_data: {hrefs: []}, scale: 1};	// later IMG       		NIL;       		end              	else if lastMap       	then begin       		local ARRAY hrefs := lastMap._data.hrefs;		// added by AREA       		local origHrefs := lastMap.origHrefs;			// restore last?       //Print("MAP:" && lastMap.USEMAP); Print(hrefs); Print(origHrefs);       		if isArray(origHrefs) and Length(origHrefs) > 0 and       			(if isArray(origHrefs[0])       			then StrFilled(origHrefs[0][0])		// kGetHREFregions already called: [[href, ...]       			else StrFilled(origHrefs[1]) and	// still raw: [NIL, href] (in table)       				origHrefs := [[origHrefs[1], 0, NIL, 0, 0, lastMap.width, lastMap.height]])       		then ArrayMunger(hrefs, Length(hrefs), 0, origHrefs, 0, nil);       		if lastMap.USEMAP // actual IMG preceded. no longer needed       		then RemoveSlot(imgMaps, Intern(SubStr(lastMap.USEMAP,1,nil)));       		lastMap := NIL;       		end,       	},                     AREA: {       	_proto: 'protoTagForm,       	HREF: nil,       	SHAPE: "",       	COORDS: nil,       	//NOHREF: nil,       	ALT: nil,              	get_data: func()       	if lastMap       	then begin       		if lastMap.noMap       		then begin // ALT or noPicture.  return text immediately. see IMG       			if HREF       			then begin       				local atag := Clone(self);       				atag._tag := 'A;       				ALT := [[atag], if ALT then ALT else "AREA:" && HREF];       //newtscape.curObj := ALT;       				end;       			if ALT       			then :getObj(tagDict, kTagP, ALT):get_data();	// origtag???       			end       		else // add area href to current (or future) IMG object. this may be converted to text if later IMG uses ALT/noPicture       			if COORDS       			then begin       				local ARRAY acoords := [];       				local val;       				if kNIE       				then begin // avoid compile       					local fn := StrTokenize(COORDS, ", ");       					while val := call fn with ()       					do  if StrFilled(val) and val := StringToNumber(val)       						then AddArraySlot(acoords, Floor(val * lastMap.scale));       					end       				else begin       					local pos, epos := 0;       					loop begin       						pos := call kStrPosAny with (COORDS, '[",", " "], epos, true, nil);       						if StrFilled(val := SubStr(COORDS, epos, if pos then pos-epos))       							and val := StringToNumber(val)       						then AddArraySlot(acoords, Floor(val * lastMap.scale));       						if pos       						then epos := pos+1       						else break;       						end;       					end;              				local INT clen := Length(acoords);       				local ARRAY hrefentry := [HREF, 0, NIL];              				if clen=4 and (StrEqual(SHAPE,"rect") or StrLen(SHAPE)=0)       				then AddArraySlot(hrefentry,       					Apply(if kNIE       						then GetGlobalFn('MakeRect)       						else Functions.MakeRect,       						acoords)) // use shape for HitTest and highlight              				else if clen=3 and StrEqual(SHAPE,"circle")       				then begin       					local INT cx := acoords[0], cy := acoords[1];       					local INT r  := acoords[2] div 2; // diam -> radius       					AddArraySlot(hrefentry, MakeOval(cx-r, cy-r, cx+r, cy+r));       					end              				else if (StrEqual(SHAPE,"poly") or StrEqual(SHAPE,"polygon"))       						and clen > 0 and (clen mod 2) = 0       				then begin       					if acoords[0]<>acoords[clen-2] or acoords[1]<>acoords[clen-1]	// !!!f. poly closed?       					then begin       						AddArraySlot(acoords, acoords[0]);       						AddArraySlot(acoords, acoords[1]);       						end;       					AddArraySlot(hrefentry, MakePolygon(acoords));       					end       				else hrefentry := NIL; // unrecog shape       				if hrefentry       				then begin       					if kNIE	// !!!f. share shape (same coords)?       					then if val := LFetch(all_AREA, COORDS, 0, '|str=|, 0)       						then hrefentry[3] := val[1]		// same COORDS/shape       						else AddArraySlot(all_AREA, [COORDS, hrefentry[3]]);       					AddArraySlot(lastMap._data.hrefs, hrefentry); // add in order       					end;       				NIL;  // don't add a visible object       				end;       		end,       	},                     CENTER:	{       	_proto: kprotoContainer,       	ALIGN:	2,       	},              |DIV|:		kprotoContainer,		// !!!g,e       NOBR:		kprotoContainer,		// !!!g       NOSCRIPT:	kprotoContainer,		// !!!g       STYLE:		kprotoContainer,		// !!!z              SCRIPT: { // supposedly this is inside a comment, and removed/not seen, but...       	_proto: kprotoContainer,	// !!!g        	addItem: func(obj)			// !!!g. ignore all contents (except </SCRIPT>       	if obj._tag = 'SCRIPT and not obj._value       	then inherited:addItem(obj),       	//else NIL              	//!!!g. get_data: kNilFunc0,       	},              NOFRAMES: {	//	!!!e. eventually like TABLE or NOBR that discards content if all frames included?       	_proto: kprotoContainer,	// !!!g        	get_data: func()       	if kNIE and optionsAPI.includeFrames       	then inherited:get_data()					// !!!g. add/remove container       	else if _value       	then :getObj(tagDict, :frameHeading(optionsAPI.frameTag),       		[kATagP, "NOFRAMES"]):get_data(),	// !!!i,f. inh doesn't get font/appearance?              	addItem: func(obj)	// !!!g. ignore all contents except </NOFRAMES>       	if (obj._tag = 'NOFRAMES or obj._tag = 'NOFRAME) and not obj._value       	then inherited:addItem(obj),       	//else NIL       	},              NOFRAME: 'NOFRAMES,	// !!!e              FRAMESET: {	// !!!e       	_proto: kprotoContainer,       	level: 1,       	frameIncludes: nil,       	addItem: func(obj)       		begin       			if kNIE and not frameIncludes and optionsAPI.includeFrames       			then frameIncludes := [];              			if obj._tag = 'FRAMESET       			then begin       				level := level + if obj._value then 1 else -1;       				if level >= 1       				then return NIL;	// ignore nesting for now              				if kNIE and frameIncludes       				then call kAddFrames with (optionsAPI, "FRAME", frameIncludes);	// !!!g       				end;       			inherited:addItem(obj);       		end,       	},              FRAME: {       	_proto: 'H1,	// !!!e       	SRC: nil,	// normally defined, but in case of unrecog unary attrib       	NAME: nil,        	get_data: func()       	if SRC       	then begin       		local entry;       		if kNIE and currentContainer.frameIncludes       			and entry := call kGetURLCache with (cacheHTML, :ResolveURL(curBook.(kBasePath), TrimString(SRC)), nil, nil, nil)       		then begin       			if BeginsWith(SRC, kHTTP) or CharPos(SRC, $/, 0)       			then :scanFixFrame(entry, entry.URL, entry.text, 0);	// !!!m       			//entry := ... if IsSoupEntry(entry) then       			AddArraySlot(currentContainer.frameIncludes, MakeEntryAlias(entry));       			NIL;       			end       		else :getObj(tagDict, :frameHeading(optionsAPI.frameTag),       			[[{_tag: 'A, HREF: SRC}], "?FRAME:" && NAME]):get_data(); // !!!i,f,e       		end,       	},              IFRAME: {	//	!!!g. like FRAMESET w/ single FRAME but NOFRAMES inside       // problem is that it would be loaded after document is finished, so not in right place?       	_proto: kprotoContainer,       	SRC: nil,       	NAME: nil,        	get_data: func()       	if kNIE and optionsAPI.includeFrames	// see FRAME       	then begin       		local entry;       		if _value and SRC       			and entry := call kGetURLCache with (cacheHTML, :ResolveURL(curBook.(kBasePath), TrimString(SRC)), nil, nil, nil)       		then begin       			if BeginsWith(SRC, kHTTP) or CharPos(SRC, $/, 0)       			then :scanFixFrame(entry, entry.URL, entry.text, 0); // !!!m       			// entry := ... if IsSoupEntry(entry) then       			call kAddFrames with (optionsAPI, "IFRAME", [MakeEntryAlias(entry)]); // like end of FRAMESET       			end;       		inherited:get_data();	// like NOFRAMES, add/remove container (to ignore contents)       		end       	else if _value       	then :getObj(tagDict, :frameHeading(optionsAPI.frameTag),	// !!!i       		[[{_tag: 'A, HREF: SRC}], "?IFRAME:" && NAME]):get_data(),              	addItem: func(obj)	// ignore all contents except </IFRAME>       	if obj._tag = 'IFRAME and not obj._value       	then begin       		inherited:addItem(obj);       		end,       	},       },     hrefScript:       func(obj,unit)	//so old books can work compatibly twith new Newt's Cape       :hrefScriptG(obj, unit, aeTap),     startHTML:       func()       begin       //Print("startHTML");       //Print([optionsAPI.pageWidth, optionsAPI.pageHeight]);       // this assumes optionsAPI is a frame, inheriting to prefsEntry       	if not optionsAPI.noStatus       	then newtscape:open();              	local opt := GetSlot(optionsAPI,'processOption); // !!!g. optionsAPI.processOption;       	if not opt       	then optionsAPI.processOption := opt := processOption;              	local htmlApp := optionsAPI.htmlApp;       	if htmlApp <> NewtsCape	// !!!g       	then htmlApp :=       		if htmlApp       		then {_proto: htmlApp}       		else if opt > kProcessMax       		then {_proto: :installHTMLApp(nil,nil)[opt-kProcessMax-1]}	// !!!e       		else NewtsCape;       	if not HasVariable(htmlApp,'addHTMLitem)       	then htmlApp.addHTMLitem := kAddHTMLitem;              	if htmlApp = NewtsCape       	then begin       //Print("before newBook");       		:removeApp(nil,true);       		:newBook();       		curBook.(kEdataPath) := optionsAPI.edata;	// moved from addFile       		//if kDebugHTTP then Print("startHTML:" && optionsAPI.edata);       		end              	else begin       		linenum := 0;       		:resetStatus();		// !!!h       		end;              	curSource := NIL;	// !!!i. progressOptions := progressView :=        	gc();       	if kProfileOn then EnableProfiling(true);       	if kDebugHTTP then NewtsCape._ticks := ticks();              	if //kCParser or       		(kBuild20 and IsFunction(parsingFrame))       	then parseJob := {       		parseString: parsingFrame,       		htmlApp: htmlApp}       	else begin       		parseJob := parsingFrame:New();       		parseJob.htmlApp := htmlApp;       		parseJob.all_HREF := [];			// !!!g       		parseJob.fixString := fixString;       		end;       end,     docDone:       func(options, ps)	// addFile, stopHTML       if options       then begin       	local sndName := optionsAPI.docDoneSound;       	if sndName and ps       	then PlaySound(if kNIE then GetRegisteredSound(sndName) else ROM_soundoff.(sndName));              	:SetRun(nil);	// !!!g              	if options.autoHide       	then call kHideNewtsCape with () 	// !!!g,f. newtscape:hide()       	else :setGauge(nil, nil, nil);       	end,     setGauge:       func(txt, newVal, newMax)       begin       /*        :SetGauge(str, ..., nil) == :setStatus       :SetGauge(nil, ..., ...) == :setGauge (old)       :SetGauge(str, ..., ...) == :SetStatus; :setGauge       */       	if optionsAPI       	then optionsAPI.helperApp:?setGauge(txt, newVal, newMax);	// !!!h       	       	if Visible(newtscape) and prefsEntry.showCmdStatus       	then begin       		if txt       		then SetValue(statusPara, 'text, txt);              		if not newVal       		then statusGauge:hide()              		else if newMax = statusGauge.maxValue       		then begin       			SetValue(statusGauge, 'viewValue, newVal);       			statusGauge:show();		// in case it was hidden       			end              		else if newMax       		then begin       			statusGauge:close();       			statusGauge.maxValue := newMax;       			statusGauge.viewValue := newVal;	// usually 0       			statusGauge:open();       			end;              		TRUE;	// !!!e. for refresh?       		end;       end,     displayLine:       func(line)	// called by :addHTML, protoSerialProtocol(2.x)       begin       	lineNum := lineNum+1;       	//StrReplace(line, lf, "", nil);              	if StrLen(line) > 1 and Visible(Newtscape)	// moved earlier. skip if just cr       	then begin       		if debugFlag       		then Print(line);              		if prefsEntry.showCmdStatus       		then SetValue(statusPara, 'text, lineNum & $: && line);	// inline       		end;       end,     actionNum: nil,     UnRegisterCardSoup:       kMyUnRegCardSoup // non-standalone       ,     parseProgress:       func(view) // used by viewIdleScript and by DoProgress       if parseJob and curSourcePos	// !!!g. and curSource        then begin       	if /*kCparser or*/ HasSlot(parseJob, 'parseString)       	then begin       		if kDebugHTTP then Print(curSource);       		parseJob:parseString(curSource, parseJob.htmlApp)       		end              	else begin       //Print("parseProgress");       		:SetRun(true);	// !!!g. just do this once earlier?       		local slen :=       			if kNIE and curSourceBuf       			then curSourceBuf.last       			else if curSource	// !!!g       			then StrLen(curSource);       		local epos, line, results := {bytesSoFar: 0, sourceLength: slen};       		while curSource and curSourcePos < slen       		do begin       			epos :=       				if kNIE       				then CharPos(curSource, unicodeCR, curSourcePos)       				else StrPos (curSource, cr, curSourcePos);       			line := if kNIE       				then call kBigSubStr with (curSource, curSourcePos, if epos then epos-curSourcePos) // !!!b1       				else SubStr(curSource, curSourcePos, if epos then epos-curSourcePos);              			if kNIE and curSourceBuf and not epos	// assume lines not longer than buffer? otherwise while...       			then if curSource := curSourceBuf:next()       				then begin // more text. add to line       					epos := CharPos(curSource, unicodeCR, 0);       					StrMunger(line, StrLen(line), 0, curSource, 0, epos);       					end       				else curSourceBuf := curSourceBuf:?close();       				       			results.bytesSoFar :=        					if epos       					then if kNIE and curSourceBuf       						then curSourceBuf.first - kNewtWorksChunkSize + epos       						else epos       					else slen;       //Print("bytes:" && results.bytesSoFar);       			if :addHTML(line, results)       			then break :SysBeep(); // heap or store error?  return NIL              			if epos	       			then curSourcePos := epos+1 // skip cr       			else break;	// last line done, or </HTML> probably occurred              			if // !!!g. not view and       				not optionsAPI.noDelay	// test superfluous but nec?       			then return 		// otherwise just continue in loop       				if kNIE       				then AddDelayedSend(NewtsCape, 'parseProgress, '[nil], kLineDelay)       				else if Visible(NewtsCape)       				then kLineDelay       				else AddDelayedAction(       					Functions.Perform, [NewtsCape, 'parseProgress, '[nil]], kLineDelay);       			end;       		end;              	// end of doc but no </HTML>?       	if not optionsAPI.noStop       	then :stopHTML();       	NIL; // stop idle if running       	end,     SetStatus:       func(txt)       if (if kNIE then IsString(txt) else isInstance(txt, 'string))	// !!!k       then begin       	if optionsAPI       	then optionsAPI.helperApp:?setStatus(txt);	// !!!h              	if Visible(newtscape) and prefsEntry.showCmdStatus			// might not be open       	then SetValue(statusPara, 'text, txt);       	end    };URLtri :=    {viewBounds: {left: 1, top: 5, right: 11, bottom: 17},     prefSym: 'showLongURL,     viewClass: 74 /* clView */    };AddStepForm(NewtsCape, URLtri);// After Script for URLtrithisView := URLtri;begin	thisView._proto := kTriButton;	thisView.viewBounds.top := kTBmargin+1;	thisView.viewBounds.bottom := kTBmargin+11;endstatusTri :=    {viewBounds: {left: 1, top: 22, right: 11, bottom: 32},     prefSym: 'showCmdStatus,     viewSetupFormScript:       func()       begin       	viewBounds := RelBounds(       		1, 1 + if prefsEntry.showLongURL then kNewUIbuttonTopL else kNewUIbuttonTop, 10, 10);       	inherited:?viewSetupFormScript();       end,     viewClass: 74 /* clView */    };AddStepForm(NewtsCape, statusTri);// After Script for statusTrithisView := statusTri;thisView._proto := kTriButtonGoStopButton :=    {viewBounds: {left: -19, top: 3, right: -4, bottom: 18},     buttonClickScript:       func() // was same as File:Open Location       if status // running?       then begin       	newtscape:cancelRequest(kStopError);	// !!!k,g       	:setStatus(nil);	// just in case       	end              else begin       /*	local args := [curBook, if curBook then curBook.(kDataPath) else optionsAPI, "", 0, 0, :currentURL(nil), nil];       	if kNIE       	then AddDeferredSend(newtscape, 'gotoHREF, args)       	else AddDeferredAction(Functions.Perform, [newtscape, 'gotoHREF, args]);       */       	local dest := prefsEntry.popupMenu, cmd;        	if StrFilled(dest)       	then begin       		if kNIE and StrPos(kBookmarksLabel, dest, 0)       		then return bookmarkButton:doCommand(kOpenBookmarks);              		foreach cmd in [       			kOpenLocation, kOpenNotes, kOpenInbox, kOpenPaperback,       			if language='Japanese then kOpenWabumiUni,       			if kNIE and nos21 and GetRoot().(kNewtworksSym) then kOpenNewtworks,       			if kNIE and cacheHTML then kOpenHTMLcache,       			if kNIE and cacheImages then kOpenImagecache,       			if kNIE and nos21 and GetUnionSoup(kCacheNetHopperSoupName)	then kOpenNetHopperCache,       			]       		do  if cmd and StrPos(cmd, dest, 0)       			then return fileButton:doCommand(cmd);	// !!!t              		if kNIE	// !!!t       		then foreach cmd in [kNewerHTMLCacheItem, kNewerImageCacheItem]       			 do if cmd and StrPos(cmd, dest, 0)       				then return goButton:doCommand(cmd,nil);	// !!!u       		end;              	fileButton:doCommand(kOpenLocation);       	end,     viewJustify: 38,     stopIcon:       MakePixFamily(           GetResourceFromFile({filename:                 "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc", resource:                 149}),           GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF", resource:                  }),           [            {rsrcSpec:             GetResourceFromFile({filename:                   "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc",                   resource: 149}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 8}]);,     goIcon:       MakePixFamily(           GetResourceFromFile({filename:                 "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc", resource:                 148}),           nil,           [            {rsrcSpec:             GetResourceFromFile({filename:                   "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc",                   resource: 148}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 8}]);,     Status: nil,     SetStatus:       func(newStatus)       if status <> newStatus       then begin       //Print("new status:" && if newStatus then "Stop" else "Go" && newStatus);       	local oldStatus := status;       	status := newStatus;       	SetValue(self, 'icon,       		/*if status='wait       		then nil       		else*/ if status       		then stopIcon       		else goIcon);       	oldStatus;       	end,     _proto: @198 /* protoPictureButton */    };AddStepForm(NewtsCape, GoStopButton);StepDeclare(NewtsCape, GoStopButton, 'GoStopButton);// After Script for GoStopButtonthisView := GoStopButton;begin	thisView.icon := thisView.goIcon;	// !!!gendstatusPara :=    {viewBounds: {left: 2, top: -15, right: -2, bottom: -2},     viewFlags: 35,     viewFont: userFont10,     viewFormat: 257,     viewLineSpacing: 13,     viewJustify: 48,     childSym: 'statusPara,     viewSetupFormScript:       func()       begin       	newtscape.(childSym) := self;       	viewBounds := Clone(viewBounds); // just adjust top&bottom       	//same as errorPara.viewSetupFormScript except for next line?       	viewBounds.top := if prefsEntry.showLongURL then kNewUIstatusTopL else kNewUIstatusTop;       	viewBounds.bottom := viewBounds.top + kLineSpacing;       //Write("status field: "); Print(viewBounds);              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := statusFontJ;              	//inherited:?viewSetupFormScript();	// !!!b       end,     text: "",     viewClass: 81 /* clParagraphView */    };AddStepForm(NewtsCape, statusPara);// After Script for statusParathisView := statusPara;begin	if language='Chinese	then thisView.viewFont := kEspy10;endstatusGauge :=    {viewBounds: {left: -70, top: -15, right: 0, bottom: -2},     viewSetupFormScript:       func()       begin       	// same as statusPara (except font)       	newtscape.(childSym) := self;       	viewBounds := Clone(viewBounds); // just adjust top&bottom       	viewBounds.top := (if prefsEntry.showLongURL then kNewUIstatusTopL else kNewUIstatusTop) - 1;       	viewBounds.bottom := viewBounds.top + kLineSpacing - 2;       	// NO viewSetupFormScript!       end,     viewValue: 0,     childSym: 'statusGauge,     viewJustify: 32,     gaugeDrawLimits: nil,     _proto: @182 /* protoGauge */    };AddStepForm(NewtsCape, statusGauge);errorPara :=    {viewBounds: {left: 2, top: -5, right: -70, bottom: 8},     viewFlags: 35,     viewFont: userFont10,     viewFormat: 257,     viewLineSpacing: 13,     viewJustify: 48,     childSym: 'errorPara,     viewSetupFormScript:       func()       begin       	newtscape.(childSym) := self;       	viewBounds := Clone(viewBounds); // just adjust top&bottom       	viewBounds.top := (if prefsEntry.showLongURL then kNewUIerrorTopL else kNewUIerrorTop) + 1;       	viewBounds.bottom := viewBounds.top + kLineSpacing;       //Write("error field: "); Print(viewBounds);              	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := statusFontJ;              	//inherited:?viewSetupFormScript();	// !!!b       end,     text: "",     viewClass: 81 /* clParagraphView */    };AddStepForm(NewtsCape, errorPara);// After Script for errorParathisView := errorPara;begin	if language='Chinese	then thisView.viewFont := kEspy10;endhideButton :=    {     buttonClickScript:       func()       newtscape:hide()	// !!!g,f -- this is replaced by kHideNewtsCape in afterScript       ,     viewTransferMode: 1,     viewFormat: 2,     viewJustify: 160,     viewBounds: {left: -29, top: -15, right: -16, bottom: -2},     viewSetupFormScript:       func()       begin       	if kNIE and not nos21       	then viewBounds := OffsetRect(_proto.viewBounds,1,1);              	inherited:?viewSetupFormScript();       	if not kNIE       	then viewFormat := vfLtGray;       end,     _proto: @166 /* protoCloseBox */    };AddStepForm(NewtsCape, hideButton);// After Script for hideButtonthisView := hideButton;begin	local vb := thisView.viewBounds;	if kNIE	then begin		thisView.icon := @14;		vb.left := vb.left-1;		vb.top  := vb.top -1;		end	else begin		vb.top  := vb.top +1;	// !!!n		end;	thisView.buttonClickScript := kHideNewtsCape; // !!!gendquitButton := {_proto: @166 /* protoCloseBox */};AddStepForm(NewtsCape, quitButton);URLpara :=    {     _Reload:       func(view)	// !!!e. 2.1       viewButton:doCommand(kReload),     _Prefs:       func(view)	// !!!e. 2.1       infoButton:viewClickScript(nil)	// !!!k. buttonClickScript()	// !!!j. DoInfoPrefs()       ,     _History:       func(view)	// !!!e. 2.1       goButton:buttonClickScript(),     viewSetupDoneScript:       if kNIE       then DefineGlobalConstant('kNewtsCapeKeys, [       	{char:		$o,       	modifiers:	kCommandModifier,       	keyMessage:	'_File,       	name:		kOpenLabel, 	//LocObj?       	category:	kAppNameL,       	},              	{char:		$s,       	modifiers:	kCommandModifier,       	keyMessage:	'_File,       	name:		"Save",			// LocObj?       	category:	kAppNameL,       	},              	{char:		$b,       	modifiers:	kCommandModifier,       	keyMessage:	'_Bookmarks,       	name:		kBookmarksLabel,       	category:	kAppNameL,       	},              	{char:		$q,       	modifiers:	kCommandModifier,       	keyMessage:	'_Quit,       	name:		"Quit",			//LocObj?       	category:	kAppNameL,       	},              /*	{char:		$w,       	modifiers:	kCommandModifier,       	keyMessage:	'_Hide,       	name:		"Hide",			//LocObj?       	category:	kAppNameL,       	},       */              	{char:		$h,       	modifiers:	kCommandModifier,       	keyMessage:	'_History,       	name:		"History",		//LocObj?       	category:	kAppNameL,       	},              	{char:		$.,       	modifiers:	kCommandModifier,       	keyMessage:	'_Stop,       	name:		"Stop",			//LocObj?       	category:	kAppNameL,       	},              	{char:		$?,       	modifiers:	kCommandModifier + kShiftModifier,       	keyMessage:	'_Help,       	name:		LocObj("Help", 'helpItem),       	category:	"General",       	},              	{char:		$r,       	modifiers:	kCommandModifier,       	keyMessage:	'_Reload,       	name:		kReload,       	category:	kAppNameL,       	},              	{char:		$t,       	modifiers:	kCommandModifier,       	keyMessage:	'_LoadImages,       	name:		kLoadWithImages,	// "Images" only?       	category:	kAppNameL,       	},              	{char:		$[,       	modifiers:	kCommandModifier,       	keyMessage:	'_Back,       	name:		kBackItem,       	category:	kAppNameL,       	},              	{char:		$\1C,				// !!!f. left arrow       	modifiers:	kCommandModifier,       	keyMessage:	'_Back,       	name:		kBackItem,       	category:	kAppNameL,       	},              	{char:		$],       	modifiers:	kCommandModifier,       	keyMessage:	'_Forward,       	name:		kForwardItem,       	category:	kAppNameL,       	},              	{char:		$\1D,				// !!!f. right arrow       	modifiers:	kCommandModifier,       	keyMessage:	'_Forward,       	name:		kForwardItem,       	category:	kAppNameL,       	},              	{char:		$8,       	modifiers:	kCommandModifier, // + kShiftModifier,       	keyMessage:	'_NewtsCape,       	name:		"Hide/Show",	// LocObj??       	category:	kAppNameL,       	showChar:	$*,       	},              	{char:		$=,       	modifiers:	kCommandModifier,       	keyMessage:	'_Prefs,       	name:		LocObj("Prefs", 'prefsItem),       	category:	kAppNameL,       	},       ]);              if kNIE then       func()	// !!!e. 2.x       :?AddKeyCommands(kNewtsCapeKeys);       /*       begin       	local ARRAY keyDefs := kNewtsCapeKeys;       	local INT len := Length(keyDefs);       	local kdef;       	if GetRoot().(kLogicKbdSym)	// !!!g       	then begin       		keyDefs := Clone(keyDefs);       		keyDefs[len-2] := kdef := Clone(keyDefs[len-2]);       		kdef.char := $];       		kdef.modifiers := Bor(kdef.modifiers, kShiftModifier);       		keyDefs[len-1] := kdef := Clone(keyDefs[len-1]);       		kdef.char := $0;       		kdef.modifiers := Bor(kdef.modifiers, kShiftModifier);       		end;       	:?AddKeyCommands(keyDefs);       end       */,     viewFormat: 12625,     _Forward:       func(view)	// !!!e. 2.1       goButton:doCommand(kForwardItem, nil),     viewLineSpacing: 13,     viewQuitScript:       func() // !!!e       :?ClearKeyCommands(),     _Stop:       func(view)	// !!!e. 2.1       newtscape:cancelRequest(kStopError)	// see stopButton       ,     _NewtsCape:       func(view)	// 2.1. * !!!f. basically same as kCopperfieldProtoItem._NewtsCape       if Visible(newtscape)       then call kHideNewtsCape with ()	// !!!g. newtscape:hide()       else newtscape:?open(),     viewFlags: 14849,     _Help:       func(view)	// !!!e. 2.1       infoButton:DoInfoHelp(),     _Quit:       func(view)	// !!!e. 2.1       newtscape:close(),     viewBounds: {left: 2, top: 22, right: -2, bottom: 74},     ViewKeyDownScript:       func(char,flags)	// !!!e       if char = unicodeCR       then begin       	newtscape.mykbd:?close();       	fileButton:doCommand(kOpenLocation);	// returns true. :getURL?       	end       //else nil       ,     _LoadImages:       func(view)	// !!!e. 2.1       viewButton:doCommand(kLoadWithImages),     _Back:       func(view)	// !!!e. 2.1       goButton:doCommand(kBackItem, nil),     textFlags:       1<<10 //vSingleKeyStrokes       ,     viewJustify: 48,     _Bookmarks:       func(view)	// !!!e. 2.1       bookmarkButton:doCommand(kOpenBookmarks)	//buttonClickScript()       ,     _File:       func(view)	// !!!e. 2.1       fileButton:buttonClickScript(),     viewSetupFormScript:       func()       begin       	local opened := prefsEntry.showLongURL;       	self.viewBounds := SetBounds(kTriMargin, kTBmargin,       		if opened //or (kNIE and KeyBoardConnected())       		then -25 else -46,	// right inset       		kTBmargin + (kLineSpacing * if opened then kURLlines else 1)       		);       	SetKeyView(self, if text then StrLen(text) else 0);       //Write(if opened then "long" else "short" && "URLpara: "); Print(viewBounds);              	/*	always regular font???       	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       	then viewFont := statusFontJ;       	*/       	//inherited:?viewSetupFormScript();	// !!!b       end,     viewClass: 81 /* clParagraphView */,     text: "",     viewFont: userFont12    };AddStepForm(NewtsCape, URLpara);StepDeclare(NewtsCape, URLpara, 'URLpara);// After Script for URLparathisView := URLpara;begin	//thisView.viewBounds := SetBounds(kTriMargin-1,5, -24,18);	RemoveSlot(thisView, 'viewBounds);	//if kNIE then thisView.text := "http://";	if kNIE	// !!!e	then begin		thisView._NewtsCape := kCopperfieldProtoItem._NewtsCape;		end	else begin		RemoveSlot(thisView, 'viewKeyDownScript);	// just cr		// see viewSetupDoneScript/kNewtsCapeKeys		RemoveSlot(thisView, 'viewSetupDoneScript);		RemoveSlot(thisView, 'viewQuitScript);		RemoveSlot(thisView, '_Back);		RemoveSlot(thisView, '_Bookmarks);		RemoveSlot(thisView, '_File);		RemoveSlot(thisView, '_Forward);		RemoveSlot(thisView, '_Help);		RemoveSlot(thisView, '_History);		RemoveSlot(thisView, '_LoadImages);		RemoveSlot(thisView, '_NewtsCape);		RemoveSlot(thisView, '_Prefs);		RemoveSlot(thisView, '_Quit);		RemoveSlot(thisView, '_Reload);		RemoveSlot(thisView, '_Stop);		end;end// Before Script for infoButton// see popupPrefsDefineGlobalConstant('kEncIndex, if kExpiringVersion then 3 else if kNIE then 2 else 1); // !!!ninfoButton :=    {viewBounds: {left: 3, top: -16, right: 16, bottom: -3},     DoInfoAbout:       func()       BuildContext({	// !!!g       	_proto: GetLayout("AboutLayout"),       	newtscape: newtscape,       	prefsEntry: prefsEntry,       	}):open(),     DoInfoHelp:       func()       begin       	local isbn := prefsEntry.helpISBN;       	if StrFilled(isbn) and call kFindBook with (isbn,nil)       	then GetRoot().(kBookReaderSymbol):openBook(isbn);       end;,     viewJustify: 134,     GenInfoAuxItems:       func()       /*if kBuild1x or GetRoot().(kRegistrationPackage)       then [kRegisterOption] //[{icon: kRegisterIcon, item: "Register"}]       else '[]       */       begin	// !!!h. was DoInfoPrefs       	local popup := Clone(popupPrefs), curOption, root := GetRoot();       	if kExpiringVersion       	then popup[0] := call kFixMenuItem with (kRegisterOption, root.(kRegistrationPackage));              	// !!!k. test 1.x???       	local prefNames := :myGetAppPrefs(kPackageName).prefNames, prefName, pos := kEncIndex+2;       	ArrayMunger(popup, pos, 1, Array(Length(prefNames),nil),0,nil); // replace Reset All, keep pickSep       	foreach prefName in prefNames       	do begin       		curOption := {item: prefName};       		if StrEqual(prefName, prefsEntry.prefName)       		then curOption.mark := kBullet;       		popup[pos] := curOption;       		pos := pos+1;       		end;       	processStart := Length(popup) - kCacheOnly;	//???              	if kNIE       	then begin       		if not call kInitGlobal with ('protos,{}).NTE_protoPrefsRollItem       		then popup[kEncIndex] := call kFixMenuItem with (kEncodingOption, nil);              		AddArraySlot(popup, {item: kCacheItem});	// !!!r. ok for serial       			//{item: call kFixMenuItem with (kCacheItem,	GlobalFnExists('InetDisplayStatus))});	// InetGrabLink. 2.0? InetGrabLinkVerbose       		end;       	       	AddArraySlot(popup, {item: call kFixMenuItem with (kPkgItem, NewtPack)});       	if kNIE       	then AddArraySlot(popup, {item: call kFixMenuItem with (kNWitem, root.(kNewtworksSym))});              	local apps := :installHTMLApp(nil,nil), app;       	if Length(apps) > 0       	then begin       		AddArraySlot(popup, 'pickSeparator);       		foreach app in apps	// !!!k. a frame. order?       		do AddArraySlot(popup, app);       		end;              	if processOption >= Length(popup) - processStart	// de-install       	then processOption := kProcessDefault;              	if isFrame(curOption := popup[processStart + processOption])       	then begin       		popup[processStart + processOption] := curOption := Clone(curOption);       		curOption.mark := kBullet;	// !!!k       		end;              	popup;       end,     DoInfoAux:       func(ARRAY items, INT cmd)	// !!!h. formerly pickActionScript       begin       	local sel := items[cmd], view;              	if kExpiringVersion and sel = kRegisterOption       	then begin       		view := GetRoot().(kRegistrationPackage);       		view:Open();       		view:ExternalRegister(kRegFrame);       		end              	else if sel = kGeneralOption       	then begin       		view := BuildContext({	// !!!g       			_proto: GetLayout("NIEPrefsLayout"),       			newtscape: newtscape,       			prefsEntry: prefsEntry,       			//myPopup: myPopup,	// !!!j. ~J       			});       		view:Open();       		if kNIE       		then SetKeyView(view, 0);	// !!!f       		end              	else if sel = kAppearanceOption       	then begin       		view := BuildContext({	// !!!g       			_proto: GetLayout("TagPrefsLayout"),       			newtscape: newtscape,       			tagDict: tagDict,       			tagDictOrig: tagDictOrig,       			inputDict: inputDict,       			inputDictOrig: inputDictOrig,       			prefsEntry: prefsEntry,       			//myPopup: myPopup,	// !!!j. ~J       			});       		view:Open();       		if kNIE       		then SetKeyView(view, 0);	// !!!f       		end              	else if kNIE and sel = kEncodingOption       	then begin       		local newItem := Clone(encodingItem);       		newItem._proto := call kInitGlobal with ('protos, {}).NTE_protoPrefsRollItem;       		OpenPrefsTo(newItem);       		end              	else if (cmd := cmd - processStart) >= 0       	then begin       		if isFrame(sel) and sel.item[0] <> $(		// avoid picked "non-pickable" items       		then processOption := cmd;       		if cmd <= kDisplayAll       		then :setPreference('processOption, cmd);	// !!!c       		end              	else if isFrame(sel)	// !!!o       	then if StrEqual(sel.item, prefsEntry.prefName)	// !!!k. prefName       		then :DoInfoAux([kGeneralOption],0)       		else begin       //Print("switching to PrefSet:" && sel.item);       			local mainPrefs := :myGetAppPrefs(kPackageName), newPrefsEntry;       			if StrEqual(sel.item, mainPrefs.prefName)       			then begin       				mainPrefs.curPrefTag := kPackageName;	// mainPrefs.tag       				newPrefsEntry := mainPrefs;       				end       			else newPrefsEntry := :myGetAppPrefs(mainPrefs.curPrefTag := sel.item & $: & kAppName);              			newtscape:updateSet(prefsEntry, 'change, newPrefsEntry, mainPrefs, true);	// !!!n       			end;       end,     popupPrefs:       [kRegisterOption, // !!!h       kGeneralOption, kAppearanceOption, kEncodingOption, 'pickSeparator,	// see kEncIndex (beforeScript)       nil,	// placeholder for PrefSets       'pickSeparator,       		/* in this order       		kDisplayItem	:= 0;       		kDisplayPage	:= 1;       		kDisplayPage1	:= 2;       		kDisplayAll		:= 3;       	 	kCacheOnly		:= 4;       		kSavePkg		:= 5;       		kSaveNW			:= 6;       		*/       {item: LocObj("Process", 'processItem) & $: && LocObj("Display Item",	'displayItemItem)}, // !!!e       {item: LocObj("Display Page",	'displayPageItem)},       {item: LocObj("Display Page1",	'displayPage1Item)},       {item: LocObj("Display All",	'displayAllItem)},       ],     encodingItem:       {_proto:	nil,	// fill in when used       overview:			kAppName,       defaultEncoding:	kDefaultEncoding,       //classSpec:		{subClass: 'string},              viewSetupFormScript: func()       	begin       		appPrefs := GetRoot().(kAppSymbol).prefsEntry; //GetAppPrefs(kAppSymbol, {})       		if appPrefs.NTEncoding = nil       		then appPrefs.NTEncoding := {};       		self.prefs := appPrefs.NTEncoding;       		SetKeyView(self,0);		// !!!f       		inherited:?viewSetupFormScript();       	end,              viewQuitScript: func()       	begin       		EntryChangeXmit(appPrefs, nil);       		inherited:?viewQuitScript();       	end,       },     viewClickScript:       func(unit)	// !!!j,e. since cancel gets called at strange times (remove for NIE only)       if kNIE       then begin       	popupView := nil;       	local val := inherited:viewClickScript(unit);       	if kNCfont and popupView and prefsEntry.systemFontFamily <> kSystemFontSym       	then SetValue(popupView, 'viewFont, menuFontJ);	//{family: sym, face: kFaceBold, size: 10});       	val;       	end       else begin	// !!!h. formerly done in afterScript       	AppInfoItems := Clone(_proto.AppInfoItems);       	ArrayMunger(AppInfoItems, Length(AppInfoItems), 0,       		:GenInfoAuxItems(), 0,nil);       	inherited:viewClickScript(unit);       	end                     ,     _proto: _v76_0    };AddStepForm(NewtsCape, infoButton);StepDeclare(NewtsCape, infoButton, 'infoButton);// After Script for infoButtonthisView := infoButton;begin	if not kExpiringVersion	// !!!h	then ArrayRemoveCount(thisView.popupPrefs, 0, 1);	// Register	if kNIE	then begin		thisView._proto := @478; //protoInfoButton		if language<>'English	// !!!d		then thisView.stdItems := [			{item: LocObj("About", 'aboutItem), msg: 'DoInfoAbout}, 			{item: LocObj("Help",  'helpItem),  msg: 'DoInfoHelp}, 			//{item: LocObj("Prefs", 'prefsItem), msg: 'DoInfoPrefs},	// !!!h			];		if not kNCfont		then RemoveSlot(thisView, 'viewClickScript);	// !!!j		end	else begin		//call kFixupInfoItems with (thisView);	// !!!h		local items := thisView.AppInfoItems := [];		if HasSlot(thisView, 'DoInfoAbout)		then AddArraySlot(items, LocObj("About", 'aboutItem));		if HasSlot(thisView, 'DoInfoHelp)		then AddArraySlot(items, LocObj("Help", 'helpItem));		//if HasSlot(thisView, 'DoInfoPrefs)		//then AddArraySlot(items, LocObj("Prefs", 'prefsItem));		AddArraySlot(items, 'pickSeparator);		thisView.AuxOffset := Length(items);		ArrayRemoveCount(thisView.popupPrefs, kEncIndex+1, 1);	// Encoding. !!!h		RemoveSlot(thisView, 'encodingItem);		end;	thisView.processStart := Length(thisView.popupPrefs) - kCacheOnly;		thisView.viewSetupFormScript := kShiftButton;	thisView.viewBounds := RelBounds(kTriMargin+1, kNewUIbuttonTop, 13, 13);	thisView.viewJustify := vjParentLeftH + vjParentTopV + vjCenterH + vjCenterV;	// note: fileButton etc. just happen to be next siblingsendfileButton :=    {     buttonClickScript:       func()       begin       	curSoupTitles := NIL;       	curSoupName := "";       	popup := [];              	// OPEN       	local url := :currentURL(nil), root := GetRoot(), titles;       	AddArraySlot(popup, call kFixMenuItem with (kOpenLocation, url));              	AddArraySlot(popup, call kFixMenuItem with (kOpenNotes,       		not (titles := :getSoupTitles(notesSoupName)) or Length(titles) > 0));	// !!!k. @717,              	AddArraySlot(popup, call kFixMenuItem with (kOpenInbox,       		not (titles := :getSoupTitles(inboxSoupName)) or Length(titles) > 0));              	AddArraySlot(popup, call kFixMenuItem with (kOpenPaperback,       		not (titles := :getSoupTitles(kPaperback)) or Length(titles) > 0));              	//if root.(kPersonalMediaSym)       	//then AddArraySlot(popup, kOpenPersonalMedia);              	if language='Japanese       	then AddArraySlot(popup, call kFixMenuItem with (kOpenWabumiUni,       		not (titles := :getSoupTitles(kWabumiUni)) or Length(titles) > 0));       		       	local newtWorks := kNIE and root.(kNewtworksSym);       	if kNIE       	then begin       		AddArraySlot(popup, call kFixMenuItem with (kOpenNewtworks, newtWorks));       		AddArraySlot(popup, call kFixMenuItem with (kOpenHTMLcache, cacheHTML and GetUnionSoup(cacheHTML)));       		AddArraySlot(popup, call kFixMenuItem with (kOpenImagecache, cacheImages and GetUnionSoup(cacheImages)));       		AddArraySlot(popup, call kFixMenuItem with (kOpenNetHopperCache, nos21 and GetUnionSoup(kCacheNetHopperSoupName)));       		if kSubmitQ then AddArraySlot(popup, kOpenSubmitCache);	// !!!g       		end;       	//GetRoot().Connection.stepChildren[0].titleIcon       	AddArraySlot(popup, call kFixMenuItem with (if commEndPt then kCloseDesktop else kOpenDesktop, root.(kSloupSymbol):?connectionLabels(kNewEndpoint)));       	AddArraySlot(popup, 'pickSeparator);              /* complete list would contain:       	kOpenLocation							[IN,]       	kOpenNotes       	kOpenInbox								       	kOpenPaperback       	kOpenPersonalMedia       	kOpenNewtworks							[IN, NIE]       	kOpenHTMLcache							[NIE]       	kOpenImagecache							[NIE]       	kOpenDesktop/kCloseDesktop       	-----       	kSaveAsPackage       	kSaveHTMLNotes/kSaveImageNotes       	kSaveHTMLNewtworks/kSaveImageNewtworks	[IN, NIE]       	kSaveBookNewtworks       	-----       	kRemoveBook       	kRemoveCache							[NIE]       	kResetHTTP								[NIE]       */              	// SAVE       	AddArraySlot(popup, call kFixMenuItem with (kSaveAsPackage, NewtPack and curBook and Length(curBook.(kContentsPath)) > 0));              	if kNIE        	then begin       		url := :currentURL(true); // for here, RemoveCache       		local img := cacheImages and url and       			(call kImageExtension with (url) /*or       			//call kGetURLCache with (cacheImages, url, nil, nil,nil)*/);       		AddArraySlot(popup,       			call kFixMenuItem with (if img then kSaveImageNotes else kSaveHTMLNotes, url));       		AddArraySlot(popup,       			call kFixMenuItem with (if img then kSaveImageNewtworks else kSaveHTMLNewtworks, url and newtWorks));       		end;              	// SAVE (misc).       	if kNIE       	then AddArraySlot(popup, call kFixMenuItem with (kSaveBookNewtworks, newtWorks));              	AddArraySlot(popup, 'pickSeparator);       	// REMOVE       	AddArraySlot(popup, call kFixMenuItem with (kRemoveBook, curBook));	// !!!e       	if kNIE       	then begin       		AddArraySlot(popup, call kFixMenuItem with (kRemoveCache, url));       		AddArraySlot(popup, 'pickSeparator);       		AddArraySlot(popup, call kFixMenuItem with (kResetHTTP, wwwFSM and GlobalFnExists('InetDisplayStatus)));       		end;              	if kNIE       	then begin       		local pp := inherited:buttonClickScript();	// kFixButtonClickScript       		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       		then SetValue(pp, 'viewFont, menuFontJ);	//{family: sym, face: kFaceBold, size: 10});       		pp;       		end       	else :myPopup(popup, nil, nil);       end,     text: "File",     viewBounds: {left: 3, top: 5, right: 30, bottom: 16},     pickActionScript:       func(INT cmd)       if curSoupTitles // Open a specific doc       then begin        	local obj := curSoupTitles[cmd];       	curSoupTitles := NIL;       	if kNIE	// in case of error       	then AddDeferredSend(self,'openDoc,[cmd,obj])       	else AddDeferredAction(Functions.Perform, [self, 'openDoc, [cmd,obj]]);       	end              // initial selection       else begin       	if kNIE 	// protoPopupButton highlighting       	then inherited:pickActionScript(cmd);       	local sel := popup[cmd];       	popup := NIL;       	try :doCommand(sel) onexception |evt.ex| do nil;       	end,     curSoupName: nil,     curSoupTitles: nil,     openDoc:       /*DefineGlobalConstant('getHandlesFunc, func(new, items, docHandles, blotter) // for Personal Media       begin       	local docHandle;       	if new       	then begin // cursor based. >= PM 2.1       		docHandle := docHandles:entry();       		while docHandle       		do begin       			AddArraySlot(items,       				{item: docHandle:GetTitle(), docHandle: docHandle, blotter: blotter});       			docHandle := docHandles:next();       			end;       		end       	else if isArray(docHandles)       	then foreach docHandle in docHandles       		do AddArraySlot(items,       			{item: docHandle.title, docHandle: docHandle, blotter: blotter});       	items;       end);       */              func(cmd, obj) // Open a specific doc       if kNIE and curSoupName = kOpenNewtworks       then begin       	:displayURL(kNewtworksSoupName & $: & obj.item);       	:dispatchFile(kHTMLMediaType, "",       		call kNewtWorksGetDoc with (EntryFromObj(obj)), nil);       	end              else if kNIE and (curSoupName = kOpenNetHopperCache)	// like EEtransfer(see matchHTMLtitle)       then begin       	local href := obj.URL, data := obj.data;       	//:displayURL(href);	// redundant       	if obj.type = kHTMLMediaType       	then :dispatchFile(kHTMLMediaType, href, call kCopyRawHTML with (data), nil)       	else :dispatchFile(kGIFMediaType, href, data, nil); 	// assume GIF       		//	if isBinary(data)       		//	then :convertImage(kGIFMediaType, href, data, {_proto: optionsAPI, cacheImages: nil, rawImage: nil}, nil)       		//	else data, nil);	// already converted       	end              else if curSoupName = kOpenDesktop       then :connect(actionNum := cmd,nil,nil)	// save temporarily              /* begin       	if obj = kOpenSerial9600       	then :connect(protoSerialProtocol.configOptions, NIL)              	else if obj = kOpenSerial57600       	then begin       		local cfg := Clone(protoSerialProtocol.configOptions);       		cfg[1] := kconfigBPS57600;       		:connect(cfg, NIL);       		end              	else if obj = kOpenADSP       	then if prefsEntry.hostADSP       		then :Confirm(       			title,       			"ADSP:" && LocObj("connect to", 'connectToMsg) & $: && prefsEntry.hostADSP,       			self, 'confirmADSP)       		else :ConfirmADSP(nil);       	end       */                     else if kNIE and curSoupName = kSaveBookNewtworks and obj := call kFindBook with (obj, nil)       then call kNewtWorksNewDoc with (obj.title, obj.(kContentsPath))                     /*       else if curSoupName = kDumpText and obj := call kFindBook with (obj, nil)       then :dumpBook(obj)              else if curSoupName = kOpenPersonalMedia       then begin       	if obj.docHandle and not obj.blotter // a document?       	then begin       		:displayURL(kPersonalMedia & $: & obj.item);       		return :dispatchFile(       			kHTMLMediaType, "",       			:matchHTMLTitle(       				obj.docHandle:getTemplate():?exportText(),       				true, true, nil, nil, nil), // unused. kTitleStart, kTitleStop),       			nil);       		end;              	// get blotters or docs list       	local docMngr := GetRoot().(kPersonalMediaSym).pt_clDocMngr;       	local pmnew := docMngr.version;       	local flstuff := // used in RQuery and GetChildren       		if pmnew       		then '{none: [tagClDocMngrRecycled]} 	// >= 2.1       		else func(fl) BAND(fl,1)=0;  			// 1.55,2.0       	local ARRAY args;              	if obj.store       	then begin // get blotters       		args := [obj.store, 'pt_protoBlotter, flstuff, nil];       		if pmnew then AddArraySlot(args, nil);       		curSoupTitles := call getHandlesFunc with (       			pmnew,       			[call kMakeSeparatorItem with (LocObj("Workspaces", 'workspacesItem)), 'pickSeparator],       			Perform(docMngr:new(kPMSoupName), 'RQuery, args),       			true);       		:myPopup(curSoupTitles, 2, nil); // autopick if only 1       		end              	else // a blotter. get docs       		begin       		curSoupTitles := call getHandlesFunc with (       			pmnew,       			[call kMakeSeparatorItem with (LocObj("Docs", 'docsItem)), 'pickSeparator],       			obj.docHandle:GetChildren('[pt_protoTextDoc, pt_protoEditPad], flstuff, nil),       			nil);       		:myPopup(curSoupTitles, nil, nil);       		end;       	end       */              else begin // Notes, Inbox, Paperback, WabumiUni       	:displayURL(curSoupName & $/ & if kNIE then obj.item else obj);       	if kNIE       	then if isArray(obj := :matchHTMLtitle(       			if obj.value then obj.value else EntryFromObj(obj), // Notes/Inbox or Paperback?       			true, nil, nil, nil, StrEqual(curSoupName,inboxSoupName)))       		then Perform(self, 'dispatchFile, obj) // other media types?       		else :dispatchFile(kHTMLMediaType, "", obj, nil)       	else :dispatchFile(       			kHTMLMediaType, "",        			:findHTMLentry(curSoupName, obj, true, kTitleStart, kTitleStop),       			nil);       	end,     popup: nil,     viewJustify: 8388614,     viewFlags: 515,     childSym: 'fileButton,     doCommand:       func(sel)       begin       	curSoupName := sel;		// same as menu string unless modified below       	local url := :currentURL(true), bm, txt, entry, titlesym;       	local edata := if kNIE and curBook and curBook.(kBasePath) = url then curBook.(kEdataPath); // StrEqual?       	local newtWorks := kNIE and nos21 and GetRoot().(kNewtworksSym);              	if sel = kOpenLocation       	then begin       		// should Referer be automatically set by gotoHREF?       		if url := :currentURL(nil)       		then begin       			local args := [curBook, if curBook then curBook.(kDataPath) else optionsAPI, "", 0, 0, url, nil];       			// these return true (for URLpara keydown)       			if kNIE       			then AddDeferredSend(self, 'gotoHREF, args)       			else AddDeferredAction(Functions.Perform, [self, 'gotoHREF, args]);       			end;       		end              	else if (if sel = kOpenNotes       		then curSoupName := notesSoupName       		else if sel= kOpenInbox       		then curSoupName := inboxSoupName       		else if sel = kOpenPaperback       		then curSoupName := kPaperback       		else if language='Japanese and sel = kOpenWabumiUni       		then curSoupName := kWabumiUni)       	then begin       		if not curSoupTitles := NewtsCape.(titlesym := Intern(curSoupName & kTitles)) // :getSoupTitles       		then begin       			if kBuild20 then call kShowBusyBoxFunc with (true);       			// !!!k. cache for Paperback and WabumiUni also       			NewtsCape.(titlesym) := curSoupTitles := :findHTMLEntry(curSoupName, [], true, kTitleStart, kTitleStop);       			Sort(curSoupTitles, '|str<|, if kNIE then 'item);       			end;       		:myPopup(curSoupTitles, nil, true);	// !!!j       		end              /*       	else if sel = kOpenPersonalMedia       	then begin       		local store;       		curSoupTitles := [call kMakeSeparatorItem with (LocObj("Stores", 'storesItem)), 'pickSeparator];       		foreach store in GetStores()       		do AddArraySlot(curSoupTitles, {item: store.name, store: store});              		:myPopup(curSoupTitles, 2, nil); // autopick if only 1       		end       */              	else if kNIE and (sel = kOpenHTMLcache or sel = kOpenImagecache)       	then begin       		local fsym, psym, ssym;       		//curSoupName := NIL;	// !!!g       		if sel = kOpenHTMLcache       		then begin       			curSoupName := cacheHTML; fsym := LocObj("HTML", 'HTMLlabel); // !!!f. LocObj("HTML Cache", 'HTMLCacheLabel);       			psym := 'HTMLlabel; //'followHTML; //ksym := 'keepQueryHTML;       			ssym := 'cacheHTML;       			end       		else begin       			curSoupName := cacheImages; fsym := LocObj("Images", 'imagesLabel); // !!!f LocObj("Image Cache", 'ImageCacheLabel);       			psym := 'ImageLabel; //'followImages; //ksym := 'keepQueryImages;       			ssym := 'cacheImages;        			end;              		if curSoupName       		then BuildContext({       			_proto: GetLayout("protoCacheBkmarkOverview"),       			newtscape: newtscape,       			soupName: curSoupName,       			title: fsym,       			prefSym: psym,       			cacheSizeSym: ssym,       			querySpec: {indexPath: '_modTime},       			}):open();       		end              	else if kSubmitQ and sel = kOpenSubmitCache	// !!!g       	then BuildContext({       			_proto: GetLayout("protoCacheBkmarkOverview"),       			newtscape: newtscape,       			soupName: kCacheSubmitSoupName,       			title: kSubmitQueue,       			submit: true,       			itemName: true,       			}):open()              	else if kNIE and sel = kOpenNewtworks       	then begin       		if newtWorks       		then begin       			if kBuild20 then call kShowBusyBoxFunc with (true);       			curSoupTitles := [];       			local cursors := [], cursor;       			gc();       			if prefsEntry.nwSummary	// !!!a       			then begin       				cursor := GetUnionSoupAlways(kNewtworksSoupName):Query({       					validTest: func(e)       						call kIsHTML with (e.summary)	// !!!j       						//or (EntryUndoChanges(e) and nil)       					});       				entry := cursor:entry();       				while entry       				do begin       					AddArraySlot(curSoupTitles, {item: entry.title, _alias: MakeEntryAlias(entry)});       					entry := NIL;       					entry := cursor:next();       					end;       				end       			else begin       				// slow for large docs/number of docs       				newtWorks:Find(kHTMLStart, cursors, 'globalFind, {setStatus: kNilFunc1}); // kIsHTML?       				foreach cursor in cursors       				do begin       					cursor := cursor.cursor;       					entry := cursor:reset();       					while entry       					do begin       						AddArraySlot(curSoupTitles, {item: entry.title, _alias: MakeEntryAlias(entry)});       						entry := NIL;       						entry := cursor:next();       						end;       					end;       				end;              			:myPopup(Sort(curSoupTitles, '|str<|, 'item), nil, true); // !!!j       			end;       		end              	else if sel = kOpenDesktop       	then begin       		if curSoupTitles := GetRoot().(kSloupSymbol):connectionLabels(kNewEndpoint)       		then :myPopup(curSoupTitles, nil, nil)       					//[kOpenSerial9600, kOpenSerial57600, kOpenADSP], nil, nil)       		end              	else if sel = kCloseDesktop       	then :disconnect(true)	// only if Sloup installed, open occurred earlier.              	else if sel = kSaveAsPackage       	then begin       		if NewtPack and curBook and Length(curBook.(kContentsPath)) > 0       		then if kNIE       			then AddDeferredSend(self, 'saveBook, [curBook, libook, exbook])       			else AddDeferredAction(Functions.Perform, [self, 'saveBook, [curBook,libook,exbook]]);       		end              	else if kNIE and (       			sel = kSaveHTMLNotes 	 or sel = kSaveImageNotes or       			sel = kSaveHTMLNewtworks or sel = kSaveImageNewtworks)       	then begin       		local title := if curBook then curBook.title else url;       		if (sel = kSaveImageNotes or (newtWorks and sel = kSaveImageNewtworks)) and url and       			bm := call kGetURLCache with (cacheImages, url, 'bitmap, edata, true)       		then AddDeferredCall(kSaveDocument, [       			if sel = kSaveImageNewtworks			// soup = graphic object       			then bm       			else if sel = kSaveImageNotes       			then {       				viewStationery: 'pict,       				viewBounds: RelBounds(noteLeft, noteTop, noteWidth, bm.bounds.bottom - bm.bounds.top),       				icon: bm,       				},       			// field nil == use "soup" as obj       			url, NIL, edata, title, kNIE and sel = kSaveImageNewtworks])              		else if (sel = kSaveHTMLNotes or (newtWorks and sel = kSaveHTMLNewtworks)) and url       		then AddDeferredCall(kSaveDocument, [cacheHTML, url, 'text, edata, title, kNIE and sel = kSaveHTMLNewtworks]);       		end              	else if kNIE and newtWorks and sel = kSaveBookNewtworks       	then :myPopup(curSoupTitles := call kAllBooks with (), nil, nil)              	else if sel = kRemoveBook       	then begin       		if curBook then :removeApp(true,nil);       		end              	else if kNIE and sel = kRemoveCache       	then begin       		if url       		then if call kImageExtension with (url) or       				not (entry := call kGetURLCache with (cacheHTML, url, '_delete, edata, nil))       			then call kGetURLCache with (cacheImages, url, '_delete, edata, nil)       			//else EntryRemoveFromSoupXmit(entry, kAppSymbol);       		end              	else if kNIE and sel = kResetHTTP       	then begin       		if wwwFSM and GlobalFnExists('InetDisplayStatus)       		then newtscape:resetFSM();       		end              	else if kNIE and sel = kOpenNetHopperCache       	then begin       		local soup;       		if nos21 and soup := GetUnionSoup(kCacheNetHopperSoupName)       		then begin       			curSoupTitles := [];       			gc();       			local cursor := soup:Query(nil), type, data;       			entry := cursor:entry();       			while entry       			do begin       				data := entry.fStreamVBO;       				if (if (type := entry.fMIMEDataType)[0] = 'text and type[1] = 'html // pathExpr?       					then data and (type := kHTMLMediaType)       					else if type[0] = 'image and type[1] = 'gif       					then type := kGIFMediaType) // other types, e.g., text/html?       				then AddArraySlot(curSoupTitles, {       						item: entry.fTransReq.fTitle,       						data: if data then data else entry.fFrameObject.icon, // for converted GIF?       						URL: call kNetHopperURL with (entry.fTransReq.targetURL),       						type: type,       						});       				entry := nil;       				entry := cursor:next();       				end;       			cursor := nil;       			:myPopup(curSoupTitles, nil, true);       			end;       		end;       end,     pickCancelledScript:       func()       begin       	curSoupTitles := popup := NIL;       	inherited:?pickCancelledScript();       end,     getSoupTitles:       func(soupName)	// !!!k       newtscape.(Intern(soupName & kTitles)),     _proto: @226 /* protoTextButton */    };AddStepForm(NewtsCape, fileButton);// After Script for fileButtonthisView := fileButton;begin	thisView.text := LocObj("File", 'fileLabel);	if kNIE	then begin		thisView._proto := protoPopupButton;		RemoveSlot(thisView, 'popup);		end	else begin		RemoveSlot(thisView, 'viewJustify);		end;	if language='German or language='French	// !!!e	then thisView.viewBounds.right := thisView.viewBounds.right + 10	else if language='Chinese	then thisView.viewBounds.right := thisView.viewBounds.right + 11 //5	else if language='Korean	then thisView.viewBounds.right := thisView.viewBounds.right + 8	else if language='Russian	then thisView.viewBounds.right := thisView.viewBounds.right + 20;	thisView.viewJustify := vjSiblingRightH + vjParentTopV + vjCenterH + vjCenterV + vjNoLineLimits;	thisView.viewSetupFormScript := kShiftButton;	thisView.viewBounds.left := 5;	thisView.viewBounds.right := thisView.viewBounds.right + 2;	//thisView.viewBounds.left := 7;	// 3+2+2	//thisView.viewBounds.right := thisView.viewBounds.right + 4;	// 2+2	end/*here's how languages modify buttons at present		C	F	G	J	K	RFile	+11 +10	+10		+8	+20View	+3		+7			+20Go		+11		+4		+8	+20Bk		-25	-10	-25		-16	+20*/viewButton :=    {     buttonClickScript:       func()       begin       	popup := [];              /* complete list would contain:       	kCurrentBook       	-----       	kReload			[IN, NIE]       	kLoadwithImages       	-----       	kViewSource       */              	local url := if kNIE then :currentURL(true);	//viewer := ,        	AddArraySlot(popup, call kFixMenuItem with (kCurrentBook,       		if curBook       		then not call kViewIsOpenFunc with (GetRoot().(kBookReaderSymbol))       		else url));	// !!!k              	/*       	AddArraySlot(popup, call kFixMenuItem with (kBookProperties, curBook));       	AddArraySlot(popup, call kFixMenuItem with (kCloseOverView,       		curBook and viewer.browser       		and call kViewIsOpenFunc with (viewer.browser)));       	*/              	if kNIE       	then begin       		local isNIE := GlobalFnExists('InetDisplayStatus);       		AddArraySlot(popup, 'pickSeparator);       		AddArraySlot(popup, call kFixMenuItem with (kReload, url and isNIE));              		local ishtml :=        			url and cacheHTML and        			not call kImageExtension with (url); /*or call kGetURLCache with (cacheImages, url, nil, nil, nil)*/       		AddArraySlot(popup, call kFixMenuItem with (kLoadWithImages, ishtml and cacheImages and isNIE));       		AddArraySlot(popup, call kFixMenuItem with (kLoadLinks,  ishtml and isNIE));	// !!!c       		AddArraySlot(popup, call kFixMenuItem with (kLoadFrames, ishtml and isNIE));	// !!!e       		AddArraySlot(popup, 'pickSeparator);       		AddArraySlot(popup, call kFixMenuItem with (kViewSource, ishtml));       		AddArraySlot(popup, kHelpers);	// !!!o              		local pp := inherited:buttonClickScript();	// kFixButtonClickScript       		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       		then SetValue(pp, 'viewFont, menuFontJ);	//{family: sym, face: kFaceBold, size: 10});       		pp;       		end       	else :myPopup(popup, nil, nil);       end,     text: "View",     viewBounds: {left: 5, top: 5, right: 40, bottom: 16},     pickActionScript:       func(INT cmd)       begin       	if kNIE       	then inherited:pickActionScript(cmd);              	local sel := popup[cmd];       	popup := NIL;       	:doCommand(sel);	// !!!b       end,     viewJustify: 8389670,     popup: nil,     doCommand:       func(sel)       if sel = kCurrentBook       then if kNIE       	then if curBook       		then AddDeferredSend(self, 'refreshBook, [true])       		else fileButton:doCommand(kOpenLocation)	// !!!k       	else AddDeferredAction(Functions.Perform, [self, 'refreshBook, [true]])              /*       else if sel = kBookProperties       then BuildContext({       	_proto: GetLayout("BookProperties"),       	book: curBook,       	}):open()              else if sel = kCloseOverView       then begin       	if curBook       	then GetRoot().(kBookReaderSymbol).browser:?close();       	end       */              else if kNIE       then begin       	local url := :currentURL(true), entry, txt, isNIE := GlobalFnExists('InetDisplayStatus);       	local ishtml :=        			url and cacheHTML and        			not call kImageExtension with (url);       //Print(url);       	local edata :=       		if curBook and (txt := curBook.(kBasePath)) and url and StrEqual(txt, url)       		then curBook.(kEdataPath);              	if sel = kReload and url and isNIE       	then begin       		:removeApp(true,true);	// leave open if desired       /*       		// txt := nil;       		if call kImageExtension with (url) or       			not (entry := call kGetURLCache with (cacheHTML, url, '_delete, edata, nil))	// url,nil       		then call kGetURLCache with (cacheImages, url, '_delete, edata, nil);       */       		:getURL(url, {reload: true, trustHTML: nil, trustImages: nil});	// !!!k       		end              	else if sel = kViewSource and ishtml       		and txt := call kGetURLCache with (cacheHTML, url, 'text, edata, true)       	then :dispatchFile(kTextMediaType, url /*&& "[source]"*/, txt, nil)              	else if sel = kHelpers	// !!!o       	then begin       		txt :=       "<HTML><HEAD><TITLE>Newt's Cape Helper Apps</TITLE></HEAD><BODY>       <TABLE><TD WIDTH=80%><B>MIME Type</B><BR>Application<TD WIDTH=20%>Extensions"; // !!!u       		local helperApps := Clone(call kInitGlobal with ('helperApps, {})), type, helperFrame, sym, helperApp;       		foreach type,helperFrame in kBuiltInMediaTypes // !!!u. merge temporarily builtin with installed       		do helperApps.(type) :=       			if isFrame(helperApp := helperApps.(type))	// any installed helperApps for this type?       			then call kAppendFrame with (Clone(helperApp),helperFrame)       			else helperFrame;              		local types := foreach type,helperFrame in helperApps collect type;       		foreach type in Sort(types, '|sym<|, nil)       		do begin       			txt := txt & "\n<TR><TD COLSPAN=2><B>" & type & "</B>";	// !!!u       			foreach sym,helperApp in helperApps.(type)	//helperFrame       			do txt := txt & "\n<TR><TD>" & sym & "<TD>" & call kMyStringer with (helperApp.extensions);       			end;              		txt := txt & "\n</TABLE></BODY></HTML>";       		:dispatchFile(kHTMLMediaType, kHelpers, txt, nil)       		end              	else if ishtml and isNIE and ((sel = kLoadWithImages and cacheImages) or sel = kLoadLinks or sel = kLoadFrames) // !!!e,c       	then if entry := call kGetURLCache with (cacheHTML, url, nil, edata, TRUE)       		then begin       			local title, cacheH := prefsEntry.showHTMLoverview, cacheI := prefsEntry.showImagesOverview;	// !!!k       			local options := {       				closeBox: nil,       				icon: newtscape.icon,        				statusText: sel,       				gauge: 0,       				titleText: "",       				};       			//if kBuild20 then call kShowBusyBoxFunc with (true);              			txt := entry.text;       			if sel=kLoadLinks       			then begin       				title := LocObj("Links", 'linksItem);       				popup := DoProgress('vGauge, options, func(contextView)       							:scanLinks(url, txt, 0, true, cacheH, cacheI, contextView, options, nil)); // !!!s,k,e. prefsEntry.linkExcept?       				entry := nil;       				end       			else if sel=kLoadFrames	// !!!e       			then begin // !!!e       				title := LocObj("Frames", 'framesItem);       				popup := :scanFrames(url, txt, 0, true, cacheH);	// !!!k,i,g       				entry := nil;       				end       			else //if sel=kLoadWithImages       				begin       				title := LocObj("Images", 'imagesLabel);       				popup := DoProgress('vGauge, options, func(contextView)       							:scanImages(nil, url, txt, 0, {loadImages: true}, true, cacheI, contextView, options));	// !!!k,e,d. nil,nil       				end;              //Print("LoadLinks/Frames:"); Print(popup);       			if IsArray(popup) and Length(popup) > 0       			then BuildContext({       					_proto: GetLayout("protoCacheBkmarkOverview"),       					newtscape: newtscape,       					title: title,       					curDoc: entry,		// for images, process last. use cache entry (in case edata). allow expired entry       					itemName: true,		// !!!d       					defaultScript: 'loadScript,       					querySpec: popup, 	// !!!d. foreach sel in popup collect {URL: sel},       					}):open()       			else if entry // sel=kLoadWithImages       			then :dispatchFile(entry.type, url, txt, nil);	// use cached entry. !!!e. new options       			end       		else if sel=kLoadWithImages       		then :getURL(url, {loadImages: true});       	end,     pickCancelledScript:       kPopupCancelScript	// !!!b       ,     childSym: 'viewButton,     _proto: @226 /* protoTextButton */    };AddStepForm(NewtsCape, viewButton);// After Script for viewButtonthisView := viewButton;begin	thisView.text := LocObj("View", 'viewLabel);	if kNIE	then begin		thisView._proto := protoPopupButton;		RemoveSlot(thisView, 'viewJustify);		RemoveSlot(thisView, 'popup);		end;	if language='German	then thisView.viewBounds.right := thisView.viewBounds.right + 7	else if language='Chinese	then thisView.viewBounds.right := thisView.viewBounds.right + 3	else if language='Russian	then thisView.viewBounds.right := thisView.viewBounds.right + 20;	thisView.viewSetupFormScript := kShiftButton;	//thisView.viewBounds.left := 7;	// 5+2	//thisView.viewBounds.right := thisView.viewBounds.right + 2;	endgoButton :=    {     buttonClickScript:       func()       begin       	local gData := call kInitGlobal with (nil, nil), links;       	local pos := gData.(kHistoryPos), len := Length(gData.(kHistoryPath));       	if curBook and isArray(links := curBook.(kLinkPath)) and Length(links) > 0       	then begin       		popup := Clone(links);       		if len > 0       		then AddArraySlot(popup, 'pickSeparator);       		end       	else popup := [];              	AddArraySlot(popup, call kFixMenuItem with (kBackItem,    len > 0 and pos > 0));		// ROM_leftbitmap?       	AddArraySlot(popup, call kFixMenuItem with (kForwardItem, len > 0 and pos < len-1));	// ROM_rightbitmap?       	AddArraySlot(popup, call kFixMenuItem with (kHomeItem,	  StrFilled(prefsEntry.startupURL)));	// !!!f       	if kNIE       	then begin	// !!!s       		AddArraySlot(popup, 'pickSeparator);       		AddArraySlot(popup, call kFixMenuItem with (kNewerHTMLCacheItem,  self.htmlCursor));	       		AddArraySlot(popup, call kFixMenuItem with (kResetHTMLCacheItem,  cacheHTML));	       		AddArraySlot(popup, call kFixMenuItem with (kNewerImageCacheItem, self.imageCursor));	       		AddArraySlot(popup, call kFixMenuItem with (kResetImageCacheItem, cacheImages));	       		end;              	if len > 0	// !!!b       	then begin       		AddArraySlot(popup, 'pickSeparator);       		popup := call kHistoryList with (popup);       		end;              	if kNIE       	then begin       		local pp := inherited:buttonClickScript();	// kFixButtonClickScript       		if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym       		then SetValue(pp, 'viewFont, menuFontJ);	//{family: sym, face: kFaceBold, size: 10});       		pp;       		end       	else :myPopup(popup, nil, nil);       end,     text: "Go",     viewBounds: {left: 5, top: 5, right: 32, bottom: 16},     viewJustify: 8389670,     pickActionScript:       func(INT cmd)       begin       	if kNIE       	then inherited:pickActionScript(cmd);              	local sel := popup[cmd], links;       	popup := nil;              	local INT linklen := 0;       	if curBook and isArray(links := curBook.(kLinkPath)) and       		(linklen := Length(links)) > 0 and cmd < linklen       	then return :getURL(call kResolveURL with (curBook.(kBasePath), sel.value), nil);              	// !!!b       	if linklen > 0       	then linklen := linklen+1;			// picksep       	:doCommand(sel, cmd - (linklen+11));// !!!t,f. Back,Forward,Home,pickSep,newer/set[4],pickSepClearHistory,pickSep       end,     popup: nil,     childSym: 'goButton,     doCommand:       func(sel,hi)       begin       	local gData := call kInitGlobal with (nil, nil);              	local ARRAY history := gData.(kHistoryPath);       	local INT len := Length(history), pos := gData.(kHistoryPos);       	       	if kNIE and (	// !!!s       		sel = kNewerHTMLCacheItem or sel = kNewerImageCacheItem or       		sel = kResetHTMLCacheItem or sel = kResetImageCacheItem)       	then begin       		local soupName, cursor, cursorSym, entry;       		if sel=kNewerHTMLCacheItem or sel=kResetHTMLCacheItem       		then begin       			soupName  := cacheHTML;       			cursorSym := 'htmlCursor;       			end       		else //if sel=kNewerImageCacheItem or sel=kResetImageCacheItem then       			begin       			soupName  := cacheImages;       			cursorSym := 'imageCursor;       			end;              		if (sel=kResetHTMLCacheItem or sel=kResetImageCacheItem) and soupName       		then begin // (re)init cursor       			self.(cursorSym) := nil;       			gc();       			self.(cursorSym) := cursor := GetUnionSoupAlways(soupName):Query({indexPath: '_modTime});       			if sel := :currentURL(true)       			then begin       				entry := cursor:?entry();       				while entry and not StrEqual(entry.URL, sel)       				do begin       					entry := nil;       					entry := cursor:next();       					end;       				entry := nil;       				cursor:?next();       				end       			else cursor:?resetToEnd();       			end       		else cursor := self.(cursorSym);              		if isFrame(entry := cursor:?prev())       		then :dispatchEntry(entry, nil);       		end              	else if sel = kClearHistoryItem       	then SetLength(history, 0)	// set pos?              	else if sel = kHomeItem	// !!!f       	then begin       		if StrFilled(sel := prefsEntry.startupURL)       		then :getURL(sel, nil);       		end              	else if len > 0 and (		// in case "non-pickable"       		if isFrame(sel)       		then true       		else if sel[0]=$( and sel[StrLen(sel)-1]=$)		// !!!s,f,e. kFixMenuItem       		then nil       		else if sel = kBackItem		       		then (pos > 0 and hi := pos-1)		// !!!e       		else if sel = kForwardItem       		then (pos < len-1 and hi := pos+1)	// !!!e       		else true)	// other str       	then begin       		if sel <> kForwardItem and pos > 0 and pos = len // add new item before going back       		then call kAddHistory with ();       		call kGoHistory with (gData, hi, if curBook then curBook.isbn else "");       		end;       end,     pickCancelledScript:       kPopupCancelScript	// !!!b       ,     _proto: @226 /* protoTextButton */    };AddStepForm(NewtsCape, goButton);// After Script for goButtonthisView := goButton;begin	thisView.text := LocObj("Go", 'goLabel);	if kNIE	then begin		thisView._proto := protoPopupButton;		RemoveSlot(thisView, 'viewJustify);		RemoveSlot(thisView, 'popup);		end	else begin		end;	if language='German	then thisView.viewBounds.right := thisView.viewBounds.right + 4	else if language='Chinese	then thisView.viewBounds.right := thisView.viewBounds.right + 11 // 5	else if language='Korean	then thisView.viewBounds.right := thisView.viewBounds.right + 8	else if language='Russian	then thisView.viewBounds.right := thisView.viewBounds.right + 20;	thisView.viewSetupFormScript := kShiftButton;	//thisView.viewBounds.left := 7;	//thisView.viewBounds.right := thisView.viewBounds.right + 2;	endbookmarkButton :=    {     buttonClickScript:       func()       begin       	local url := :currentURL(true), folder;       	//local INT maxLen := 0;       	popup := [];       	local ARRAY collArray := [];              	if IsString(bookmarks)	// formerly :collectBookmarks       	then begin       		// !!!k       		foreach folder in GetFolderList(kAppSymbol, nil)       		do AddArraySlot(collArray, {item: GetFolderStr(folder), labels: folder});       		Sort(collArray, '|str<|, 'item);       		ArrayInsert(collArray, 'pickSeparator, 0); // after sort              		if prefsEntry.unfiledBookmarkMenu       		then begin       			if Length(folder := :getBookmarks(nil)) > 0		// append Unfiled items directly       			then begin       				AddArraySlot(collArray, 'pickSeparator);       				ArrayMunger(collArray, Length(collArray), 0, folder,0,nil);       				end;       			end       		else ArrayInsert(collArray, {item: GetFolderStr(folder := nil), labels: nil}, 1); // Unfiled folder into menu       		// note: folder is nil or array of Unfiled (for popup widen at end)              		AddArraySlot(popup, kOpenBookmarks); // call kFixMenuItem with (kOpenBookmarks, entry or Length(collArray) > 0));       		//AddArraySlot(popup, kRemoveAll);       		//AddArraySlot(popup, kSaveOutline);              		AddArraySlot(popup, call kFixMenuItem with (kAddBookmark,  url));       		AddArraySlot(popup, call kFixMenuItem with (kRemoveBookmark, url)); // and (entry or Length(collArray) > 0)));       		end;              	//AddArraySlot(popup, kAddPattern);       	AddArraySlot(popup,       		{item: LocObj("Newt's Cape Example Page", 'newtscapeBookmarkItem),       		value: "http://members.bellatlantic.net/~sweyer/newton/newtscape/examples.htm"});              	if Length(collArray) > 0       	then ArrayMunger(popup, Length(popup), 0, collArray, 0, nil); // contains seps. !!!j,b. moved              	local pp := inherited:buttonClickScript(), font;	// similar to kFixButtonClickScript       	if folder and Length(folder) > 0	// widen if Unfiled included directly       	then begin       		pp.pickMaxWidth := GetAppParams().appAreaWidth-10;       		font := pp.viewFont;       		end;       	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym	// change font?       	then font := menuFontJ;	//{family: sym, face: kFaceBold, size: 10});       	if font       	then SetValue(pp, 'viewFont, font);       	pp;       end,     text: "Bookmarks",     viewBounds: {left: 5, top: 5, right: 68, bottom: 16},     viewJustify: 8389670,     pickActionScript:       func(INT cmd) // if error?       begin       	inherited:pickActionScript(cmd);       	local sel := popup[cmd];       	popup := nil;       	try       		if isFrame(sel)			// demo or user bookmark       		then if HasSlot(sel,'labels)	// !!!j       			then begin       				//prefsEntry.bookmarkLabel := sel.labels;       				//:doCommand(kOpenBookmarks);       				// !!!k. collect all labels, popup, fix       				:myPopup(popup := :getBookmarks(sel.labels), nil, true);       				end       			else :getURL(sel.value, nil) // {edata: sel.edata}       		else :doCommand(sel);       	onexception |evt.ex| do nil;       end,     popup: nil,     childSym: 'bookmarkButton,     doCommand:       func(sel)	// via pickActionScript or "Newt's Cape menu"       begin       	local url := :currentURL(true), entry; // for add/remove bookmark              	if sel = kAddBookmark and url       	then :addBookmark(       			if curBook and (entry := curBook.(kBasePath)) and StrEqual(entry, url)       			then curBook.title else url, url)       			       	else if sel = kOpenBookmarks       	then BuildContext({       			_proto: GetLayout("protoCacheBkmarkOverview"),       			newtscape: newtscape,       			soupName: bookmarks,       			title: kBookmarksLabel,       			itemName: [LocObj("bookmark", 'bookmarkLabelL), LocObj("bookmarks", 'bookmarksLabelL)],	// !!!d       			querySpec: {indexPath: 'sortOn},       			prefSym:	'bookmarkLabel,       			caches: 	[	// !!!k. compute at view time       				if prefsEntry.showHTMLoverview then cacheHTML,       				if prefsEntry.showImagesOverview then cacheImages],       			//labelsFilter: prefsEntry.bookmarkLabel,       			}):open()              	else if sel = kRemoveBookmark and url       	then begin       		gc();       		local cursor := GetUnionSoupAlways(bookmarks):?Query(nil);       		entry := cursor:entry();       		while entry       		do if StrEqual(url, entry.URL)       			then return EntryRemoveFromSoupXmit(entry, popup := nil)       			else entry := cursor:next();       		end       end,     pickCancelledScript:       kPopupCancelScript	// !!!b       ,     getBookmarks:       func(elabel)       begin       	gc();       	local cursor := GetUnionSoupAlways(bookmarks):Query(nil), entry := cursor:reset();       	local ARRAY results := [];       	local ename, eurl, esort;       	while entry       	do begin       		if  entry.labels = elabel       			and StrFilled(esort := entry.sortOn)       			and StrFilled(ename := entry.name)       			and StrFilled(eurl	:= entry.URL)       		then BInsert(results,       					{item: ename,       					value: eurl,       					//edata: entry.edata,       					sortOn: esort,       					}, '|str<|, 'sortOn, nil);       		entry := cursor:next();       		end;       	cursor := nil;       	results;       end,     _proto: @226 /* protoTextButton */    };AddStepForm(NewtsCape, bookmarkButton);// After Script for bookmarkButtonthisView := bookmarkButton;begin // entire button removed for Infonautics	thisView.text := kBookmarksLabel;	if kNIE	then begin		thisView._proto := protoPopupButton;		RemoveSlot(thisView, 'viewJustify);		RemoveSlot(thisView, 'popup);		end;	if language='German or language='Chinese	then thisView.viewBounds.right := thisView.viewBounds.right - 25	else if language='French	// !!!e	then thisView.viewBounds.right := thisView.viewBounds.right - 10	else if language='Korean	then thisView.viewBounds.right := thisView.viewBounds.right - 16	else if language='Russian	then thisView.viewBounds.right := thisView.viewBounds.right + 20;	thisView.viewSetupFormScript := kShiftButton;	//thisView.viewBounds.left := 7;	//thisView.viewBounds.right := thisView.viewBounds.right + 2;endkbdButton :=    {viewBounds: {left: 22, top: -16, right: 40, bottom: -3},     viewJustify: 134,     viewSetupFormScript:       func()       begin       	self.viewBounds :=       		//if kNIE and KeyboardConnected()       		//then kBounds0 else       		if prefsEntry.showLongURL       		then RelBounds(-21, 24, 18, 13)			// ncGoButton, kbdButton [vertical]       		else RelBounds(-42, kTBmargin, 18, 13);	// urlPara, kbdButton, ncGoButton [horizontal]       	inherited:?viewSetupFormScript();       end,     buttonClickScript:       DefineGlobalConstant('keyFramedMask, keyFramed + (keyFramed << 1));	// !!!h. wid=2 for NOS 2.1, wid=1 for NOS 2.0?              DefineGlobalConstant('kKeysize1, keyHUnit + keyVUnit + keyAutoHilite + keyRoundingUnit*3);	// !!!h. + (keyFramed*2)       // 'shift'(288362504) = (keyHUnit*2) + keyVUnit + (keyFramed*2) + keyAutoHilite + keyRoundingUnit*3              DefineGlobalConstant('kNIEKeyRow,       	[8, 8,       	"http://", "http://", 	keyHUnit + keyHHalf + kKeysize1,		// 2.5       	"www.", "www.", 		keyHUnit + keyHHalf + kKeysize1,		// 2.5       	".com", ".com",			keyHHalf + keyHQuarter + kKeysize1,		// 1.75       	".edu", ".edu",			keyHHalf + keyHQuarter + kKeysize1,		// 1.75       	".net", ".net",			keyHHalf + keyHQuarter + kKeysize1,		// 1.75       	".htm", ".htm",			keyHHalf + keyHQuarter + kKeysize1,		// 1.75       	".html",".html",		keyHUnit + kKeysize1,					// 2.0       ]);              /*       optionISO       288361480-keyautohilite-(keyFramed*2)-(keyRoundingUnit*3)-(keyHUnit+keyHHalf)-keyVUnit              spacebarISO       288370696-keyautohilite-(keyFramed*2)-(keyRoundingUnit*3)-(keyHUnit*6)-keyvunit              optionUS       288363528-keyautohilite-(keyFramed*2)-(keyRoundingUnit*3)-(keyHUnit*2)-keyHHalf-keyVUnit              spacebarUS       288371720-keyautohilite-(keyFramed*2)-(keyRoundingUnit*3)-(keyHUnit*6)-keyHHalf-keyvunit       */              if kNIE then       DefineGlobalConstant('kCmdKey,	// !!!f       	["cmd", kCommandKeyCode, kKeysize1 + keyHHalf]	//$\uF7FF ?       );              DefineGlobalConstant('kCmdKeyWid, keyHUnit + keyHHalf);	// to subtract from spacebar              DefineGlobalConstant('kKeyFrameWid, func(ARRAY keys, INT offset, INT wid)	// !!!h       begin       	local INT i;       	for i:=offset to Length(keys)-1 by 3       	do keys[i+2] := Bor(keys[i+2], wid);       	keys;       end);              func()       begin       	local root := GetRoot(), akbd := root.alphaKeyboard;       	if kNIE       	then begin       		local logicKbd := root.(kLogicKbdSym);       		if not newtscape.mykbd       		then begin       			// customize keys       			local ARRAY keys := Clone(kNIEKeyRow);       			if prefsEntry.kbdKeys       			then begin       				local fn := StrTokenize(prefsEntry.kbdKeys, $,), key, i;       				for i:=2 to Length(keys)-1 by 3       				do  if key := call fn with ()       					then begin       						if StrFilled(TrimString(key))       						then keys[i] := keys[i+1] := key;       						end       					else break; // done       				end;       			// create/register kbd       			newtscape.mykbd := akbd;	// default              			if logicKbd       			then logicKbd:?AddKeyArray(kAppSymbol, [call kKeyFrameWid with (keys, 2, keyFramed*2)])	// !!!h       			else begin       				// use standard kbd (if child template matches)       				local vb := akbd.viewBounds, vc, kp, kpUSdefs, kpISOdefs;       				if not vb       				then vb := akbd.saveBounds;              				if IsFrame(vb) and IsArray(vc := akbd.viewChildren) and IsFrame(kp := vc[0]) and       					IsArray(kpISOdefs := kp.keyDefinitionsISO) and IsArray(kpUSdefs := kp.keyDefinitionsUS)       				then begin       					local INT frWid := Band(kpUSdefs[0][4], keyFramedMask);	// !!!h. existing frame wid of 1st key       					local ARRAY cmdKey := call kKeyFrameWid with (Clone(kCmdKey), 0, frWid), defs, row;       					call kKeyFrameWid with (keys, 2, frWid);              					// to modify keydefs for cmdKey (maybe), new top row       					foreach defs in [kpUSdefs := Clone(kpUSdefs), kpISOdefs := Clone(kpISOdefs)] // !!!f       					do  if Length(defs) = 5 and Length(row := defs[4]) = 17       						then begin       							row := defs[4] := Clone(row);       							row[10] := row[10] - kCmdKeyWid; 	// steal width from spacebar       							ArrayMunger(row,8,0, cmdKey,0,nil);	// insert between option and spacebar       							end;              					vb := Clone(vb);       					vb.top := vb.top - 20;              					vc := Clone(vc);       					vc[0] := {       						_proto: kp,       						keyDefinitionsISO: ArrayInsert(kpISOdefs,keys,0),       						keyDefinitionsUS:  ArrayInsert(kpUSdefs, keys,0),       						};              					newtscape.mykbd := BuildContext({       						_proto: akbd._proto,       						viewBounds: vb,       						saveBounds: vb,       						viewChildren: vc,       						});       					end;       				end;       			end;              		if call kViewIsOpenFunc with (mykbd)       		then return inherited:buttonClickScript()	// kbd menu. !!!b. no selection hilite       		else if logicKbd       		then mykbd:openWith(kAppSymbol)		// moved (so kbd menu can appear)       		else mykbd:open();       		end       	else akbd:toggle();              	local view := GetView('viewFrontKey);       	if view and StrFilled(view.text)       	then view:SetHilite(0,StrLen(view.text),true);       end,     icon:       MakePixFamily(           GetResourceFromFile({filename:                 "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc", resource:                 146}),           GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF", resource:                  }),           [            {rsrcSpec:             GetResourceFromFile({filename:                   "SteveW:Newton/Steve:Newt's Cape 2.0:NewtsCape.rsc",                   resource: 146}),             bitDepth: 1},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 2},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 4},            {rsrcSpec:             GetResourceFromFile({filename: ":\u00E0000200C6\u$\uF7FF",                   resource: }),             bitDepth: 8}]);,     _proto: @198 /* protoPictureButton */    };AddStepForm(NewtsCape, kbdButton);// After Script for kbdButtonthisView := kbdButton;begin	if kNIE	then begin		thisView._proto := protoSmallKeyboardButton;	// like in protoNamePassword		RemoveSlot(thisView, 'icon);		//RemoveSlot(thisView, 'buttonClickScript);		end;	thisView.viewJustify := vjParentRightH + vjParentTopV + vjCenterH + vjCenterV;	RemoveSlot(thisView, 'viewBounds);end// After Script for NewtsCapethisView := NewtsCape;begin//thisView.URLencodeString := kURLencodeString;//thisView.URLencodeVal := kURLencodeVal;//thisView.URLencodeObject := kURLencodeObject;//thisView.aboutView := thisView.NIEPrefsView := thisView.TagPrefsView := NIL;	// !!!g. see infoButton:Prefslocal children, obj;// unusedRemoveSlot(thisView,'viewBounds);	// set in viewSetupFormScriptRemoveSlot(thisView,'progressOptions);	// !!!iRemoveSlot(thisView,'progressView);	// !!!i//thisView.protoCacheBkmarkOverview := GetLayout("protoCacheBkmarkOverview");//thisView.protoNamePassword := GetLayout("protoNamePassword");kProtoContainer.getAlign := thisView.tagDictOrig.P.getAlign;	// share// misc. fixup/sharingthisView.tagDictOrig.A.HREF 	:= thisView.tagDictOrig.U; // used in :getRunthisView.tagDictOrig.HR.data 	:= if kProfileOn then {_proto: protoBorder} else protoBorder;thisView.tagDictOrig.P.getRun 	:= thisView.getRun;	RemoveSlot(thisView,'getRun);thisView.tagDictOrig.P.addStyle := thisView.addStyle;thisView.tagDictOrig.P.addBlock := thisView.addBlock;	RemoveSlot(thisView,'addBlock);thisView.tagDictOrig.P.SimpleTextHeight := thisView.SimpleTextHeight;children := thisView.tagDictOrig.TEXTAREA.data.viewChildren; // !!!athisView.tagDictOrig.TEXTAREA.data.allocateContext := [children[0].preallocatedContext, children[0]]; //textAreaScrollchildren[2].viewSetupFormScript := children[1].viewSetupFormScript;	// sharechildren[2].buttonClickScript 	:= children[1].buttonClickScript;	// shareobj := children[0].viewChildren[0];children[0].allocateContext := [obj.preallocatedContext, obj]; //textAreaEditobj.viewChangedScript2 	:= thisView.inputDictOrig.TEXT.data.viewChildren[1].viewChangedScript;obj.viewSetupFormScript := thisView.inputDictOrig.TEXT.data.viewChildren[1].viewSetupFormScript;//if language='Chinese//then thisView.inputDictOrig.TEXT.data.viewChildren[1].viewFont := kEspy12;thisView.tagDictOrig.SELECT.data.viewClickScript :=thisView.inputDictOrig.TEXT.data.viewClickScript := thisView.inputDictOrig.CHECKBOX.data.viewClickScript;thisView.inputDictOrig.PASSWORD.data._proto := thisView.inputDictOrig.TEXT.data;thisView.inputDictOrig.BUTTON := thisView.inputDictOrig.SUBMIT;if language <> 'Japanesethen RemoveSlot(thisView, 'Wabumiuni_Titles);if not kNIEthen begin	RemoveSlot(thisView.tagDictOrig.SELECT.data,	'pickerSetup);	RemoveSlot(thisView.tagDictOrig.SELECT.data,	'menuFont);	RemoveSlot(thisView.tagDictOrig, 				'SELECT_MENU);	/*	RemoveSlot(thisView.tagDictOrig, '|dc:Title|);	RemoveSlot(thisView.tagDictOrig, '|dc:Creator|);	RemoveSlot(thisView.tagDictOrig, '|dc:Identifier|);	RemoveSlot(thisView.tagDictOrig, '|dc:Publisher|);	RemoveSlot(thisView.tagDictOrig, '|dc:Rights|);	RemoveSlot(thisView.tagDictOrig, '|dc:Date|);	RemoveSlot(thisView.tagDictOrig, '|dc:Description|);	RemoveSlot(thisView.tagDictOrig, '|dc:Type|);	RemoveSlot(thisView.tagDictOrig, '|dc:Format|);	RemoveSlot(thisView.tagDictOrig, '|dc:Source|);	RemoveSlot(thisView.tagDictOrig, '|dc:Language|);	RemoveSlot(thisView.tagDictOrig, '|dc:Relation|);	RemoveSlot(thisView.tagDictOrig, '|dc:Coverage|);	*/	end;if not kNCfontthen begin	RemoveSlot(thisView, 'Notify);	// !!!j	RemoveSlot(thisView, 'fixFontsJ);	end;thisView.inputDictOrig.IMAGE.get_dataIMG := thisView.tagDictOrig.IMG.get_data;thisView.inputDictOrig.IMAGE.data.SCRIPT := thisView.inputDictOrig.SUBMIT.data.SCRIPT;//thisView.inputDictOrig.IMAGE.addAttrib 	 := thisView.inputDictOrig.SUBMIT.addAttrib;thisView.inputDictOrig.RADIO.rbData.viewChildren := thisView.inputDictOrig.CHECKBOX.data.viewChildren;thisView.inputDictOrig.RADIO.rbData.viewClickScript := thisView.inputDictOrig.CHECKBOX.data.viewClickScript;thisView.inputDictOrig.RADIO.getWidth := thisView.inputDictOrig.CHECKBOX.getWidth;//thisView.inputDictOrig.RESET.data.viewSetupFormScript :=//!!!b	thisView.inputDictOrig.SUBMIT.data.viewSetupFormScript;thisView.inputDictOrig.RESET.getWidth := thisView.inputDictOrig.SUBMIT.getWidth;/*thisView.inputDictOrig.CHECKBOX.dataR := Clone(thisView.inputDictOrig.CHECKBOX.data);thisView.inputDictOrig.CHECKBOX.dataR._proto := protoRCheckBox;thisView.inputDictOrig.CHECKBOX.dataR.viewJustify := vjTopV + vjRightH;thisView.inputDictOrig.CHECKBOX.dataR.viewChildren := [viewChildren: // override built-in 1-line only label	{viewClass: 98, 	viewFlags: 3, 	viewJustify: vjParentFullV + vjParentFullH, //8388852, -oneLineOnly -vjCenterV	viewBounds: kBounds0, // indent	}];*/// for Notes and/or NewtworksthisView.NewtsCapeDoIt := kNewtsCapeDoItFunc;/*if kCparserthen begin	RemoveSlot(thisView, 'addHTML);	thisView.parsingFrame := HTMLParser.ParseString;	// replace w/ ref to C fn	endelse // this is all we need for NS parser (don't bother with extra view stuff)*/	thisView.parsingFrame := |layout_parse.t|.parsingFrame;if kBuild20then RemoveSlot(thisView, 'GetUserConfig);children := thisView.stepChildren;//thisView.viewJustify := vjParentFullH + vjParentBottomV;if kNIEthen thisView._proto := protoDragger;thisView.viewFlags := Bor(thisView.viewFlags, vFloating);if kNIEthen begin	thisView.all_AREA := NIL;				// !!!g,f	thisView.all_HREF := 	thisView.fixPkgHREF := kFixPkgHREF;	RemoveSlot(thisView, 'viewIdleScript);	// uses DoProgress instead	RemoveSlot(thisView, 'viewClickScript);	RemoveSlot(thisView, 'viewDrawScript);	thisView.viewFormat := Bor(thisView.viewFormat, 208); //vfFrameDragger);	thisView.resolveURL	 	:= kResolveURL;	if kDebugHTTP	then begin	// for debugging convenience		thisView.collectURLs 	:= kCollectURLs;		thisView.getURLCache 	:= kGetURLCache;		thisView.putURLCache 	:= kPutURLCache;		thisView.sendHTTP	 	:= kSendHTTP;		thisView.getFileName	:= kGetFileName;		thisView.mySubStr		:= kSubStr;		thisView.FindBook		:= kFindBook;		thisView.GIF			:= GIF;		//thisView._Cparse := HTMLParser.ParseString;		end;	//else RemoveSlot(thisView, '_Cparse);	thisView.fetchURL := thisView.getURL;	//thisView.speakFormat  := kSpeakFormat;	// for InstallScript	thisView.curSourceBuf := NIL;	endelse begin	// 1.x (non-NIE)		//RemoveSlot(thisView, '_Cparse);	thisView.NIEPrefsLayout := GetLayout("NIEPrefsLayout");	// !!!n		RemoveSlot(thisView, '_CloseFrontView);	thisView.viewFormat := Bor(thisView.viewFormat, vfFrameMatte); // for drag frame	RemoveSlot(thisView, 'AddBookmark);	RemoveSlot(thisView, 'AddLocale);	RemoveSlot(thisView, 'Bookmarks);	RemoveSlot(thisView, 'Confirm);	RemoveSlot(thisView, 'convertImage);	RemoveSlot(thisView, 'doEvent);	RemoveSlot(thisView, 'ReorientToScreen);	RemoveSlot(thisView, 'resetFSM);	RemoveSlot(thisView, 'scanFixFrame);	RemoveSlot(thisView, 'scanFrames);	RemoveSlot(thisView, 'scanImages);	RemoveSlot(thisView, 'scanLinks);	RemoveSlot(thisView, 'wwwFSM);	ArrayRemoveCount(children, Length(children)-2,1); // remove bookmarkButton	RemoveSlot(thisView, 'viewShowScript);	RemoveSlot(thisView, 'dispatchEntry);	end;//RemoveSlot(thisView, 'cancelRequest);/* children	URLtri	commandTri	ncGoButton	statusPara	statusGauge	errorPara	hideButton	quitButton0	URLpara1	NIEPrefsView2	TagPrefsView3	versionText4	infoButton5	displayButton								[+IN]6	urlText, titleText, isbnText, stitleText,	[-IN]	lineText, itemText, pageText				[-IN]	fileButton	viewButton	goButton-2	bookmarkButton								[-IN, +NIE]-1	kbdButton*/if not kNewEndpointthen begin	thisView.protoSerialProtocol.waitLine.doScript :=			thisView.protoSerialProtocol.waitLine.inputScript;	RemoveSlot(thisView.protoSerialProtocol.waitLine, 'inputScript); // inherit :DoScript(..)	end;	if kNIE	then begin		children[2].goIcon := thisView.icon := kNotesRouteItem.icon;	// !!!g. share		// !!!g. thisView.icon itself still used (earlier status)??		end	else begin		thisView.NotesGetTitle 		:= kNotesGetTitle;	// for installScript		thisView.NotesRouteScript 	:= kNotesRouteScript;		end;kShowNCButton.icon := thisView.icon;	//children[kNewUIObjs-1] := protoCloseBox;		// avoid 1 level?	//ArrayRemoveCount(children, kNewUIObjs+5, 8);	// remove displayButton,urlText-pageText	//ArrayRemoveCount(children, kNewUIObjs+3, 1);	// remove versionText	if (kBuild1x and kNIE) or (StrFilled(kBetaVersion) and not kExpiringVersion)	then RemoveSlot(thisView, 'sharewareFee);	// also see info buttoncall func()begin	local isMethod := func(m)		isFrame(m)		and not m._proto		and (isInstance(m,'CodeBlock) or isInstance(m,'_function));	local projfns := [kAllData, kGetData, kSetData, kPrintFunc]; // others???	local kProfilenum := func(fr,fname,sname,num)		begin		local s,v;		local oldproto := fr._proto;		//fr := Clone(fr);		RemoveSlot(fr,'_proto); // sym or bad magic ptr errs		if sname		then sname := sname & $.		else Print(fname && "[map for Profile]");		foreach s,v in fr		do if call isMethod with (v)			then begin				if not SetContains(projfns,v)				then Print(fname & $. & (num := num+1) && $[ & sname&s & $]);				end			else if isFrame(v)			then num := call kProfilenum with (v,fname,sname&s,num);		if oldproto		then fr._proto := oldproto;		num;		end;	if kProfileOn then call kProfilenum with (thisView.tagDictOrig,"tagDictOrig",nil, kProfileFnOffset);	if kProfileOn then call kProfilenum with (thisView.inputDictOrig,  "inputDictOrig",nil, kProfileFnOffset);	local kfixProto := func(fr)		begin		local s, v, sym, pr, formpr := thisView.tagDictOrig.protoTagForm;		foreach s,v in fr		do if (isFrame(v) and isInstance(sym := v._proto, 'symbol))				or isInstance(sym := v,'symbol)			then if (pr := if sym='protoTagForm then formpr else GetSlot(fr,sym))				then if sym=v then fr.(s) := pr else fr.(s)._proto := pr				else Print ("undefined proto" && sym);		end;	call kFixProto with (thisView.tagDictOrig);	call kFixProto with (thisView.inputDictOrig);end with ();endconstant |layout_MainLayout| := NewtsCape;// End of file MainLayout