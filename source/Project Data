// Project Data// NewtsCape 2.1/Newt's Cape Lite// Copyright 1995-2002. S. Weyer & G. Simon. All Rights Reserved Worldwide// see kAboutText also/*2.1f:- increased vboflush- pkg(No) doesn't install; DoProgress option (for Unzip)- added 'process' to Scheduleif Accept-encoding worked, need to cleanup, add test for zlib present, removeapproval etc.*/// before release -- Print ////// test PrefSets on 1.x?// test Hemlock (add Print stmts)// avoid HTMLCache:NewtsCape_Titles, etc. -- don't reg soup change??// use base instead of overviewApp?// avoid some compiler warningsDeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);//for 1.x only: set kNIE to NIL. add NATIVE to kSplitTextHeightFunc ? (if there are 2.0 native fns)if not IsGlobalConstant('kNIE)then DefineGlobalConstant('kNIE, 	kBuild20 or kIgnoreNativeKeyword);		// NIE-specific version? (1.x-oNly, 1.x-NIE, 2.x-NIE)DefineGlobalConstant('kVersionNum, 		"2.1");DefineGlobalConstant('kVersionInt, 		"21");DefineGlobalConstant('kBetaVersion, 	"f");DefineGlobalConstant('kStyleMeasure,	kBuild20 and TRUE);		// !!!mDefineGlobalConstant('kExpiringVersion, kNIE and NIL);DefineGlobalConstant('kDebugHTTP, 		kDebugOn or NIL);			/**/DefineGlobalConstant('kNewEndPoint,		kNIE);DefineGlobalConstant('kNCfont,			language='Japanese or language='Chinese or language='Russian or language='Korean); // !!!a1DefineGlobalConstant('kSubmitQ,			kNIE and NIL); 	// !!!g. NASA?DefineGlobalConstant('kFullOffset,		40);			// !!!a1DefineGlobalConstant('kFullOffset2,		2*kFullOffset);	// !!!a1/*in many places in code, kNIE is also used to mean "running on a 2.x system at development time".kBuild20 would flag 2.x-specific code called from a book at run-time*/ //DefineGlobalConstant('kCParser,		kBuild20 and NIL);		// replace with C parser//DefineGlobalConstant('kCParseVersion,	"13");//DefineGlobalConstant('kAddEncoding,	language='Japanese or language='Chinese or NIL);DefineGlobalConstant('kVerBeta, kVersionNum & kBetaVersion);DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &		(if not kIgnoreNativeKeyword then $N) &		//(if kCParser then $C & kCParseVersion) &		(if kDebugOn or kDebugHTTP then $D) &		(if kProfileOn then $P) &		(if kExpiringVersion then $X) &		(if kBuild20 then "-2") &		(if kNIE then "(NIE)") &// should compare actual symbols to avoid problems like "Japan"		(if language<>'english then $~ & Upcase(SPrintObject(language))[0]) // else if kAddEncoding then "~E"));DefineGlobalConstant('kAppNameS, kAppName); // for soup names etc.DefineGlobalConstant('kAppNameL, "Newt's Cape"); // maybe slightly longerconstant kBrowserName := kAppNameL;DefineGlobalConstant('kVersion, kAppNameL && kVersionString);Print("nwcp" & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then nil	// $N?	else if language='English	then /*if kAddEncoding		then $E		else*/ if kBuild1x		then if kNIE			then $X			else $L		else $2	else Upcase(SPrintObject(language))[0])	& ".pkg");Print(kAppNameS && kVersionString && DateNTime(Time()));Print(kAppSymbol);// use this in most places instead of kAppSymbol so "Newt's Cape Lite" can shareif not IsGlobalConstant('kNewtsCapeSymbol)then DefineGlobalConstant('kNewtsCapeSymbol, kAppSymbol); // '|NewtsCape:NewtsCape|// -----constant kProfileFnOffset := 1; // for 2.0? (0 for 1.x?)// Eventually the following global functions will be defined?DeclareGlobalFn('ClearVBOCache,1);if kNIEthen begin	DeclareGlobalFn('RegUnionSoup, 2);	DeclareGlobalFn('UnRegUnionSoup, 2);	end;if kBuild20then begin	DeclareGlobalFn('Query,2);	endelse begin	if kNIE	then begin		DeclareGlobalFn('GetFunctionArgCount,1);		DeclareGlobalFn('IsNumber,1);		DeclareGlobalFn('SubstituteChars,3);		DeclareGlobalFn('PowerOffResume,1);		DeclareGlobalFn('CreateSoupFromSoupDef, 3);		DeclareGlobalFn('IsCharacter, 1);		DefineGlobalConstant('protoStatusTemplate,@467);		DefineGlobalConstant('protoBasicEndpoint, @383);		DefineGlobalConstant('protoDragger, @132);		DefineGlobalConstant('protoSmallKeyboardButton, @624);		DefineGlobalConstant('protoPopupButton, @386);		DefineGlobalConstant('protoDragNGo, @804);		DefineGlobalConstant('ROM_DefRotateFunc, @588);		DefineGlobalConstant('protoTXView, @826);		DefineGlobalConstant('protoDateNTimeTextPicker, @630);		DefineGlobalConstant('protoNewFolderTab, @669);		DefineGlobalConstant('protoSoupOverview, @460);		//DefineGlobalConstant('newtCheckAllButton, @872); // 2.1 only		DefineGlobalConstant('ROM_routeUpdateBitmap,@761);		DefineGlobalConstant('ROM_alarmIconTinyBitmap, @591);		DefineGlobalConstant('ROM_routePasteText, @773);		DefineGlobalConstant('ROM_closedPadlockBitmap, @601);		DefineGlobalConstant('ROM_openPadlockBitmap, @600);		DefineGlobalConstant('ROM_routeDeleteIcon, @291);		DefineGlobalConstant('ROM_routeDuplicateIcon, @292);		DefineGlobalConstant('kShiftModifier, 	1 << 26);		DefineGlobalConstant('kOptionModifier,  1 << 28);		DefineGlobalConstant('editFont10, 0x00002803);		DefineGlobalConstant('editFont12, 0x00003003);				DeclareGlobalFn('MakeFontMenu, 4);		DeclareGlobalFn('BInsertRight, 5);		DeclareGlobalFn('BDelete, 5);		DeclareGlobalFn('SetFontParms, 2);		DeclareGlobalFn('SetFontFamily, 2);		DeclareGlobalFn('SetFontFace, 2);		DeclareGlobalFn('SetFontSize, 2);		DeclareGlobalFn('PerformIfDefined, 3);		DeclareGlobalFn('GetFolderStr, 1);		DeclareGlobalFn('GetFolderList, 2);		end	else begin		DefineGlobalConstant('ROM_DefRotateFunc, nil);	// e.g. protoNamePassword (unused)		DefineGlobalConstant('protoSmallKeyboardButton, nil);		DeclareGlobalFn('GetFolderStr, 1);		DeclareGlobalFn('GetFolderList, 2);		DeclareGlobalFn('SetFontFace, 2);		DeclareGlobalFn('BDelete, 5);		end;	DefineGlobalConstant('kCommandModifier, 1 << 25);	DeclareGlobalFn('EntryFlushXmit, 2);	DefineGlobalConstant('kCommandKeyCode, 55);	DeclareGlobalFn('IsEntryAlias, 1);	DeclareGlobalFn('EntryFromObj, 1);	DeclareGlobalFn('CreateTargetCursor, 2);	DeclareGlobalFn('RemoveAlarm, 1);	DeclareGlobalFn('GetAlarm, 1);	DeclareGlobalFn('TargetIsCursor, 1);	DeclareGlobalFn('GetTargetCursor, 2);	DeclareGlobalFn('GetSoupDef, 1);	DeclareGlobalFn('EntryCopyXmit, 3);	DeclareGlobalFn('EntryMoveXmit, 3);	DeclareGlobalFn('GetAppAlarmKeys, 1);	DeclareGlobalFn('MakeTextLines, 4);	DeclareGlobalFn('StyledStrTruncate, 3);	DeclareGlobalFn('InetGetAllLinksStatus, 0);	DeclareGlobalFn('InetSetDefaultLinkID, 1);	DeclareGlobalFn('InetGetDefaultLinkID, 0);	DeclareGlobalFn('AddAlarm, 5);	DeclareGlobalFn('StrTokenize, 2);	DeclareGlobalFn('IsFunction,1);	DeclareGlobalFn('IsInteger,1);	DeclareGlobalFn('ObjectPkgRef, 1);	DefineGlobalConstant('kTextCompander,	"TLZStoreCompander");	DefineGlobalConstant('kBitmapCompander,	"TPixelMapCompander");	DeclareGlobalFn('RegPowerOff,2);	DeclareGlobalFn('UnRegPowerOff,1);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('GetGlobalFn,1);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('TransportNotify,3);	DeclareGlobalFn('GetDataDefs,1);	DeclareGlobalFn('GetAppPrefs,2);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('IsRichString,1);	DeclareGlobalFn('AddDelayedSend,4);	DeclareGlobalFn('AddDeferredSend,3);	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('AddDelayedCall,3);	DeclareGlobalFn('AddProcrastinatedSend, 5);	DeclareGlobalFn('LSearch,5);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('IsSymbol,1);	DeclareGlobalFn('RegUnionSoup,2);	DeclareGlobalFn('UnRegUnionSoup,2);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('Send,2);	DeclareGlobalFn('EntryRemoveFromSoupXmit,2);	DeclareGlobalFn('RegSoupChange,3);	DeclareGlobalFn('EntryChangeXmit,2);	DeclareGlobalFn('EntryReplaceXmit,3);	DeclareGlobalFn('UnRegSoupChange,2);	DeclareGlobalFn('BInsert,5);	DeclareGlobalFn('isVBO, 1);	DeclareGlobalFn('GetVBOStore, 1);	DeclareGlobalFn('GlobalFnExists, 1);	DeclareGlobalFn('KeyboardConnected, 0);	DeclareGlobalFn('ResolveEntryAlias, 1);	DeclareGlobalFn('GetUnionSoupAlways, 1);	DeclareGlobalFn('MakeEntryAlias, 1);	DeclareGlobalFn('ProtoPerformIfDefined, 3);	DeclareGlobalFn('GetFontFace, 1);	DeclareGlobalFn('GetFontSize, 1);	DeclareGlobalFn('GetFontFamilySym, 1);	DeclareGlobalFn('BFind, 4);	DeclareGlobalFn('ArrayInsert, 3);	DeclareGlobalFn('GetVBOcompander, 1);	DeclareGlobalFn('OffsetRect, 3);	if not IsGlobalConstant('HTMLParser)	then DefineGlobalConstant('HTMLParser,{});	DeclareGlobalFn('GetPkgRefInfo, 1);	DeclareGlobalFn('RegisterViewDef, 2);	DeclareGlobalFn('UnRegisterViewDef, 2);	DeclareGlobalFn('DecodeRichString, 2);	DeclareGlobalFn('StrExactCompare, 2);	DeclareGlobalFn('AddProcrastinatedCall, 4);	DeclareGlobalFn('SubstituteChars, 3);	end;DeclareGlobalFn('SoundList, 0);DeclareGlobalFn('GetRegisteredSound,1);DeclareGlobalFn('InetGetIPAddress, 1);DeclareGlobalFn('CharPos,3);DeclareGlobalFn('BookAvailable,2);//DeclareGlobalFn('StrHexDump,2);DeclareGlobalFn('GetPkgRef,2);DeclareGlobalFn('XmitSoupChange,4);DeclareGlobalFn('ThawPackage,1);DeclareGlobalFn('AsyncConfirm,3);DeclareGlobalFn('SafeRemovePackage,1);DeclareGlobalFn('TotalTextBounds,2);DeclareGlobalFn('DoProgress,3);DeclareGlobalFn('MakeCompactFont,3);DeclareGlobalFn('OpenPrefsTo, 1); // NTE// these are deprecated (and might disappear)DefineGlobalConstant('kMyRegCardSoup, func(soupName,soupIndexes,appSymbol,appObject)if kBuild20 or Functions.RegUnionSoup existsthen RegUnionSoup(appSymbol,		{name: 	 	soupName,		userName: 	soupName,		ownerApp:	kNewtsCapeSymbol, // note: to match UnRegUnionSoup		userDescr:	soupName && appObject[1],		indexes: 	soupIndexes,		})else call kRegisterCardSoupFunc with (soupName,soupIndexes,appSymbol,appObject));DefineGlobalConstant('kMyRegCardSoupNC, func(soupName,soupIndexes,appSymbol,appObject) // non-standalone (unused so far)GetRoot().(kNewtsCapeSymbol):?RegisterCardSoup(soupName,soupIndexes,appSymbol,appObject));DefineGlobalConstant('kMyUnRegCardSoup, func(soupName)if kBuild20 or Functions.UnRegUnionSoup existsthen UnRegUnionSoup(soupName, kNewtsCapeSymbol)else call kUnregisterCardSoupFunc with (soupName));DefineGlobalConstant('kMyUnRegCardSoupNC, func(soupName) // non-standalone (unused so far)GetRoot().(kNewtsCapeSymbol):?UnRegisterCardSoup(soupName));DefineGlobalConstant('kMyGetUserConfig, func(configSym)if kBuild20 or Functions.GetUserConfig existsthen GetUserConfig(configSym)else call kGetUserConfigFunc with (configSym));DefineGlobalConstant('kMyGetUserConfigNC, func(configSym) // non-standalonebegin	local app;	if not (app := GetRoot().(kNewtsCapeSymbol))	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	app:?GetUserConfig(configSym);end);// -----DefineGlobalConstant('kAboutText,"<HTML><HEAD><META CONTENT=\"icon\" NAME=\"data.ic\"><TITLE>" & LocObj("About", 'aboutItem) && kAppNameL & "</TITLE></HEAD><BODY><H1>" & kAppNameL && kVersionString & "</H1><IMG SRC=\"ic\"><H2>" & LocObj("Introduction", 'introductionText) & "</H2><P>" &LocObj("CreateNewton books with text, graphics, tables andforms from HTML", 'aboutCreate) & ".<P>&copy;1995-2002. S.Weyer&amp;G.Simon." &&LocObj("All Rights Reserved Worldwide", 'rightsReserved) &$. & (if language='German then $  else unicodeCR) &"<H2>" & LocObj("For More Information", 'moreInfo) & "</H2><UL><LI>" & (if language<>'German then unicodeCR) &"<A HREF=\"http://members.bellatlantic.net/~sweyer/newton/newtscape.htm\">" & LocObj("web info", 'webInfo) &"</A><LI><A" & (if language='German then $  else unicodeCR) &"HREF=\"mailto:weyer@kagi.com\">Steve</A>, <A HREF=\"mailto:greg@accesscom.com\">Greg</A></UL></BODY></HTML>");// File menuDefineGlobalConstant('kOpenLocation,	LocObj("Open Location", 'openLocationItem));DefineGlobalConstant('notesSoupName,	ROM_paperrollsoupname);DefineGlobalConstant('kNotesSym,		'paperroll);DefineGlobalConstant('kOpenNotes, 		LocObj("Open Notes", 'openNotesItem) & $É);DefineGlobalConstant('kSaveHTMLNotes, 	LocObj("Save HTML to Notes", 'saveHTMLNotes));DefineGlobalConstant('kSaveImageNotes,	LocObj("Save Image to Notes", 'saveImageNotes));DefineGlobalConstant('inboxSoupName,	ROM_inboxsoupname);DefineGlobalConstant('kOpenInbox,		LocObj("Open Inbox", 'openInboxItem) & $É);DefineGlobalConstant('kInboxSym,		'ioBox);DefineGlobalConstant('kPaperback,		"Paperback");DefineGlobalConstant('kOpenPaperback,	LocObj("Open Paperback", 'openPaperbackItem) & $É);DefineGlobalConstant('kNamesSym,		'cardfile);DefineGlobalConstant('kWabumiUni,		"WabumiUni");DefineGlobalConstant('kOpenWabumiUni,	LocObj("Open WabumiUni", 'openWabumiUniItem) & $É);/*DefineGlobalConstant('kUnfiled,			"Unfiled");	// via GetFolderStr?DefineGlobalConstant('kPersonalMedia,	LocObj("Personal Media", 'personalMediaItem));DefineGlobalConstant('kPMSoupName,		"DocDir:Gaia");DefineGlobalConstant('kPersonalMediaSym,'|Personal Media:Gaia|);DefineGlobalConstant('kOpenPersonalMedia,LocObj("Open Personal Media", 'openPersonalMediaItem) & $É);*/DefineGlobalConstant('kNewtworksSoupName,	"NewtWorks");	// not localized?DefineGlobalConstant('kNewtworksSym,		'Newtworks);DefineGlobalConstant('kOpenNewtworks,		LocObj("Open NewtWorks", 'openNewtWorksItem) & $É);DefineGlobalConstant('kSaveHTMLNewtworks,	LocObj("Save HTML to NewtWorks", 'saveHTMLNewtworksItem));DefineGlobalConstant('kSaveImageNewtworks,	LocObj("Save Image to NewtWorks", 'saveImageNewtworksItem));DefineGlobalConstant('kSaveBookNewtworks,	LocObj("Save Book to NewtWorks", 'saveBookNewtworksItem) & $É);constant kExtrasSym 	:= 'ExtrasDrawer;constant kURLcopSymbol	:= 'urlCop;DefineGlobalConstant('kOpenDesktop, 	LocObj("Open Desktop", 'openDesktopItem) & $É);DefineGlobalConstant('kCloseDesktop,	LocObj("Close Desktop", 'closeDesktopItem));constant kOpenSerial9600	:= LocObj("Serial(9600)", 'serial9600);constant kOpenSerial57600	:= LocObj("Serial(57600)", 'serial57600);constant kOpenADSP			:= LocObj("ADSP", 'ADSPlabel);DefineGlobalConstant('kSaveAsPackage,	LocObj("Save as Package", 'savePackageItem));DefineGlobalConstant('kRemoveBook,		LocObj("Remove Current Book", 	'removeCurrentBookItem));DefineGlobalConstant('kRemoveCache,		LocObj("Remove from Cache", 	'removeFromCacheItem));//DefineGlobalConstant('kDumpText,		LocObj("Save as Text to Desktop", 'saveTextDesktopItem) & $É);// soup names, indexes, queriesconstant sysSoupName 		:= ROM_systemsoupname;DefineGlobalConstant('kSystemQuery, {type: 'index, indexPath: 'tag, startKey: kPackageName});constant kPkgSoupName  		:= "TEMPPKG:TKnollSys";   // same as NewtPack (1.x)DefineGlobalConstant('kHTMLSoupName, "TEMPHTML:" & kAppNameS);DefineGlobalConstant('kHTMLQuery, if kNIE then nil else {type: 'index}); // {type:'index,indexPath:'contentID});DefineGlobalConstant('kHTMLIndexes, []); 	// [{structure: 'slot, path: 'contentID, type: 'int}]);DefineGlobalConstant('kTempHTMLSoupDef, {	name: 	 	kHTMLSoupName,	userName: 	kHTMLSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && "Temp Soup",	indexes: 	kHTMLIndexes,	});constant kSoupDir := "soup/";	// for local "files" (for HREF, ACTION)DefineGlobalConstant('kSoupChanged, func(soupName,appSymbol,changeType,changeData) // for RegSoupChangeGetRoot().(kNewtsCapeSymbol):?soupChanged(soupName));//DefineGlobalConstant('kResourceQuery, {type: 'index, indexPath: 'name}); // bitmaps, sounds// -----// {URL*: string, text: string (or bitmap: binary), modified: date, expires: date}DefineGlobalConstant('kCacheHTMLSoupName, 	"HTMLCache:"  & kAppNameS);DefineGlobalConstant('kOpenHTMLcache, 	LocObj("Open HTML Cache", 'openHTMLCacheItem) & $É);DefineGlobalConstant('kCacheImagesSoupName, "ImageCache:" & kAppNameS);DefineGlobalConstant('kOpenImagecache, 	LocObj("Open Image Cache", 'openImageCacheItem) & $É);//DefineGlobalConstant('kOpenDemoURLs, 	LocObj("Open Demo URLs",   'openDemoURLsItem) & $É);DefineGlobalConstant('kOpenNetHopperCache, 	LocObj("Open NetHopper Cache", 'OpenNetHopperCacheItem) & $É);constant kCacheNetHopperSoupName := "NH3StreamDOX:ALLPEN";DefineGlobalConstant('kCacheIndex, {structure: 'slot, path: 'URL, type: 'string});DefineGlobalConstant('kCacheSortIndex, {structure: 'slot, path: '_modTime, type: 'int, order: 'descending});DefineGlobalConstant('kCacheHTMLSoupDef, {	name: 	 	kCacheHTMLSoupName,	userName: 	kCacheHTMLSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && LocObj("HTML", 'HTMLlabel),	// !!!j. LocObj("HTML Cache", 'HTMLCacheLabel),		indexes: 	[kCacheIndex, kCacheSortIndex],	});DefineGlobalConstant('kCacheImagesSoupDef, {	name: 	 	kCacheImagesSoupName,	userName:	 kCacheImagesSoupName,	ownerApp:	 kNewtsCapeSymbol,	userDescr: 	kAppNameL && LocObj("Images", 'imagesLabel),	// !!!j. LocObj("Image Cache", 'ImageCacheLabel),	indexes: 	[kCacheIndex,				kCacheSortIndex,				],	});// !!!gDefineGlobalConstant('kSubmitQueue, 		"Submit Queue");	//LocObj???DefineGlobalConstant('kOpenSubmitCache, 	"Open" && kSubmitQueue & $É); //LocObj???		DefineGlobalConstant('kCacheSubmitSoupName,	"SubmitQueue:" & kAppNameS);DefineGlobalConstant('kCacheSubmitSoupDef, {	name: 	 	kCacheSubmitSoupName,	userName: 	kCacheSubmitSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && kSubmitQueue,	indexes: 	[],		//kCacheIndex, kCacheSortIndex,	???	});DefineGlobalConstant('kBookmarksLabel, LocObj("Bookmarks", 'bookmarksLabel));/* {name: string, URL: string, labels: symbol, type*: symbol, created: date,	modified: date, valid: int, sortOn*: string, labels: symbol} */DefineGlobalConstant('kBookmarkSoupName, "Bookmarks:" & kAppNameS);DefineGlobalConstant('kBookmarkSoupDef, {	name: 	 	kBookmarkSoupName,	userName: 	kBookmarkSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && kBookmarksLabel,	indexes: 	[		'{structure: slot, path: sortOn, type: string},		'{structure: slot, path: type, type: symbol},		//'{structure: slot, path: Labels, type: symbol},		//kCacheSortIndex		],		});// {domain*: string, path: string, expires: date, name: string, value: string}/*DefineGlobalConstant('kCookieSoupName, "Cookies:" & kAppNameS);DefineGlobalConstant('kCookieIndex, {structure: 'slot, path: 'domain, type: 'string});DefineGlobalConstant('kCookieSoupDef, {	name: 	 	kCookieSoupName,	userName: 	kCookieSoupName,	ownerApp: 	kNewtsCapeSymbol,	userDescr: 	kAppNameL && LocObj("Cookies", 'cookiesLabel),	indexes: 	[kCookieIndex],	});*/// -----constant kNewtSymbol		:= '|NewtDevEnv:TKnollSys|; // for saving bookconstant kSloupSymbol		:= '|Sloup:TKnollSys|;constant kBookReaderSymbol	:= 'Copperfield;constant kHelpReaderSymbol	:= 'tinyTim;// View menuDefineGlobalConstant('kCurrentBook,		LocObj("Current Book", 'currentBookItem));//DefineGlobalConstant('kBookProperties, "Book Properties");	// LocObj//DefineGlobalConstant('kCloseOverView,	LocObj("Close Overview", 'closeOverViewItem));DefineGlobalConstant('kReload,			LocObj("Reload", 'reloadItem));DefineGlobalConstant('kLoadWithImages,	LocObj("Load with Images", 'loadWithImagesItem) & $É);DefineGlobalConstant('kLoadLinks,		LocObj("Load Links", 'loadLinksItem) & $É);	// !!!cDefineGlobalConstant('kLoadFrames,		LocObj("Load Frames", 'loadFramesItem) & $É);	// !!!eDefineGlobalConstant('kViewSource,		LocObj("Document Source", 'documentSourceItem));DefineGlobalConstant('kHelpers,			LocObj("Helpers", 'helperItem));	// !!!o// Bookmark menuDefineGlobalConstant('kAddBookmark,		LocObj("Add Bookmark", 'addBookmarkItem));DefineGlobalConstant('kRemoveBookmark,	LocObj("Remove Bookmark", 'removeBookmarkItem));//DefineGlobalConstant('kAddPattern,		"http://www.");//DefineGlobalConstant('kRemoveAll,		LocObj("Remove All", 'removeAllItem));DefineGlobalConstant('kSaveOutline,		LocObj("Save as Outline", 'saveOutlineItem));DefineGlobalConstant('kOpenBookmarks,	LocObj("Browse/Schedule", 'openBookmarksItem)  & $É);// Options menuDefineGlobalConstant('kRegisterOption,	LocObj("Register", 'registerItem) & $É);DefineGlobalConstant('kGeneralOption,	LocObj("General", 'generalItem) & $É);DefineGlobalConstant('kAppearanceOption,LocObj("Appearance", 'appearanceItem) & $É);DefineGlobalConstant('kProcessOption,	LocObj("Process", 'processItem) & $É);DefineGlobalConstant('kEncodingOption,	LocObj("Encoding", 'encodingItem) &  $É);DefineGlobalConstant('kResetAllOption,	LocObj("Reset All", 'resetAllItem) & $É);// processOption (Newt's Cape)constant kDisplayItem	:= 0;constant kDisplayPage	:= 1;constant kDisplayPage1	:= 2;constant kDisplayAll	:= 3;constant kCacheOnly		:= 4;constant kSavePkg		:= 5;constant kSaveNW		:= 6;DefineGlobalConstant('kProcessDefault, kDisplayPage);DefineGlobalConstant('kProcessMax, if kNIE then kSaveNW else kSavePkg);	// in case other built-in options?constant kCacheItem := LocObj("Cache Only", 'cacheOnlyItem);constant kPkgItem := kSaveAsPackage;constant kNWItem := LocObj("Save to NewtWorks", 'saveNewtworksItem);// for Register (Newt's Cape)constant kRegistrationPackage := '|Register:FlaSheridn|;constant kSharewareFee := 35.00;DefineGlobalConstant('kRegFrame,	{package: kNewtsCapeSymbol, 	price:	  kSharewareFee,	platform: 'Newton, 	Version:  kVersionString,	notes:	 LocObj("Thanks for registering", 'thanksRegister) && kAppNameL,	});// Notesconstant dataNoteFont := userFont10; // 10241DefineGlobalConstant('slotNoteFont, dataNoteFont + tsBold); //1058817constant noteHeight := 265;constant noteWidth := 226;constant noteLeft := 10;constant noteTop := 2;DefineGlobalConstant ('kSourcePath,'[pathExpr: data,0,text]);constant kDelay 		:= 2000;	// for disconnect, also for saveNowconstant kLineDelay 	:= 1; 		// for between lines during viewIdleScript/AddDelayedSendconstant kDragRadius 	:= 4;// communications (Newt's Cape)constant kLineLength := 3000; // was 2K/*DefineGlobalConstant('kconfigBPS57600, // openButton.pickActionScript	{label: kCMOSerialIOParms,	type: 	'option,	opCode: if kNewEndPoint then opSetRequired else opSetNegotiate,	result:	nil,	form:	'template,	data: 	if kNewEndPoint		then {			arglist: [				k1StopBits,		// 1 stop bit				kNoParity,		// no parity bit				k8DataBits,		// 8 data bits				k57600bps,		// data rate in bps		// ***				],			typelist: ['struct,				'long,			// stop bits				'long,			// parity				'long,			// data bits				'long,			// bps				],			}		else {			bps: k57600bps, dataBits: k8DataBits,		// ***			stopBits: k1StopBits, parity: kNoParity,			},	});if not kNewEndPointthen begin	RemoveSlot(kconfigBPS57600, 'result);	RemoveSlot(kconfigBPS57600, 'form);	end;DefineGlobalConstant('kADSPconfig,[ // configOptions for ADSP{label:	kCMSAppleTalkID,type:	'service,opCode:	opSetRequired,},{label:	kCMSAppleTalkID,type:	'option,opCode:	opSetRequired,form:	'template,data:	if kNewEndpoint	then {		arglist: [KCMOAppleTalkADSP],		typelist:['struct,			['array, 'char, 4],			],		}	else kCMOAppleTalkADSP,},{label:	kCMOEndpointName,type:	'option,opCode:	opSetRequired,form:	'template,		data:	if kNewEndpoint	then { 		arglist:  [kADSPEndpoint],		typelist: ['struct,			['array, 'char, 0],			],		}	else kADSPEndpoint,},		]);if not kNewEndPointthen begin	RemoveSlot(kADSPconfig[1], 'form);	//kCMSAppleTalkID	RemoveSlot(kADSPconfig[2], 'form);	//kCMOEndpointName	end;*/// for character entitiesconstant kSpace 			:= " ";constant kDash 				:= "-";DefineGlobalConstant('kSplitArray, func(ARRAY a1, a2, nv) // for development timebegin	SetLength(a1, Length(nv) div 2);	SetLength(a2, Length(nv) div 2);	local INT i;	for i:=0 to Length(nv)-1 by 2	do begin		a1[i div 2] := nv[i];		a2[i div 2] := nv[i+1];		end;end);DefineGlobalConstant('kCharNames160,[ // proposed? p.66-67, p.75-76// a contiguous list of char names (case sensitive)// *** have no Newton font char (see kCharExcept)"nbsp",		// 160. no-break space ***"iexcl",	// inverted exclamation mark"cent",		// cent sign"pound",	// pound sterling sign"curren",	// general currency sign"yen",		// yen sign"brvbar",	// broken (vertical) bar ***	// !!!x"sect",		// section sign"uml",		// umlaut (dieresis)"copy",		// copyright sign"ordf",		// 170. ordinal indicator, feminine"laquo",	// angle quotation mark, left"not",		// not sign"shy",		// soft hyphen ***"reg",		// registered sign"macr",		// macron"deg",		// degree sign"plusmn",	// plus-or-minus sign"sup2",		// superscript 2 ***"sup3",		// superscript 3 ***"acute",	// 180. acute accent"micro",	// micro sign"para",		// pilcrow (paragraph sign)"middot",	// middle dot"cedil",	// cedilla"sup1",		// superscript 1 ***"ordm",		// ordinal indicator, masculine"raquo",	// angle quotation mark, right"frac14",	// fraction one-quarter ***"frac12",	// fraction one-half ***"frac34",	// 190. fraction three-quarters ***"iquest",	// inverted question mark"Agrave",	// A, grave accent"Aacute",	// A, acute accent"Acirc",	// A, circumflex accent"Atilde",	// A, tilde"Auml",		// A, dieresis or umlaut mark"Aring",	// A ring"AElig",	// AE, diphthong (ligature)"Ccedil",	// C, cedilla"Egrave",	// 200. E, grave accent"Eacute", 	// E, acute"Ecirc",	// E, circumflex"Euml",		// E, umlaut"Igrave",	// I, grave"Iacute", 	// I, acute"Icirc",	// I, circumflex"Iuml",		// I, umlaut"ETH",		// Eth, Icelandic ***"Ntilde", 	// N, tilde"Ograve",	// 210. O, grave"Oacute", 	// O, acute"Ocirc",	// O, circumflex"Otilde", 	// O, tilde"Ouml",		// O, umlaut"times",	// multiply sign ***"Oslash",	// O, slash"Ugrave",	// U, grave"Uacute", 	// U, acute"Ucirc",	// U, circumflex"Uuml",		// 220. U, umlaut"Yacute", 	// Y, acute ***"THORN",	// THORN, Icelandic ***"szlig",	// sharp s, German (sz ligature)"agrave",	// a, grave"aacute",	// a, acute"acirc",	// a, circumflex"atilde",	// a, tilde"auml",		// a, umlaut"aring",	// a ring"aelig",	// 230. ae, diphthong (ligature)"ccedil",	// c, cedilla"egrave",	// e, grave"eacute", 	// e, acute"ecirc",	// e, circumflex"euml",		// e, umlaut"igrave",	// i, grave"iacute", 	// i, acute"icirc",	// i, circumflex"iuml",		// i, umlaut"eth",		// 240. eth, Icelandic ***"ntilde", 	// n, tilde"ograve",	// o, grave"oacute", 	// o, acute"ocirc",	// o, circumflex"otilde", 	// o, tilde"ouml",		// o, umlaut"divide",	// divide sign"oslash",	// o, slash"ugrave",	// u, grave"uacute", 	// 250. u, acute"ucirc",	// u, circumflex"uuml",		// u, umlaut"yacute", 	// y, acute ***"thorn",	// thorn, Icelandic ***"yuml",		// y, umlaut]);// fixStringDefineGlobalConstant('kCharCodes, []);DefineGlobalConstant('kCharNames, []);// a non-contiguous list of char names (case sensitive) & corresponding codescall kSplitArray with (kCharCodes, kCharNames,[60, "lt",62,	"gt",38,	"amp",34,	"quot",]);// a few chars with no unicode charDefineGlobalConstant('kCharExceptNames, []);DefineGlobalConstant('kCharExceptValues,[]);constant kBullet := $\u2022;// used in fixString. also if fixISO, single chars (only) copied in HTTP.Instantiatecall kSplitArray with (kCharExceptNames, kCharExceptValues,[//127//128//129130, $\u201A,	// [sbquo] 	!!!f131, $\u0192,	// [fnof]	!!!f132, $\u201E,	// [bdquo]	!!!f133, $\u2026,	// [hellip] ...134, $\u2020,	// dagger [dagger]135, $\u2021,	// doubledagger [Dagger]136, $\u02C6,	// circumflex [circ]137, $\u2030,	// salinity//138139, $\u2039,	// [lsaquo]	!!!f140, $\u0152,	// OE diphthong [OElig]//141//142//143//144145, $\u2018,	// [lsquo]	!!!f146, $\u2019,	// [rsquo]	!!!f147, $\u201C,	// [ldquo]	!!!f148, $\u201D,	// [rdquo]	!!!f149, kBullet,	// bullet [bull]150, $\u2013,	// [ndash]	!!!f151, $\u2014,	// [mdash] 	!!!f152, $\u02DD,	// [Prime?]	!!!f153, $\u2122,	// trademark [trade]//154155, $\u203A,	// [rsaquo]	!!!f156, $\u0153,	// oe diphthong [oelig]//157//158159, $\u0178,	// Yumlaut [Yuml]?// kCharNames160//160, $ ,		// [nbsp] non breaking space. !!!g166, $|,		// [brvbar] broken vertical bar173, $-,  		// [shy] soft hyphen178, "^2", 		// [sup2] superscript 2179, "^3", 		// [sup3] superscript 3185, "^1", 		// [sup1] superscript 1 $\u0131 ?188, "1/4",		// [frac14]189, "1/2",		// [frac12]190, "3/4",		// [frac34]//208, kCharNames160[208-160],	// ETH215, $*,  		// times//221, kCharNames160[221-160],	// Yacute//222, kCharNames160[222-160], 	// THORN//240, kCharNames160[240-160],	// eth//253, kCharNames160[253-160],	// yacute//254, kCharNames160[254-160],	// thorn]);/*Euro&euro; = &#8364;in iso-8859-15, 164 decimal (map to curren?)*/// possibly share kCharExceptValues, kCharSpecialValues -- most of beginning are same? but what about diffs?// entities with no code#DefineGlobalConstant('kCharSpecialNames, []);DefineGlobalConstant('kCharSpecialValues,[]);call kSplitArray with (kCharSpecialNames, kCharSpecialValues,[// Latin Extended-B"fnof",		$\u0192,	// florin latin small f = function// GREEK capital//Alpha    CDATA "&#913;",U+0391//Beta     CDATA "&#914;".U+0392//Gamma    CDATA "&#915;",U+0393"Delta",	$\u2206,	// CDATA "&#916;",U+0394//Epsilon  CDATA "&#917;",U+0395//Zeta     CDATA "&#918;",U+0396//Eta      CDATA "&#919;".U+0397//Theta    CDATA "&#920;",U+0398//Iota     CDATA "&#921;",U+0399//Kappa    CDATA "&#922;",U+039A//Lambda   CDATA "&#923;",U+039B//Mu       CDATA "&#924;",U+039C//Nu       CDATA "&#925;",U+039D//Xi       CDATA "&#926;",U+039E//Omicron  CDATA "&#927;",U+039F"Pi",		$\u220F,	// CDATA "&#928;",U+03A0//Rho      CDATA "&#929;",U+03A1//no Sigmaf, and no U+03A2 character either"Sigma",	$\u2211,	// CDATA "&#931;",U+03A3//Tau      CDATA "&#932;",U+03A4//Upsilon  CDATA "&#933;",U+03A5//Phi      CDATA "&#934;",U+03A6//Chi      CDATA "&#935;",U+03A7//Psi      CDATA "&#936;",U+03A8"Omega",	$\u2126,	//    CDATA "&#937;",U+03A9// Greek small letter//alpha    CDATA "&#945;",U+03B1//beta     CDATA "&#946;",U+03B2//gamma    CDATA "&#947;",U+03B3"delta",	$\u2202,	// CDATA "&#948;",U+03B4//epsilon  CDATA "&#949;",U+03B5//zeta     CDATA "&#950;",U+03B6//eta      CDATA "&#951;",U+03B7//theta    CDATA "&#952;",U+03B8//iota     CDATA "&#953;",U+03B9//kappa    CDATA "&#954;",U+03BA//lambda   CDATA "&#955;",U+03BB"mu",		$\u00B5,    // CDATA "&#956;",U+03BC//nu       CDATA "&#957;",U+03BD//xi       CDATA "&#958;",U+03BE//omicron  CDATA "&#959;",U+03BF"pi",		$\u03C0,//rho      CDATA "&#961;",U+03C1//sigmaf   CDATA "&#962;",U+03C2//sigma    CDATA "&#963;",U+03C3//tau      CDATA "&#964;",U+03C4//upsilon  CDATA "&#965;",U+03C5//phi      CDATA "&#966;",U+03C6//chi      CDATA "&#967;",U+03C7//psi      CDATA "&#968;",U+03C8//omega    CDATA "&#969;",U+03C9//thetasym CDATA "&#977;",U+03D1//upsih    CDATA "&#978;",U+03D2 w/ hook symbol//piv      CDATA "&#982;",U+03D6// General Punctuation"bull",		kBullet,	// bullet. NOT the same as bullet operator, U+2219"hellip",	$\u2026,	// horizontal ellipsis = three dot leader"prime",	$\u00B4,	// !!!f. $',// prime = minutes = feet, U+2032"Prime",	$\u02DD,	// !!!f. $", 		// double prime = seconds = inches, U+2033//oline    CDATA "&#8254;" -- overline = spacing overscore, U+203E"frasl",	$\u2044,	// fraction slash// Letterlike Symbols//weierp   CDATA "&#8472;" -- script capital P = power set = Weierstrass p, U+2118//image    CDATA "&#8465;" -- blackletter capital I = imaginary part, U+2111//real     CDATA "&#8476;" -- blackletter capital R = real part symbol, U+211C"trade",	$\u2122,	// CDATA "&#8482;" -- trade mark sign, U+2122//alefsym  CDATA "&#8501;" -- alef symbol = first transfinite cardinal, U+2135	//NOT the same as hebrew letter alef, U+05D0 although the same glyph could be used to depict both characters// Arrows//larr     CDATA "&#8592;" -- leftwards arrow, U+2190//uarr     CDATA "&#8593;" -- upwards arrow, U+2191//rarr     CDATA "&#8594;" -- rightwards arrow, U+2192//darr     CDATA "&#8595;" -- downwards arrow, U+2193//harr     CDATA "&#8596;" -- left right arrow, U+2194//crarr    CDATA "&#8629;" -- downwards arrow with corner leftwards = carriage return, U+21B5//lArr     CDATA "&#8656;" -- leftwards double arrow, U+21D0. 'is implied by'?//uArr     CDATA "&#8657;" -- upwards double arrow, U+21D1//rArr     CDATA "&#8658;" -- rightwards double arrow, U+21D2. 'implies'?//dArr     CDATA "&#8659;" -- downwards double arrow, U+21D3//hArr     CDATA "&#8660;" -- left right double arrow, U+21D4// Mathematical Operators// forall   CDATA "&#8704;" -- for all, U+2200"part",		$\u2202,	// CDATA "&#8706;" -- partial differential, U+2202//exist    CDATA "&#8707;" -- there exists, U+2203//empty    CDATA "&#8709;" -- empty set = null set = diameter, U+2205//nabla    CDATA "&#8711;" -- nabla = backward difference, U+2207//isin     CDATA "&#8712;" -- element of, U+2208//notin    CDATA "&#8713;" -- not an element of, U+2209//ni       CDATA "&#8715;" -- contains as member, U+220B"prod",		$\u220F,	// CDATA "&#8719;" -- n-ary product = product sign, U+03A0 'greek capital letter pi'"sum",		$\u2211,	// CDATA "&#8721;" -- n-ary sumation, U+2211. U+03A3 'greek capital letter sigma'"minus",	$-,			// CDATA "&#8722;" -- minus sign, U+2212//lowast   CDATA "&#8727;" -- asterisk operator, U+2217"radic",	$\u221A,	// CDATA "&#8730;" -- square root = radical sign, U+221A//prop     CDATA "&#8733;" -- proportional to, U+221D"infin",	$\u221E,	// CDATA "&#8734;" -- infinity, U+221E//ang      CDATA "&#8736;" -- angle, U+2220//and      CDATA "&#8743;" -- logical and = wedge, U+2227//or       CDATA "&#8744;" -- logical or = vee, U+2228//cap      CDATA "&#8745;" -- intersection = cap, U+2229//cup      CDATA "&#8746;" -- union = cup, U+222A"int",		$\u222B,	// CDATA "&#8747;" -- integral, U+222B//there4   CDATA "&#8756;" -- therefore, U+2234"sim",		$~,			// CDATA "&#8764;" -- tilde operator = varies with = similar to, U+223C	// NOT the same character as the tilde, U+007E, although the same glyph might be used to represent both//cong     CDATA "&#8773;" -- approximately equal to, U+2245"asymp",	$\u2248,	// CDATA "&#8776;" -- almost equal to = asymptotic to, U+2248"ne",		$\u2260,	// CDATA "&#8800;" -- not equal to, U+2260//equiv    CDATA "&#8801;" -- identical to, U+2261"le",		$\u2264,	// CDATA "&#8804;" -- less-than or equal to, U+2264"ge",		$\u2265,	// CDATA "&#8805;" -- greater-than or equal to, U+2265//sub      CDATA "&#8834;" -- subset of, U+2282//sup      CDATA "&#8835;" -- superset of, U+2283	//nsup, 'not a superset of, U+2283' is not covered by the Symbol font encoding//nsub     CDATA "&#8836;" -- not a subset of, U+2284//sube     CDATA "&#8838;" -- subset of or equal to, U+2286//supe     CDATA "&#8839;" -- superset of or equal to, U+2287//oplus    CDATA "&#8853;" -- circled plus = direct sum, U+2295//otimes   CDATA "&#8855;" -- circled times = vector product, U+2297//perp     CDATA "&#8869;" -- up tack = orthogonal to = perpendicular, U+22A5//sdot     CDATA "&#8901;" -- dot operator, U+22C5. NOT the same character as U+00B7 middle dot// Miscellaneous Technical//lceil    CDATA "&#8968;" -- left ceiling = apl upstile, U+2308//rceil    CDATA "&#8969;" -- right ceiling, U+2309//lfloor   CDATA "&#8970;" -- left floor = apl downstile, U+230A//rfloor   CDATA "&#8971;" -- right floor, U+230B//lang     CDATA "&#9001;" -- left-pointing angle bracket = bra, U+2329	//lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark'//rang     CDATA "&#9002;" -- right-pointing angle bracket = ket, U+232A	//rang is NOT the same character as U+003E 'greater than' or U+203A 'single right-pointing angle quotation mark'// Geometric Shapes"loz",		$\u25CA,	// CDATA "&#9674;" -- lozenge, U+25CA// Miscellaneous Symbols//spades   CDATA "&#9824;" -- black spade suit, U+2660	//black here seems to mean filled as opposed to hollow//clubs    CDATA "&#9827;" -- black club suit = shamrock, U+2663//hearts   CDATA "&#9829;" -- black heart suit = valentine, U+2665//diams    CDATA "&#9830;" -- black diamond suit, U+2666// Latin Extended-A -->"OElig",	$\u0152,	// CDATA "&#338;"  -- latin capital ligature OE, U+0152"oelig",	$\u0153,	// CDATA "&#339;"  -- latin small ligature oe, U+0153	//ligature is a misnomer, this is a separate character in some languages -->//Scaron  CDATA "&#352;"  -- latin capital letter S with caron, U+0160 ISOlat2 -->//scaron  CDATA "&#353;"  -- latin small letter s with caron, U+0161 ISOlat2 -->"Yuml",		$\u0178,	// CDATA "&#376;"  -- latin capital letter Y with diaeresis, U+0178// Spacing Modifier Letters"circ",		$\u02C6,	// CDATA "&#710;"  -- modifier letter circumflex accent, U+02C6"tilde",	$\u02DC,	// CDATA "&#732;"  -- small tilde, U+02DC// General Punctuation"ensp",		$ ,		// CDATA "&#8194;" -- en space, U+2002"emsp",		$ ,		// CDATA "&#8195;" -- em space, U+2003"thinsp",	$ ,		// CDATA "&#8201;" -- thin space, U+2009//zwnj    CDATA "&#8204;" -- zero width non-joiner, U+200C//zwj     CDATA "&#8205;" -- zero width joiner, U+200D//lrm     CDATA "&#8206;" -- left-to-right mark, U+200E//rlm     CDATA "&#8207;" -- right-to-left mark, U+200F"ndash",	$\u2013,	// CDATA "&#8211;" -- en dash, U+2013"mdash",	$\u2014,	// CDATA "&#8212;" -- em dash, U+2014"lsquo",	$\u2018,	// CDATA "&#8216;" -- left single quotation mark, U+2018"rsquo",	$\u2019,	// CDATA "&#8217;" -- right single quotation mark, U+2019"sbquo",	$\u201A,	// CDATA "&#8218;" -- single low-9 quotation mark, U+201A"ldquo",	$\u201C,	// CDATA "&#8220;" -- left double quotation mark, U+201C"rdquo",	$\u201D,	// CDATA "&#8221;" -- right double quotation mark, U+201D"bdquo",	$\u201E,	// CDATA "&#8222;" -- double low-9 quotation mark, U+201E"dagger",	$\u2020,	// CDATA "&#8224;" -- dagger, U+2020"Dagger",	$\u2021,	// CDATA "&#8225;" -- double dagger, U+2021"permil",	$\u2030,	// CDATA "&#8240;" -- per mille sign, U+2030"lsaquo",	$\u2039,	// CDATA "&#8249;" -- single left-pointing angle quotation mark, U+2039 ISO proposed"rsaquo",	$\u203A,	// CDATA "&#8250;" -- single right-pointing angle quotation mark, U+203A ISO proposed //euro   CDATA "&#8364;"  -- euro sign, U+20AC// dots//"ldots", 	$\u2026,	// ???// spaces//"sp", 	$ ,		// ???//Icon Entities (see html3:entities.htm)//substitute IMG inline in fixString?//&ftp; -- ftp server//&gopher; -- gopher server//&telnet; -- telnet connection//&archive; -- archive server//&filing.cabinet; -- filing cabinet//&folder; -- folder or directory//&fixed.disk; -- fixed media drive//&disk.drive; -- removeable media drive//&document; -- unspecified document type//&unknown.document; -- unrecognised document type//&text.document; -- text/plain, text.html etc//&binary.document; -- binary data//&binhex.document; -- binhex format//&audio; -- audio sequence//&film; -- film or animation, such as an MPEG movie//&image; -- photograph, drawing or graphic of any kind//&map; -- geographical or a schematic map//&form; -- fill-out form//&mail; -- email messages//&parent; -- parent of current document//&next; -- next document in current sequence//&previous; -- previous document in current sequence//&home; -- home document//&toc; -- table of contents//&glossary; -- glossary of terms etc//&index; -- searchable index//&summary; -- summary//&calculator; -- A calculator//&caution; -- Warning sign//&clock; -- A clock//&compressed.document;//&diskette; -- A diskette//&display; -- A computer screen//&fax; -- A fax machine//&mail.in; -- mail-in tray//&mail.out; -- mail-out tray//&mouse; -- mouse/pointing device//&printer; -- hardcopy device//&tn3270; -- tn3270 terminal session//&trash; -- waste paper basket//&uuencoded.document; -- uuencoded data]);constant kGIFextension	:= ".gif";constant kGIFStart		:= "GIF";			// for matching binaryconstant kJPEGStart		:= "JFIF";DefineGlobalConstant('kEmptyGlobal, {	cache: [], historyPos: 0,				htmlApps: {}, helperApps: {},	imageExtensions: [kGIFextension],	protos: {},	}); constant kPkgStart := "package";constant kHistoryPath	:= 'cache;		// should have been called historyconstant kHistoryPos	:= 'historyPos;DefineGlobalConstant('kInitGlobal, func(slot,val)begin	local gData;	if kBuild1x or Functions.GetGlobals exists	then begin		if not gData := GetGlobals().(kNewtsCapeSymbol)		then GetGlobals().(EnsureInternal(kNewtsCapeSymbol)) := gData := EnsureInternal(kEmptyGlobal);		end	else begin		if not gData := GetGlobalVar(kNewtsCapeSymbol)		then DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal(kEmptyGlobal));		end;	if slot	then if gData.(slot)		then gData.(slot)		else gData.(EnsureInternal(slot)) := EnsureInternal(val)	else gData;end);constant kFirstFieldsFlag	:= '_pageField1;// FORM functionsDefineGlobalConstant('kAllData, func(keep) // "allData"// use this instead of :AuthorData() to make sure Hidden values, form_init used// keep=nil means resetbegin	local iData := call kInitGlobal with (Intern(ISBN), {}), iaction, adata;	if not (adata := idata.(iaction := EnsureInternal(Intern(action))))	then adata := idata.(iaction) := {};	if not idata.(kFirstFieldsFlag)	// keep track for book of which TEXT/PASSWORD field on page is first	then idata.(EnsureInternal(kFirstFieldsFlag)) := [];	if not keep or Length(adata) = 0	then begin		bdata := :BookData();		local hidden := if bdata then DeepClone(bdata.form_hidden.(iaction)) else {}; // closed?		ReplaceObject(adata, EnsureInternal(hidden));		bdata:?form_init(adata,action);		if not keep and call kViewIsOpenFunc with (GetRoot().(kBookReaderSymbol)) // refresh for reset		then :ScrollPage(0);		end;	adata;end);DefineGlobalConstant('kGetData, func(name) // assume symbolif namethen :AllData(true).(name));DefineGlobalConstant('kSetData, func(name,val) // assume symbolif namethen :AllData(true).(EnsureInternal(name)) := EnsureInternal(Clone(val)));DefineGlobalConstant('kPrintFunc, func(val) Print(val)); // for default SCRIPTconstant cr := "\n";constant lf := "\u000A";DefineGlobalConstant('crlf, unicodeCR&unicodeLF);DefineGlobalConstant('kNilFunc0, func() nil);DefineGlobalConstant('kNilFunc1, func(arg) nil);  // for viewClickScriptDefineGlobalConstant('kAppHeight, 152);		// 1.3 = 136DefineGlobalConstant('kAppWidth, 240);DefineGlobalConstant('kThick, 3); 			// thickness of app frame. just let it possibly clip on left/rightconstant kTagP	  := '{_tag: P};DefineGlobalConstant('kATagP, [kTagP]);constant kTagHTML := '{_tag: HTML, _value: true};constant kTagBODY := '{_tag: BODY, _value: true};constant kHTMLStart		:= "<HTML>";constant kHTMLStop		:= "</HTML>";constant kTitleStart	:= "<TITLE>";constant kTitleStop		:= "</TITLE>";constant kBodyStart		:= "<BODY";constant kBodyStop		:= "</BODY>";constant kHeadStop		:= "</HEAD>";constant kBaseStart 	:= "<BASE";constant kFrameStart	:= "<FRAME";constant kIFrameStart	:= "<IFRAME";constant kLinkStart		:= "<LINK";constant kHREF			:= "HREF=";	// !!!gconstant kSRC			:= "SRC=";constant kNAME			:= "NAME=";constant kALT			:= "ALT=";constant kCommentStart	:= "<!--";constant kCommentStop	:= "-->";constant kHelpISBN := "introtoc.htm"; // first bookconstant kAlign := '["Left", "Right", "Center", "Justify"];DefineGlobalConstant('kPrefTags, [	"ADDRESS", "BLOCKQUOTE", "CAPTION", "DD", "DT",	// !!!e,b "DIV"	"H1","H2", "H3", "H4", "H5", "H6",	"LI", "P", "PRE",	"TITLE",	// "XMP",	//"TD", "TH",		// these are containers	'pickSeparator,		// add form objs (some in tagDict, inputDict)	"CHECKBOX", "RADIO", 	//"PASSWORD", "PASSWORD_LABEL", "RESET",	"SELECT", "SELECT_LABEL", "SELECT_MENU", "SUBMIT",	"TEXT", "TEXT_LABEL", "TEXTAREA",		]);if kBuild1xthen begin	ArrayRemoveCount(kPrefTags,		ArrayPos(kPrefTags,"SELECT_MENU",SetContains(kPrefTags,'pickSeparator)+1,Functions.StrEqual), 1);	end;DefineGlobalConstant('kNoName, 		LocObj("no NAME", 'noNameErr));DefineGlobalConstant('kNoHelper,	LocObj("no helper for", 'noHelperErr));DefineGlobalConstant('kMissing,		${ & LocObj("missing", 'missingErr) && "^0}");DefineGlobalConstant('kReplacePkg,	LocObj("Replace existing package?", 'replacePackage));constant kHTTP 		:= "http:";constant kHTTPS		:= "https://";constant kHTTPlen	:= 7;			// = http://constant kMailTo 	:= "mailto:";constant kNews		:= "news:";constant kFtp		:= "ftp:";constant kJavaScript:= "javascript:";constant kLocation	:= "Location";constant kPost 		:= "POST";constant kGet		:= "GET";constant kTitles	:= "_Titles";DefineGlobalConstant('kDefaultMethod, kGet);constant kNewtsPaperSymbol := '|NewsNewt:SKoren|;constant kURL		:= "URL";constant kUnkURL  := "x"; // for form stuff?constant kDefaultEncType 		:= "application/x-www-form-urlencoded";constant kHTMLMediaType 		:= "text/html";constant kGIFMediaType			:= "image/gif";constant kTextMediaType 		:= "text/plain";constant kJPEGMediaType			:= "image/jpeg";constant kAllMediaType			:= "*/*";DefineGlobalConstant('kContentTypeSym, Intern("Content-Type"));DefineGlobalConstant('kIsHTML, func(htmlSource)	// !!!j. was :skipHTMLif htmlSourcethen begin	local spos := StrPos(htmlSource, kHTMLStart, 0);	if spos	then spos	else StrPos(htmlSource, "<!DOCTYPE", 0);	end);// BOOKS// page indent/bounds  (see :bookTemplate)DefineGlobalConstant('kGetInt, func(val, default)	// !!!bbegin	if (if kBuild20 then isInteger(val) else isInstance(val, 'int))	then val	else if (if kBuild20 then IsString(val) else isInstance(val, 'string))		and val := StringToNumber(val)	then Floor(val)	else default;		// typically: 0, nilend);DefineGlobalConstant('kGetStr, func(val, default)	// !!!b. see bookTemplatebegin	if (if kBuild20 then IsString(val) else isInstance(val, 'string)) and StrFilled(val)	then Clone(val)	else default;end);DefineGlobalConstant('kprotoContainer, {	// used for rootContainer, UL, TABLE, etc.	left:		0,	top:		0,	right:		0,	bottom:		0,	indent:		0,	above:		0,	indentR:	0,	below:		0,	align:		0,	height:		0,	// e.g., for UL	_tag:		NIL,	_value:		NIL,	_container:	NIL,	_contents:	NIL,	getWidth:	func() 				right  - left - indent - indentR,	getHeight:	func() 				bottom - top,	addTop:		func(INT newVal)	top := top + newVal,	// !!!a1. unnecessary accessors (save some space)	//getLeft:	func()				left,	//setLeft:	func(INT newVal)	left := newVal,	//getRight:	func()				right,	//setRight:	func(INT newVal)	right := newVal,	//getTop:		func()				top,	//setTop:		func(INT newVal)	top := newVal,	//getBottom:	func()				bottom,	//setBottom:	func(INT newVal)	bottom := newVal,	setContainer: func(newContainer)	// msg to currentContainer. push/pop a container		if newContainer		then begin			newContainer.left 		:= left;	//  + newContainer.indent			newContainer.indent 	:= newContainer.indent + indent;			//newContainer.indentR 	:= newContainer.indentR + indentR;			newContainer.top 		:= top; 	//  + newContainer.above; (only if not=rootcontainer.top?)	// :setTop ???  			newContainer.right 		:= right;	// - newtContainer.indentR;			newContainer.bottom		:= bottom;	// - newtContainer.below;			newContainer._container := self;			newContainer;			end		else if _container		then begin			_container.top := top; // :setTop(top);	//  + below ?			_container;			end		else self,	// keep around just in case (e.g., TD outside TABLE)	fixWidth: func(str, INT availWid, INT contWid)	// str: width as a percentage or pixels	begin		local slen, ival, wid :=			if (if kBuild20 then IsString(str) else isInstance(str, 'string)) and				(slen := StrLen(str)) > 0			then if str[slen-1] = $% //EndsWith(str,"%")					then begin					if ival := StringToNumber(SubStr(str,0,slen-1))	// !!!q. nec for German ROMs & small nums?					then min(availWid, Floor(contWid * ival/100));	// % of container width					end				else if ival := StringToNumber(str)				then min(availWid, Floor(ival));				// pixels <= availWid		if wid		then right := left + wid		else wid := right - left;		wid;	end,	renderObj:	func(obj)	// copied by P		while isFrame(obj) and obj := obj:addBlock() do obj:newPage(),	addItem: func(obj)	// default/direct behavior: render and display	begin//if kDebugHTTP then Print("container:" && _tag && if _value then "start" else "stop");		local obj1 := obj._tag, newobj;		if optionsAPI.ignoreTables and SetContains('[TD,TH,TR,TABLE],obj1)		then return NIL;		if obj._value and		// moved/expanded			(((obj1='TR or (obj1='CAPTION and not optionsAPI.ignoreTables))	// !!!k				and _tag <> newobj := 'TABLE) or	// e.g., missing <TABLE> tag in concerts.calendar.com			 ((obj1='TD or obj1='TH) 	  and _tag <> newobj := 'TR)		// missing TABLE/TR after nested?			)		then begin//Print("adding:" && newobj);			currentContainer:addItem(:getObj(tagDict, newobj, true)); 	// add TABLE/TR			return currentContainer:addItem(obj);						// add obj to new TABLE/TR			end;		if newobj := obj:get_data()		then if isArray(newobj)			then // array of objs (assume only single level)				foreach obj1 in newobj	// 				do :renderObj(obj1)			else :renderObj(newobj);	// single obj	end,	get_data: func()	// used by TABLE, TR, TD/TH	begin		if _value		then begin			align := :getAlign();			currentContainer := currentContainer:setContainer(self);			_contents := [];			end		else if _tag = currentContainer._tag	// !!!g. only pop if same tag (e.g., extra </DIV>		then currentContainer := currentContainer:setContainer(nil);		NIL;	end,	fixAttribute: func(val, type, default)	// used by TABLE, TR, TD/TH. copied by P	if isInstance(val, type)	// already converted?	then val	else if (if kBuild20 then IsString(val) else isInstance(val, 'string))	then if type='int		then begin			local slen := StrLen(val), ival;			if val[slen-1] = $%			then if ival := StringToNumber(SubStr(val,0,slen-1))	// !!!q. for German ROMs. see fixWidth				then Floor(default * ival / 100)		// HR WIDTH				else default			else if ival := StringToNumber(val)			then Floor(ival)			else default;			end		else if type='symbol		then Intern(val)		else val	else default,	});constant kSplitHeight := 14; // see :addBlockDefineGlobalConstant ('kContentsPath,	'contents);DefineGlobalConstant ('kPagePath,		'[pathExpr: rendering,0,pages]);DefineGlobalConstant ('kHintPath,		'[pathExpr: rendering,0,contents,0]);DefineGlobalConstant ('kTemplatePath,	'[pathExpr: templates,0]);DefineGlobalConstant ('kScriptsPath,	'[pathExpr: templates,0,scripts]);DefineGlobalConstant ('kTOCPath,		'[pathExpr: browsers,0,list]);DefineGlobalConstant ('kStringHintsPath,'hints);DefineGlobalConstant ('kStylePath,		'styles);DefineGlobalConstant ('kDataPath,		'data);							// doublecheck separate access via :BookData()DefineGlobalConstant ('kBasePath,		'[pathExpr: data, base_href]);DefineGlobalConstant ('kEdataPath,		'[pathExpr: data, edata]);DefineGlobalConstant ('kLinkPath,		'[pathExpr: data, links]);DefineGlobalConstant ('kFHiddenPath,	'[pathExpr: data, form_hidden]);DefineGlobalConstant ('kFPrintPath,		'[pathExpr: data, form_printnames]);// title, shortTitle, author, isbn, help, appSymbol, _package ?/*1.x:whereisBook{...bookSoup: {book: <book itself>} = libooklibrary.books [	{<book info slots>,	booksoup: {book: <book itself>},	}...]2.0:whereisBook{library: {<book info, soup entry slots>} = :getLibraryEntrybookSoup: {book: <book itself>} = libooklibrary [??]*/DefineGlobalConstant('kLFetch, func(ARRAY a, item, INT start, testfn, path, ix) // if ix=true then index else entry/*begin	local INT rest := Length(a) - start;	local testFn := if kNIE		then if rest=1			then GetGlobalFn(if testSym='|str=| then 'StrEqual else testSym)			else if testSym='|=| or testSym='|str=| then testSym else if testSym then GetGlobalFn(testSym) else '|=|		else xxxif Length(a) - start = 1then if call (if kNIE then GetGlobalFn(testSym) else Functions.(testSym)) with (item, a[start])	then if ix		then start		else a[start]	else nilelse if kNIEthen if (start := LSearch (a, item, start, if testSym='|=| or testSym= '|str=| then testSym else GetGlobalFn(testSym), path))	then if ix		then start		else a[start]	else nil	else if path then*/begin // like limited LFetch for 1.x. if path=nil, use ArrayPos directly	local entry, val;	local INT i;	for i := 0 to Length(a)-1	do if (val := (entry := a[i]).(path)) and call testfn with (item, val)	then return if ix then i else entry;	NIL;	end//else ArrayPos(a, item, start, testfn));DefineGlobalConstant('kFindPkg, func(pkgname)if kNIEthen begin	local store, pkg;	foreach store in GetStores()			// was GetPackageStores	do if pkg := GetPkgRef(pkgname, store)	then return pkg;	NIL;	endelse call kLFetch with (GetPackages(), pkgname, 0, Functions.StrEqual, 'title, nil));DefineGlobalConstant('kThawPkg, func(pkgname) // thaw an app or bookif (kBuild20 or Functions.ThawPackage exists) and	pkgname := call kFindPkg with (pkgname)then begin	ThawPackage(pkgname);	TRUE;	end);// same def as used in NewtDefineGlobalConstant('kFindBook, func(isbn,libentry) // used by refreshBook, kGotoHREF, saveBook, dumpBookbegin	local viewer := GetRoot().(kBookReaderSymbol), nos20 := kBuild20 or HasVariable(viewer,'getLibraryEntry);	local libook := viewer:whereIsBook(isbn), library := viewer.library; // !!!u	if (kBuild20 or nos20) and libook and		(not isFrame(libook.bookSoup)									// <bad pkg ref>		or not try libook.bookSoup.book onexception |evt.ex| do NIL)	// *** evt.ex.fr ***	then begin // see kBookCleanup		if library		then RemoveSlot(library, Intern(isbn)); // NOS 2.x bug. badly removed help book?		libook := NIL;		end;	if not libook	then libook := if call kThawPkg with (isbn) then viewer:whereIsBook(isbn);	if libook	then if libentry		then if kBuild20 or nos20			then libook.library			else begin				if library				then call kLFetch with (library.books, isbn, 0, Functions.StrEqual, 'isbn, nil);				end		else if libook.bookSoup and			(not nos20 or not libook.library or libook.library.bookPresent>0 or libook.bookSoup.help)		then libook.bookSoup.book;end);DefineGlobalConstant('kFindApp, func(appsym)if (if kBuild20 then IsSymbol(appsym) else isInstance(appsym,'symbol))then begin	local root := GetRoot(), app;	if app := root.(appsym)	then app	else if call kThawPkg with (SprintObject(appsym))	then root.(appsym);	end);DefineGlobalConstant('kAllBooks, func()begin // return array of current ISBNs	local viewer := GetRoot().(kBookReaderSymbol), nos20 := kBuild20 or HasVariable(viewer,'getLibraryEntry);	local libentry, all := [], libentries := viewer.library; // ?? undoc	if libentries and (kBuild20 or nos20 or libentries := libentries.books)	then foreach libentry in libentries		do if kBuild20 or nos20			then begin				if libentry.book //and not libentry.help 	// deleted?				then AddArraySlot(all, libentry.book.isbn);				end			else if libentry.booksoup				then AddArraySlot(all, libentry.isbn);	Sort(all, '|str<|, nil);end);DefineGlobalConstant('kSubStr, func(str, pos, upto, bwith)if StrFilled(str)then begin	local pos1 := pos;	if (if kBuild20 then IsString(pos) else isInstance(pos,'string)) // pos = str or int	then begin		local INT slen := StrLen(pos);		pos1 :=			if bwith			then (if BeginsWith(str,pos) then 0)			else if kBuild20 and slen=1			then CharPos(str,pos[0],0)			else StrPos(str,pos,0);		if pos1		then pos1 := pos1 + slen		else return NIL;		end;	local pos2 := if (if kBuild20 then IsString(upto) else isInstance(upto,'string))  // upto = str, int or NIL (end)		then if kBuild20 and StrLen(upto)=1			then CharPos(str, upto[0], pos1)			else StrPos(str, upto, pos1)		else upto;	SubStr(str, pos1, if pos2 then pos2- pos1);	endelse str);DefineGlobalConstant('kMyTrim, func(str, start, stop)	// !!!eTrimString(SubStr(str, start, if stop then stop-start)));DefineGlobalConstant('kSendMsg, func(addr, namestr, subj, bodyText)if StrFilled(bodyText)	// !!!gthen begin	local href, root := GetRoot();	if not addr and BeginsWith(bodyText, kHTTP)	then begin 		local newtscape;		if (newtscape := root.(kNewtsCapeSymbol)) and			(addr := newtscape:fixOptions(nil).httpProxy)		then addr := call kSubStr with (addr, kMailTo, nil, true);		if not StrFilled(addr)		then addr := Clone("web-mail@ebay.com");	// ???		namestr := "WebMail";		subj := "WebMail Request";		href := call kSubStr with (bodyText, 0, "#", nil);		bodyText := "WebMail-Format: text-source\nWebMail-ID:" & kAppNameL & $- &				kVersionInt & "\n\n<URL:" & href & ">\n";		end;	TrimString(addr);	local spos := if kBuild20 then CharPos(addr, $?, 0) else StrPos(addr, "?", 0), entry; // mailto:...?subject=...	if spos	then begin		if entry := call kSubStr with (addr, "?subject=", "&", nil)	// in case &body= also		then subj := entry;		if entry := call kSubStr with (addr, "&body=", nil, nil)		then begin			StrReplace(entry, "\\n", cr, nil);			bodyText := ParamStr(entry & unicodeCR, [if href then href else bodyText]);			end;		addr := SubStr(addr, 0, spos);		end;	if spos := if kBuild20 then CharPos(addr, $<, 0) else StrPos(addr, "<", 0)	// John Smith <jsmith@foo.com>	then begin		namestr := call kMyTrim with (addr, 0, spos);	// !!!e. TrimString(SubStr(addr, 0, spos));		addr := call kSubStr with (addr, spos+1, ">", nil);		end;	local item := {}, mailSym := 'mail;	if kBuild20 or Functions.TransportNotify exists	then begin // 2.x		gc();		entry := GetUnionSoup(ROM_cardfileSoupName):Query( // find existing person based on email addr.			{type: 'words,			words: if (spos := CharPos(addr, $@, 0))				then [SubStr(addr,0,spos), SubStr(addr,spos+1,nil)]				else [addr]}):entry();		if not entry		then begin			local firstName := "", lastName := "";			if namestr			then if spos := CharPos(namestr,$ ,0)				then begin					firstName := SubStr(namestr, 0, spos);					lastName  := SubStr(namestr, spos+1, nil);					end				else lastName := namestr;			entry := {				name: {class: 'person, first: firstName, last: lastName},				email: if ClassOf(addr)='string then SetClass(addr,'|string.email|) else addr,				country: GetUserConfig('country),				};			end;		if not isFrame(item := TransportNotify(mailSym:='|WyndMAIL:GDT|, 'NewItem, [nil])) and		   not isFrame(item := TransportNotify(mailSym := 'mail, 'NewItem, [nil])) 				//last used mail transport		then return NIL;// customroute.  setupItem of routing format. cram in toRef.// newest docs about setupItm in Prog Guide		item.toRef := [GetDataDefs('|nameRef.email|):MakeNameRef(entry, '|nameRef.email|)];		if not item.fromRef		then item.fromRef := GetDataDefs('|nameRef.email|):MakeNameRef(GetUserConfig('currentPersona), '|nameRef.email|);			// {email: GetUserConfig('mailAccount)} ?		item.class := 'mailText;	//'ioItem; ?? (only if Text stationery installed?)		//item.state := 'ready;		end	else item.email := addr; // 1.x	item.appSymbol := kNotesSym;	// Notes.  copperfield?	item.connect 	:= NIL;			// sendNow	item.hidden 	:= NIL;			// hideIOBox	item.title 		:= subj;		// Subject:	item.body 		:= { // for ?		//class: 'text, //(only if Text stationery installed?)  //kdatasymbol,  // with this -- no stationery?		text: bodyText,		//timeStamp: Time(),		//version: kVersionInt,		};	item.text := bodyText;			// for eWorld, GoFetch, ?	/*if kBuild20 or Functions.OpenRoutingSlip exists	then OpenRoutingSlip(item, {target: item, targetView: root.(kBookReaderSymbol)})		//self:GetTargetInfo('routing))	else*///if kDebugHTTP then Print(item);	if kBuild20 or Functions.Send exists	then begin		Send(mailSym, item);		root.(kInboxSym):?Open();	// !!!a. OpenAsOutBox(); this seems to set Outbox as a perm pref		end	else call kSendFunc with (mailSym, item); 	// Outbox automatically opens for 1.xend);DefineGlobalConstant('kNetHopperURL, func(urlframe)if urlframethen begin	// use NetHopper API?  bodyDataStr, extraDataStr, markerStr?	local url := urlframe.protocolStr & "://" & urlframe.domainNameStr;	if urlframe.port	then url := url & $: & urlframe.port;	url & urlframe.directoryStr & urlframe.fileNameStr;end);DefineGlobalConstant('kNewVBO, func(store, cl, dlen)	// the recommended initializationbegin	gc();	local data := if not IsInteger(dlen) then dlen;		// string or binary obj	local vbo :=		(if store then store else GetDefaultStore()):NewCompressedVBO(			EnsureInternal(if cl then cl else 'string),		// cl == binary. !!!g			if data then Length(data) else dlen,// length of string or binary or #			kTextCompander, 					//kBitmapCompander unreliable for bin?			nil);	if data	then begin		BinaryMunger(vbo, 0, nil, data, 0, nil);		if Length(data) > 2		then ClearVBOCache(vbo);		end;	vbo;end);constant kMinVBOlen := 8192; 	// :getRun, :addBlock, parse:AddContentItem, kBigSubStrDefineGlobalConstant('kVBOFlush, 32*1024);	// !!!f,d was 20K. was 24K. ( < 32K?). :getRun, inputLine, inputTextSpec, inputBinarySpecDefineGlobalConstant('kCopyRawHTML, func(str)	// used by matchHTMLtitle(EETransfer), openDoc(NetHopper)if kNIE and strthen begin // packed ascii (8-bit not unicode chars)	local INT i, len := Length(str), byte;	local htmlSource := call kNewVBO with (nil, nil, (len*2) + 2);	for i := 0 to len-1	do begin		if (byte := ExtractByte(str,i)) = 0		then break StrMunger(htmlSource,i,nil, nil,0,nil);		htmlSource[i] :=			if byte = chLF			then unicodeCR			else Chr(byte);		if (i mod kVBOFlush) = 0 and i > 0		then ClearVBOCache(htmlSource);		end;	ClearVBOCache(htmlSource);	htmlSource;	end);// note: URL comparison should probably be case sensitive (except for host name) ???DefineGlobalConstant('kCacheEqual, func(url, url2, edata, edata2) // used in kGetURLCache[2], kGoHistory. kGotoHREF(url = url2 or	(if kBuild20	then IsString(url) and IsString(url2) and StrEqual(url, url2)	else isInstance(url,'string) and isInstance(url2,'string) and StrEqual(url, url2)	)) and 		(edata = edata2 or	(if kBuild20	then IsString(edata) and IsString(edata2) and StrEqual(edata, edata2)	else isInstance(edata,'string) and isInstance(edata2,'string) and StrEqual(edata, edata2) 	)));// return nil if not found; or entry or text/bitmap (not "true" anymore?)DefineGlobalConstant('kGetURLCache, func(soupCacheName, href, field, edata, expOK)if kNIE and soupCacheName and hrefthen begin	gc();	local newtscape := GetRoot().(kAppSymbol), result, removed;	local entry := GetUnionSoupAlways(soupCacheName):Query({		indexPath: 'URL, 	// for l-o-n-g strings		beginKey: href,		endKey: href,		validTest: func(entry)			call kCacheEqual with (entry.url, href, entry.edata, edata)			//or (EntryUndoChanges(entry) and nil)		}):entry();		if entry and call kCacheEqual with (entry.url, href, entry.edata, edata)	// doublecheck	then if field = '_delete or (not expOK and entry.expires and entry.expires <= Time())		then begin			EntryRemoveFromSoupXmit(entry, nil);	// avoid multiple xmits			result := field = '_delete;				// avoid extra lookups? (NH, other cache)			removed := true;						end		else begin			if kDebugHTTP			then begin Print("get cache:" && href); Print("edata:" && edata); end;			result := if field then entry.(field) else entry;			local type := entry.type;			EntryUndoChanges(entry);		// prevent problems during Save?			if isBinary(result)	and not IsString(result) // normally, result is a soup entry, or text or a bitmap frame				and ClassOf(result) <> 'picture	// !!!r. PICT ok.			then begin//Print("kGetURLCache raw Image");//Print(result);				result :=		// if not (rawImage), then convert it here (e.g., GIF, JPEG?)					if not type or StrEqual(type, kGIFMediaType)					then newtscape:convertImage(type, href, result, {_proto: newtscape.optionsAPI, cacheImages: nil, rawImage: nil}, nil)					else newtscape:dispatchFile(type, href, result, nil);	// e.g., JPEG?//Print(result);				if IsString(result) // error msg				then begin					GetRoot().(kAppSymbol):Notify(kNotifyAlert, result, href);	// !!!j					result := NIL;					end;				end;			end;	if removed	then XmitSoupChange(soupCacheName, kNewtsCapeSymbol, 'whatThe, NIL);	local soup, cursor, url, data;	if not result and field <> '_delete and (soup := GetUnionSoup(kCacheNetHopperSoupName)) // !!!d. (field='text or field='bitmap)	then begin		entry := nil;		gc();		cursor := soup:Query(nil);		entry := cursor:entry();		while entry		do begin			url := call kNetHopperURL with (entry.fTransReq.targetURL);			data := entry.fStreamVBO;			if url and StrEqual(href, url)			then break result :=				if field = 'text				then call kCopyRawHTML with (data)				else if field = 'bitmap				then if data					then newtscape:convertImage(kGIFMediaType, href, data, {_proto: newtscape.optionsAPI, cacheImages: NIL, rawImage: nil}, nil)					else entry.fFrameObject.icon				else if data	// !!!k				then entry;		// !!!d			entry := nil;			entry := cursor:next();			end;		end;	/* to include LunaSuite cache (why?)	Inbox(Cache folder)	URL = :fixString(entry.fCacherStr)	// possible % e.g., for ~	text = fdocument.fbody.fbody;		// "raw"?  are graphics cached? how distinguish? what format?	*/	result;	end);// used in ReceiveTextSuccess, ReceiveBinarySuccess(convertImage), protoSerialProtocolDefineGlobalConstant('kPutURLCache, func(store, soupCacheName, href, field, entry, content, modified, expires, edata, data, type) //, labelsif kNIE and soupCacheName and hrefthen begin	if entry	then entry.URL := href		// should be same except for redirect?	else entry := {URL: href};	//, labels: labels	entry.(field) := content;	entry.modified := if modified then modified else Time();	// but if Newton clock is wrong...	if edata	then entry.edata := edata;	if data	then entry.data := data;if kDebugHTTP then Print("put cache:" && href && "==" && edata);	if expires	then entry.expires := expires;	entry.type := type;	if isSoupEntry(entry)	then EntryFlushXmit(entry, kNewtsCapeSymbol)	// EntryChangeXmit(entry,nil)		// !!!j  AddFlushedXmit(entry, kNewtsCapeSymbol); // AddToDefaultStoreXmit(entry, nil);	else GetUnionSoupAlways(soupCacheName):AddToStoreFlushedXmit(entry, store, kNewtsCapeSymbol)	end);/*DefineGlobalConstant('kTempCacheEntry, func(entry)entry and (StrFilled(entry.edata)) // or CharPos(entry.URL, $?, 0))	// a POST result or generated document?);*/DefineGlobalConstant('kCollectURLs, func(soupCacheName, results, maxEntries, aentry, keep, expOK)	// check/collect URLs in a cache. used in viewSetupFormScript & cachemenuif kNIE and soupCacheNamethen begin	gc();	local cursor := GetUnionSoupAlways(soupCacheName):Query(nil);	if soupCacheName <> kCacheHTMLSoupName and		maxEntries and cursor:countEntries() <= maxEntries	then return results;	local INT now := Time(), count := 0;	local entry := cursor:reset();	while entry	do begin		if isFrame(entry)		then if (not expOK and entry.expires and entry.expires <= now) or	// remove expired entries				(not results and not keep and StrFilled(entry.edata)) // call kTempCacheEntry with (entry))	// remove results/gendoc entries			then begin				EntryRemoveFromSoupXmit(entry, nil); // no need to notify since new list assigned (Open) or nil-ed (quit) immed afterwardsif kDebugHTTP then Print("expiring:" && entry.URL && entry.edata);				end			else if (count := count+1) and		// count good entries					isArray(results) and					not StrFilled(entry.edata)	// currently don't add POST temp entries to cache (menu) list			then begin//Write(entry.URL & $ ); Print(entry.bitmap);				AddArraySlot(results, if aentry then {item: entry.URL, _alias: MakeEntryAlias(entry)} else entry.URL);				EntryUndoChanges(entry);				end			else if kDebugHTTP and results=true			then begin Print(entry.URL); Print(entry.edata); end;		entry := nil;		entry := cursor:next();		end;	if results or (count := count - maxEntries) <= 0	then return results;	// delete some entries from beginningif kDebugHTTP then Print("remove additional" && count && "regular entries");	entry := cursor:reset();	while count > 0 and entry	do begin		if isFrame(entry) and not entry.locked		then beginif kDebugHTTP then Print("removing old:" && entry.URL);			EntryRemoveFromSoupXmit(entry, nil); // ditto on change notif			count := count - 1;			end;		entry := nil;		entry := cursor:next();		end;	end);DefineGlobalConstant('kCharPosLast, func(str, ch)if kBuild1x or CharPos(str,ch,0)then begin	local INT i;	for i := StrLen(str)-1 to 0 by -1	do  if str[i] = ch		then return i;	NIL;	end);DefineGlobalConstant('kGetFileName, func(href) // used by kGoToHREF, BASE, dispatchFilebegin	// find last //*	local spos := 0, cpos := 0;	while spos := if kBuild20 then CharPos(href, $/, spos) else StrPos(href, "/", spos)	do cpos := spos := spos+1;*/	local cpos := call kCharPosLast with (href, $/);	call kSubStr with (href, if cpos then cpos+1 else 0, "#", nil);		// +1end);/*DefineGlobalConstant('kEndsWithAny, func(str, exts)if kBuild20then LFetch(exts, str, 0, GetGlobalFn('EndsWith), nil)else begin	local ext;	foreach ext in exts	do if EndsWith(str, ext)	then return ext;	NIL;	end);*/DefineGlobalConstant('kImageExtension, func(href)if hrefthen begin//EndsWith(href, kGIFextension)//call kEndsWithAny with (href, ) // !!!h,a	local exts := call kInitGlobal with ('imageExtensions, [kGIFextension]);	if kNIE	then LSearch (exts, href, 0, GetGlobalFn('EndsWith), nil)	else ArrayPos(exts, href, 0, Functions.EndsWith);end);DefineGlobalConstant('kHTMLExtensions, [".html", ".htm"]);constant kMaxHistory := 20; // for History (book) popup. compute for landscape???DefineGlobalConstant('kUntitled, LocObj("Untitled", 'untitledLabel));DefineGlobalConstant('kUntitledISBN, kUntitled & ".htm");// structure of History entry (kGoHistory)// isbn, pagenum, title, url, edataDefineGlobalConstant('kAddHistory, func() // called by kGotoHREF, kPostData, kSendHTTPbegin	local root := GetRoot(), viewer := root.(kBookReaderSymbol), bdata, newtscape, curBook;	if call kViewIsOpenFunc with (viewer)		// book might now be closed	then curBook := viewer	else if newtscape := root.(kAppSymbol)	// otherwise, see if Newt's Cape is active	then curBook := newtscape.curBook;	// assume history(cache) exists from kBookOpenScript	local gData := call kInitGlobal with (nil, nil);	local ARRAY history := gData.(kHistoryPath);	local INT len := Length(history);	if curBook and (len=0 or gData.(kHistoryPos) <> len-1)		and not StrEqual(curBook.isbn, kUntitledISBN)	then begin		local bdata, cp, title, isbn, bhref, edata;		if viewer = curBook		then begin			bdata 	:= viewer:bookData();			isbn 	:= viewer.isbn;			// these are EnsureInternal-ed below			cp	 	:= viewer:currentPage();				title 	:= viewer:BookTitle();				bhref 	:= bdata.base_href;			edata 	:= bdata.edata;			end		else begin	// newtscape. for ultimate o-o, add :bookData, :currentPage, :BookTitle methods to book?			bdata 	:= curBook.data;			isbn	:= Clone(curBook.isbn);		// clone these because of savePkg?			cp 		:= 1;			title 	:= Clone(curBook.title);			bhref 	:= Clone(bdata.base_href);			edata 	:= Clone(bdata.edata);			end;if kDebugHTTP then begin Print("adding"); Print([isbn, cp, title, bhref, edata]); end;		// avoid duplicate (kCacheEqual)??		// !!!b. save some heap for same book?		local entry :=			if len > 0	// !!!u			then if kBuild20				then LFetch(history, isbn, 0, '|str=|, 0)				else call kLFetch with (history, isbn, 0, Functions.StrEqual, 0, nil);		if entry and call kCacheEqual with (entry[3],bhref, entry[4],edata)		then begin	// share			isbn  := entry[0];			title := entry[2];			bhref := entry[3];			edata := entry[4];			entry := history[len-1]; // !!!e. elim dup entries at end			if entry[1]=cp and call kCacheEqual with (entry[3],bhref, entry[4],edata)			then isbn := nil;			end;		if isbn	// !!!e		then AddArraySlot(history, EnsureInternal([isbn, cp, title, bhref, edata]));		local INT diff := len + 1 - kMaxHistory;		if diff > 0		then ArrayRemoveCount(history, 0, diff);		end;	gData.(kHistoryPos) := Length(history);end);DefineGlobalConstant('kSendHTTP, func(href, methenc, hname, edata, data, options) // ~same args&order as 'newURL (except hname<->enctype)if StrLen(href) > kHTTPlen // more than http:// ?then begin	local root := GetRoot(), newtscape := root.(kNewtsCapeSymbol), proxy;	if kNIE and newtscape and 		// options usually from HTTP FSM. otherwise, current "global" options		(options := newtscape:Init(if options then options else newtscape.optionsAPI))		and not ((proxy := options.httpProxy) and BeginsWith(proxy, kMailto)) 	// allow cache entries even if NIE frozen (if not mailto:)		//and GlobalFnExists('InetDisplayStatus) // InetGrabLink 2.0? InetGrabLinkVerbose	then beginif kDebugHTTP then begin Write("kSendHTTP: "); Print(options); end;		if not options.noStatus		then newtscape:open();		local tmp := StrPos(href,":/",0);	// !!!s		if not tmp		then return nil;		if href[tmp+2] <> $/	// e.g., http:/w3opac-cgi-bin/expertensuche.pl		then StrMunger(href := Clone(href),tmp+2,0, "/",0,1);				// if just host (no dir or file), then make sure it ends with /		if not CharPos(href,$/,tmp+3)		then href := href & $/;		local method := methenc, enctype := kDefaultEncType; // compat with < 1.3f		if isArray(methenc)		then begin			method	:= methenc[0];			enctype := methenc[1]; // future support of PUT etc.?			end;		if not options.noHistory		then call kAddHistory with ();	// don't add when just navigatingif kDebugHTTP then Print("edata");		if edata and StrEqual(method,kGet)		then href := href & $? & edata;		newtscape:displayURL(href);		if options.edata		then (if not edata then edata := options.edata)	// kGoHistory. href ok.		else options.edata := edata;	// (for infonautics search from Newtworks)		if not options.start		then options.start := 0;		//options.base := href;	// in :DoEvent		if hname		then options.hrefname := hname;if kDebugHTTP then Print("cache");		if call kImageExtension with (href) or			not ((options.cacheEntry :=				call kGetURLCache with (newtscape.cacheHTML, href, nil, edata, options.ignoreHTMLExpiration))	// options.cacheHTML ??				or LSearch(kHTMLextensions, href, 0, GetGlobalFn('EndsWith), nil)) // !!!h				//or call kEndsWithAny with (href, kHTMLextensions))		then options.cacheEntry :=		// options.cacheImages ??			call kGetURLCache with (newtscape.cacheImages, href, nil, edata, options.ignoreImageExpiration);	// possibly generated (non .gif) image?if kDebugHTTP then Print("close");		// defer for highlighting?		if not options.noClose		then begin			root.(kBookReaderSymbol):?close();	// AddDeferredSend(root.(kBookReaderSymbol),'close,nil);			root.(kHelpReaderSymbol):?close();	// AddDeferredSend(root.(kHelpReaderSymbol),'close,nil);			end;if kDebugHTTP then Print("doEvent");		newtscape:DoEvent('newURL, [href, method, enctype, edata, data, options]);		end	else call kSendMsg with (nil,nil,nil,href);	end);// return array of positions or nil. used twice by kResolveURLDefineGlobalConstant('kStrPosS, func(str, subs, pos)begin	local ARRAY apos := [];	local sub1 := if kNIE and StrLen(subs)=1 then subs[0];	while pos := if kNIE and sub1 then CharPos(str, sub1, pos) else StrPos(str, subs, pos)	do begin		AddArraySlot(apos, pos);		pos := pos+1;		end;	apos;end);DefineGlobalConstant('kURLmatch, func(s)if (if kNIE then IsString(s) else isInstance(s,'string))	// !!!jthen BeginsWith(s, kHTTP & "//")	// !!!r	or BeginsWith(s, kMailto) or BeginsWith(s, kNews) or BeginsWith(s, kFtp)	or BeginsWith(s, kHTTPS)		// !!!g);// merge relative href with BASE. used kGoToHref, SUBMIT:SCRIPTDefineGlobalConstant('kResolveURL, func(bhref, href)if call kURLmatch with (href)	// !!!j. href and BeginsWith(href, kHTTP)then hrefelse if bhref and BeginsWith(bhref, kHTTP) and StrFilled(href)then begin	local del :=		if BeginsWith(href,"./") //  ./foo -> foo		then 2		else if BeginsWith(href, kHTTP)	// !!!r. but not // (since kURLmatch didn't succeed). make just start with /. e.g., http:/w3opac-cgi-bin/index1.pl?DATABASE=sisis		then 5;	if del	then StrMunger(href:=Clone(href),0,del, nil,0,nil);//http://host.domain.net/dir/resource.htm[;var1=value1][?<query string>][#<fragment]	//bhref := call kSubStr with (bhref, 0, "?", nil);	local npos, qpos :=			// e.g., http://.....?...&pubURL=http*C*//...		if kBuild20		then CharPos(bhref, $?, 0)		else StrPos(bhref, "?", 0);		if qpos	then begin		if (npos := if kBuild20 then CharPos(bhref, $;, 0) else StrPos(bhref, ";", 0))		and npos < qpos		then qpos := npos;		bhref := SubStr(bhref, 0, qpos);		end;	if npos := StrPos(bhref, "//", kHTTPlen)	 // !!!r. e.g., http://www.altavista.com//cgi-bin...	then begin	// include one / ?		bhref := SubStr(bhref, 0, npos+1);		npos := nil;		end;	local ARRAY hdir, bdir := call kStrPosS with (bhref, "/", kHTTPlen);	// !!!r	local INT hdirlen, bdirlen := Length(bdir), nhref;	if bdirlen=0	then begin		bdir := [StrLen(bhref)];		bhref := bhref & $/;		bdirlen := 1;		end;	if href[0] = $/ //BeginsWith(href, "/")	then //href := SubStr(href,1,nil);		nhref := SubStr(bhref, 0, if npos then npos+1 else bdir[0]) & href	else begin		hdir := call kStrPosS with (href, "../", 0);		if bdirlen >= (hdirlen := Length(hdir))		then nhref :=			SubStr(bhref, 0,				if npos then npos+2				else if bdirlen > hdirlen then bdir[bdirlen-hdirlen-1]+1 //else nil				) &			if hdirlen=0 then href			else SubStr(href, hdir[hdirlen-1]+3, nil);		end;	//if kDebugOn then print("resolving" && bhref && "\n +" && href && "\n ->" && nhref);	nhref;	end);/* for example:base:  http://somesite.com/  http://somesite.com/dir1/dir2/foo.htm  http://somesite.com//cgi-bin/dir1/foo.htmhref:  bar.htm  /bar.htm  ../bar.htm  /foo/bar.htm  ./foo/bar.htm  /cgi-bin/dir2/bar.htm*/DefineGlobalConstant('kHelpViewerSetup, func(helpBook)// helpBook = next help book (or nil for close)// returns viewer// used by kGoToHref, :refreshBook, :removeAppbegin	local viewer := GetRoot().(kHelpReaderSymbol);	if kBuild20 or GetVariable(viewer,'ReOrientToScreen)	then begin		if not helpBook or viewer.bookRef <> helpBook		then viewer:close();		viewer;		end	else begin // 1.x		local curView := GetView('viewFrontMost);		if HasVariable(curView,'openManual)		then if helpBook			then if curView.bookRef = helpBook				then return curView				else nil			else return curView:close();		// else nil;		BuildContext({_proto: viewer, bookRef: helpBook});		end;end);DefineGlobalConstant('kDoHREF, func(isbn, name, helpbook)begin	// see refreshBook	local viewer := GetRoot().(kBookReaderSymbol), openMsg := 'openBook, openArg := isbn, num;	if helpbook	then begin		openMsg := 'openManual;		viewer := call kHelpViewerSetup with (openArg := helpbook);		end;/*	// unused	local cp;	if not helpbook		and call kViewIsOpenFunc with (viewer) // book might now be closed. e.g., NewtATut	then cp := viewer:currentPage();*/	if isbn	then Perform(viewer, openMsg, [openArg]);	if name	then if helpbook		then begin			viewer:openHelpTo(name);	// openHelpBookTo -- aValue error??? viewer.outline:?TopicByName(name);				viewer.outline:?Show();			end		else if (if kBuild20 then IsInteger(num := name) else isInstance(num := name, 'int))			or num := call kGetInt with (call kSubStr with (name, "PAGE#", nil, true), nil) // !!!b				//((num := call kSubStr with (name, "PAGE#", nil, true)) and				//(num := StringToNumber(num)) and num := Floor(num))		then viewer:TurnToPage(min(num, viewer:countPages()))		else viewer:TurnToContent('name, name);end);DefineGlobalConstant('kGetAttrib, func(str, delim1, delim2, INT spos)begin	local epos := CharPos(str, delim1, spos);	if not epos then return NIL;	local name := call kMyTrim with (str, spos, epos);	// !!!e. TrimString(SubStr(str, spos, epos-spos));	spos := epos+1;	epos := if delim2 then CharPos(str, delim2, spos);	//local val := TrimString(SubStr(str, spos, if epos then epos-spos));	[name, call kMyTrim with (str, spos, epos), if epos then epos+1];	// !!!eend);DefineGlobalConstant('kGetAttribS, func(str, delim1, delim2, INT spos)begin	local epos := StrPos(str, delim1, spos);	if not epos then return NIL;	local name := call kMyTrim with (str, spos, epos);	// !!!e. TrimString(SubStr(str, spos, epos-spos));	spos := epos+1;	epos := if delim2 then StrPos(str, delim2, spos);	//local val := TrimString(SubStr(str, spos, if epos then epos-spos));	[name, call kMyTrim with (str, spos, epos), if epos then epos+1];	// !!!eend);// minimum compile for standalone books or user-controlled options. no error returnedDefineGlobalConstant('kCompileVal,{compileVal: func(str) try call Compile(str) with () onexception |evt.ex| do NIL});DefineGlobalConstant('kGoToHREF, func(bk,bdata,hrefstr, x1,y1,href,item)if (if kBuild20 then IsString(href) else isInstance(href,'string)) and StrFilled(href)then begin // called by kGoToHREFclick and :getURL//Print([bk,bdata,hrefstr,x1,y1,href,item]);	local ihref := Intern(href), nref := bdata.(ihref);	if (if kBuild20 then IsString(nref) else isInstance(nref, 'string))	then nref := bdata.(ihref := Intern(href := nref));  // string shadow (immediate map)	if (if kBuild20	// !!!g. moved from later npos<>0 test		then IsFunction(nref)		else isInstance(nref, '_function) or isInstance(nref, 'CodeBlock))	then /* we could pass bk instead of item to provide more context; if so, then GetVariable(xxx,'item) */		return Perform(bdata,ihref,[x1,y1,href,bk]);	local npos := if kBuild20 then CharPos(href, $#, 0) else StrPos(href, "#", 0), href1 := href, href2;	if npos	then begin		href1 := SubStr(href,0,npos);		href2 := SubStr(href,npos+1,nil);		end;//Print([href, href1, href2, nref, ihref, npos]);	local nbk, bhref, app, newisbn, httpref, addr, entry, tmp := bk, msg, args;	// save bk(obj)	local help := bk and GetVariable(bk,'openManual);	if help 		// !!!g. moved earlier	then bk := GetVariable(bk,'bookRef);	local curisbn := if bk then GetVariable(bk,'ISBN);//Print(curisbn);	local newtscape := GetRoot().(kNewtsCapeSymbol), cpos;	local options := if newtscape then newtscape:?fixOptions(newtscape.optionsAPI); // use global if any	if not options	then options := {};//Write("kGotoHREF: "); Print(options);	if npos<>0 // nil or >0	then 		//if BeginsWith(href, kHTTP)	// do below to resolve isbn		//then httpref := href1		if newtscape		// allow pseudo-URL of form: "Notes/theTitle"			and (((addr := call kSubStr with (href, "Notes/", nil, true)) and app := notesSoupName)				 /*or ((addr := call kSubStr with (href, "Inbox/", nil, true)) and app := inboxSoupName)*/				 )			and (entry := newtscape:findHTMLentry(app, addr, true, kTitleStart, kTitleStop))		then /*if isArray(entry)			then begin				entry[3] := options;				Perform(newtscape, 'dispatchFile, entry);				end			else*/ newtscape:dispatchFile(kHTMLMediaType, href, entry, options) /* how about file:// ??		else if kNIE and newtscape and 				// soup/foosoup/bar.htm			(addr := call kSubstr with (href, kSoupDir, nil, true)) and		// soup/			(app :=  call kSubstr with (addr, 0, "/", nil)) and				//      foosoup			(addr := call kSubstr with (addr, app & $/, nil, true)) and		//			    bar.htm			entry := call kGetURLCache with (app, addr, nil, nil, nil)		then newtscape:dispatchFile(entry.type, addr, entry.(if BeginsWith(entry.type, "text/") then 'text else 'bitmap), options) */		else if (			if app := call kFindApp with (ihref)			then (msg := 'toggle) and args := '[]			else if ((newtscape and options.allowCompile) or					(IsReadonly(href) and newtscape := kCompileVal)) // NOTE: newtscape only used in this block, not later in method					and (cpos := if kBuild20	// start of msg							then CharPos(href1, $/, 0)							else  StrPos(href1, "/",0)						) <> 0					and (begin						if not cpos						then cpos := -1;						tmp := if kBuild20 // start of args							then CharPos(href1,$?, cpos+1)							else  StrPos(href1,"?",cpos+1);						msg := Intern(SubStr(href1, cpos+1, if tmp then tmp-cpos-1));						if cpos > 0						then app := call kFindApp with (Intern(SubStr(href1,0,cpos)))			// appSymbol						else msg := if kBuild20 then GetGlobalFn(msg) else  Functions.(msg);	// function						end)			then args :=				if tmp				then if (if kBuild20 then CharPos(href1,$=,tmp) else StrPos(href1,"=",tmp))					then begin // frame: ?a=1&b=2&c=3						args := {};						local ARRAY attrib := [nil,nil,tmp+1];						while (tmp := attrib[2]) and attrib :=							if kBuild20							then call kGetAttrib  with (href1, $=,  $&,  tmp)							else call kGetAttribS with (href1, "=", "&", tmp)						do args.(Intern(attrib[0])) := newtscape:compileVal(attrib[1]);						[args];						end					else newtscape:compileVal($[ & SubStr(href1,tmp+1,nil) & $])	// array of csv: ?1,2,3				else '[]			)		then if app			then Perform(app, msg, args)			else Apply(msg, args)		else if (cpos := if kBuild20 then CharPos(href1, $:, 0) else StrPos(href1,":",0))			and not BeginsWith(href, kHTTP) // have Newt's Cape handle directly (below)?			and (app := GetRoot().(kURLcopSymbol)):?PreferredApp(href, 'getURL, {})		then app:getURL(href, options)		else if addr := call kSubStr with (href, kMailTo, nil, true)		then call kSendMsg with (			addr,			if hrefstr then hrefstr else bdata.name,			if bk then GetVariable(bk, 'TITLE) else bdata.subject,			if bdata.body then bdata.body			else options.mailBody				// !!!g. "hi,\nI saw this cool document in Newt's Cape."			)		else if BeginsWith(href, kNews)	// not registered for URLcop?		then return call kFindApp with (kNewtsPaperSymbol):?getURL(href,options)		else if BeginsWith(href, kFtp)			// not registered for URLcop			or BeginsWith(href, kJavaScript)		then return NIL	// |NewtFTPConnection:Tactile| ???		else begin // http: or relative. now better checking for book even if absolute//if kDebugHTTP then Print("href1:" && href1);			newisbn := call kGetFileName with (href1);//if kDebugHTTP then Print("newisbn:" && newisbn);			tmp := call kResolveURL with (bhref := bdata.base_href, href1);//if kDebugHTTP then Print("tmp:" && tmp);			if curisbn and StrEqual(curisbn,newisbn) // same book?				and call kCacheEqual with (bhref, tmp, bdata.edata, nil)				//and not bdata.edata				//and (not IsInstance(bhref,'string) or StrEqual(bhref, href1))			then nil 	// newisbn := NIL			else if not (					((nbk := call kFindBook with (newisbn,nil))		// other book not \ed?					//or nbk := call kFindBook with (newisbn := $/ & newisbn,nil) // for old (<= 1.6m) standalone books?? (see addIncludes)					) and					nbk.data and					(not bhref or call kCacheEqual with (nbk.(kBasePath), tmp, nbk.(kEdataPath), nil))					)					//and StrFilled(bhref) and BeginsWith(bhref, kHTTP)			then begin//Print("base:" && nbk.(kBasePath)); Print("edata:" && nbk.(kEdataPath));				httpref := tmp; // call kResolveURL with (bhref, href1);				npos := href2 := newisbn := NIL; // don't try to use that topic				end			else if not nbk then newisbn := nil;			end;//if kDebugHTTP then Print("httpref:" && httpref);	if httpref	// TCP or WebMail	then call kSendHTTP with (httpref, kGet, href2, nil, nil, nil)	else if newisbn or npos	then begin		args := [			newisbn,			if href2 then href2 else options.hrefname,			if nbk and nbk.help			then nbk			else if help			then call kFindBook with (curisbn,nil)];		call kAddHistory with ();		if kBuild1x and Functions.AddDeferredAction exists		then AddDeferredAction(kDoHREF, args)		else AddDeferredCall  (kDoHREF, args);		// do callbackFn ??		end;end);DefineGlobalConstant('kShapeHilite, {transferMode: modeXor, fillPattern: vfBlack});DefineGlobalConstant('kPickHREFfunc, func(INT cmd) // assumes newscape, args slotsbegin	local bhref := args[1].base_href;	local url :=		if cmd > 0		then call kResolveURL with (bhref, if kBuild20 and cmd > 3 then args[6].src else args[5]); // IMG,doc URL	if cmd=0		// get URL	then if newtscape		then begin			if kBuild20			then AddDeferredSend(newtscape, 'gotoHREF, args)			else AddDeferredAction(Functions.Perform, [newtscape, 'gotoHREF, args]);			end		else if kBuild20		then   AddDeferredCall(kGotoHREF, args)		else AddDeferredAction(kGotoHREF, args)// note: these other commands weren't added if newtscape=nil	else if cmd=1	// display resolved URL of link	then begin		newtscape:open();		newtscape:displayURL(url);		end			else if kBuild20	then begin		local pos := CharPos(url,$#,0);		if pos		then url := SubStr(url,0,pos);		if cmd=2	// cache only		then newtscape:DoEvent(NIL, [{			cacheOnly: true,			fURLqueue: [url]	// resolved URL			}])		else if cmd=3	// bookmark highlighted text w/ resolved URL		then begin			//newtscape:init(nil);	// !!!i			newtscape:AddBookmark(if StrFilled(args[2]) then args[2] else url, url);			end		else // if cmd=4 then	// load image, redisplay original doc			begin			AddDeferredSend(newtscape, 'removeApp, [true,true]);	// keep open if desired			newtscape:DoEvent(NIL, [{				checkCache: true,				fURLqueue: [	// also add Referer option?					url,		// resolved IMG URL					bhref,		// current doc (force later cache lookup via checkCache)					],				}]);			end;		end;end);DefineGlobalConstant('kBuiltinFonts, '[espy, newYork, geneva]); // 1.x & 2.x [familyPicker, dumpBook]// use ROM_fontSystemxxx instead for Japanese/Chinese system patch??constant kSystemFontSym := 'espy;	//ROM_systemFont ??DefineGlobalConstant('kEspy9,	if kNIE then ROM_fontSystem9 		else 0x00002400);	// was kNCfont	DefineGlobalConstant('kEspy9B,	if kNIE then ROM_fontSystem9Bold 	else 0x00102400);DefineGlobalConstant('kEspy10,	if kNIE then ROM_fontSystem10 		else 0x00002800);DefineGlobalConstant('kEspy10B,	if kNIE then ROM_fontSystem10Bold	else 0x00102800);DefineGlobalConstant('kEspy12,	if kNIE then ROM_fontSystem12		else 0x00003000);DefineGlobalConstant('kGoToHREFclickShare, func(obj,unit,gestureID)	// viewGestureScript compatible (rather than viewClickScript)if gestureID=aeTap or gestureID=aeLinethen begin// see kGetHrefRegions// [0=href, 1=start, 2=count, 3=left, 4=top, 5=right, 6=bottom, ] or ... 3=rect,polygon,oval,	local INT gx := GetPoint(firstX,unit);	// (save gx,gy for 1.x DoPopup)	local INT gy := GetPoint(firstY,unit);//Print(obj); GetRoot().(kAppSymbol).curObj := obj;	local item 	 := GetVariable(obj,'item);//Print(item);	local data	 := item.data;	local INT dataOffset := if not (if kBuild20 then IsString(data) else IsInstance(data,'string)) or data = obj.text then 0 else StrPos(data, obj.text, 0); // moved here for PointToCharOffset and SetHilite	local INT cpos :=		if (kBuild20 or HasVariable(obj,'PointToCharOffset)) and IsString(data)		then obj:PointToCharOffset(gx,gy) + dataOffset		else -1;//Print(cpos);	local sview := obj.scrolledView;	if not sview then sview := obj;	local href, gb := sview:GlobalBox(), hrefstr, bdata, vh, scale;	local ARRAY hrefentry;	local INT x1 := gx - gb.left; // offset for 1.x or all/graphic compare	local INT y1 := gy - gb.top;//Print([x1,y1,]); Print(item.hrefs);	local hrefstart, hreflen, hrefobj;	foreach hrefentry in item.hrefs	do if (if (hreflen := hrefentry[2]) and cpos >= 0			then hrefentry[1] <= cpos and cpos <= (hrefentry[1]+hreflen)			else Length(hrefentry) > 3				and (hrefobj := hrefentry[3]) and				if (if kBuild20 then IsInteger(hrefobj) else isInstance(hrefobj,'int))				then hrefobj      <= x1 and x1 <= hrefentry[5] and				  	 hrefentry[4] <= y1 and y1 <= hrefentry[6]				else HitShape(if kBuild1x and isFrame(hrefobj) then hrefobj := DeepClone(hrefobj) else hrefobj,x1,y1) // polygons crash for Hitshape/DoDrawing?			)		then break href := hrefentry[0];//Print(href);	if href	then begin		if (scale := item.scale) and scale <> 1		then begin			x1 := RIntToL(x1 / scale);			y1 := RIntToL(y1 / scale);			end;//Print([x1,y1,href]);		if not (bdata := obj:BookData())		then bdata := {};					if hreflen		then begin			hrefstr := SubStr(data, hrefstart := hrefentry[1], hreflen); // for mail addr or bookmark			if gestureID = aeTap			then begin // hilight it				//obj:HiliteBlock(item, hrefstart, hreflen);  // hilite range (for regular book). doesn't work w/ aliases?				//RefreshViews();				// hilite is wrt to text in child, but should use hrefstart-dataOffset (but not avail in obj)				hrefstart := hrefstart - dataOffset;				obj:SetHilite(hrefstart, hrefstart + hreflen, true);				Sleep(4);				//SetValue(obj, 'hilites, nil); // delayed?				call kClearSelectionHilitesFunc with (obj);				//SetKeyView(nil, 0); // caret when return??				end;			end		else begin // graphic or area			if Length(hrefentry) <= 3 or (if kBuild20 then IsInteger(hrefobj) else isInstance(hrefobj,'int))			then begin				if gestureID = aeTap // highlight it				then sview:Hilite(vh := true); 	// all (e.g., IMG)				if item.ismap and not 			// server side image map					((hrefstr := bdata.(Intern(href)))	// except if shadow URL					and (if kBuild20						then IsFunction(hrefstr)						else isInstance(hrefstr, '_function) or isInstance(hrefstr, 'CodeBlock))					)				then href := href & $? & x1 & $, & y1;				end			else if gestureID = aeTap			then begin	// client-side image map -- highlight it				//obj:DrawShape(hrefobj, kShapeHilite); // shape?				sview:DoDrawing('DrawShape, [hrefobj, kShapeHilite]);	// avoid clipping problems				sview:Dirty(); // unhilite after delay				end;			hrefstr := "";			end;		local newtscape := call kFindApp with (kNewtsCapeSymbol);		if gestureID = aeTap		then begin			if newtscape	// use latest version if possible			then newtscape:?gotoHREF(obj,bdata,hrefstr, x1,y1,href,item);			else call kGotoHREF with (obj,bdata,hrefstr, x1,y1,href,item);			if vh //and call kViewIsOpenFunc with (obj)			then 				// turn off highlight (if still open, e.g., NewtATut?) help???				//obj:?scrollPage(0);	// takes too long				// call kClearSelectionHilitesFunc with (obj);	// gets left on (e.g., email)				sview:Hilite(nil);			end		else begin	// aeLine			local args := [obj,bdata,hrefstr,x1,y1,href,item];			local cmds := [LocObj("Go", 'goLabel) & $: && href];			if newtscape			then AddArrayslot(cmds, LocObj("Display URL", 'displayURLitem));			if kBuild20 or HasVariable(self, 'PopupMenu)			then begin				local font := kEspy9;				if newtscape				then begin					AddArraySlot(cmds, kCacheItem);					AddArraySlot(cmds,						kAddBookmark & $: &&						if StrFilled(hrefstr) then hrefstr else href);					if item.src					then AddArraySlot(cmds,						LocObj("Load Image", 'loadImageItem) & $: && item.src);					if kNCfont and newtscape.menuFontJ					then font := newtscape.menuFontJ;	// !!!j					end;				obj.newtscape := newtscape;	// this avoids BuildContext mess				obj.args := args;				obj.pickActionScript := kPickHREFfunc;				vh := obj:PopupMenu(cmds, {left: x1, top: y1});				vh.pickMaxWidth := GetAppParams().appAreaWidth-10;				SetValue(vh, 'viewFont, font);				end			else begin				gb := newtscape:GlobalBox();//Print([gx,gy]); Print(gb);				DoPopup(cmds, gx - gb.left, gy - gb.top, {					newtscape: newtscape,					args: args,					pickActionScript: kPickHREFfunc,					//pickCancelledScript: kNilFunc0,					});				end;			end;		TRUE;	// handled		end;	//NIL	// allow hilighting etc.	end);DefineGlobalConstant('kGoToHREFclickNC, func(obj,unit,gestureID) // non-standalonebegin	local app;	if not (app := GetRoot().(kNewtsCapeSymbol))	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	if HasVariable(app, 'hrefScriptG)	// so new books can work with old or new Newt's Cape	then app:hrefScriptG(obj,unit,gestureID)	else app:?hrefScript(obj,unit);end);DefineGlobalConstant('kGoToHREFclick, func(obj,unit,gestureID)begin	local app;	if not (app := GetRoot().(kNewtsCapeSymbol))	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	if HasVariable(app, 'hrefScriptG)	// so new books can work with old or new Newt's Cape	then app:hrefScriptG(obj,unit,gestureID)	else if HasVariable(app, 'hrefScript)	then app:hrefScript(obj,unit)	else // nil might mean either kGoToHREFclickNC had no script, or no HREF		//call kGoToHREFclickNC with (obj, unit, gestureID) or		call kGoToHREFclickShare with (obj,unit, gestureID);end);DefineGlobalConstant('kAHREF, [ // sharable (via bookTemplate). see :addBlock	//'viewClickScript,	//func(unit) :hrefScript(self,unit),	'viewGestureScript,	func(unit,gestureID) :hrefScript(self,unit,gestureID),	// -> kGoToHREFclick or kGoToHREFclickNC]);DefineGlobalConstant('kAHREFG, [ // sharable version for graphics	'viewGestureScript,	kAHREF[1],	'viewFlags,	vVisible+vClipping+vClickable+vGesturesAllowed, // otherwise vGestureScript wouldn't work	'viewClickScript,	func(unit)	if self.scrolledView	then :hrefScript(self, unit, aeTap),	// otherwise, client image maps don't work if scrolling	//else nil so line gesture can be recognized]);DefineGlobalConstant('kLineBreakChars, [$\n, $ , $\t, $-, $/, $+, $], $[, $*, $=, $&, $^, $|, $<, $>, $\\, ]);// !!!j. borrowed from HTMListDefineGlobalConstant('kBigStringObj, {new: func(str)	{_proto: self,	bigStr: str,	nextFlush: if kNIE then kVBOFlush,	},append: func(str,start,count)	begin		StrMunger(bigStr,StrLen(bigStr),0, str,start,count);		if kNIE		then begin			local INT slen := StrLen(bigStr);			if IsVBO(str)			then begin				if (slen*2) >= nextFlush				then begin					ClearVBOCache(bigStr);					nextFlush := slen + kVBOFlush;					end;				end			else if slen > kMinVBOlen	// mutate large heap str to VBO			then begin				bigStr := call kNewVBO with (nil, nil, bigStr);				nextFlush := slen + kVBOFlush;				end;			end;	end,length: func() StrLen(bigStr),contents: func()	begin		if kNIE		then ClearVBOCache(bigStr);		bigStr;	end,});DefineGlobalConstant('kBigSubStr, func(str,start,count)	// !!!m. used in kSplitTextHeightFunc, addBlockif kNIE and IsVBO(str) and (if count then count else StrLen(str)-start) > kMinVBOlenthen begin	local bigStr := call kNewVBO with (nil,nil,"");	StrMunger(bigStr,0,nil, str,start,count);	ClearVBOCache(bigStr);	// !!!b1	bigStr;	endelse SubStr(str, start, count));// !!!m. if both=true then return both (as earlier);// otherwise return only single styles array//   if start=0, return upto count//   if start>0 then return until end(ignoring count)DefineGlobalConstant('kSplitRuns, func (ARRAY styles, INT start, count, both)begin // ASSUMES pos < string length	local INT i, tot := 0, ntot, pos := if start=0 then count else start; // split point	local s1,s2;	for i:=0 to Length(styles)-1 by 2	do  if (ntot := tot+styles[i]) < pos		then tot := ntot // again		else break;	// split	if both or start=0	then s1 := ArrayMunger([],0,nil, styles,0,i+2);	if ntot > pos	then begin		if s1		then s1[i] := pos-tot;		if ntot = pos+1		then i:=i+2;		end;	else i := i+2;	if both or start > 0	then begin		s2 := ArrayMunger([],0,nil, styles,i,nil);		if ntot > pos+1		then s2[0] := ntot-pos-1;		end;	// return	if both	then [s1,s2]	else if s1	then s1	else s2;end);/*call func(runs)	// calc total run lengthbegin	local i, tot := 0;	for i:=0 to Length(runs)-1 by 2	do tot := tot + runs[i];	tot;end with ()getroot().|NewtsCape:NewtsCape|:simpletextheight(substr("", 0,719), 320, [])getroot().|NewtsCape:NewtsCape|.curbook.rendering[0].pages[1].blocks[4].bounds*/if kStyleMeasure thenDefineGlobalConstant('kDummyHeightView, { // !!!m. used in kMySimpleHeightFunc for TotalTextBounds	viewClass: clEditView,	viewFlags: vAnythingAllowed,	recConfig: ROM_rcPrefsConfig,	//@443	});DefineGlobalConstant('kScreenChars, if kNIE then 1800 else 900); // !!!oDefineGlobalConstant('kMySimpleHeightFunc, func(text, INT start, count, INT width, font) // !!!o,m. used in kMakeNote, :SimpleTextHeightbegin//Print([start,count,width]);//Print("kMySimpleHeightFunc1");	if (if count then count=0 else StrLen(text) = start)	// !!!o. empty?	then return 0;	if count or start > 0	then text :=			if kNIE			then call kBigSubStr with (text, start, count)	// !!!o. avoid measuring too much in some situations. 2K sems like plenty			else Substr(text, start, count);/*if not isArray(font)then begin//Print(text);Write("totaltextbounds: " &	TotalTextBounds({	// avoid earlier Substr in addBlock (but viewOriginY doesn't work in dummyheightview?)			text: text,			viewFont: font,			viewBounds: RelBounds(0,0,width,0)},			kDummyHeightView).bottom);Print("; textbounds: " &	TextBounds(text, font, RelBounds(0,0,width,0)).bottom + if Endswith(text,cr) then FontHeight(font) else 0);end;*///local ht :=	if kStyleMeasure and isArray(font)	// !!!m	then TotalTextBounds({	// avoid earlier Substr in addBlock (but viewOriginY doesn't work in dummyheightview?)			text: text,			styles: if start = 0 then font else call kSplitRuns with (font, start, nil, nil), // !!!o. ok to be longer?			viewBounds: RelBounds(0,0,width,0)},			kDummyHeightView).bottom	else/*		TotalTextBounds({			text: text,			viewFont: font,			viewBounds: RelBounds(0,0,width,0)},			kDummyHeightView).bottom;*/		(if text[StrLen(text)-1] = unicodeCR //EndsWith(text,cr)	// bug in TextBounds,kSimpleTextHeightFunc		then FontHeight(font)		else 0) +		(if kBuild20		then TextBounds(text, font, RelBounds(0,0,width,0)).bottom	// faster than TotalTextBounds?		else call kSimpleTextHeightFunc with (text,width,font)		);//Print("kMySimpleHeightFunc2");//	ht;/*if kStyleMeasure and GetRoot().(kAppsymbol).debugHeightthen beginPrint("\nkMySimpleHeightFunc. wid:" && width & "; ht:" && ht); Print(font); Print(text);end;ht;*/end);// used by kGetHrefRegions, :addBlockDefineGlobalConstant('kSplitTextHeightFunc, func NATIVE (str, ARRAY stcnt, INT wid, font, nht) // !!!o. native for 1.xif kStyleMeasure	// !!!mthen begin	// it would be nice to avoid substr/splitRuns (viewOriginY w/in editView?)	local INT cpos := 0, start := stcnt[0], count := stcnt[1];//Print(["kSplitTextHeightFunc1",start,count,wid,font,nht]);	local copyRange := start > 0 or StrLen(str) > count;	// !!!y	local gb, ch, view := BuildContext({		viewClass: clParagraphView,		viewFlags: vVisible,		ReorientToScreen:	ROM_DefRotateFunc,	// !!!q		text: if copyRange then str := call kBigSubStr with (str, start, count) else str, // !!!y,o. nil. avoid copying/too much?		viewBounds: RelBounds(0,0,wid,nht),		});	try begin		if isArray(font)		then view.styles := if copyRange then font := call kSplitRuns with (font, start, count, nil) else font // !!!y,o. nil		else begin			view.viewFont := font;			//!!!z. doesn't work with landscape or styles or ???  view.viewFlags := vVisible+vCalculateBounds;	// !!!y more accurate for PRE?			end;		view:open();		gb := view:GlobalBox();		cpos := view:PointToCharOffset(gb.right, gb.bottom); // bottom of last line?  FontHeight(font));//if GetRoot().(kAppSymbol).debugHeight then//Print("\nkSplitTextHeightFunc. cpos:" && cpos);		if cpos < 0 or call kMySimpleHeightFunc with (str, 0, cpos, wid, font) > nht // !!!o		then begin//Print("\nkSplitTextHeightFunc. actual height:" && stlen & "; wid:" && wid & "; nht:" && nht);//Print(font); Print(str);			cpos := view:PointToCharOffset(gb.right, gb.bottom-10); // earlier line?//Print("\nkSplitTextHeightFunc2. cpos:" && cpos);			end;//Print("kSplitTextHeightFunc2");		if cpos <= 0		then cpos := 0		else if cpos >= count		then cpos := count-1		else while cpos > 0			 do if SetContains(kLineBreakChars, ch := str[cpos])				then break				else if ch = $. and (cpos=count-1 or isWhiteSpace(str[cpos+1]))	// !!!o				then break cpos:=cpos+1				else cpos := cpos-1;//Print("kSplitTextHeightFunc3. cpos:" && cpos & "; cpos+start:" && start+cpos);		end	onexception |evt.ex| do nil;	view:close();//Print("kSplitTextHeightFunc3");	start + cpos;	endelse begin// sort of inverse of SimpleTextHeight// for given height, return max position in str (where line would break) -- see addBlock// or// 1.x: if nht=NIL, then return array of all line ends -- see kGetHrefRegions	local INT lpos := stcnt[0], start := stcnt[0], count := stcnt[1], slen := start + count;	// !!!o	local INT swid, ht := FontHeight(font), spos;	local ARRAY lines := [];	local cpos, toowide, xht := nht;	local kSetContains  := Functions.SetContains;	local kStrFontWidth := Functions.StrFontWidth;	loop begin		cpos := nil;		for spos := lpos to slen-1		do if cpos := call kSetContains with(kLineBreakChars, str[spos]) // faster than CharPos		then break;		swid := call kStrFontWidth with(SubStr(str,start,(if cpos and cpos<=2 then spos else spos+1)-start),font);		toowide := swid >= wid;		if (toowide and (if cpos=1 and swid=wid then lpos := spos+1 else true))			or (if cpos=0 then lpos := spos+1) // cr?		then begin			if nht			then (if (xht := xht - ht) < ht then break)			else if kBuild1x	// !!!m			then AddArraySlot(lines, lpos-1);			start := lpos; // new beginning of line			if toowide and cpos=0 then spos := spos-1; // don't lose cr			end;		lpos := spos+1;		if lpos > slen then break;		end;	if nht	then if lpos=0 then 0 else lpos-1	else if kBuild1x	// !!!m	then SetAdd(lines,slen,nil);end);/*call func(str,start,wid,font,nht)beginlocal kLineBreakChars := '[$\n, $ , $\t, $-, $/, $+, $], $[, $*, $=, $&, $^, $|, $<, $>, $\\,];local gb, cpos, view := BuildContext({		viewClass: clParagraphView,		viewFlags: vVisible+vCalculateBounds,		viewJustify: 0,		ReorientToScreen:	ROM_DefRotateFunc,		text: if start=0 and StrLen(str) < 1800 then str else str := SubStr(str, start, 1800),		viewBounds: RelBounds(0,0,wid,nht),		});		if isArray(font)		then view.styles := font		else view.viewFont := font;		//view.textFlags := vFixedTextStyle;	try begin		view:open();//Print(view);		gb := view:GlobalBox();		cpos := view:PointToCharOffset(gb.right, gb.bottom);local ch, ht2 := TextBounds(	Substr(str,start,cpos), font, RelBounds(0,0,wid,0)).bottom;Print("height:" && ht2);		if cpos < 0 or ht2 > nht		then cpos := view:PointToCharOffset(gb.right, gb.bottom-10);		if cpos <= 0		then cpos := 0		else if cpos >= count		then cpos := count-1		else while cpos > 0			 do if SetContains(kLineBreakChars, ch := str[cpos])				then break				else if ch = $. and (cpos=count-1 or isWhiteSpace(str[cpos+1]))	// !!!o				then break cpos:=cpos+1				else cpos := cpos-1;		end	onexception |evt.ex| do nil;	view:close();	start+cpos;end with (ss, 0, 320, 12288, 402)end with (	getroot().copperfield.contentarea:childviewframes()[1].item.data, 0,	320, 12288, 402)*/DefineGlobalConstant('kGetHrefRegions, func (str, INT start, count, INT wid, INT ht, font, ARRAY hrefs) // NATIVE?if Length(hrefs)=2then begin	if isArray(hrefs[0])	then hrefs	else if (if kNIE then IsString(hrefs[1]) else isInstance(hrefs[1], 'string))	then [[hrefs[1], start, count, 0, 0, wid, ht, ], ];	 // href for entire para (or IMG)	endelse if Length(hrefs) > 0 and isArray(hrefs[0])	// already converted image mapthen hrefselse begin// hrefs: [len1, nil, len2, "#href", len3, nil, len4, "#href",...]// return new format array of hrefs or NIL// [[0=href, 1=left, 2=top, 3=right, 4=bottom, 5=start, 6=count, ], ]// see kGotoHREFclick	local INT i := 0, hlen, hlast := Length(hrefs)-1, tot := start, inc, regionLen := 0;	local ARRAY regions := Array(Length(hrefs), NIL);	local href;//Print([str, start, count, wid, ht, font]); Print(hrefs);	if kBuild1x	then begin		local INT x1, x2, y1, ntot, spos, epos, fht := FontHeight(font);		local ARRAY lines := call kSplitTextHeightFunc			with (str,				//[start, if hlast>0 and hrefs[hlast]=nil then count-(hrefs[hlast-1]-start) else count],				[start, if hlast>0 and hrefs[hlast]=nil then count-hrefs[hlast-1] else count], // !!!o				wid, font, NIL);		local ARRAY xhrefs := Clone(hrefs); // due to KLUDGE below		local linenum := 0, comparefn := Functions.|<=|;		local findOld := Functions.ArrayPos exists;//if BeginsWith(str,"¥ Index: A") then Print(lines);		end;	while i <= hlast	do if isArray(obj := hrefs[i])	// (e.g., AREA already added in a TABLE)	then begin		regions[regionLen] := obj; //AddArraySlot(regions, obj);		regionLen := regionLen+1;		i := i+1;		end	else if kBuild20	then begin		hlen := obj;		if href := hrefs[i+1]		then begin			regions[regionLen] := [href, tot, hlen]; //AddArraySlot(regions, [href, tot, hlen]);			regionLen := regionLen+1;			end;		tot := tot + hlen;		i := i+2;		end	else begin		hlen := xhrefs[i];		href := xhrefs[i+1];		inc := 2;//if BeginsWith(str,"¥ Index: A") then Print([hlen, href]);		if href and linenum and			(linenum := if kBuild1x and findOld				then ArrayPos(lines, tot, linenum, comparefn)				else  LSearch(lines, tot, linenum, comparefn, nil))		then begin			y1 := linenum * fht;			spos := if linenum=0 then start else lines[linenum-1]+1;			epos := lines[linenum];			x1 := StrFontWidth(SubStr(str, spos, tot-spos), font);			if (ntot := tot + hlen) > epos			then begin // split				hlen := epos - tot + 1;				xhrefs[i] := ntot - epos - 1;  // UGLY KLUDGE				inc := 0;				ntot := epos+1;				end;			x2 := StrFontWidth(SubStr(str, spos, ntot-spos), font);			regions[regionLen] := [href, tot, hlen, x1, y1, x2, y1+fht, ]; //AddArraySlot(regions, [href, tot, hlen, x1, y1, x2, y1+fht, ]);			regionLen := regionLen+1;			tot := ntot;			end		else tot := tot + hlen;		i := i + inc;		end;//if BeginsWith(str,"¥ Index: A") then Print(regions);	if regionLen > 0	then begin		SetLength(regions, regionLen);		regions;		end;	end);DefineGlobalConstant('kRemoveAllSoupEntries, func(soupName)	// remove all entriesif soupNamethen begin	local soup := if kNIE then GetUnionSoupAlways(soupName) else if isFrame(soupName) then soupName else GetUnionSoup(soupName);	local soups := if soup then if kNIE then soup:GetSoupList() else soup.soupList;	if soups	then foreach soup in soups	do if kNIE		then soup:removeAllEntriesXmit(kNewtsCapeSymbol)		else soup:removeAllEntries();	end);DefineGlobalConstant('kGetHTMLFunc, func(contentID) // used during Save Pkg (1.x), during developmentbegin	local soup 	 := GetRoot().(kNewtsCapeSymbol).htmlSoup;	local cursor := if kNIE		then begin gc(); GetUnionSoupAlways(soup):Query(kHTMLQuery); end		else Query(soup, kHTMLQuery);	local entry  := cursor:GoToKey(contentID), entdata;	if entry	then begin		cursor := soup := nil;		entdata := entry.data;		if kNIE //kBuild20 or Functions.EntryRemoveFromSoupXmit exists		then EntryRemoveFromSoupXmit(entry,nil)		else EntryRemoveFromSoup(entry);		if isFrame(entdata) and entdata.hrefs		then entdata.scripts := if isInstance(entdata.data, 'string) then kAHREF else kAHREFG;	// no interference with kImgAnim?		end;	entdata;end);if kNIEthen DefineGlobalConstant('kMungeContentScript, func(content) // see :addBlock, kGetHTMLFunc/*if IsEntryAlias(content)then begin	content := ResolveEntryAlias(content).data;	if isFrame(content) and content.hrefs	then content.scripts := if IsString(content.data) then kAHREF else kAHREFG;	content;	endelse*/ if IsEntryAlias(content.data)then begin	content := Clone(content);	content.data := ResolveEntryAlias(content.data).data;	if IsEntryAlias(content.hrefs)	then content.hrefs := ResolveEntryAlias(content.hrefs).data;	content;	endelse content);if kNIEthen DefineGlobalConstant('kFixPkgHREF, func(content) // for fixing already retrieved aliasif isFrame(content)then begin	if content.hrefs	then content.scripts := if IsString(content.data) then kAHREF else kAHREFG;	content;	endelse content);/*if kNIEthen DefineGlobalConstant('kBookSearchScript, func(searchStr,stringLen,theContent,bookData, bookFrame) // implement (or prevent) Findbegin	Print(searchStr);	TRUE;	// just prevent for nowend);*/DefineGlobalConstant('kGetFontFamily, func(font)//if kBuild20 then GetFontFamilyNum(font) or GetFontFamilySym(font) elseif isFrame(font)then font.familyelse Band(font,tsFamilyMask) // >> tsFamilyShift;);DefineGlobalConstant('kGetFontFace, func(font)if kNIEthen GetFontFace(font)else if isFrame(font)then font.faceelse Band(font,tsFaceMask) >> tsFaceShift);DefineGlobalConstant('kGetFontSize, func(font)if kNIEthen GetFontSize(font)else if isFrame(font)then font.sizeelse Band(font,tsSizeMask) >> tsSizeShift);DefineGlobalConstant('kSetFont, func(font,family,face,size) // used in getRun and Prefs.if kNIEthen SetFontParms(font, {family: family, face: face, size: size})	// !!!melse begin	if not family	then family := if kNIE then GetFontFamilySym(font) else call kGetFontFamily with (font); // !!!k	local fpos := SetContains(kBuiltinFonts,family);	if fpos then family := fpos;	if not face	then face := if kNIE then GetFontFace(font) else call kGetFontFace with (font);	if not size	then size := if kNIE then GetFontSize(font) else call kGetFontSize with (font);	if kNIE	then MakeCompactFont(family,size,face)	else if isInstance(family,'symbol)	then {family: family,			face: face,			size: size}	else family + //(family << tsFamilyShift) +		  (face   << tsFaceshift) +		  (size   << tsSizeShift);end);DefineGlobalConstant('kAddEmphasis, func(font, bits)begin	font := Clone(font);	font.face := Bor(font.face, bits);	font;end);DefineGlobalConstant('kFaceStrings, [	[kFaceBold, 		"B"],	[kFaceItalic, 		"I"],	[kFaceUnderline, 	"U"],	[kFaceOutline,		"O"],	[kFaceSuperScript,	"SUP"],	[kFaceSubScript,	"SUB"],	]);/*DefineGlobalConstant('kCollectFontNames, func()begin	local ARRAY labelCommands := [Fonts.espy.name, Fonts.newYork.name, Fonts.geneva.name]; // order important (same as kBuiltinFonts symbols)	local s,v;	// add 2.x-only built-ins (e.g., handwriting), user-installed (e.g., Monaco, Minico)	foreach s,v deeply in Fonts					// 2.x use?: call kGetAllFontsFunc with () except where System font?	do if not SetContains(kBuiltinFonts, s)		// = ok	then AddArraySlot(labelCommands, v.name);	labelCommands;end);DefineGlobalConstant('kFindFontSymbol, func(fam)begin	local s, v;	foreach s,v deeply in Fonts	do if StrEqual(v.name,fam)	then return s;	kSystemFontSym;end);*/// return [{item: "Casual", family: 'casual},...]DefineGlobalConstant('kCollectFontNames, func()	// !!!jif kNIEthen begin	local ARRAY items;	local font, val;	if GlobalFnExists('MakeFontMenu) 			// 2.1 only	then items := MakeFontMenu(nil,'all,'none,'none)	// & wrong for MacCenter/DinamPatch (dup names)	else begin		items := [];		local sym, symMap := '{		// ROM_systemFont = 'espy			//espyFont: espy, 	// not in GetAllFonts, but added later			newYorkFont: newYork,			genevaFont: geneva,			handwritingFont: handwriting,			};		foreach font in call kGetAllFontsFunc with ()		do begin			val := symMap.(sym := font.screenSym);			BInsertRight(items, {item: font.name, family: if val then val else sym}, '|str<|, 'item, nil);			end;		font := Fonts.(sym := kSystemFontSym);	// add system font (not in GetAllFonts)		BInsertRight(items, {item: font.name, family: sym}, '|str<|, 'item, nil);		end;	// if any duplicate names(e.g., MacCenter/DinamPatch), add font sym to disambiguate	val := "";	// prev	foreach font in items	do  if StrEqual(val, val := font.item)		then font.item := val & $( & font.family & $);	items;	endelse begin // 1.x	local sym, font;	Sort(foreach sym,font deeply in Fonts		 collect {item: font.name, family: sym},		'|str<|,'item);	end);// labelPicker doesn't save or return :popupMenu in Popit// and not possible to use inherited:popupMenu (and :parent():popupMenu appears in wrong place)DefineGlobalConstant('kFixPicker, func(menuFont, wid)	// ~Jbegin	local INT i;	local ARRAY children := GetRoot():childViewFrames();	local pp;	for i := Length(children)-1 to 0 by -1	do  if isFrame(pp := children[i]) and pp.pickItems		then begin			pp.bounds := pp.viewBounds;			if wid			then pp.pickMaxWidth := GetAppParams().appAreaWidth-10;			pp.viewFont := menuFont;       		return pp:?SyncView(); // SetValue(clast, 'viewFont, kEspy);			end;end);// maybe do this in protos, then specific pickers can inherited: to get at least true?DefineGlobalConstant('kFixPickerSetup, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then AddDeferredCall(kFixPicker, [newtscape.menuFontJ, nil]);	// !!!j	TRUE;end);DefineGlobalConstant('kFixPickerFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then begin		viewFont 			:= 	newtscape.labelFontJ;		entryLine.viewFont 	:= 	newtscape.dataFontJ;		end	else if language='Chinese	then entryLine.viewFont := kEspy10;  // ~C	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kFixButtonFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	// !!!j	then viewFont := newtscape.labelFontJ;	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kFixButtonClickScript, func() // !!!j. protoInfoButton, protoPopupButton, protoNewFolderTab.showBarTextbegin	local pp := inherited:buttonClickScript();	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then SetValue(pp, 'viewFont, newtscape.menuFontJ);	//{family: sym, face: kFaceBold, size: 10});	pp;end);DefineGlobalConstant('kFixActionClickScript, func() // !!!j. protoActionButtonbegin // almost same as protoInfoButton (popupView)//Print("action start");	popupForm := NIL;	inherited:buttonClickScript();	// !!!j//Print(popupForm);	if kNCfont and popupForm and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then SetValue(popupForm, 'viewFont, newtscape.menuFontJ);	//{family: sym, face: kFaceBold, size: 10});//Print("action end");end);constant kFixTextFormScript := kFixButtonFormScript; // share// newtscape vs. newtscape.prefsEntry ?????DefineGlobalConstant('kFixInputFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then viewFont := newtscape.entryFontJ;	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kFixCheckFormScript, func() // sharebegin	if kNCfont and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then viewFont := newtscape.dataFontsJ;	inherited:?viewSetupFormScript();end);// used in SUBMIT, IMAGEDefineGlobalConstant('kPostSoup, func(btitle,soupName,fdata)begin // uses kNewtsCapeSymbol instead of isbn for appsymbol	local soup := :RegisterCardSoup(soupName, [], kNewtsCapeSymbol, ["form", "forms"]);	if kBuild20 or HasVariable(soup,'AddToStoreFlushedXmit)	then soup:AddFlushedXmit(fdata, nil) // AddToDefaultStoreXmit(fdata,nil)	else soup:AddToDefaultStore(fdata);	:UnRegisterCardSoup(soupName);	NIL;	// don't resetend);DefineGlobalConstant('kMakeNote, func(title, str, styles, font)begin	local nos20 := kBuild20 or Functions.XmitSoupChange exists;	local INT ht;	local para;	if (if kBuild20 then IsString(str) else isInstance(str, 'string))	then begin // create a para object to embed		if not (kBuild20 or nos20) and StrFilled(title)		then str := title & unicodeCR & unicodeCR & str;		if not font		then font := if styles then styles[1] else dataNoteFont;		ht := 2*FontHeight(font) + // add two lines			call kMySimpleHeightFunc with (str, 0, nil, noteWidth, if kStyleMeasure and styles then styles else font); // !!!o,m		para := {			viewStationery: 'para,			viewBounds: RelBounds(noteLeft,noteTop,noteWidth,ht),			text: str,			}; 		if styles		then para.styles := styles		else para.viewFont := font;		end	else if isFrame(str)	then begin // e.g., picture		para := str;		ht := para.viewBounds.bottom - para.viewBounds.top;		end	else return NIL; // error?	local noteframe := {		viewStationery: kNotesSym,		height: ht,		data: [para],		timeStamp: Time(),		};	if kBuild20 or nos20	then begin		if StrFilled(title)		then noteframe.title := title;		noteframe.class := kNotesSym;		GetUnionSoup(notesSoupName):AddFlushedXmit(noteframe, 'entryAdded);		//XmitSoupChange(notesSoupName, kNewtsCapeSymbol, 'whatThe, NIL);		end	else begin		GetUnionSoup(notesSoupName):AddToDefaultStore(noteframe);		BroadcastSoupChange(notesSoupName);		end;	NIL; // does not reset by defaultend);DefineGlobalConstant('kMyStringer, func(ARRAY a) // like Stringer, with commas between valsif athen begin	local str, s;	foreach s in a	do str := str & (if str then $,) & s;	str; // maybe nil	end);constant kForm := "FORM:";DefineGlobalConstant('kPostNotes, func(btitle, ARRAY pnames, fdata)begin // METHOD??	local str := Clone(""); // kForm && btitle & unicodeCR & unicodeCR;	local ARRAY styles := Array(Length(pnames)*4, nil);	local INT i := 0, len := 0, oldlen := 0;	local sym, val;	foreach sym in pnames // actually a string	//foreach sym,val in fdata	do begin		val := fdata.(Intern(sym));		// slot		StrMunger(str,len,0, sym & ": ", 0, nil);		styles[i] 	:= (len := StrLen(str)) -oldlen;		styles[i+1] := slotNoteFont;		oldlen 		:= len;		i			:= i+2;		// value(s)		StrMunger(			str,len,0,			(if isArray(val) or isFrame(val)			then call kMyStringer with (val) else val ) & unicodeCR,0,nil);		styles[i] 	:= (len := StrLen(str)) -oldlen;		styles[i+1] := dataNoteFont;		oldlen 		:= len;		i			:= i+2;		end; 	call kMakeNote with (btitle, str, styles, slotNoteFont); // does not reset by defaultend);DefineGlobalConstant('kAppendFrame, func(f1, f2) // used by addIncludes,connect,begin	local s, v;	foreach s,v in f2	do f1.(s) := v;	f1;end);/*DefineGlobalConstant('kAppendString, func(s1, s2) // unused?	StrMunger(s1,StrLen(s1),0, s2,0,nil));DefineGlobalConstant('kAppendArray, func(array a1, array a2) // unused?	ArrayMunger(a1,Length(a1),0, a2,0,nil));*/DefineGlobalConstant('kAppendObj, func(a, obj)if athen begin	if isReadonly(a)	then a := Clone(a);	if isArray(obj)	then ArrayMunger(a,Length(a),0, obj,0,nil)	else if obj	then AddArraySlot(a, obj);	a;	endelse if isArray(obj)	// "nil" array. create a new onethen objelse if objthen [obj]else []	);DefineGlobalConstant('kGetResource, func(name)begin	local rf := OpenResFileX(HOME & "NewtsCape.rsc");	local icon := GetPictAsBits(name,nil);	CloseResFileX(rf);	icon;end);DefineGlobalConstant('kGoHistory, func(gData, INT i, curisbn) // used by kHistoryButton, kBackButton, Go popup. same fn as end of kGotoHref???.begin	local ARRAY history := gData.(kHistoryPath);	if i < 0 or i >= Length(history)	then return NIL;	local ARRAY historyEntry := history[i];	gData.(kHistoryPos) := i;	//SetLength(history, i);	local historyid := historyEntry[0];	local pnum := historyEntry[1], href, bdata, edata;	local viewer := GetRoot().(kBookReaderSymbol);	if kNIE	then begin		href := historyEntry[3];		bdata := viewer:BookData();		edata := if Length(historyEntry) > 4 then historyEntry[4];		end;	if (StrEqual(curisbn, historyid) or call kFindBook with (historyid, nil)) and		(not kNIE or			(bdata and call kCacheEqual with (bdata.base_href, href, bdata.edata, edata)))	then begin		viewer:openBook(historyid);		viewer:turnToPage(min(pnum, viewer:countPages()));		TRUE;		end	else if kNIE and href	then begin		call kFindApp with (kNewtsCapeSymbol):?getURL(href,			{hrefname: pnum,			edata: edata,			noHistory: true,			});		TRUE;		end;	//else return NIL;end);DefineGlobalConstant('kClearHistoryItem,	LocObj("Clear History", 'clearHistoryItem));DefineGlobalConstant('kHistoryList, func(topLabels) // kHistoryButton, Go popupbegin	local gData := call kInitGlobal with (nil, nil);	local ARRAY history := gData.(kHistoryPath);	local INT len := Length(history);	if len > 0	then begin		local INT i, tlen := Length(topLabels), historyPos := gData.(kHistoryPos);		local ARRAY historyList := Array(tlen + 2 + len, NIL);		ArrayMunger(historyList,0,tlen, topLabels,0,tlen);		historyList[tlen]	:= kClearHistoryItem;		historyList[tlen+1] := 'pickSeparator;		tlen := tlen+2;		for i:= 0 to len-1 // add most recent kMaxHistory titles		do historyList[i+tlen] := history[i][2] && "p." & history[i][1];			//AddArraySlot(historyList, history[i][2] && "p." & history[i][1]);		if historyPos >= 0 and historyPos < len		then historyList[historyPos + tlen] := {item: historyList[historyPos + tlen], mark: kCheckMarkChar};		historyList;		end	else topLabels;	// historyListend);DefineGlobalConstant('kBackItem,	// for Go popup	/*if kNIE	then {item: LocObj("Back", 'backItem), icon: ROM_leftbitmap}	else*/ LocObj("Back", 'backItem));DefineGlobalConstant('kForwardItem,	// for Go popup	/*if kNIE	then {item: LocObj("Forward", 'forwardItem), icon: ROM_rightbitmap}	else*/ LocObj("Forward", 'forwardItem));DefineGlobalConstant('kHomeItem, LocObj("Home",'homeItem));	// !!!fDefineGlobalConstant('kNewerHTMLCacheItem,  LocObj("Newer HTML Cache Item",  'newerHTMLitem));	// !!!a1,sDefineGlobalConstant('kNewerImageCacheItem, LocObj("Newer Image Cache Item", 'newerImageItem));	// !!!a1,sDefineGlobalConstant('kResetHTMLCacheItem,  LocObj("Set HTML Cache Item",    'setHTMLitem));  	// !!!a1,sDefineGlobalConstant('kResetImageCacheItem, LocObj("Set Image Cache Item",	 'setImageItem));	// !!!a1,sDefineGlobalConstant('kHistoryButton,	{_proto: protoPictureButton,	icon: call kGetResource with ("overviewDot"), // ROM_overviewBitmap undef in 2.1	viewBounds: RelBounds(0,0,12,12),	buttonClickScript: func()	begin		local ARRAY historyList := call kHistoryList with ([]);		if kBuild1x and Functions.DoPopup exists		then DoPopup(historyList,0,0,self) 		else :PopupMenu(historyList, {left: 0, top: 0});	end,	pickActionScript: func(INT i)	begin		// assume exists from kBookOpenScript		local gData := call kInitGlobal with (nil, nil);		if i = 0		then SetLength(gData.(kHistoryPath), 0)			// no need to set historyPos? (it gets set with next add)		else call kGoHistory with (gData, i-2, isbn);	// Clear History, 'pickSeparator	end,	});DefineGlobalConstant('kBackButton,	{_proto: protoPictureButton,	icon: ROM_leftbitmap,	viewBounds: RelBounds(0,0,10,12),	step: -1,	// !!!e. was limit	buttonClickScript: func() // shared with kForwardButton, _Back(kbd), _Forward(kbd)	begin		// assume exists from kBookOpenScript		local gData := call kInitGlobal with (nil, nil);		local historyPos := gData.(kHistoryPos), len := Length(gData.(kHistoryPath));		if (if step < 0 then historyPos > 0 else historyPos < len-1) // !!!e		then begin			if step < 0 and historyPos = len			then call kAddHistory with (); // add current book when going back at end			call kGoHistory with (gData, historyPos+step, if kBuild20 then GetRoot().(kBookReaderSymbol).isbn else isbn); // !!!e. in case called via kbd			end;	end,	viewSetupFormScript: func()	begin		local gData := call kInitGlobal with (nil, nil), historyPos := gData.(kHistoryPos);		if (if step < 0 then historyPos=0 else historyPos >= Length(gData.(kHistoryPath))-1) // !!!e		then viewFormat := 67109425; //Band(bnot(vfFrameMask), viewFormat) + vfFrameGray;		inherited:?viewSetupFormScript();	end,	});DefineGlobalConstant('kForwardButton,	{_proto: kBackButton,	icon: ROM_rightbitmap,	//viewBounds: RelBounds(0,0,10,12),	step: 1,	// !!!e	});DefineGlobalConstant('kDummyButton,	{_proto: protoPictureButton,	viewBounds: RelBounds(0,0,10,0),	// was 11 (same as kBackButton for width)	viewFormat: 0,	viewFlags: vVisible,	/*buttonClickScript: func() // this unfortunately is on top of the markupButton		markupButton:buttonClickScript(),*/	});DefineGlobalConstant('kScrollPage2, func(n)begin	inherited:scrollPage(n);	if n = 0	then GetRoot().(kBookReaderSymbol):Dirty();end);DefineGlobalConstant('kBrowserQuit, func() // for NOS 2.x rotate bug (Overview)begin	inherited:?viewQuitScript();	self.(EnsureInternal('ReOrientToScreen)) := ROM_DefRotateFunc; //@588end);//GatherKeyCommands(view)//if kNIE then	// !!!xDefineGlobalConstant('kBookKeys, [	{char:		$[,	modifiers:	kCommandModifier,	keyMessage:	'_Back,	name:		kBackItem,	category:	kAppNameL,	},	{char:		$\1C,	// !!!f. left arrow	modifiers:	kCommandModifier,	keyMessage:	'_Back,	name:		kBackItem,	category:	kAppNameL,	},	{char:		$],	modifiers:	kCommandModifier,	keyMessage:	'_Forward,	name:		kForwardItem,	category:	kAppNameL,	},	{char:		$\1D,	// !!!f. right arrow	modifiers:	kCommandModifier,	keyMessage:	'_Forward,	name:		kForwardItem,	category:	kAppNameL,	},	{char:		$8,	modifiers:	kCommandModifier, // + kShiftModifier,	keyMessage:	'_NewtsCape,	name:		kAppNameL,	category:	kAppNameL,	showChar:	$*,	},/* !!!f. fix in NC??	{char:		$w,	modifiers:	kCommandModifier,	keyMessage:	'_CloseBook, _CloseFrontView	name:		"Close",	category:	"Viewing",	},*/]);DefineGlobalConstant('kBrowserSetup, func()	// !!!jbegin	local newtscape;	if kNCfont and (newtscape := GetRoot().(kNewtsCapeSymbol)) // !!!k		and newtscape.prefsEntry and newtscape.prefsEntry.systemFontFamily <> kSystemFontSym	then begin		SetValue(outline, 'viewFont, newtscape.menuFontJ);		AddDeferredCall(func()			SetValue(:childViewFrames()[3]:childViewFrames()[0], 'viewFont, newtscape.menuFontJ), nil); //"Contents"		end;	inherited:?viewSetupFormScript();	// !!!k. re-fixup bounds so at upper right?	local gb := GetRoot().(kBookReaderSymbol):GlobalBox();	// this should go at bottom of actual title, but viewer.contentArea:childViewFrames()[0].viewBounds.bottom is wrong	viewBounds := RelBounds(gb.right-232, gb.top+20, 224, 173);	// !!!r,n,k. -gb.left. 224+8 for border. gb.bottom-178. 20 for titleend);DefineGlobalConstant('kBookOpenScriptShare, func(obj, protoDummyButton, protoHistoryButton, protoBackButton, protoForwardButton) // standalone usebegin//Print('kBookOpenScriptShare);	call kInitGlobal with (kHistoryPath, []);	call kInitGlobal with (kHistoryPos,	 0);	local viewer := GetRoot().(kBookReaderSymbol), bdata := viewer:BookData(), titleFormat, obj;	//viewer.contentArea.(EnsureInternal('viewSetupDoneScript)) := kviewSetupDone2; // fix TITLE	if bdata	then begin		if isFrame(titleFormat := bdata.titleFormat) and Length(titleFormat) > 0	// inline		then begin			local sym, titleObj := viewer.contentArea:childViewFrames()[0];			foreach sym,obj in titleFormat	// e.g., viewFont, viewJustify			do SetValue(titleObj,sym,obj);			end;		GetRoot().(kNewtsCapeSymbol):?displayURL(EnsureInternal(bdata.base_href));	// !!!g		end;	if kBuild20 or HasVariable(viewer, 'SetStatusBarButtons) // 2.x ?	then begin		if not viewer.cntrlPanel.NCinit	// !!!k		then begin			viewer:SetStatusBarButtons({				left:  [protoDummyButton, protoHistoryButton],	// 2.0 (bug in viewSetupChildren)				right: [protoForwardButton,protoBackButton,],				});			// !!!e. viewer.(EnsureInternal('scrollPage)) := kScrollPage2;			obj := viewer.browser;			if not GlobalFnExists('PackRGB)	// not needed for 2.1?			then obj.(EnsureInternal('viewQuitScript)) := kBrowserQuit;			obj.(EnsureInternal('viewSetupFormScript)) := kBrowserSetup;	// !!!k,j			obj := viewer.cntrlPanel;			obj.(EnsureInternal('NCinit)) := true;	// !!!k			if Length(obj.stepChildren)=0	//  automatically open?			then obj:ChangeState();			//viewer.(EnsureInternal('_CloseFrontView)) := viewer._CloseFrontView;			SetKeyView(viewer, 0);	// !!!f			viewer:?AddKeyCommands(kBookKeys);			end;		end	else if viewer.buttonsOn // MP100 ?	then begin		obj := viewer.pagenumber:parent();		if not obj.stepChildren or Length(obj.stepChildren)=0		then begin			AddStepView(obj, {				_proto: protoHistoryButton,	// history/NC				viewBounds: RelBounds(143,2, protoHistoryButton.viewBounds.right,13),				});			AddStepView(obj, {				_proto: protoBackButton,				viewBounds: RelBounds(165,2, 10,13),				});			AddStepView(obj, {				_proto: protoForwardButton,				viewBounds: RelBounds(181,2, 10,13),				});			obj:dirty();			end;		end	else if (obj := viewer.extraButtons) and not HasSlot(obj, 'stepChildren)	then begin // MP110 (other 1.x)		obj.viewBounds := SetBounds(-188,-17,-33,0); // -168 for back w/o forward		obj.stepChildren := [stepChildren:			{_proto: 	protoHistoryButton,			viewBounds: RelBounds(82,2, protoHistoryButton.viewBounds.right,13)}, // history/NC			{_proto: protoBackButton,			viewBounds: RelBounds(104,2, 10,13)},			{_proto: protoForwardButton,			viewBounds: RelBounds(120,2, 10,13)},			];		end;	TRUE;end);DefineGlobalConstant('kBookOpenScriptNC, func() // NC needed at runtimebegin	local app := GetRoot().(kNewtsCapeSymbol);	if not app	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	app:?BookOpenScript(self);end);DefineGlobalConstant('kBookOpenScript, func() // regular (standalone use; NC not needed at runtime)begin	// !!!f,e	local app := GetRoot().(kNewtsCapeSymbol);	if not app	then app := if kBuild20 then GetGlobalVar(kNewtsCapeSymbol) else GetGlobals().(kNewtsCapeSymbol);	app:?BookOpenScript(self)			// try NC script first	or	call kBookOpenScriptShare with (self, kDummyButton, kHistoryButton, kBackButton, kForwardButton);end);DefineGlobalConstant('kBookCloseScript, func() // for regular bookbeginif kDebugHTTP then Print("BookCloseScript0");	local viewer := GetRoot().(kBookReaderSymbol);	//RemoveSlot(viewer.contentArea, 'viewSetupDoneScript);	// not needed?	if kBuild20 or SetStatusBarButtons exists // 2.0 ?	then beginif kDebugHTTP then Print("BookCloseScript1");		// !!!e. RemoveSlot(viewer, 'scrollPage); //AddDeferredCall(GetGlobalFn('RemoveSlot), [viewer, 'scrollPage]);		//viewer.scrollPage := GetVariable(viewer._proto, 'scrollPage)		//RemoveSlot(viewer, 'TurnToPage);			//RemoveSlot(viewer, 'TurnToContent);		//RemoveSlot(viewer, 'TurnToSubject);if kDebugHTTP then Print("BookCloseScript2");		viewer:?ClearKeyCommands();		end	else if not viewer.buttonsOn and viewer.extraButtons  // 1.x (not MP100)?	then RemoveSlot(viewer.extraButtons,'stepChildren);end);// used by :removeApp, and also "noStatus" books (kBookCloseScriptInv, kHelpBookCloseScriptInv2, kHelpBookCloseScriptInv1x)// coord with :bookTemplate, :refreshBookDefineGlobalConstant('kBookCleanup, func(isbn, help, ver)if helpthen if kBuild20 or ver	then //RemoveSlot(GetRoot().(kBookReaderSymbol).library, Intern(isbn))		GetRoot().(kBookReaderSymbol):UnRegisterBookRef(isbn)	else begin		local pos := call kLFetch with (Extras, isbn, 0, Functions.StrEqual, 'isbn, true);		if pos then ArrayRemoveCount(Extras,pos,1);		SetRemove(GetRoot().(kBookReaderSymbol).library.books, call kFindBook with (isbn,true)); // BookRemoved({isbn: isbn}); //???		endelse begin // regular book (both 1.x and 2.0)if kDebugHTTP then Print("kBookCleanup1");	GetRoot().(kBookReaderSymbol):?close();	// for StartBar (SAS)if kDebugHTTP then Print("kBookCleanup2");	BookRemoved({isbn: isbn});if kDebugHTTP then Print("kBookCleanup3");	RemoveSlot(call kInitGlobal with (nil,nil), Intern(isbn));if kDebugHTTP then Print("kBookCleanup4");	end);DefineGlobalConstant('kBookCleanup2, func(isbn, help, ver)	// removeApp, refreshBookbegin	if help	then call kHelpViewerSetup with (nil);	call kBookCleanup with (isbn, help, ver);end);DefineGlobalConstant('kBookCloseScriptInv, func()		// 1.x&2.0. regular "noStatus" bookbegin	call kBookCloseScript with ();	call kBookCleanup with (isbn,nil,true);end);DefineGlobalConstant('kHelpBookCloseScriptInv2, func()	// 2.0. contentArea.viewQuitScriptbegin	call kBookCleanup with (isbn,true,true);	inherited:?viewQuitScript();end);DefineGlobalConstant('kHelpBookCloseScriptInv1x, func()	// 1.x. contentArea.viewQuitScriptbegin	call kBookCleanup with (isbn,true,nil);	inherited:?viewQuitScript();end);/*DefineGlobalConstant('kInstallScriptHelpBook, func(partFrame)begin Print(partFrame.theForm);Print("saving isbn:" && partFrame.isbn := partFrame.theForm.isbn); // save for removeScriptend);DefineGlobalConstant('kRemoveScriptHelpBook, func(partFrame)RemoveSlot(GetRoot().(kBookReaderSymbol).library, Intern(partFrame.isbn)));*/DefineGlobalConstant('kAllType, func(alist, cl) // used in addBlock (1.x)if isArray(alist)then begin	local a;	foreach a in alist	do if not isInstance(a, cl)		then return NIL;	TRUE;end);DefineGlobalConstant('k036, ["0", "3", "6"]); // left, belowDefineGlobalConstant('kAddHTMLitem, func(tag, results) // a default htmlApp:addHTMLitembegin	local tag1 := tag._tag, mf := self.(tag1), args := [tag];	local newtscape := GetRoot().(kNewtsCapeSymbol);	if results	then begin		local ntags := LocObj("Tag", 'tagLabel) & $: && self._numTags := if self._numTags then _numTags+1 else 1;		local INT pos := results.bytesSoFar, len := results.sourceLength;		if newtscape.prefsEntry.showCmdStatus		then begin			newtscape:setGauge(ntags & $; && pos & $/ & len & $; && UPCASE(SPrintObject(tag1)), pos, len); // !!!y. inline sofar,utag			RefreshViews();			end;		end;	if newtscape.debugFlag		// !!!k.	then begin		Write("\ntag: "); Print(tag);		end;	//PerformIfDefined(self, tag1, args);	if (if kNIE		then IsFunction(mf)		else isInstance(mf, '_function) or isInstance(mf, 'CodeBlock))	then Perform(self, tag1, args)	else if isFrame(mf)	then Perform({_parent: self, _proto: mf}, 'addHTMLitem, args);end);// -----constant kParseUpdateSize	:=  200;constant kPkgUpdateSize	 	:= 2048;constant kPrefUpdateDelay	:= 2000;	// for procrastinated :setPreferenceDefineGlobalConstant('kMaxISBN, 14);	// longer for 2.x?DefineGlobalConstant('kMaxString, func(str, slen)if StrLen(str) > slen then call kMyTrim with (str,0,slen) else str	// !!!e. TrimString(SubStr(str,0,slen)) else str);DefineGlobalConstant('kDeclareSelf, func()	// for some viewSetupFormScriptsbegin	newtscape.(childSym) := self;	inherited:?viewSetupFormScript();end);constant kDefaultEncoding	:= 'sjis; //'|string.sjis|;/*DefineGlobalConstant('kNTEforFORM, func(str)begin	// note: this might create a "empty" pref frame from a saved book?	local prefs := GetAppPrefs(kAppSymbol, {}).NTEncoding;	local def := NTE_methods:GetPrefsNTEncoding(prefs, kDefaultEncoding);	local bin := NTE_methods:uni2code(str, def, nil);	local INT len := Length(bin), i;	local result := MakeBinary((len+1) * 2, 'string);			for i:=0 to len-1	do //result[i] := CHR(ExtractByte(bin, i));		StuffUniChar(result, i*2, ExtractByte(bin, i));	// better if =0	//StuffUniChar(result, len*2, unicodeNUL);	result;end);*/constant kHex := "0123456789ABCDEF";DefineGlobalConstant('kURLencodeString, func(val)	// moved from inside kURLencodeValbegin	local i := 0, ch, s := if (if kBuild20 then IsString(val) else isInstance(val,'string)) then Clone(val) else SPrintObject(val), code; // support long(>1024) string	local addEncoding := if kNIE then call kInitGlobal with ('protos,{}).NTEforFORM;	if kNIE and addEncoding and language <> 'Chinese	then s := call addEncoding with (s);	// call kNTEforFORM			while i < StrLen(s)	do if (if kNIE and addEncoding		then (IsAlphaNumeric(ch := s[i]) and (ORD(ch) < 0x7F)) or				SetContains('[    $-, $_, $.,     $*,            $@, ], ch)		else isAlphaNumeric(ch := s[i]) or				SetContains('[$$, $-, $_, $., $!,    $(, $), $'], ch)	// add /:?  earlier removed $&, $+, $/.  add $,* ?				)		then i:= i+1/* according to http://www.ietf.org/rfc/rfc1738.txtonly alphanumerics, the special characters "$-_.+!*'(),", andreserved characters used for their reserved purposes may be usedunencoded within a URL -- but we'll also allow / and :*/		else if ch = $ 	// space?		then begin			s[i] := $+;			i := i+1;			end		else if ch = unicodeCR		then begin			StrMunger(s,i,1, "%0D%0A",0,nil);			i := i+6;			end		else if ch = unicodeLF		then StrMunger(s,i,1, nil,0,nil) 	// delete		else begin 			// other non-alpha. => %HH			code := Ord(ch);//Print([ch,code]);			if code > 255			then code :=				if ch := SetContains(kCharExceptValues, ch)	// map a few out-of-range chars back to char entity code				then kCharExceptNames[ch]				else Ord($?);	//??			StrMunger(s,i,1, $% & kHex[code div 16] & kHex[code mod 16],0,nil);			i := i+3;			end;	s;end);// note: kURLencodeObject isn't defined until later, so accessed here via a parameterDefineGlobalConstant('kURLencodeVal, func(osym, str, fdata, enc, psym, val, kURLencodeObject)	// shareif (isArray(val) and Length(val) > 0) or isFrame(val)then call kURLencodeObject with (psym,str,val,enc,NIL) 	// recur. CHECKBOX [values], IMAGE {x: y:}else str	& (if str then if enc then $& else unicodeCR)	// field separator	& (begin		local namestr :=			call kURLencodeString with (				// name. encode				if osym				then if isFrame(fdata)					// repeat for array; foo.x for frame					then osym & $. & psym					else osym				else psym);		if StrLen(namestr) > 0	// !!!b. for ISINDEX		then namestr & $=		else namestr;		end)	& if isArray(val)	// and Length(val=0)		then nil		else if val=true		then "TRUE"		else if enc and (							// value			if (if kBuild20				then IsString(psym)				else isInstance(psym,'string))		// exceptions to encoding:  how to generalize??			then not StrEqual(psym, "address") and not StrEqual(psym, "usermail")			else psym<>'address and psym<>'usermail)		then call kURLencodeString with (val)		//instead of inline (so share w/ name)		else val);DefineGlobalConstant('kURLencodeObject,begin // kludge so recursion in definition will worklocal fn :=func(osym, str, fdata, enc, pnames)begin // called from kPostMail and self	local psym, val;	if pnames	then foreach psym in pnames	// avoids lookup, preserves order		do begin//Print(psym);			if HasSlot(fdata, val := Intern(psym))	// avoid problems with unused Submit/Image		 	then str := call kURLencodeVal with (osym, str, fdata, enc, psym, fdata.(val), fn); // fn = kURLencodeObject			end	else foreach psym,val in fdata // array or frame		 do if psym <> '_proto			then str := call kURLencodeVal with (osym, str, fdata, enc, psym, val, fn);	str;end;fn;end);// used directly in :getURLDefineGlobalConstant('kPostData, func(addr, btitle, methenc, fdata, pnames, options)begin // ??? currently, enctype not checked (everything is url-encoded); it's just passed along//Print(addr); Print(methenc); Print(fdata); Print(pnames); Print(options);	local edata :=		if (if kNIE then IsString(fdata) else isInstance(fdata,'string))		then fdata		else call kURLencodeObject with (nil, nil, fdata, true, pnames);	if BeginsWith(addr,kHTTP) // kHTTPS ??	then call kSendHTTP with (addr, methenc, nil, edata, fdata, options) // kAddHistory in kSendHTTP	else call kSendMsg  with (addr, nil, kForm && btitle, edata);	NIL; // does not reset by defaultend);DefineGlobalConstant('kPostMail, func(btitle, addr, fdata) // called from SUBMIT, IMAGEbegin	local newtscape := call kFindApp with (kNewtsCapeSymbol);	local bdata := :BookData(), options := {}; //extraHeader: {Referer: bdata.base_href}};	local pnames := if bdata then bdata.form_printnames.(Intern(action));	if newtscape	then newtscape:?getURL(addr, {subject: btitle, data: fdata, dataNames: pnames, method: METHOD,})		//extraHeader: options.extraHeader})	else call kPostData with (addr, btitle, [METHOD,ENCTYPE], fdata, pnames, options);	// use saved (old?) versionend);DefineGlobalConstant('kLookupError, func(ARRAY alist, errnum1, errnum2) // fInputHeaderSpec, :errorbegin	local spos;	if (spos := SetContains(alist,errnum1))		or (errnum2 and spos := SetContains(alist,errnum2))	then alist[spos+1];end);DefineGlobalConstant('kFilterHTMLStrings, nil);DefineGlobalConstant('kEmptyQuit,	LocObj("empty upon quit?", 'emptyQuitItem));DefineGlobalConstant('kTrustCache,	LocObj("trust cache?", 'trustCacheItem));DefineGlobalConstant('kShowItemsOverview, LocObj("show items in overviews", 'showItemOverview));	// !!!kDefineGlobalConstant('kIgnoreExpiration, LocObj("Ignore Expiration", 'ignoreExpirationItem)); // !!!e//DefineGlobalConstant('kFollowURL,  	LocObj("open URL immediately?", 'openURLitem));		//DefineGlobalConstant('kKeepQueryResults, "keep query results?");DefineGlobalConstant('kStoreItem,  	LocObj("Store", 'storeItem));		// !!!g	DefineGlobalConstant('kDefaultItem,	LocObj("default", 'defaultItem));DefineGlobalConstant('kNoneItem,	LocObj("none", 'noneItem));DefineGlobalConstant('kStrPosAny, func (str, ARRAY astrs, INT start, minp, chOnly)begin // find minimum of a set of chars/strings	local pos, mpos, astr;	foreach astr in astrs	do if (pos := if kNIE and chOnly then CharPos(str,astr,start) else StrPos(str,astr,start))		then if minp			then (if (not mpos) or pos < mpos then mpos := pos)			else return pos;	mpos;end);constant kMaxPWChar  := 0x00FF;constant kHidePWChar := 0xFF00;// used in INPUT PASSWORD, protoNamePasswordDefineGlobalConstant('kEncodeFunc, func(txt, enc) // enc=true (encode), =nil (decode)begin	// return string (or nil if already all encoded)//if kDebugHTTP then Print("encoding(" & (if enc then "true" else "nil") & "):" && txt);	local INT i, char, slen := StrLen(txt);/*	local newtxt := Clone(txt);	for i := 0 to StrLen(newtxt)-1	do begin		char := ORD(newtxt[i]);		newtxt[i] := CHR(if enc then BOR(kHidePWChar,char) else BAND(kMaxPWChar,char));		end;*/	if slen=0	then return if enc then nil else txt;	local newchar, newtxt := if not enc then Clone(txt);	for i := 0 to slen-1	do begin		char := ORD(txt[i]);		newchar :=			if enc			then begin				if char <= kMaxPWChar				then begin					if not newtxt					then newtxt := txt;	// overwrite directly (not readonly!)					BOR(kHidePWChar, char);					end;				end			else BAND(kMaxPWChar,char);	// assume encoded (so always decode)		if newchar		then newtxt[i] := CHR(newchar);		end;	newtxt;end);DefineGlobalConstant('kImgAnim, [ // sharable (via bookTemplate). see :addBlock'viewIdleScript,func() if (kBuild1x or call kViewIsOpenFunc with (self)) and not stoppedthen begin	local ARRAY pics := item.data.pics;	local view := self.scrolledView, views;	if kBuild1x and not view and		Length(views := :childViewFrames()) > 0	then view := views[Length(views)-1].scrolledView;	if not view	then view := self;	SetValue(view, 'icon, pics[ipics]);	//RefreshViews();	local delay := item.data.delays[ipics];	if (ipics := ipics+1) >= Length(pics)	then begin		ipics := 0;		if loops and (loops := loops-1) <= 0		then delay := nil;		end;	if delay and kBuild20	then begin		AddDelayedSend(self, 'viewIdleScript, nil, delay);		nil;	// in case invoked via :setupIdle		end	else delay;end,'viewSetupFormScript,func()beginif item.data.picsthen begin	self.loops := item.data.loops; // number of times to repeat	local INT delay := item.data.delays[self.ipics := 0];	self.icon := item.data.pics[0];	self.stopped := NIL;	if kBuild20	then AddDelayedSend(self, 'viewIdleScript, nil, delay)	else :setupIdle(delay);	end;inherited:?viewSetupFormScript();end,]);DefineGlobalConstant('kColorTable16,SetLength(SetClass("\uF000F000F000F000E000E000E000E000D000D000D000D000C000C000C000C000B000B000B000B000A000A000A000A0009000900090009000800080008000800070007000700070006000600060006000500050005000500040004000400040003000300030003000200020002000200010001000100010000000000000000000",'grayPattern), 128));DefineGlobalConstant('kColorTable4,SetLength(SetClass("\uF000F000F000F000A000A000A000A00050005000500050000000000000000000",'grayPattern), 32));// after MakeBitmap or ScaleShapeDefineGlobalConstant('kFixBitmap, func(obj, bnds, bpp)	// tagDict.IMG, convertImageif isInstance(obj, 'bitmap)then begin	if not bnds	then bnds := ShapeBounds(obj);	if not bpp	then bpp :=			if kBuild20 and obj.colordata			then obj.colordata.bitdepth			else 1;	local bits := obj.data;	if kBuild20 and not bits and obj.colordata	then bits := obj.colordata.cbits;	if bpp=1	then {		bounds: bnds,		bits: bits,		}	else if kBuild20	then {						// gray scale for 2.1		bounds: bnds,		colordata: {			cbits: bits,			bitdepth: bpp,			colortable: if bpp=4 then kColorTable16 else kColorTable4,	// so printing will work?			},		};	endelse obj	//PICT?);DefineGlobalConstant('kScaleBounds, func(bounds, scale)	// tagDict.IMG (anim, AREA)SetBounds(	RIntToL(bounds.left * scale),	RIntToL(bounds.top * scale), 	RIntToL(bounds.right * scale), 	RIntToL(bounds.bottom * scale)	));/*DefineGlobalConstant('kHideKbdButton, func() // viewSetupFormScript for kbdButton, protoNamePasswordbegin	if kNIE and KeyboardConnected()	then viewFlags := 0;	inherited:?viewSetupFormScript();end);*/DefineGlobalConstant('kHelpBookData, func()	if bookRef exists	then bookRef.data);//constant kNewUIObjs			:= 9;	// # new interface items. URLtri, commandTri, ncGoButton, statusPara, statusGauge, errorPara, stopButton, hideButton, quitButtonconstant kURLlines			:= 3;	// # of URL lines to expand toconstant kLineSpacing		:= 13;	// for URLpara, statusParaconstant kTBmargin			:= 4;	// top/bottom marginconstant kmidmargin			:= 5;	// margin between "lines"constant kNewUIinsetR		:= 18;	// space for book close boxconstant kNewUIbuttonHeight := 13;constant kNewUIbuttonTop	:= kTBmargin + kLineSpacing + kmidmargin;constant kNewUIbuttonTopL	:= kTBmargin + (kLineSpacing*kURLlines) + kmidmargin;constant kNewUIstatusTop	:= kNewUIbuttonTop  + kNewUIbuttonHeight + kmidmargin;constant kNewUIstatusTopL	:= kNewUIbuttonTopL + kNewUIbuttonHeight + kmidmargin;constant kNewUIerrorTop		:= kNewUIstatusTop  + kLineSpacing;constant kNewUIerrorTopL	:= kNewUIstatusTopL + kLineSpacing;constant kTriMargin := 13;		// start of URLpara, infoButton/*4	margin(drag dot)13	URLpara(13	2nd&3rd lines)5	spacing13	buttons5	spacing(13	statusPara)4	margin*/DefineGlobalConstant('kShiftButton, func() // viewSetupFormScript for infoButton, fileButton, etc. assumes sibling h justifbegin	viewBounds :=		if kNIE and not nos21 and GetAppParams().AppAreaWidth <= kAppWidth	// 2.0 portrait		then OffsetRect(_proto.viewBounds,-2,0);		else Clone(_proto.viewBounds);	viewBounds.top :=  if prefsEntry.showLongURL then kNewUIbuttonTopL else kNewUIbuttonTop;	viewBounds.bottom := viewBounds.top + kNewUIbuttonHeight;	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym	then self.viewFont := labelFontJ;	if childSym exists	then :parent().(childSym) := self;//Write(self.text && "button: "); Print(viewBounds);	inherited:?viewSetupFormScript();end);// unusedDefineGlobalConstant('kShiftOptionsButton, func() // viewSetupFormScript for optionsButtonbegin // like kShiftbutton, but if on 2.0 in portrait mode, omit	// moved kEncodingOption to buttonClickScript	viewBounds := Clone(_proto.viewBounds);	if kNIE and not nos21 and GetAppParams().AppAreaWidth <= kAppWidth	// 2.0 portrait	then viewBounds.right := 0;	viewBounds.top :=  if prefsEntry.showLongURL then kNewUIbuttonTopL else kNewUIbuttonTop;	viewBounds.bottom := viewBounds.top + kNewUIbuttonHeight;//Write(self.text && "button: "); Print(viewBounds);	if kNCfont and prefsEntry.systemFontFamily <> kSystemFontSym	then viewFont := labelFontJ;	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kTriButton, {	// a toggling triangleviewClass: clView,viewFlags: vClickable + vVisible + vClipping,opened: nil,//viewBounds: 10x10//prefSym:	closedTri:	[0,0, 8,4, 0,8, 0,0],	// can't create polygon itself at build time?openTri:	[0,0, 8,0, 4,8, 0,0],viewDrawScript: func()	:DrawShape(		MakePolygon(if opened			then openTri			else closedTri),		{transferMode: modeCopy,		penSize: 1,		fillPattern: if opened then vfWhite else vfBlack,		}),viewClickScript: func(unit)	begin	// toggle. redisplay, open/close sound		:setPreference(prefSym, opened := not opened);	// !!!k		/*if kNIE		then AddDeferredSend(self, 'setPreference, [prefSym, opened := not opened])		else AddDeferredAction(Functions.Perform, [self, 'setPreference, [prefSym, opened := not opened]]);		*/		PlaySound(if opened then ROM_draweropen else ROM_drawerclose);		:Dirty();	// redraw immed? returns TRUE	end,viewSetupFormScript: func()	self.opened	:= prefsEntry.(prefSym),});DefineGlobalConstant('kShowNCButton, { // a tiny NC button for book bar_proto: protoPictureButton,viewBounds: RelBounds(0,0,16,16),buttonClickScript: func()				// shared with hideButton, _NewtsCape(kbd)	GetRoot().(kAppSymbol):?open(),	/*begin		local newtscape := GetRoot().(kAppSymbol);		if call kViewIsOpenFunc with (newtscape) then newtscape:hide();		newtscape:open();	end,*///icon -- set in afterScript//icon: call kGetResource with ("NC book 13x13"),});DefineGlobalConstant('kScanAttribute, func(line, attrib)	// used in scanImages, scanLinks, scanFrames, scanFixFrame, kGetBaseif linethen begin	local INT stop := StrLen(line);	local i, pos1, pos2, ch;	// looks for ...  attrib= "........"     >	//				  ^       ^        ^     ^	if not i := StrPos(line, attrib, 0)	// !!!g,f. assume immed = suffix (otherwise, heALThcare)	then return NIL;	// look for first char of value	for i := i+StrLen(attrib) to stop-1	// !!!g	do  if (ch := line[i]) = $" or ch = $'		// find next " or '		then begin			pos1 := (pos2 := i) + 1;			while (pos2 := CharPos(line, ch, pos2+1))				and line[pos2-1] = $\\	// !!!g. quoted quote?			do nil;			break if not pos2 then pos2 := stop;			end					else if not isWhiteSpace(ch) // and ch <> $=		then break pos1 := i;	// pos2 is nil	if pos1	then begin		if not pos2		then for i := pos1+1 to (pos2 := stop)-1	// break on next whitespace		 	 do if isWhiteSpace(line[i])				then break pos2 := i;		if pos1 < pos2		then TrimString(SubstituteChars(SubStr(line,pos1,pos2-pos1), "\n\t", "  ")); // kMyTrim		// else NIL;		end;	end);DefineGlobalConstant('kHideNewtsCape, func()begin	local root := GetRoot(), newtscape := root.(kAppSymbol);	if Visible(newtscape)	then begin		if kNIE and not newtscape.hideObj	// !!!g		then newtscape.hideObj := root.notifyIcon:?AddAction(			kAppNameL, kShowNCButton.buttonClickScript, nil); //func() GetRoot().(kAppSymbol):open()		SetKeyView(nil, 0);	// !!!f		newtscape:hide();		end;end);DefineGlobalConstant('kFixMenuItem, func(str, pick)if pick then str else $( & str & $)	// {item: $( & str & $), pickable: NIL});constant kLogicKbdSym := '|TLK:LogicTools|;DefineGlobalConstant('kBounds0, SetBounds(0,0,0,0));DefineGlobalConstant('kPopupCancelScript, func()	// !!!bbegin	popup := NIL;	inherited:?pickCancelledScript();end);DefineGlobalConstant('kProcessNextCallback, func(options)	// overview:Process, FRAMESETbegin	local newtscape := GetRoot().(kAppSymbol), msg := "", sel := options.processParams[0], len := Length(sel);	if len > 0	then begin		local href := sel[0], entry := EntryFromObj(href);	// !!!f//Print(sel);Print(href);Print(entry);		if entry		then href := entry.URL	// cache		else entry := href;		// bookmark		msg := options.processMsg & $[ & len & "]:" && href;		ArrayRemoveCount(sel,0,1);		AddDelayedSend(newtscape, if IsFrame(entry) then 'dispatchEntry else 'getURL, [entry, options], kDelay);	// !!!f		end;	newtscape:setStatus(msg);end);constant kFixedFrame := "<!--FIXEDFRAME-->";DefineGlobalConstant('kMakeSeparatorItem, func(str, pick)	// !!!jbegin	local item := {item: "--" & (if str then str else GetFolderStr(nil)) & "--"};	// !!!a1	if not pick	then item.pickable := NIL;	item;end);DefineGlobalConstant('kGetStoresList, func(val)	// !!!j. was in protoCachePicker, now shared by bookmarkPickerbegin	local store, name;	local INT pos := 0;	local ARRAY cmds := [{item: kDefaultItem}, 'pickSeparator];	// default.value = nil	foreach store in GetStores()	do begin		AddArraySlot(cmds, {item: name := store:GetName(), value: name});		if val and StrEqual(val, name)		then pos := Length(cmds)-1;		end;	cmds[pos].mark := kCheckMarkChar;	cmds;end);constant kStopError := 'stopButtonNC;	// !!!kDefineGlobalConstant('kCollectList, func(str, ch)	// !!!tbegin	local result := [], fn := StrTokenize(str, ch), val;	while val := call fn with ()	do  if StrFilled(TrimString(val))		then AddArraySlot(result, val);	result;end);// "item" is search arg, array element is aitem. used by :getRun, :scanLinksDefineGlobalConstant('kStrContains, func(item, aitem) // !!!f. test-fn for LSearch/ArrayPosif kNIEthen isInteger(StrPos(item, aitem, 0))	// !!!u,m. result must be 0 or true for matchelse StrPos(item, aitem, 0)				// !!!m (ArrayPos doesn't reverse));/*DefineGlobalConstant('kScanURL, func(url1, url2)	// !!!wif IsString(url2)then if IsString(url1)	// common case	then StrEqual(url1,url2)	else begin		if isEntryAlias(url1)		then url1 := EntryFromObj(url1).URL		else if isArray(url1)		then url1 := url1[0]		else if isFrame(url1)		then url1 := url1.URL;		//if isEntryAlias(url2)		//then url2 := EntryFromObj(url2).URL		//else if isArray(url2)		//then url2 := url2[0]		//else if isFrame(url2)		//then url2 := url2.URL;		IsString(url1) and StrEqual(url1,url2);		end);DefineGlobalConstant('kLinkMatch, func(entry, url)	// !!!wStrEqual(url, if IsString(entry) then entry else entry[0]));*/// ===========/*xx := getroot():notify(knotifymessage, "Newt's Cape:Open", "");xx.viewSetupFormScript := func()begin //Print("viewSetupFormScript");	GetRoot().|NewtsCape:NewtsCape|:?open();	AddDeferredSend(base,'close,nil);end;xx.viewChildren := nil;xx.sound := nil;*//*hh := {_proto: protoPictureButton, icon: ROM_overviewBitmap, viewBounds: RelBounds(0,0,12,12),};bb := {_proto: protoPictureButton, icon: ROM_leftbitmap, viewBounds: RelBounds(0,0,10,12),};ff := {_proto: protoPictureButton, icon: ROM_rightbitmap, viewBounds: RelBounds(0,0,10,12),};dd := {_proto: protoPictureButton, viewBounds: RelBounds(0,0,10,0), viewFormat: 0, viewFlags: vVisible,};nn := {_proto: protoPictureButton, icon: GetRoot().|Newtscape:Newtscape|.icon, viewBounds: RelBounds(0,0,16,16),};getroot().copperfield:SetStatusBarButtons({left: [dd, hh], right: [ff,bb]});getroot().copperfield:SetStatusBarButtons({left: [dd, nn], right: [dd,dd]});DoProgress('vGauge, {statusText: "this is a status", titleText: "a title", gauge: 0},	func(progressView)	getroot().|ViewFrame:JRH|:newValue("setStatus", progressView.setStatus))functions.doprogress.literals[0].setstatus	// :eventpause(true) ??strhexdump(@624.icon.bits, 0)getglobals().|NewtsCape:NewtsCape|getroot().|NewtsCape:NewtsCape|.debugflag := breakonthrows := nil ;getroot().|NewtsCape:NewtsCape|.debugflag := true;getroot().|NewtsCape:NewtsCape|:geturl("http://lthmtek.msek.lth.se/~cim93hf4/avanti.html", nil)getroot().|NewtsCape:NewtsCape|:geturlcache("htmlcache:newtscape", "http://www.siebel.com/company/company.html", 'text, nil)getroot().|NewtsCape:NewtsCape|:dispatchfile("text/html", "foo.htm", "<HTML><HEAD><TITLE>test</TITLE></HEAD><BODY><FORM ACTION=\"foo\"><TABLE><TR><TD>some text<TD><TEXTAREA NAME=x>abc</TEXTAREA></TABLE></FORM></BODY></HTML>", nil)getroot().|NewtsCape:NewtsCape|.URLpara.textgetroot().|NewtsCape:NewtsCape|.curbook.contentsgetroot().|NewtsCape:NewtsCape|.curbook.contents[0].datagetroot().|NewtsCape:NewtsCape|.curbook.rendering[0].pages[0].blocksgetroot().|NewtsCape:NewtsCape|:collectURLs("htmlcache:newtscape", true, nil)getroot().copperfield.contentarea:childviewframes()getroot().copperfield:whereisbook("")getroot().copperfield:whereisbook("test2.htm").booksoup.book.datagetroot().copperfield.librarylength(getroot():childviewframes())length(getroot().copperfield:getOfflineBooks())length(getroot().copperfield:getOnlineBooks())call func(book)begin	local obj, href, newtscape := getroot().|NewtsCape:NewtsCape|, bhref := book.data.base_href;	foreach obj in book.contents	do if obj.hrefs		then begin//Print(obj.hrefs);			foreach href in if IsEntryAlias(obj.hrefs) then ResolveEntryAlias(obj.hrefs).data else obj.hrefs			do begin Print(href[0]); Print(newtscape:resolveURL(bhref, href[0])); end;			end;end with (getroot().|NewtsCape:NewtsCape|.curbook)call func(x)begin	local i,obj;	foreach obj in x	do Print(obj);end with (xxx)call func(n)begin local i, t := ticks();for i:=1 to ndo xxx;ticks() - t;end with (100);getviewdefs('copperfield)getdefs('viewdef,['copperfield],nil)getdatadefs('copperfield)getrouteformats({class: '|Data:NewtsCape:NewtsCape|})GetFormatTransports(	getrouteformats({class: '|Data:NewtsCape:NewtsCape|}),	getroot().|NewtsCape:NewtsCape|:gettargetinfo('routing).target)xx := getroot().extrasdrawer:GetPartCursor(nil, nil, '_all) xx:next()getroot().extrasDrawer:GetPartEntryData(xx:entry())*//*options stuffInit:NC.viewSetupDoneScript (nil)NC.getURL (options)NC.dispatchFile (options)NC.DoEvent (options)NC.connect (nil)NC.goToHref (nil)kSendHTTP (options/optionsAPI)NC.cachePicker (nil)NC.addIncludes (options)----fixOptions:NC.viewSetupFormScript (nil)NC.getOptionkSendMsgkGoToHREF----neitherNC.addFileNC.startHTMLkSendMsg called by: kGoToHref, kSendHTTP, kPostDatakPostData called by :getURL, kPostMailkPostMail called by "SUBMIT"kSendHTTPkGoToHref called by :getURL, :gotoHREF, kGoToHREFclickShare:goToHref called by kGoToHREFclickShare, "RADIO/CHECKBOX/TEXT"http://bigweb.misty.com/weyer/newton/graphics/HELLOSMALL.JPGKillStdButtonBar(Array(4, '{buttonBarPosition: none}));KillStdButtonBar(nil);// continue to HTTP Project Data// for debugging serialxx := {	_parent: getroot().|NewtsCape:NewtsCape|,	_proto: getroot().|NewtsCape:NewtsCape|.protoSerialProtocol,	setInputSpec: func(x) Print("setInputSpec"),	};xx.commEndPt := xx;call func(ep,str)begin	local pos, spos := 0;	while (pos := CharPos(str,unicodeCR,spos))	do begin		ep:InputLine(SubStr(str,spos,pos-spos));		spos := pos+1;		end;end with (xx,"findlocale("http:NewtsCape")getglobals().|NewtsCape:NewtsCape|.|foo.htm|.|1_saveMap|getroot().|NewtsCape:NewtsCape|.curbook.datagetroot().|NewtsCape:NewtsCape|.curbook.rendering[0].pages[1].blocksgetroot().copperfield.contentarea:childviewframes()[2]printlength:= 100;breakonthrows := nilgetroot():childviewframes()getroot().|NewtsCape:NewtsCape|:setpreference('includeFrames, "x")getroot().|NewtsCape:NewtsCape|:fixFrame("http://download.planetnewton.com/downindex.asp",getroot().|NewtsCape:NewtsCape|:dispatchfile("text/html", "foo.htm", "<HTML><HEAD><TITLE>test</TITLE></HEAD><BODY></BODY></HTML>", nil)getroot().|NewtsCape:NewtsCape|.wwwfsmgetroot().|NewtsCape:NewtsCape|:resetfsm()getroot().|NewtsCape:NewtsCape|.tempoverview.overview.selectedcall func(href)GetUnionSoupAlways("HTMLCache:NewtsCape"):Query({	indexPath: 'URL, 	// for l-o-n-g strings	beginKey: href,	endKey: href,	validTest: func(entry)		StrEqual(entry.url,href),	}):entry()with ("http://members.bellatlantic.net/~sweyer/testx.htm")getroot().|hemlock:seanl|GetRoot().|Hemlock:seanl|:APIDoSimpleSearch("Newton");qq := GetRoot().|Hemlock:seanl|:APISearchEngineCursor();ee := qq:entry(); nilGetRoot().|Hemlock:seanl|:APIDoSearch([ee], "Newtown")GetRoot().|Hemlock:seanl|:APIDoFullSearch([ee], "Newtown", {})pp := getroot().|NewtsCape:NewtsCape|.prefsEntry; [pp.prefName, pp.tag, pp.curPrefTag, pp.prefNames]call func(old, cur)begin	local cur := clone(cur), slot,val;	foreach slot,val in old	do removeslot(cur,slot);	cur;end with (gg, GetGlobals())end with (rr, GetRoot())call func(old, cur)begin	local slot,val;	foreach slot,val in old	do if val <> GetVariable(cur,slot)	then Print(slot);end with (gg, GetGlobals())end with (rr, GetRoot())xx := {closeBox: nil,icon: getroot().|NewtsCape:NewtsCape|.icon, statusText: "Loading Links",gauge: 1000,titleText: "<A",};doprogress('vgauge, xx,func(contextView)beginlocal x; for x:=1 to 100do begin xx.gauge := x; contextView:SetStatus('vGauge, xx); end;Print("done?"); end)gc(); stats(); [length(getglobals()), length(getroot()), length(getroot():childviewframes())]gg := clone(getglobals()); rr := clone(getroot()); nilgetroot().|ViewFrame:JRH|:newValue("x", protoActionButton)getroot().|NewtsCape:NewtsCape|.curbook*/