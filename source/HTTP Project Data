// HTTP Project Data// continued from Project Data (for Newt's Cape)// these are constants primarily used for NIE, in HTTP FSM (and sometimes elsewhere also)// if they're needed in Project Data (for definition order),// they might be defined here also for standalone useif kNIEthen begin	DeclareGlobalFn('InetOpenConnectionSlip, 3);	DeclareGlobalFn('InetDisplayStatus, 3);	DeclareGlobalFn('InetGrabLink, 3);			// deprecated	DeclareGlobalFn('InetReleaseLink, 3);		// deprecated	DeclareGlobalFn('InetCancelLink, 3);	DeclareGlobalFn('InetGetLinkStatus,1);	DeclareGlobalFn('DNSGetAddressFromName, 3);	DeclareGlobalFn('DNSCancelRequests, 2);	DeclareGlobalFn('InetGetErrorString, 1);	DeclareGlobalFn('InetSetDefaultLinkID, 1);	DeclareGlobalFn('InetGetAllLinksStatus, 0);	DeclareGlobalFn('InetGetDefaultLinkID, 0);	// NIE 2.0	DeclareGlobalFn('InetGrabLinkVerbose, 3);	DeclareGlobalFn('InetReleaseLinkVerbose, 3);	DeclareGlobalFn('InetIPAddressToString, 1);	DeclareGlobalFn('RegInetLinkStatusChange, 3);	DeclareGlobalFn('UnRegInetLinkStatusChange, 1);	DeclareGlobalFn('InetIsValidIPAddressStr, 1);	DeclareGlobalFn('InetIPStringToAddress, 1);	// Event codes used by system	constant kEventToolSpecific	:= 1;	constant kEventDisconnect	:= 2;	constant kEventRelease		:= 3;	end;constant kHTTPver	:= "HTTP/1.0";	// for outgoingconstant kHTTPStr	:= "HTTP";		// for incomingDefineGlobalConstant('kHTTPSym, 'HTTP);// some http Header fieldsconstant kContentType 	:= "Content-Type";DefineGlobalConstant('kContentTypeSym0, Intern(kContentType & $0));	// originalconstant kContentLength := "Content-Length";DefineGlobalConstant('kContentLengthSym, Intern(kContentLength));constant kContentBase := "Content-Base";DefineGlobalConstant('kContentBaseSym, Intern(kContentBase));constant kDate			:= "Date";DefineGlobalConstant('kDateSym, Intern(kDate));constant kLastModified	:= "Last-modified";DefineGlobalConstant('kLastModifiedSym, Intern(kLastModified));constant kAuthorization := "Authorization";//DefineGlobalConstant('kAuthorizationSym, Intern(kAuthorization));constant kAuthenticate	:= "WWW-authenticate";//DefineGlobalConstant('kAuthenticateSym, Intern(kAuthenticate));constant kProxyAuthenticate		:= "Proxy-Authenticate";constant kProxyAuthorization	:= "Proxy-Authorization";//DefineGlobalConstant('kProxyAuthorizationSym, Intern(kProxyAuthorization));constant kSetCookie		:= "Set-Cookie";DefineGlobalConstant('kSetCookieSym, Intern(kSetCookie));DefineGlobalConstant('kLocationSym, Intern(kLocation));constant kServer		:= "Server";DefineGlobalConstant('kServerSym, Intern(kServer));constant kExpires		:= "Expires";DefineGlobalConstant('kExpiresSym, Intern(kExpires));constant kAccept		:= "Accept";//DefineGlobalConstant('kAcceptSym,	Intern(kAccept));constant kAcceptLang	:= "Accept-Language";	// !!!v//DefineGlobalConstant('kAcceptLangSym,	Intern(kAcceptLang));constant kAcceptEncoding:= "Accept-Encoding";	// !!!f// for sending onlyconstant kSendCookie	:= "Cookie";constant kIfModified	:= "If-Modified-Since";constant kUserAgent		:= "User-Agent";constant kBasic			:= "Basic";		// for authorizationconstant kReferrer 		:= "Referer";	// (sic)DefineGlobalConstant('kReferrerSym,	Intern(kReferrer));// note: serial works for text xfer; how to do binary xfer (w/o xon/xoff)?// to use serial, comment this out. add fsm.fSerial. edit newURL:actionconstant fSerial := NIL;	// leave out for now?constant kTextXferSize	 :=  2000;	// for reading text files partially (check discardAfter)constant kBinaryXferSize :=  2000;	// for reading binary files partiallyconstant kCleanupDelay   :=  1000;	// for NIE cleanup before dispatch?constant kMaxLineSize	 := 36000;	// !!!b1//DefineGlobalConstant('kHemlockDelay, 6 * kCleanupDelay);DefineGlobalConstant('kDoNextState, 	func() :?DoEvent(nextState, nil));DefineGlobalConstant('kErrDoNextState, func(error)beginif kDebugOn then :?MNotifyError(NotifyMsg, error);	// !!!i	error := NotifyMsg &&		if IsNumber(error) and GetGlobalFn('InetGetErrorString)	// NIE 1.1		then InetGetErrorString(error)		else error;	if not fHTTPoptions.error	// !!!k	then fHTTPoptions.error := error;	//:callBackError(error, fHTTPoptions);	// !!!j,h	if nextState	then :?DoEvent(nextState, nil); // for CancelLinkend);DefineGlobalConstant('kDoCancelAbort,	func() fAbort := true);DefineGlobalConstant('kCompletionSpec, { // _proto this. add failEvent, succEvent slots.	async: 		true,	reqTimeout: 0, //kNoTimeout,	failEvent: 	'failEvent, // override this!	succEvent: 	'succEvent, // override this!	completionScript: func(ep, options, result)		if result		then ep:DoEvent(failEvent, [result])		else ep:DoEvent(succEvent, nil),	});DefineGlobalConstant('kDoCancelEP, func()begin	fAbort := true;	try		fEndPoint:?Cancel(nil);	onexception |evt.ex.comm| do	nil;	// Send HTTP:Cancel state would need Disconnectend);DefineGlobalConstant('kByteBeginsWith, func(bytes, str, INT start) // for checking GIF, packagebegin	local INT i, slen := StrLen(str);	if start+slen > Length(bytes)	then return NIL;	for i := 0 to slen-1	do if ExtractChar(bytes, start+i) <> str[i]		then return NIL;	TRUE;end);DefineGlobalConstant('kBytePos, func(bytes, str, INT start) 	// like StrPos for finding "...package"begin	local INT i, slen := StrLen(str);	//if slen=0	//then return start;	if start+slen > Length(bytes)	then return NIL;	local ch0 := str[0];	for i := start to Length(bytes)-slen-1	do  if ExtractChar(bytes, i) = ch0 and call kByteBeginsWith with (bytes,str,i)		then return i;	NIL;end);constant base64Chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";	// the mapDefineGlobalConstant('kEncodeBase64, func (str) //NATIVE? encode from string to BASE64. used in authenticateButton (decoder in vCalCard)begin	local INT code, savecode, bits, usedbits := 0, i, rlen := 0;	local result := str&str; 			// longer than nec, but shorten at end	for i:=0 to StrLen(str)-1	do begin		code := Ord(str[i]); // kOrd. another 8 bits (7?, 16?)		// for each char, map 6 bits via base64Chars, shift remainder		if usedbits = 0		then begin // save 6 bits, keep 2			savecode := code >> 2;			bits 	 := BAND(code, 0x3) << 4;			usedbits := 2;			end		else if usedbits = 2		then begin // save 2+4 bits, keep 4			savecode := BOR(bits, code >> 4);			bits 	 := BAND(code, 0xF) << 2;			usedbits := 4;			end		else //if usedbits = 4 then			begin // save 4+2 bits, save 6, keep 0			savecode := BOR(bits, code >> 6);			result[rlen] := base64Chars[savecode];			rlen := rlen+1;			savecode := BAND(code, 0x3F);			usedbits := 0;			end;		result[rlen] := base64Chars[savecode];		rlen := rlen+1;		end;	if usedbits > 0 // any remaining bits?	then begin		result[rlen] := base64Chars[bits];		rlen := rlen+1;		end;	StrMunger(result,rlen,nil, "===",0,rlen mod 4); // shorten, add paddingend);DefineGlobalConstant('kDecodeBase64, func (str)begin	local INT bit6, bits, usedbits := 0, dpos := 0, i, slen := StrLen(str);	local chmap, savebyte, char;	local data := MakeBinary(slen*2, 'string); //GetDefaultStore():NewCompressedVBO('binary, slen*3 div 4, kTextCompander, nil);	for i:=0 to slen-1	do begin		char := str[i];		if char = $=		then break;		if chmap := CharPos(base64Chars,char,0)	// see vCalCard for faster ~3x NATIVE version?		then begin			bit6 := chmap;			if usedbits = 0			then begin //  +0 [6] start a byte (6 leftover)				savebyte := nil;				bits 	 := bit6 << 2;				usedbits := 6;				end			else if usedbits = 2			then begin // 2+6 [0]	complete a byte, no leftover				savebyte := BOR(bits, bit6);				bits 	 := usedbits := 0;				end			else if usedbits = 4			then begin // 4+4 [2]	complete a byte, 2 leftover				savebyte := BOR(bits, bit6 >> 2);				bits 	 := BAND(bit6, 3) << 6;				usedbits := 2;				end			else // if usedbits = 6 then				begin // 6+2 [4]	complete a byte, 4 leftover				savebyte := BOR(bits, bit6 >> 4);				bits 	 := BAND(bit6, 0xF) << 4;				usedbits := 4;				end;			if savebyte			then begin				StuffUniChar(data, dpos, savebyte);				dpos := dpos+2;				end;			end;		end;	//Print(usedbits);	StrMunger(data,dpos div 2,nil, nil,0,nil); // shorten, return data stringend);// to read/print http format dates (Wdy, DD-Mon-YYYY HH:MM:SS GMT),// efficiently and especially on non-US systemsDefineGlobalConstant('kHTTPtimeSpec,GetDateStringSpec([	[kElementHour,		kFormatNumeric],	[kElementMinute, 	kFormatNumeric],	[kElementSecond, 	kFormatNumeric],	[kElementSuffix, 	kFormatLong],	]));if kDebugHTTP then Print("http time spec:" && kHTTPtimeSpec);	// 10922701DefineGlobalConstant('kHTTPdateSpec,GetDateStringSpec([	// reversed for longDateOrder?	[kElementYear,		kFormatNumeric],	[kElementMonth, 	kFormatAbbr],	[kElementDay, 		kFormatNumeric],	[kElementDayOfWeek, kFormatAbbr],	]));if kDebugHTTP then Print("http date spec:" && kHTTPdateSpec);	// 11614802DefineGlobalConstant('kHTTPlocaleName, "http:" & kAppNameS);DefineGlobalConstant('kHTTPlocale, {_proto: 	nil,	//currentLocale -- see installScript// override/ensure minimum stufftitle: 		kHTTPlocaleName, localeSym: 	kAppSymbol,	// kHTTPlocaleSymlongDateFormat: {	_proto: 		nil, //currentLocale.longDateFormat,	abbrDofWeek: 	["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], 	abbrMonth: 		["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], 	longDateDelim:	["", ", ", " ", " ", ""],	longDateOrder: 	kHTTPdateSpec,	dayLeadingZ: 	kLeadZero, 	},timeFormat: {	_proto:			nil, //currentLocale.timeFormat,	timeSepStr1: 	":",	timeSepStr2: 	":",	//morningStr:	"",	//eveningStr:	"",	suffixStr: 		" GMT",	hourLeadingZ: 	kLeadZero,	minuteLeadingZ: kLeadZero,	secondLeadingZ: kLeadZero,	timeCycle: 		kCycle24,	midNightForm: 	kUseHour24,	//noonForm: 	kUseHour12,	},  });// LongDateStr(Time(), ROM_dateTimeStrSpecs.abbrDateStrSpec)// LongDateStr(Time(), 11614802); //kHTTPdateSpec// Timestr(Time() , ROM_dateTimeStrSpecs.longTimeStrSpec)// Timestr(Time() , 10922701); 	  //kHTTPtimeSpecDefineGlobalConstant('kAdjMin, func()	// used by kPrintDate, kReadDatebegin	local gmtSecs := GetUserConfig('location).gmt;	local dstSecs := GetUserConfig('daylightSavings);	((if gmtSecs then gmtSecs else 0) + (if dstSecs then dstSecs else 0)) div 60;end);DefineGlobalConstant('kPrintDate, func(tt)if ttthen begin // return this format: Sun, 06 Nov 1994 08:49:37 GMT	tt := tt - call kAdjMin with ();	// adjust for time zone, dst	// set "http" locale temporarily	local oldLocaleSym := GetLocale().localeSym, str;	SetLocale(kAppSymbol);	try		// nothing should go wrong, but in case it does...		str := LongDateStr(tt, kHTTPdateSpec) && TimeStr(tt, kHTTPtimeSpec)	onexception |evt.ex| do nil;	SetLocale(oldLocaleSym);	str;end);DefineGlobalConstant('kReadDate, func(str)begin // generally: Wdy, DD-Mon-YYYY HH:MM:SS GMT/*Sun, 06 Nov 1994 08:49:37 GMT	// RFC 822 (http://ds.internic.net/rfc/rfc822.txt)								//	updated by RFC 1123 (http://ds1.internic.net/rfc/rfc1123.txt)Sunday, 06-Nov-94 08:49:37 GMT	// RFC 850 (http://ds.internic.net/rfc/rfc850.txt),								//	obsoleted by RFC 1036 (http://www.w3.org/hypertext/WWW/Protocols/rfc1036/rfc1036.html#z6)Sun Nov 6 08:49:37 1994			// ANSI C's asctime() format*/	local spos, cpos1, cpos2;	// cascade test	if  (spos  := CharPos(str, $ , 0)) and		// skip day of week		(cpos1 := CharPos(str, $:, spos)) and		(cpos2 := CharPos(str, $:, cpos1+1))	then begin//if kDebugHTTP then Print("readDate orig:" && str);		local dstr := SubStr(str, spos, cpos2-spos), totMin;// omit secs & GMT		if not EndsWith(str, "GMT")							// not 1&2 -- i.e., 3 (ANSI C)		then StrMunger(dstr, cpos1-3-spos, 0, str, StrLen(str)-5, 5); // insert year before time		// set "http" locale temporarily		local oldLocaleSym := GetLocale().localeSym;		SetLocale(kAppSymbol);		try	begin		// nothing should go wrong, but in case it does...			if totMin := StringToDate(dstr)			then totMin := totMin + 1 + call kAdjMin with ();	// always adjust (even for 3)			end		onexception |evt.ex| do return 0;		SetLocale(oldLocaleSym);//if kDebugHTTP then Print("readDate conv:" && call kPrintDate with (totMin));		totMin;		end	else 0;end);DefineGlobalConstant('kGetCookies, func(cookies, host, file, pref)	// used in Genesis:newURL, :quitif isArray(cookies) // assume sorted by [domain,path]then begin	local INT i, now := Time(), len := Length(cookies);	local ARRAY cookie;	local str;	// reverse order for remove, and more specific first	for i := len-1 to 0 by -1	// [[domain, path, expire, name, val],...]	do begin		cookie := cookies[i];		if (if cookie[2] then cookie[2] <= now else not host)		then ArrayRemoveCount(cookies, i, 1) // expired -- remove		else if host and EndsWith(host, cookie[0]) and BeginsWith(file, cookie[1])		then str := str & (if str then "; ") & cookie[3] & $= & cookie[4]; // !!!o		end;	if pref and len <> Length(cookies)	then GetRoot().(kAppSymbol):?setPreference('cookies,cookies);	str;	end);/*Set-Cookie: CCB=1; path=/;expires=Wednesday, 09-Nov-99 23:12:40 GMT; domain=.elibrary.comSet-Cookie: id=0; path=/;expires=Wednesday, 09-Nov-99 23:12:40 GMT; domain=.elibrary.comSet-Cookie: CUSTOMER=WILE_E_COYOTE; path=/; expires=Wednesday, 09-Nov-99 23:12:40 GMTSet-Cookie: PART_NUMBER=ROCKET_LAUNCHER_0001; path=/Set-Cookie: SHIPPING=FEDEX; path=/fooSet-Cookie: PART_NUMBER=RIDING_ROCKET_0023; path=/ammoSet-Cookie: Count=1; expires=Wednesday, 09-Nov-1999 23:12:40 GMT; path=/; domain=.illuminatus.comSet-cookie: Name=Fred; expires=Wednesday, 01-Jan-97 12:00:00 GMTSet-cookie: Color=Red; expires=Wednesday, 01-Jan-97 12:00:00 GMT*/DefineGlobalConstant('kMakeAttrib, func(name,val)if valthen name & $: && val & crlf);// renamed from kPutCookie. vals an array of strings (was just val)DefineGlobalConstant('kPutCookies, func(args)	// used in fInputHeaderScriptif argsthen begin	// args = [cookies, host, vals, pref]	local cookies := args[0];	local host 	  := args[1];		local cpos, val, cval, name, attrib;//Print("before"); Print(cookies);	local ARRAY cookie;	foreach val in args[2]	// vals	do begin		cookie := [host, "/", nil, nil, nil];	// defaults		cpos := 0;		while cpos and attrib := call kGetAttrib with (val, $=, $;, cpos)		do begin			name := attrib[0];			cval := attrib[1];			cpos := attrib[2];			if StrEqual(name, "domain")			then cookie[0] := cval			else if StrEqual(name, "path")			then cookie[1] := cval			else if StrEqual(name, "expires")			then cookie[2] := call kReadDate with (cval)			else if StrEqual(name, "Max-Age")	// HTTP/1.1			then cookie[2] := Time() + ((call kGetInt with (cval,1)+59) div 60) // !!!a. round up secs to next minute			//else if not StrEqual(name, "secure") then // ignore 1.1 Version=, Comment=			else begin				cookie[3] := name;				cookie[4] := cval;				end;			end;		cval := BInsert(cookies, cookie,				func(ARRAY a, ARRAY b)				begin					local INT sc0 := StrCompare(a[0],b[0]), sc1;					if sc0=0					then if (sc1 := StrCompare(a[1],b[1])) = 0						then StrCompare(a[3],b[3])						else sc1					else sc0;				end, nil, 'returnElt);		if cval <> cookie		then begin	// replace expires,value in existing entry			cval[2] := cookie[2];			cval[4] := cookie[4];			end;		end;	if args[3] // pref	then GetRoot().(kAppSymbol):?setPreference('cookies,cookies);//Print("after"); Print(cookies);	cookies;end);DefineGlobalConstant('kRemoveComments, func(str)begin	local cpos1 := 0, cpos2, nextFlush := if isVBO(str) then kVBOFlush; // !!!b	while (cpos1 := StrPos(str, kCommentStart, cpos1)) and		  (cpos2 := StrPos(str, kCommentStop,  cpos1+4))	do begin		StrMunger(str, cpos1, cpos2-cpos1+3, nil, 0, nil);		if nextFlush and (cpos1 * 2) > nextFlush		then begin			ClearVBOCache(str);			nextFlush := nextFlush + kVBOFlush;			end;		end;	//cpos1;	// for parserend);constant kNewtonPkgMediaType 	:= "application/x-newton-compatible-pkg";//constant kAppOctetMediaType	:= "application/octet-stream";constant kPKGextension			:= ".pkg";DefineGlobalConstant('kBuiltInMediaTypes, {});DefineGlobalConstant('kMediaAll, {});kMediaAll.(kAppSymbol) := {};kBuiltInMediaTypes.(Intern(kHTMLMediaType)) := kMediaAll;kBuiltInMediaTypes.(Intern(kGIFMediaType)) 	:= kMediaAll;DefineGlobalConstant('kMediaTextPkg, {});kMediaTextPkg.(kAppSymbol) := {extensions: [kPKGextension, ".*"]};kBuiltInMediaTypes.(Intern(kTextMediaType)) := kMediaTextPkg;DefineGlobalConstant('kMediaPkg, {});kMediaPkg.(kAppSymbol) := {extensions: [kPKGextension]};kBuiltInMediaTypes.(Intern(kNewtonPkgMediaType)):= kMediaPkg;kBuiltInMediaTypes.|application/*|				:= kMediaPkg;	// !!!u. (Intern(kAppOctetMediaType))kBuiltInMediaTypes.(Intern(kAllMediaType)) 		:= kMediaPkg;//constant kWWWunknownMediaType 					  := "www/unknown";	// e.g., palmzip ?//kBuiltInMediaTypes.(Intern(kWWWunknownMediaType)) := kMediaPkg;DefineGlobalConstant('kHead, "HEAD");/*allowable (1.1) methods:"OPTIONS"                ; Section 9.2"GET"                    ; Section 9.3"HEAD"                   ; Section 9.4"POST"                   ; Section 9.5"PUT"                    ; Section 9.6"DELETE"                 ; Section 9.7"TRACE"                  ; Section 9.8*/DefineGlobalConstant('kHeapMsg,	LocObj("out of heap/store?", 'noHeapStoreErr));DefineGlobalConstant('kFixOptions, func(fURLqueue, options)	// used by dispatchCache, textSuccess, BinarySuccessif fURLqueue and Length(fURLqueue) > 0then begin	options := Clone(options);	// use _proto?	options.cacheOnly := true;	options;	endelse options);DefineGlobalConstant('kResetHTTP, LocObj("Reset HTTP", 'resetHTTPlabel));// continue to Final Project Data (for Newt's Cape)