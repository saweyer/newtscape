// Final Project Data// continued from HTTP Project Data// includes Notes and Newtworks API// InstallScript and RemoveScriptDefineGlobalConstant('kOpenLabel, 	LocObj("Open", 'openItem)); // used only by outside apps (GetTitle, Kbd Summary)DefineGlobalConstant('kGetURLlabel, LocObj("getURL", 'getURLItem));DefineGlobalConstant('kFindlabel,	LocObj("Find", 'FindItem));DefineGlobalConstant('kOpenLabelE, 	if kNCfont then "Open"   else kOpenLabel);DefineGlobalConstant('kGetURLlabelE,if kNCfont then "getURL" else kGetURLlabel);DefineGlobalConstant('kFindlabelE,	if kNCfont then "Find"   else kFindlabel);// this handles both Notes and NewtWorks text selection/entries//constant kChecked := '["checked"];	// share//constant kElibraryURL := "http://www.elibrary.com/";DefineGlobalConstant('kAltaVistaFindFrame, {title: "AltaVista Text",	// !!!dURL:	"http://www.altavista.com//cgi-bin/query",method:	kGet,querySlot:		'q,data:	{	q:			"",			// set by kNewtsCapeDoItFunc (via querySlot)	//fmt:		"c",	text:		"yes",		// !!!d	pg: 		"q",	what:		"web",	},dataNames: [				// if case sensitive	"q","text","pg","what",	// !!!d	],dataSource: "[\"q\",\"\",\"text\",\"yes\",\"pg\",\"q\",\"what\",\"web\",],		// !!!d. \"fmt\",\"c\"]",});constant kDefaultCacheSize := 50; // used for default in NC:viewSetupDoneScript// at some point, add additional (> 2.0a) prefs; shorter 1.x version??DefineGlobalConstant('kPrefSetItem, 	LocObj("PrefSet", 'prefSetItem));	// !!!kDefineGlobalConstant('kDefaultPrefName, LocObj("Main PrefSet", 'mainPrefSetLabel));			// !!!kDefineGlobalConstant('kDefaultPrefs, { 					// commented out nil slots to save space	tag: 				kPackageName,//	agentPrefix:		nil, //if kDebugHTTP then "eMateEL",//	agentSizeRes:		nil,	allowCompile:		if not kNIE then 'compile,//	allowHosts:			nil,//	autoHide:			nil,//	autoLogin:			nil,	bitsPerPixel:		1,//	bookmarkLabel:		nil,	bookmarkSoupName:	kBookmarkSoupName,//	cacheDesktop:		nil,	cacheHTML:			kDefaultCacheSize,	cacheImages:		kDefaultCacheSize,//	compressedPkg:		nil,	convAnim:			nil,		// needed for version test	cookies:			[],	cookiesConfirm:		'ask,	curPrefTag:			kPackageName,	// !!!k//	docDoneSound:		nil,//	emptyHTML:			nil,//	emptyImages:		nil,	findFrame: 			if kNIE then kAltaVistaFindFrame else {},//	followHTML:			true,//	followImages:		true,	helpISBN:			kHelpISBN,	//hostADSP:			nil,//	httpNoProxy:		nil,//	httpProxy:			nil,//	ignoreTables:		nil,//	loadImages:			nil,	mailBody:			"hi,\nI saw this cool document in Newt's Cape.",	// !!!g//	noClose:			nil,//	noStatus:			nil,//overviewBookmarksOnly		pageSize:			if kNIE then 'full else 'portrait,	prefName:			kDefaultPrefName,	// !!!k	prefNames:			[kDefaultPrefName],	// !!!k//	rawImage: 			nil,	removeComments: 	true,//	scaleImage:			nil,	standAlone: 		true,//	startupURL:			nil,//systemFontFamily//systemFontSize	threshold:			128,	trustHTML:			true,	trustImages:		true,	//zoneADSP:			nil,	});if kNIE // kNCfontthen begin	kDefaultPrefs.systemFontFamily := kSystemFontSym;	kDefaultPrefs.systemFontSize := 9;	endelse begin	// !!!g	local sym;	foreach sym in '[		bookmarkSoupName, cacheHTML, cacheImages, cookies,		cookiesConfirm, findFrame, trustHTML, trustImages ]	do RemoveSlot(kDefaultPrefs, sym);	end;DefineGlobalConstant('kNewtsCapeDoItFunc, func(data) // called by kNotesRouteScript, kNewtworksDoItFuncbegin	local url := "", options, source, newtscape := GetRoot().(kNewtsCapeSymbol);	if call kViewIsOpenFunc with (newtscape)	then begin newtscape:hide(); newtscape:show(); end	else newtscape:open();		// :init???	if not StrFilled(data)	then return;	if call kIsHTML with (data)		// !!!j. StrPos(data, kHTMLStart, 0)	then begin		source := data;										// text = source <<<<<		options := {loadImages: nil};		end	else if call kURLmatch with (data)	then url := TrimString(data)							// text = URL	 <<<<<	else if kNIE and StrLen(data) < 100 // maxlength?	then begin		local findFrame := newtscape.prefsEntry.findFrame;		local findData := findFrame.data, app;		if StrFilled(url := findFrame.url)		then begin			if BeginsWith(url, "Hemlock")	// !!!h			then begin				if app := GetRoot().|Hemlock:seanl|				then begin/*latest: http://scruffy.cs.umd.edu:8080/seanl/Newton/Hemlock/api.htmlAPISearchEngineCursor()	Returns a cursor for all the search engine plugins in Hemlock.	Most significantly, entries should have a slot called "Name",	which gives the name of the engine. If you need more information	than that, tell me. 	APIDoSimpleSearch(terms)	Opens Hemlock and puts terms into its search terms field, but does	nothing else. This lets users set the search engines themselves. 	APIDoSearch(searchentries,terms)	Opens Hemlock and performs a search on searchentries (an array of	search engine entries accessed through	GetRoot().|Hemlock:seanl|:APISearchEngineCursor()), and terms	(a string of search terms separated by spaces).*/					local fn := StrTokenize(url,$;), engNames := [], val := call fn with (); // skip appSym					while val := call fn with ()					do  if StrFilled(TrimString(val))						then if StrEqual(val,"_all")							then break engNames := nil							else AddArraySlot(engNames, val);					//app:open();					//SetValue(app.SearchTerms.entryLine, 'text, data);					app:APIDoSimpleSearch(data);					if IsArray(engNames) and Length(engNames)=0					then return;					gc();					local cursor := app:APISearchEngineCursor(), entry := cursor:?entry(), engines := [];					while entry					do begin						if not IsArray(engNames) or LSearch(engNames,entry.name,0,'|str=|,nil)						then AddArraySlot(engines, entry);						entry := cursor:next();						end;					if Length(engines) > 0					then app:APIDoSearch(engines, data);						//app:APIDoFullSearch(engines, data, Clone(findData));					end;				return;				end;			if isFrame(findData) and Length(findData) > 0				and StrFilled(findFrame.method)			then begin				options := {					method: 	findFrame.method,					data:		findData := Clone(findData),					dataNames:	findFrame.dataNames,					};				findData.(findFrame.querySlot) := data;			// text = query	 <<<<<				end;			end;		end;	if source	then newtscape:dispatchFile(kHTMLMediaType, url, source, options)	else begin		if kNIE		then begin			newtscape.curSourceBuf := newtscape.curSourceBuf:?close(); // in case set in kCopyNewtWorksRange			if url			then call kRemoveComments with (url := Clone(url));	// !!!g			end;		if url		then if kNIE and CharPos(url,unicodeCR,0)	// list of URLs?			then newtscape:DoEvent(NIL, [{					cacheOnly: true,					autoLogin: nil,					noStatus: nil,					trustHTML: nil,					trustImages: nil,					fURLqueue: call kCollectList with (url, unicodeCR),	// !!!t					}])			else newtscape:getURL(url, options);	// single URL		end;end);// ----------// NotesDefineGlobalConstant('kNotesGetHighlightedText, func(target)if HiliteOwner() and GetHiliteOffsets()	and (target = GetVariable(HiliteOwner(), 'target) or		// Notes	'realData? !!!j		 target = GetVariable(HiliteOwner(), 'parentTarget))	// Inboxthen begin	local ARRAY offset;	local start, str, txt;	foreach offset in GetHiliteOffsets()	do  if (start := offset[1]) and		(isInstance(txt := offset[0].text, 'string) or	// !!!a1  (SimpleMail Text Stationery)			isInstance(txt := offset[0].realData.text, 'string))	// !!!e		then str := str & (if str then unicodeCR)  & call kMyTrim with (txt, start, offset[2]); // !!!o	str;	//if str and call kURLmatch with (str) then str;	end);DefineGlobalConstant('kGetLabel, func(newtscape, langLabel, engLabel)kAppNameL & $: &	if not kNCfont or (newtscape.prefsEntry and newtsCape.prefsEntry.systemFontFamily = kSystemFontSym) // !!!a1	then langLabel	else engLabel);DefineGlobalConstant('kNotesGetTitle, func(target)// for GetTitle slot of routeframeif targetthen begin	local newtscape := GetRoot().(kNewtsCapeSymbol);	local str := call kNotesGetHighlightedText with (target), lab;	if str or target.(kSourcePath) exists	then if call kURLmatch with (if str then str else target.(kSourcePath))	// !!!g		then call kGetLabel with (newtscape, kGetURLlabel, kGetURLlabelE) 		else if newtscape:matchHTMLtitle(if str then str else target, nil, true, kTitleStart, kTitleStop, nil)		then call kGetLabel with (newtscape, kOpenLabel, kOpenLabelE) 		else if kNIE		then begin			local lab := call kGetLabel with (newtscape, kFindlabel, kFindlabelE);			if newtscape.prefsEntry			then if StrFilled(str := newtscape.prefsEntry.findFrame.title)				then lab && $( & str & $)				else NIL			else lab & $?;		// not sure until open			end;	end);DefineGlobalConstant('kNotesRouteScript, func(target,targetView)begin // for RouteScript slot of routeframe	local str := call kNotesGetHighlightedText with (target);	GetRoot().(kNewtsCapeSymbol):NewtsCapeDoIt(if str then str else target.(kSourcePath)); // selection or first paraend);constant kNewtsCapeRouteScriptSym := 'NewtsCapeRouteScript;	// for install/removeDefineGlobalConstant('kNotesRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kNotesGetTitle,icon:				call kGetResource with ("NewtsCape tiny"),	// "NC popup 16x16"tag:				kNewtsCapeSymbol,routeScript:		kNotesRouteScript,});DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chainNCitems:			[kNotesRouteItem],	// !!!jGetRouteScripts:	func(targetInfo)begin	local routes := Clone(NCitems), oldRoutes;	// !!!j	if oldRoutes := inherited:?GetRouteScripts(targetInfo)	then routes := SetUnion(routes, oldRoutes, true);	SetUnion(routes, routeScripts, true);end});// ----------// HyperNewt/*constant kHyperNewtSymbol := '|HyperNewt:ATOW|;DefConst('kDefaultNonSoupHyperLinkInfoFrame, {	appSymbol: nil,	timeStamp: nil,	});DefConst('kNewtsCapeIcon, kNotesRouteItem.icon); //call kGetResource with ("NewtsCape tiny"));DefConst('kNewtsCapeSaveHyperLinkFunc, func(entry)begin	local hyperlinkinfo := Clone(kDefaultNonSoupHyperLinkInfoFrame);	// Required slots	local title := entry.title;	local icon := kNewtsCapeIcon;	hyperlinkinfo.class := ClassOf(entry);	hyperlinkinfo.appSymbol := kNewtsCapeSymbol;	//Newt's Cape specific stuff	hyperlinkinfo.URL := entry.URL;Print(title);Print(hyperlinkinfo);	return { title: title, icon: icon, hyperlinkinfo: hyperlinkinfo };end);DefConst('kNewtsCapeShowHyperLinkFunc, func(hyperlinkInfo)begin	local newtscape := GetRoot().(kNewtsCapeSymbol);	if newtscape	then begin		GetRoot().(kHyperNewtSymbol):?Minimize();		newtscape:?getURL(hyperlinkinfo.URL, nil);		return true;		end;	return nil;end);DefConst('kFrameSymbol, Intern("Frame:" & kNewtsCapeSymbol));DefConst('kDataSymbol, 	Intern("Data:" & kNewtsCapeSymbol));*/// ----------// NewtWorksconstant kNewtWorksChunkSize := 2048; // 2K. was 4Kconstant kRejectChars := "\u2206\u"; // graphic indicatorif kNIEthen DefineGlobalConstant('kNewtWorksBuf, {first:		NIL,last: 		NIL,textView: 	NIL,cleanup: 	NIL,close: func()begin	if cleanup	then textView:close();	textView := NIL;end,next: func()if first < last and textViewthen begin	local str := StringFilter( // strip out graphics characters			textView:GetRangeData(				{first: first, 				last: min(last, first + kNewtWorksChunkSize),				}, 'text),			kRejectChars, 'rejectAll);	first := first + kNewtWorksChunkSize;	str;	end//else nil});if kNIEthen DefineGlobalConstant('kCopyNewtWorksRange, func(textView, range, cleanup)	// added cleanupbegin // QA: Extracting All Text from a ProtoTXView Object	local bufObj := {_proto: kNewtWorksBuf,		first: if range then range.first else 0,		last: if range then range.last else textView:GetCountCharacters(),		textView: textView,		cleanup: cleanup,		};	local str := bufObj:next();	if bufObj.first < bufObj.last	then GetRoot().(kNewtsCapeSymbol).curSourceBuf := bufObj;	str;	// return first part of str (along with separate buffer object)/*	local INT start := if range then range.first else 0;    local INT last := if range then range.last else textView:GetCountCharacters();    local INT i, nextFlush := kVBOFlush, slen := 0;	local cstr, str := call kNewVBO with (nil, nil, "");	for i := start to last by kNewtWorksChunkSize    do begin		cstr := StringFilter( // strip out graphics characters					textView:GetRangeData(						{first: i, 						last: min(last, i + kNewtWorksChunkSize),						}, 'text),					kRejectChars, 'rejectAll);		StrMunger(str, slen, 0,	cstr, 0, nil);	// was i,nil		slen := slen + StrLen(cstr);		if (slen*2) >= nextFlush		then begin			ClearVBOCache(str);			nextFlush := nextFlush + kVBOFlush;			end;		end;	ClearVBOCache(str);	if cleanup	then textView:close();	str;*/end);if kNIEthen DefineGlobalConstant('kNewtWorksDoItFunc, func(viewDefView, newtAppBase)	// newtAppBase is unusedbegin	// check if anything is selected	local range := viewDefView:GetHiliteRange();	// if nothing is selected, treat it as 'Select All'	if range.first = range.last	then range := NIL;		/*begin	  	range.first := 0 ;	  	range.last 	:= viewDefView:GetCountCharacters();		end;*/	GetRoot().(kNewtsCapeSymbol):NewtsCapeDoIt(call kCopyNewtWorksRange with (viewDefView, range, nil)); // GetRangeDataend);if kNIEthen DefineGlobalConstant('kToolFrame,	{ // see Rot13 exampledataTypeSymbol: 'paper,		// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)item: 			kAppNameL,	// REQUIRED: appears in popup in tool picker.//setItemText: func(a,b) begin Print(a); Print(b); "foo"; end,keyCommand: {				// optional	char:		$h,	modifiers:	kCommandModifier,	keyMessage:	'DoNewtsCape,	keyFn:		func(viewDefView)					call kNewtWorksDoItFunc with (viewDefView, nil),	// newtAppBase is unused	name:		kAppNameL,	category:	"General"	// LocObj??	},// REQUIRED: called when user selects the item in the Tools pickercmdFunc:	kNewtWorksDoItFunc,});DefineGlobalConstant('kFixedFont, 	{family: 'Courier, 		face: kFaceNormal, size: 10, });DefineGlobalConstant('kDefaultFont, {family: kSystemFontSym,face: kFaceNormal, size: 10, });DefineGlobalConstant('kMargin32,	SetBounds(32, 32, 32, 32));if kNIEthen DefineGlobalConstant('kDummyTx, {	_proto: protoTxView,	viewBounds: kBounds0,	viewFlags: vNoFlags,	ReorientToScreen: ROM_DefRotateFunc,	viewSetupFormScript: func()	begin		//inherited:?viewSetupFormScript();	// !!!b		:SetGeometry(nil, 0, 0, kMargin32); // how to wrap long lines?		:SetStore(GetDefaultStore());	end,});if kNIEthen DefineGlobalConstant('kNewtWorksGetDoc, func(entry)begin	local dummy := BuildContext(kDummyTx);	dummy:Open();	dummy:Internalize(entry.saveData);	call kCopyNewtWorksRange with (dummy, nil, true); // dummy:GetRangeData(..., 'text);end);/*notes on possibly using HTMList forFile:Save HTML/Image to NewtWorks (kSaveDocument)File:Save Book to Newtworks (kNewtWorksNewDoc)Process:Save to NewtWorks (:newBook,:addBlock,:stopHTML)these would map onto kDummyTx obj in HTMListkDummyTx:newkAppendNewtWorksObjkNewtWorksSaveDocadvantage: improvements in format mapping (e.g., rulers/justification)space savings: kAppendNewtWorksObj, kNewtWorksSaveDoc*/if kNIEthen DefineGlobalConstant('kAppendNewtWorksObj, func(doc, obj)begin	local dlen := doc:GetCountCharacters(), txt, pos, newObj, styles, slen, tlen, slast;	if (newObj :=		if IsString(obj)	// text w/ default font (e.g., HTML source)		then {			text: obj,			styles: [StrLen(obj), kFixedFont]			}		else if isFrame(obj) and IsString(txt := obj.data)	// book text object		then begin			if (pos := obj.dataOffset) or obj.dataLen			then txt := SubStr(txt, if pos then pos else 0, obj.dataLen); // just part on this page			tlen := StrLen(txt);			if styles := obj.styles			then begin // check since some books might be wrong!				slen := 0;				for pos:=0 to (slast := Length(styles)-2) by 2 // add run lengths				do slen := slen + styles[pos];				if (pos := slen-tlen) <> 0				then beginif kDebugHTTP then Print("styles off by:" && pos);					styles := Clone(styles);					if (styles[slast] := styles[slast] - pos) < 0					then return if kDebugHTTP then Print("really off!");					end;				end			else styles := [tlen, if obj.viewFont then obj.viewFont else kDefaultFont];			{text: txt,			styles: styles,			};			end		else if isFrame(obj) or isBinary(obj) // graphic (bitmap, PICT)		then {			class: 'graphics,			shape: MakeShape(obj),			})	then doc:Replace({first: dlen, last: dlen}, newObj, nil);	// doesn't handle rulers/justification (see HTMList)end);if kNIEthen DefineGlobalConstant('kNewtWorksSaveDoc, func(dummy, title, show) // kNewtWorksNewDoc, Process()begin	gc();	local saveData := dummy:Externalize();	ClearVBOCache(saveData);	// !!!d	local summary := SubstituteChars(			StringFilter(				dummy:GetRangeData({first: 0, last: min(dummy:GetCountCharacters(), 80)}, 'text),				kRejectChars, 'rejectAll),			cr, " ");	dummy:Close(); 	local app := GetRoot().(kNewtworksSym);	local entry := app:AdoptEntryFromStationery({	// add the data to Works		title: Clone(title),		saveData: saveData,		hiliteRange: {first: 0, last: 0},		margins: kMargin32,		summary: summary,		},		'paper,		GetDefaultStore());	/*app:AdoptEntryFromStationery({title: url}, 'paper, GetDefaultStore());	app.viewDefView:Replace(		{first: 0, last: 0},		{text: txt,		styles: [StrLen(txt), kFixedFont]},		nil);*/	if show	then begin		app:open();		// DANGER undocumented! open to this doc and titlebox		try app:showFoundItem(entry, {findWords: [""]}) // {setStatus: kNilFunc1})		onexception |evt.ex.outofmem| do begin app:close(); Rethrow(); end		onexception |evt.ex| do nil;		AddDelayedSend(app, '_titleKeyScript, '[nil], 100);		end;end);if kNIEthen DefineGlobalConstant('kNewtWorksNewDoc, func(title, data)	// called via kSaveDocument(Save HTML/Image), Save Book (from Bob Ebert)if GetRoot().(kNewtworksSym)then begin	// use a txView to properly create the SaveData info	local dummy := BuildContext(kDummyTx), obj;	dummy:Open();	if isArray(data)	// curBook.contents	then foreach obj in data		 do begin			obj := call kMungeContentScript with (obj); // resolve any aliases			if obj.type <> 'form	// text and graphics only			then begin					call kAppendNewtWorksObj with (dummy, if IsString(obj.data) then obj else obj.data);				call kAppendNewtWorksObj with (dummy, cr);	// some spacing between paras				end;			end	else call kAppendNewtWorksObj with (dummy, data);	call kNewtWorksSaveDoc with (dummy, title, true);	end);if kNIEthen DefineGlobalConstant('kGetBASE, func(content)	// shared by scanImages, protoSerialProtocolcall kScanAttribute with (call kSubStr with (content, kBaseStart, ">", nil), kHREF); // !!!f,e);if kNIEthen DefineGlobalConstant('kGetTITLE, func(content)	// !!!kbegin	local ftitle := call kSubStr with (content, kTitleStart, kTitleStop, nil);	if ftitle and StrFilled(TrimString(ftitle))	then ftitle;	// :fixString laterend);if kNIEthen DefineGlobalConstant('kSaveDocument, func(cacheSoup, url, field, edata, title, nw) // shared by File:Save as *, kSaveAsHTMLbegin	local obj := if field then call kGetURLCache with (cacheSoup, url, field, edata, true) else cacheSoup;	if obj	then begin		local pos;		if IsString(obj) and not StrPos(obj, kBaseStart, 0)	// add <BASE> if not there		then StrMunger(				obj := Clone(obj), if (pos := StrPos(obj,kTitleStart,0)) then pos else 0, 0,				("<BASE HREF=\"" & url & "\">\n"), 0, nil);if kDebugHTTP then Print(obj);		if kNIE and nw		then call kNewtWorksNewDoc with (title, obj)		else if not nw		then call kMakeNote with (title, obj, nil, nil);		end;end);DefineGlobalConstant('kCopperfieldProtoItem, { // !!!e. for Copperfield _proto chainscrollPage: kScrollPage2,	// 2.x_Back: func(view)			// 2.1. see kBookKeyskBackButton:buttonClickScript(),_Forward: func(view)		// 2.1kForwardButton:buttonClickScript(),_NewtsCape: func(view)		// 2.1. * !!!fbegin	local newtscape := GetRoot().(kNewtsCapeSymbol);	if Visible(newtscape)	then call kHideNewtsCape with ()	// !!!g. newtscape:hide()	else newtscape:?open();	//kShowNCButton:buttonClickScript(),end,// if none, soft kbd closes; hard kbd closes NC_CloseFrontView: func(view)	// 2.1	just book or overview or page num, not NC also!//:close(),	// soft: closes book (only if NC shown/hidden), overview closes book, but kbd closes (if NC hidden) //GetView('viewFrontKey):close(),//GetView('viewFrontMost):close(),	// soft: overview closes NC if hiddenGetRoot().(kBookReaderSymbol):close(),});// ----------// InboxDefineGlobalConstant('kInboxGetTitle, func(target)	// for GetTitle slot of kInboxRouteItembegin	local newtscape := GetRoot().(kNewtsCapeSymbol);	if call kURLmatch with (call kNotesGetHighlightedText with (target))	// !!!j	then call kGetLabel with (newtscape, kGetURLlabel, kGetURLlabelE)	else if newtscape:matchHTMLtitle(target, nil, true, kTitleStart, kTitleStop, nil)	then call kGetLabel with (newtscape, kOpenLabel, kOpenLabelE)end);DefineGlobalConstant('kInboxRouteScript, func(target,targetView)// for RouteScript slot of routeframebegin	local obj := call kNotesGetHighlightedText with (target), newtscape := GetRoot().(kNewtsCapeSymbol);	if StrFilled(obj)	then newtscape:NewtsCapeDoIt(obj)	// !!!j	// what does this do that's different from NewtsCapeDoIt ???	else if isArray(obj := newtscape:matchHTMLtitle(target, true, nil, nil, nil, true))	then begin		obj[3] := {loadImages: nil};		Perform(newtscape, 'dispatchFile, obj); // other media types?		end	else newtscape:dispatchFile(kHTMLMediaType, "", obj, {loadImages: nil});end);DefineGlobalConstant('kInboxRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kInboxGetTitle,icon:				kNotesRouteItem.icon,	// share "Newt's Cape tiny"tag:				kNewtsCapeSymbol,routeScript:		kInboxRouteScript,});DefineGlobalConstant('kInboxProtoItem, { // for Inbox _proto chainNCitems:			[kInboxRouteItem],	// !!!jGetRouteScripts:	kNotesProtoItem.GetRouteScripts,	// !!!j. share});// ----------DefineGlobalConstant('kDayMin, 24*60);// code borrowed/modified from NewtPack (Serg)DefineGlobalConstant('kRegExpDays, 45);						// number of days to expireDefineGlobalConstant('kRegExpMin, kRegExpDays * kDayMin);	// number of mins to expireDefineGlobalConstant('kRegNagDays, 15);						// number of days to nagDefineGlobalConstant('kRegNagMin, kRegNagDays * kDayMin);	// number of mins to nagDefineGlobalConstant('kRegExpSym, Intern($X & kNewtsCapeSymbol)); // this is the app-specific ID for this "lock" DefineGlobalConstant('kRegExpired, func(nag)if kExpiringVersionthen begin	// true - demo has expired	// nil - full demo or non-demo build	local entry := GetAppPrefs(kRegExpSym, {});	if not entry.version or			// first time		entry.version < kVerBeta	// newer beta/version	then begin	// add/update		entry.version := kVerBeta;		EntryChangeXmit(entry,nil);	// init/update		NIL;	// ok to continue		end	else begin		local INT now := Time(), start := EntryModTime(entry);		now < start or now >= start + kRegExpMin - nag;		end;	end);//if kExpiringVersion then SetPartFrameSlot('DoNotInstall, kRegExpired);	// diff fn w/o arg?DefineGlobalConstant('kNamesGetValue, func(target)	// !!!nif targetthen begin	local str, fields;	if  IsArray(fields := GetRoot().(kNamesSym):?BcCustomFields(target, nil))			and (fields := LFetch(fields,kURL,0,'|str=|,'label))		and IsString(str := fields.value)	then str	else if IsArray(fields := target.notes) and Length(fields) > 0			and IsString(str := fields[0].text)	then str;	end);if kNIE thenDefineGlobalConstant('kNamesGetTitle, func(target)// for GetTitle slot of routeframeif targetthen begin	local str := call kNamesGetValue with (target), newtscape := GetRoot().(kNewtsCapeSymbol);	if call kURLmatch with (str)	then call kGetLabel with (newtscape, kGetURLlabel, kGetURLlabelE)	else if newtscape:matchHTMLtitle(str, nil, true, kTitleStart, kTitleStop, nil)	then call kGetLabel with (newtscape, kOpenLabel, kOpenLabelE);	end);if kNIE thenDefineGlobalConstant('kNamesRouteScript, func(target,targetView)	GetRoot().(kNewtsCapeSymbol):NewtsCapeDoIt(call kNamesGetValue with (target))	// !!!n);// ----------DefineGlobalConstant ('kAddPatchFunc, func(target, template)if targetthen begin	// init the patch	target:close();	// !!!j	local patch := EnsureInternal({}), sym, val;	// copy all of the patched slots (including tag)	foreach sym, val in template	do patch.(EnsureInternal(sym)) := val;	patch.(EnsureInternal('tag)) := EnsureInternal(kNewtsCapeSymbol);	// link into the target's proto chain	patch.(EnsureInternal('_proto)) := target._proto;	target._proto := patch; // returns patch	end);DefineGlobalConstant('kRemovePatchFunc, func(target)if targetthen begin	target:close();	// !!!j	local nextProto;	while nextProto := target._proto	do  if nextProto.tag = kNewtsCapeSymbol		then break target._proto := nextProto._proto		else target := nextProto;	end);//----------// INSTALL/REMOVE scripts// abort if no Copperfield?InstallScript := func(partFrame)begin	call kInitGlobal with (nil, nil);	local newtscape := partFrame.theForm, root := GetRoot(), notes := root.(kNotesSym), rf;	if kNIE	then begin		if notes		then call kAddPatchFunc with (notes, kNotesProtoItem);		call kAddPatchFunc with (root.(kInboxSym), kInboxProtoItem);		newtscape:?addLocale();		RegUnionSoup(kNewtsCapeSymbol, kCacheHTMLSoupDef);		// here rather than :init		RegUnionSoup(kNewtsCapeSymbol, kCacheImagesSoupDef);		if kSubmitQ then RegUnionSoup(kNewtsCapeSymbol, kCacheSubmitSoupDef);		// !!!g		//addIndexXmit for additional indexes??		RegUnionSoup(kNewtsCapeSymbol, kBookmarkSoupDef);		RegUnionSoup(kNewtsCapeSymbol, kTempHTMLSoupDef);		//RegAppClasses(kNewtsCapeSymbol, ['routeBinary]);		AddDeferredCall(func()	// defer in case Newtworks installed later, e.g., on MP2K			GetRoot().(kNewtWorksSym):?RegNewtWorksTool(EnsureInternal(kNewtsCapeSymbol), kToolFrame), nil); // eMate only?		//RegisterViewDef(newtscape.speakFormat, kNCDataDefSym);		call kAddPatchFunc with (root.(kBookReaderSymbol), kCopperfieldProtoItem);	// !!!e		if kBuild20	// !!!r. not ~X		then begin		// !!!g. Names routing			rf := EnsureInternal({				GetTitle:	nil,				routeScript:nil,				icon:		nil,				//tag:		kNewtsCapeSymbol,				});			rf.GetTitle		:= kNamesGetTitle;			rf.routeScript	:= kNamesRouteScript;			rf.icon			:= kNotesRouteItem.icon;			call kRegNamesRouteScriptFunc with (kNewtsCapeSymbol, rf);			end;		end	else begin	// 1.x		local routingFrame := GetGlobals().Routing;		routingFrame.(EnsureInternal(kNewtsCapeSymbol)) := newtscape.NIEPrefsLayout.routeScripts; // !!!n		if notes		then begin				rf := EnsureInternal(				{GetTitle: nil, icon: nil, tag: kNewtsCapeSymbol, routeScript: kNewtsCapeRouteScriptSym});			local rs; // := notes.routeScripts;			rf.GetTitle := newtscape.NotesGetTitle; //kNotesGetTitle; // add method (so not cloned)			if isFrame(rs := routingFrame.(kNotesSym)) // 1.x			then begin				notes.(rf.routeScript) := newtscape.NotesRouteScript; // kNotesRouteScript; // add method to Notes				if isReadonly(rs)				then rs := routingFrame.(kNotesSym) := Clone(rs);				rs.(rf.tag) := rf;				end;			end;		end;/*		if kNIE		// already registered with URLcop	then AddDeferredCall(func(appSymbol, types, suitability, handlersFrame)			root.(kURLcopSymbol):?RegURLHandler(appSymbol, types, suitability, handlersFrame),  			[kNewtsCapeSymbol, '[http], 38, {FetchURL: true, GetURL: true}   			]); //Assist: need a lexical dictionary to support URL parsing/matching	partFrame.taskTemplateID :=		RegTaskTemplate(newtscape.taskTemplate); // stash ref globally		local hsoup := GetUnionSoup("Hyperlink Manager"), entry; // HyperNewt		if hsoup and (not (entry := hsoup:query({indexPath: 'appSymbol, beginKey: kNewtsCapeSymbol}):entry())			or entry.appSymbol <> kNewtsCapeSymbol)		then hsoup:AddToStoreFlushedXmit({			appSymbol: kNewtsCapeSymbol,			SaveHyperLink: kNewtsCapeSaveHyperLinkFunc,			ShowHyperLInk: kNewtsCapeShowHyperLinkFunc,			}, GetStores()[0], nil);		RegisterViewDef(newtscape.frameFormat, kDataSymbol);		if StrFilled(root.(kNewtsCapeSymbol):getPrefsEntry().autoOpen)		then AddDeferredSend(root.(kNewtsCapeSymbol), 'open, nil)		else root.(kNewtsCapeSymbol).prefsEntry := NIL;*///if kDebugOn then AddDeferredCall(func() GetRoot().(kNewtsCapeSymbol):?Open(), nil);end;RemoveScript := func(partFrame)begin	local root := GetRoot(), notes := root.(kNotesSym);	if kNIE	then begin		if notes		then call kRemovePatchFunc with (notes);			/* begin			if i := LSearch(rs, kNewtsCapeSymbol, 0, '|=|, 'tag)			then ArrayRemoveCount(rs,i,1);			end */		call kRemovePatchFunc with (root.(kInboxSym));		// restore old locale		//SetLocale(partFrame.oldLocaleTitle);		call kRemoveLocaleFunc with (kHTTPlocaleName);		// RemoveLocale def in 2.1, but undef in 2.0		UnRegUnionSoup(kCacheHTMLSoupName,	kNewtsCapeSymbol);	// here rather than :quit		UnRegUnionSoup(kCacheImagesSoupName, kNewtsCapeSymbol);		if kSubmitQ then UnRegUnionSoup(kCacheSubmitSoupName, kNewtsCapeSymbol);	// !!!g		UnRegUnionSoup(kBookmarkSoupName, kNewtsCapeSymbol);		UnRegUnionSoup(kHTMLSoupName, kNewtsCapeSymbol);		//UnregAppClasses(kNewtsCapeSymbol);		root.(kNewtWorksSym):?UnRegNewtWorksTool(kNewtsCapeSymbol); // eMate only?		//UnRegisterViewDef(kFrameSymbol, kDataSymbol);		//UnRegisterViewDef(kNCViewDefSym, kNCDataDefSym);		call kRemovePatchFunc with (root.(kBookReaderSymbol)); // !!!e		// Names routing		if kBuild20	// !!!r		then call kUnRegNamesRouteScriptFunc with (kNewtsCapeSymbol);	// !!!g		end	else begin // 1.x		local rs, routingFrame := GetGlobals().Routing; // := notes.routeScripts;		RemoveSlot(routingFrame, kNewtsCapeSymbol);	// !!!n		if notes and isFrame(rs := routingFrame.(kNotesSym)) 		then begin			RemoveSlot(rs, kNewtsCapeSymbol);			RemoveSlot(notes, kNewtsCapeRouteScriptSym);			end;		end;/* if partFrame.taskTemplateID	then begin		UnRegTaskTemplate(partFrame.taskTemplateID);		partFrame.taskTemplateID := NIL;		end;*/end;