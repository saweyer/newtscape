//PilotDoc 1.0//install copied from HTMList/JPEG//Copyright 1999-2000. S. Weyer. All Rights Reserved Worldwideconstant kAutoPartName := "PilotDoc";constant kFileName := "pdoc";DefineGlobalConstant('kVersionNum, 	"1.0");DefineGlobalConstant('kVersionInt, 	"10");DefineGlobalConstant('kBetaVersion, "e");/*- fixed options.(EnsureInternal bug- added TapAction? DoProgress? ClearVBOCache only 32K? RichReader formatting; how often actually used (only 2 books on memoware);  for new books, save doc to HTML*/// avoid some compiler warningsDeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);DeclareGlobalFn('ClearVBOCache, 1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalConstant('kExpiringVersion, NIL);DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if not kIgnoreNativeKeyword then $N) &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if kExpiringVersion then $X) &	(if kBuild20 then "-2"));DefineGlobalConstant('kVersion, kAutoPartName && kVersionString);Print(kFileName & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then $N	else if language='English	then $2	else Upcase(SPrintObject(language))[0])	& ".pkg");Print(kVersion && DateNTime(time()));DefineGlobalConstant('kPkgSymbol, Intern(kPackageName)); // kAppSymbol='autoPrint([kAppName, kPkgSymbol]);//Print(kAppSymbol);	// sameDefineGlobalConstant('kNewtsCapeSymbol, '|NewtsCape:NewtsCape|);DefineGlobalConstant('kNewtsCapeEmptyGlobal, { // from Newt's Cape	cache: [], historyPos: 0,				htmlApps: {}, helperApps: {},	imageExtensions: [".gif"],	protos: {},	}); 	DefineGlobalConstant('kVBOFlush, 16*1024);DefineGlobalConstant('kRefreshStatus, 4000);constant kTextMediaType := "text/plain";constant kHTMLMediaType := "text/html";						// !!!dconstant kHTMLStart		:= "<HTML>";DefineGlobalConstant('kDocMediaTypes, [	kTextMediaType, "*/*", 									// !!!c. other 	"application/octet-stream", "chemical/x-pdb",	"application/x-pilot-pdb", "application/x-pilot-prc", 	// !!!c.  palmzip	"application/x-palmpilot", "application/x-pilot",		// !!!c. other	]);constant kMediaExtensionPos := 2;	// 0-2 require file extension check (see InstallScript)DefineGlobalConstant('kDocExtensions, [".pdb", ".prc"]);DefineGlobalConstant('kTypeIDs, '["TEXtREAd", "vIMGView"]);DefineGlobalConstant('kMapNCTypes, [kTextMediaType, "image/gif"]); // same len as kTypeIDsconstant kConvertDoc := "convert DOC";constant kConvertImg := "convert IMG";//DefineGlobalConstant('kHeader3, SetLength(SetClass("\u406F8000",'binary),3));DefineGlobalConstant('kExtractString, func(data, INT offset, INT len)if offset+len < Length(data)then begin	local INT i;	local s := MakeBinary((len*2)+2, 'string);	for i := 0 to len-1	do StuffByte(s, (i*2)+1, ExtractByte(data, offset+i));	s;	endelse "");DefineGlobalConstant('kColorTable16,SetLength(SetClass("\uF000F000F000F000E000E000E000E000D000D000D000D000C000C000C000C000B000B000B000B000A000A000A000A0009000900090009000800080008000800070007000700070006000600060006000500050005000500040004000400040003000300030003000200020002000200010001000100010000000000000000000",'grayPattern), 128));       DefineGlobalConstant('kColorTable4,SetLength(SetClass("\uF000F000F000F000A000A000A000A00050005000500050000000000000000000",'grayPattern), 32));/*DefineGlobalConstant('kByteStrEqual, func(data, INT start, str)begin	local INT i, slen := StrLen(str);	if start+slen > Length(data)	then return NIL;	for i := 0 to slen-1	do  if ExtractChar(data, start+i) <> str[i]		then return NIL;	TRUE;end);*//*PDB/PRC HEADER=78[ 0]32: name(CString)[32] 2: flags(0)[34] 2: version(0)[36] 4: create time[40] 4: mod time[44] 4: backup time[48] 4: mod num[52] 4: app info[56] 4: sort info[60] 4: Type, e.g., TEXt, vIMG[64] 4: ID, e.g., REAd, View[68] 4: seed[72] 4: next_rec[76] 2: num recs[78] */DefineGlobalConstant('kHelperFrame, {transferMode: 'binary,extensions: nil,	// !!!dmatchFile: func(url, data) // for Inbox testing	(not extensions or LSearch(extensions, url, 0, GetGlobalFn('EndsWith), nil)) and	LSearch(kTypeIDs, call kExtractString with (data,60,8), 0, '|str=|, nil),addFile: func(contentType, url, data, options)//DEBUGif kDebugOn and options and options.docType	// save to soupthen begin	RegUnionSoup(kPkgSymbol, {	//offline testing		name: 	kPackageName,		userName: kPackageName,		ownerApp: kPkgSymbol,		userDescr: kPackageName,		indexes: [{structure: 'slot, path: 'URL, type: 'string}]})	:AddToDefaultStoreXmit(		{URL: url,		data: data,		type: options.docType}, nil);	return TRUE;	endelse beginif kDebugOn then Print(contentType);	local newtscape := GetRoot().(kNewtsCapeSymbol), newData, typeID, compressed;	local errFunc := func(msg,arg)		newtscape:?errorStatus(kAutoPartName & $: && msg & $: && arg);	local flushStatusFunc := func(msg)		begin			if si >= nextFlush			then begin				ClearVBOCache(newData);				nextFlush := si + kVBOFlush;				end;			if si >= nextRefresh			then begin				if newtscape:?setGauge(kAutoPartName && msg & $: && nextRefresh & $/ & slen, nextRefresh, slen)				then RefreshViews();				nextRefresh := nextRefresh + kRefreshStatus;       			end;		end;	if not (typeID := LSearch(kTypeIDs, newData := call kExtractString with (data,60,8), 0, '|str=|, nil))	then return call errFunc with ("unknown TypeID", newData);	local dtype := kMapNCTypes[typeID];	// !!!d		local INT di := ExtractWord(data,80), dlen := Length(data), slen;	//actually long@78. avoid out of range	local INT ch, si, j, off, len;		if di < 80 or di >= dlen-16 // or not BinEqual(kHeader3, ExtractBytes(data,82,3,'binary))	then return call errFunc with ("unknown header loc", di);	if not options then options := {};	options.(EnsureInternal('bookTitle)) := ExtractCString(data,0);		// !!!e	newtscape:?resetStatus();	local INT nextFlush := kVBOFlush, nextRefresh := kRefreshStatus;if kDebugOn then Print([	di, options.bookTitle, "numRecords:" && ExtractWord(data,76),	"appInfo:" && ExtractWord(data,54), "sortInfo:" && ExtractWord(data,58)	]);	if typeID=0		// TEXtREAd	then begin	/* DOC HEADER=16 [0] 2: version: 0x0002 if data is compressed, 0x0001 if uncompressed [2] 2: spare: purpose unknown (set to 0 on creation) [4] 4: total length of text before compression [8] 2: records: number of text records[10] 2: record_size:	maximum size of each record (usually 4096)[12] 4: position: currently viewed position in the document[16]*/		if ExtractWord(data,di+10) <> 4096		then return call errFunc with ("header not recognized", ch); // necessary??		compressed := ExtractWord(data,di) = 2;if kDebugOn then Print(["compressed:", compressed]);		slen := (ExtractLong(data, di+4) * 2) + 2;	//unicode+null		di := di+16;		si := 1;	// no unicode, so write just right bytes(si odd)		newData := GetDefaultStore():NewCompressedVBO('string, slen, kTextCompander, nil); //"TLZStoreCompander"if kDebugOn then Print(["di:" && di, "dlen:" && dlen, "si:" && si, "slen:" && slen]);		//if EndsWith(url, ".prc")							// kDocExtensions[1]		//then while ExtractByte(data,di)=14 do di := di+1;	// skip until real chars		while di < dlen and si < slen		do begin			ch := ExtractByte(data,di);if kDebugOn then GetGlobals().(kNewtsCapeSymbol).(EnsureInternal(kPkgSymbol)) := [ch,di,dlen,data,si,slen,newData];			if compressed			then begin				if ch >= 0xC0				then begin					//192-255=0xc0-0xff. Insert a space followed by 7-bit byte					StuffByte(newData, si, 0x20);				//space					if (si := si+2) < slen						// !!!c					then StuffByte(newData, si, Band(ch,0x7F));	//7-bit byte					si := si+2;					end				else if ch >= 0x80				then begin					//128-191=0x80-0xbf. Copy a sequence from a previous part of the block					//ignore 2 hi bits; 11 bits offset from end of uncompressed str; 3 bits len + 3					ch  := Band(ExtractWord(data,di), 0x3FFF);					len := Band(ch,0x7)+3;					off := (ch >> 3) * 2;	//for binary offset					for j := 1 to len					do begin						StuffByte(newData, si, ExtractByte(newData, si-off));						if (si := si+2) >= slen then break;	// !!!c						end;					di := di+1;	//skip extra byte					end				else if ch >= 0x9				then begin					//10-127=0x0a-0x7f. Pass through as-is  	9/10???					StuffByte(newData, si, if ch=chLF then chCR else ch);					si := si+2;					end				else if ch >= 0x1				then begin					//1-9=0x01-0x09. Copy the following N bytes verbatim 9/10??if kDebugOn then Print(["verbatim:",di,ch,si]);					for j := di+1 to (di := di+ch)					do begin						ch := ExtractByte(data,j);						StuffByte(newData, si, if ch=chLF then chCR else ch);	// !!!c						if (si := si+2) >= slen then break;						// !!!c						end;					//di+1 below					end				else if kDebugOn then Print("null:" && di);				end			else begin //uncompressed. expand ascii to unicode (like compressed 0x09-0x7F)				StuffByte(newData, si, if ch=chLF then chCR else ch);				si := si+2;				end;			di := di+1;			call flushStatusFunc with (kConvertDoc);			end;		if (si := si+1) < slen		then SetLength(newData,si); // shorten but keep null		ClearVBOCache(newData);		end	else //if typeID=1 then	// vIMGView		begin // see Sloup:BitmapFromRawData/*IMG HEADER=58 [0]32: name(CString)[32] 1: version (0=uncompressed; 1=compressed)[33] 1: type (0xFF=monochrome, 0=gray-4, 2=gray=16)[34] 4: reserved[38] 4: note[42] 2: x_last[44] 2: y_last[46] 4: reserved[50] 2: x_anchor[52] 2: y_anchor[54] 2: width[56] 2: height[58]*/		compressed := ExtractByte(data,di+32) = 1;		ch := ExtractByte(data,di+33);	//type		local bitdepth := if ch=0xFF then 1 else if ch=0 then 2 else if type=2 then 4;		if not bitdepth or (bitdepth > 1 and not GlobalFnExists('PackRGB)) // 2.1?		then return call errFunc with ("bitdepth", bitdepth);		local INT pixelWidth  := ExtractWord(data,di+54);		local INT rowBytes8   := (pixelWidth*bitdepth + 7) div 8;		local INT rowBytes32  := 4*((pixelWidth*bitdepth + 31) div 32);		local INT pixelHeight := ExtractWord(data,di+56);		slen := rowBytes32 * pixelHeight;		off  := rowBytes32 - rowBytes8; // padif kDebugOn then Print([compressed, bitdepth,pixelWidth,pixelHeight,rowBytes8, rowBytes32, off, slen]);//		if compressed and rowBytes8 <> rowBytes32//		then return call errFunc with ("compressed & not row32 padded", nil); // messy		di := di+58;	//skip IMG header		si := 16;		//skip bitmap header		newData := GetDefaultStore():NewCompressedVBO(if bitdepth=1 then 'bits else 'cbits, si+slen, kTextCompander, nil);		StuffWord(newData,  4, rowBytes32);		StuffWord(newData, 12, pixelHeight);		StuffWord(newData, 14, pixelWidth);		if compressed		then while di < dlen			 do begin				ch  := ExtractByte(data,di);				len := ch+1;				di  := di+1;				if ch <= 0x80				then begin	// copy next ch+1 literal bytes					if off=0					then BinaryMunger(newData,si,len, data,di,len) // contiguous					else for j := 0 to ch //len-1						 do begin							if ((si+j-16) mod rowBytes32) = rowBytes8							then si := si+off;							StuffByte(newData, si+j, ExtractByte(data,di+j));						 	end;					di := di + len;					end				else begin // copy next byte ch+1 times					len := len-0x80;					ch  := ExtractByte(data,di);					for j := 0 to len-1					do begin						if off > 0 and ((si+j-16) mod rowBytes32) = rowBytes8						then si := si+off;						StuffByte(newData, si+j, ch);						end;					di := di + 1;					end;				si := si + len;				call flushStatusFunc with (kConvertImg);				end		else if off=0	//uncompressed: contiguous		then BinaryMunger(newData,si,slen, data,di,slen)		else //uncompressed: add padding to each row			for j := 1 to pixelHeight			do begin				BinaryMunger(newData,si,rowBytes8, data,di,rowBytes8);				si := si + rowBytes32;				di := di + rowBytes8;				call flushStatusFunc with (kConvertImg);				end;				ClearVBOCache(newData);		ch := RelBounds(0,0,pixelWidth,pixelHeight);		newData :=			if bitdepth=1			then {				bounds: ch,				bits: newData,				}			else {				bounds: ch,				colordata: {					cbits: newData,					bitdepth: bitdepth,					colortable: if bitdepth=4 then kColorTable16 else kColorTable4,					},				};		end;	if newtscape:?setGauge("",nil,slen)	then RefreshViews();	if kDebugOn //and options.resultOnly	then return ss := newData;	//DEBUG	if dtype=kTextMediaType and StrPos(newData, kHTMLStart, 0)	// !!!d	then AsyncConfirm("process HTML or display plain text?", '["HTML", "text"],		func(x)		newtscape:?addFile(if x=0 then kHTMLMediaType else dtype, url, newData, options)		)	else newtscape:?addFile(dtype, url, newData, options);end,});DefineGlobalConstant('kHelperFrameExt, {_proto: 	kHelperFrame,extensions: kDocExtensions, /*only these extensions for generic types*/});DefineGlobalConstant('kInstallHelperApp, func(contentType, sym, helperApp)if GetRoot().(kNewtsCapeSymbol)	// use built-in installHelperApp if therethen GetRoot().(kNewtsCapeSymbol):installHelperApp(contentType, sym, helperApp)else begin	local gData := GetGlobalVar(kNewtsCapeSymbol);	if not gData	then DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal(kNewtsCapeEmptyGlobal)); 	local helperApps := gData.helperApps;	local icontentType := Intern(contentType);	local helperFrame := helperApps.(icontentType); 	if isFrame(helperApp)	then begin // install		if not helperFrame then		helperApps.(EnsureInternal(icontentType)) := helperFrame := EnsureInternal({});		// assume in this version that helperApp has 'addFile		helperFrame.(EnsureInternal(sym)) := helperApp; // add/replace		end	else if helperFrame and Length(RemoveSlot(helperFrame,sym))=0	then RemoveSlot(helperApps, icontentType); // un-install	end;);InstallScript := func(partFrame, removeFrame)begin	local data := partFrame.partData, contentType, i;	foreach i,contentType in data.mediaTypes	do data:installHelperApp(contentType, kPkgSymbol,		if i <= kMediaExtensionPos then data.helperFrameExt else data.helperFrame);end;RemoveScript :=	func(removeFrame)begin	local contentType;	foreach contentType in kDocMediaTypes	do call kInstallHelperApp with (contentType, kPkgSymbol, nil);end;SetPartFrameSlot('text, kAppName);	// nicer than symbol, plus allows tapAction. !!!eSetPartFrameSlot('tapAction, func()	GetRoot():Notify(0,		kAppName && kVersionNum & kBetaVersion,		"a Newt's Cape helperApp for\nPalm books: .pdb,.prc files.\n\n©2001. Steve Weyer\nwww.kagi.com/weyer/#PilotDoc"));partData := {	// avoids ensure-internaling at install time?installHelperApp:	kInstallHelperApp,mediaTypes: 		kDocMediaTypes,helperFrame: 		kHelperFrame,helperFrameExt: 	kHelperFrameExt,};