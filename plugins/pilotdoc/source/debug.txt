// =============/*DEBUGGING:qq := getunionsoup("DOC:NewtsCape"):query(nil);	//oldqq := getunionsoup("PilotDOC:NewtsCape"):query(nil);	//newqq := getunionsoup("Inbox"):query(nil);	qq:resetToEnd()ee := qq:reset();[ee.url, ee.type, edoc := ee.data, ExtractLong(edoc,78)]ee := qq:next(); if ee then [ee.url, edoc := ee.data, ExtractLong(edoc,78)]call func(data,offset,len)	//ExtractStringbegin	local i,s;	for i:=0 to len-1 do s := s & ExtractChar(data,offset+i);	s;end with (edoc,83,3)end with (edoc,60,8)	//signaturegetroot().|NewtsCape:NewtsCape|:dispatchfile(	"application/octet-stream", "http://www.memoware.com/dickensd.prc", edoc, nil)call func(data)begin local di := ExtractLong(edoc,78);	[ExtractWord(edoc,di), ExtractLong(edoc,di+4), ExtractWord(edoc,di+10), ExtractCString(edoc,0)]end with (edoc)call func(data,start)begin local i, w;for i:=start to Length(data)-2 by 2do if ((w := ExtractWord(data,i)) = 1 or w=2) and ExtractWord(data,i+10)=4096then break Print (i);end with (edoc,0)call func(data)begin local di := ExtractLong(data,78);	[ExtractWord(data,di), ExtractLong(data,di+4), ExtractWord(data,di+10), ExtractCString(data,0)]end with (edoc)local i; for i:=0 to 32 by 2 do Print(i & $: && ExtractWord(edoc,i))local i; for i:=0 to 90 by 2 do if ExtractWord(edoc,i)=90 then break Print(i)call func(data,start)begin local i, w;for i:=start to start+14 by 2do Print(i & $: && ExtractWord(edoc,i))end with (edoc,392)call func()beginlocal qq := getunionsoup("PilotDOC:NewtsCape"):query(nil);local ee := qq:?entry();local esfunc := func(data,offset,len)begin	local i,s;	for i:=0 to len-1 do s := s & ExtractChar(data,offset+i);	s;end;while eedo begin	//if StrEqual(ee.type,"TealDoc") or StrEqual(ee.type,"RichReader") then	Print([ee.type, ExtractCString(ee.data,0), call esfunc with (ee.data,60,4), call esfunc with (ee.data,64,4), ee.url]);	ee := qq:next();	end;end with ()trailing bookmarkscall func(str)begin	local kCharPosR := func(str,ch,endPos)		begin			local i;			for i:=endPos to 0 by -1			do  if str[i] = ch				then return i;			return NIL;		end;	local slast := StrLen(str)-1, spos, epos;	if str[slast]=$\n	then epos := slast;	if  (spos := call kCharPosR with (str, $\n, slast-1))		and (str[spos+1] = $<)		and (epos := CharPos(str,$>,spos))	then begin		local bm := Substr(str,spos+2,epos-spos-2);Print(bm);		local str2 := Clone(str);		StrMunger(str2,spos+1,nil, nil,0,nil);	// remove		local i, subs := '["&", "&amp;", "<", "&lt;", ">", "&gt;", "\n\n", "\n<P>"];		for i:=0 to Length(subs)-1 by 2		do StrReplace(str2,subs[i],subs[i+1],nil);		spos := 0;		while spos := StrPos(str2,bm,spos)		do begin			epos := CharPos(str2,$\n,spos);			StrMunger(str2,epos,0, "</H1>",0,nil);			StrMunger(str2,spos,StrLen(bm), "<H1>",0,nil);			end;		StrMunger(str2,0,0, "<HTML><HEAD><TITLE>xxx</TITLE></HEAD><BODY>\n",0,nil);		StrMunger(str2,StrLen(str2),0, "</BODY></HTML>\n",0,nil);		str2;		end;end with (ss)Teal  combine with <XMP> ???<HRULE ...>		=> <HR><LINK TEXT="tt" TAG="$$aa" x=30 width=100 >	=>	<A HREF="##$$aa">tt</A><LABEL NAME=$$Greet>xxx 	=> <A NAME="$$Greet">xxx</A><HEADER TEXT="Contents" ALIGN=CENTER STYLE=UNDERLINE> <BOOKMARK NAME="Contents" > not always begin on a line.need to scan instead for closing > (only if on same line)and replace just that (not entire line) since mult tags can be on same line!call func(str)begin	local kScanAttribute := func(line, attrib, INT start, INT stop)begin	local i, pos1, pos2, ch;	// looks for ...  attrib= "........"     >	//				  ^       ^        ^     ^	if not i := StrPos(line, attrib, start)	// assume immed = suffix	then return NIL;	// look for first char of value	for i := i+StrLen(attrib) to stop-1	do  if (ch := line[i]) = $" or ch = $'		// find next " or '		then begin			pos1 := (pos2 := i) + 1;			while (pos2 := CharPos(line, ch, pos2+1))				and line[pos2-1] = $\\	// !!!g. quoted quote?			do nil;			break if not pos2 then pos2 := stop;			end					else if not isWhiteSpace(ch) // and ch <> $=		then break pos1 := i;	// pos2 is nil	if pos1	then begin		if not pos2		then for i := pos1+1 to (pos2 := stop)-1	// break on next whitespace		 	 do if isWhiteSpace(line[i])				then break pos2 := i;		if pos1 < pos2		then TrimString(SubstituteChars(SubStr(line,pos1,pos2-pos1), "\n\t", "  "));		// else NIL;		end;end;	local spos, epos := 0, slen := StrLen(str), llen, line, name, val, sub;	while spos := CharPos(str, $<, epos)	do begin		epos := CharPos(str, $\n, spos);		if not epos then epos := slen;		line := Substr(str, spos, llen := epos - spos);		sub := nil;		if BeginsWith(line, "<HRULE")		then sub := "</XMP><HR><XMP>"				else if BeginsWith(line, "<LABEL") or BeginsWith(line, "<BOOKMARK")		then begin			if name := call kScanAttribute with (line, "NAME=", 0, llen)			then begin				val := CharPos(str, $\n, epos+1); // end of next line (heading?)				StrMunger(str, if val then val else slen, 0, "</A></H1><XMP>", 0, nil);				sub := "</XMP><H1><A NAME=\"" & name & "\">";				end;			end		else if BeginsWith(line, "<LINK")		then begin			if (name := call kScanAttribute with (line, "TAG=", 0, llen)) and				(val := call kScanAttribute with (line, "TEXT=", 0, llen))			then sub := "</XMP><P><A HREF=\"#" & name & "\">" & val & "</A><XMP>";			end		else if BeginsWith(line, "<HEADER")		then begin			if val := call kScanAttribute with (line, "TEXT=", 0, llen)			then sub := "</XMP><H1>" & val & "</H1><XMP>";			end;		if sub		then begin			StrMunger(str, spos, llen, sub, 0, nil);			epos := spos + StrLen(sub);			end		else epos := spos+1;	// after <		end;	StrMunger(str,0,0, "<HTML><HEAD><TITLE>xxx</TITLE></HEAD><BODY><XMP>",0,nil);	StrMunger(str,StrLen(str),0, "</XMP></BODY></HTML>\n",0,nil);	str;end*/