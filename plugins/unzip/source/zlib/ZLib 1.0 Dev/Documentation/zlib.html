<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <html lang="en"><head>	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">	<title>ZLib :: Documentation</title>	<style type="text/css">	<!--	body {		background-color : #F0F0F0;		font-color : #002000;	}	a:link {		color: #003000;	}	a:active {		color: #00C000;	}	a:visited {		color: #008000;	}	code {		color: #000000;	}	code.comment {		color: #C00000;	}	-->	</style></head><body bgcolor="#F0F0F0" link="#003000" alink="#00C000" vlink="#008000" text="#002000">	<h2 align="center">ZLib :: Documentation</h2>		<h3>Table of contents</h3>		<ul>		<li><a href="#introduction">Introduction</a>		<li><a href="#newtonscript">NewtonScript interface</a>		<ul>			<li><a href="#version">GetZLibVersion</a>			<li><a href="#deflate">ProtoDeflateStream</a>			<li><a href="#inflate">ProtoInflateStream</a>		</ul><!--	<li><a href="#cpp">C++ interface</a>	-->		<li><a href="#history">Change history</a>	</ul>	<h3><a name="introduction">Introduction</a></h3>	<p>This documentation explains how to use the ZLib Newton port Library prototypes. As I'm writing this,	the ZLib Newton port isn't complete.</p>		<p>The ZLib Newton port is a partial port for NewtonOS of <a href="http://www.gzip.org/zlib/">ZLib 1.1.3</a>	by Jean-loup Gailly &amp; Mark Adler. The reason why it's partial is just that I'm lacking time to finish porting	it (i.e. to write NewtonScript wrappers and the documentation). If you need functions that haven't been ported,	<a href="mailto:pguyot@kallisys.net">contact me</a>.</p>	<p>This documentation supposes that you're used to ZLib APIs. I won't describe them here, I'll just describe	the wrappers. You can find the documentation for the ZLib APIs <a href="http://www.gzip.org/zlib/manual.html">here</a>.</p>		<p>The ZLib can only be interfaced from NewtonScript for the moment.</p>		<h3><a name="newtonscript">NewtonScript Interface</a></h3>	<p>The NewtonScript interface is based on units. For an introduction on units, cf the	<a href="libraries.html">Kallisys Newton Libraries general documentation</a>.	<p>The Units define a function and two prototypes.</p>	<hr>	<h4><a name="version">GetZLibVersion</a></h4>		<p><b>GetZLibVersion</b></p>	<p>call UR( kZLibSymbol, 'GetZLibVersion ) with ()</p>	<p>Returns the version of the ZLib as string.</p>	<table summary="GetZLibVersion parameters">		<tr>			<td>return value</td>			<td>The version of the ZLib library as a NewtonScript (unicode) string.</td>		</tr>	</table>	<hr>	<h4><a name="version">ProtoDeflateStream</a></h4>		<p><b>ProtoDeflateStream</b> is a prototype to deflate (compress) a stream of data.	You use it with the _proto chain of NewtonOS, i.e.:</p>	<pre><code>	local frame myDeflateStream := {		_proto: UR( kZLibSymbol, 'ProtoDeflateStream )	};	</code></pre>		<p>The deflate stream frame has two slots, <code>zstream</code> and <code>zstreamf</code>. <code>zstream</code> is an integer. It's	a pointer to the stream structure for this prototype. Do not use it, just let the methods set/use/remove it. <code>zstreamf</code>	slot is a frame with the NewtonScript representation of some elements of the zstream structure. It has the following slots:</p>	<table summary="zstreamf slots">		<tr>			<td valign="top"><i>bin_in</i></td>			<td valign="top">The binary object to parse data from. This binary can be of any class.</td>		</tr>		<tr>			<td valign="top"><i>next_in</i></td>			<td valign="top">The index (in bytes, zero based) to the data in the binary object. This is an integer, and added to the pointer			of the binary object, it is the next_in field of the zstream structure.</td>		</tr>		<tr>			<td valign="top"><i>avail_in</i></td>			<td valign="top">The number of bytes available in the binary object for input. Beware, there is no check that added to next_in,			this is smaller than the size of the binary. This value is directly converted to/from the zstream avail_in field.</td>		</tr>		<tr>			<td valign="top"><i>total_in</i></td>			<td valign="top">The number of input bytes processed. This field is read from the zstream total_in field.</td>		</tr>		<tr>			<td valign="top"><i>bin_out</i></td>			<td valign="top">The binary object to store output to. This binary can be of any class.</td>		</tr>		<tr>			<td valign="top"><i>next_out</i></td>			<td valign="top">The index (in bytes, zero based) to the data in the binary object. This is an integer, and added to the pointer			of the binary object, it is the next_out field of the zstream structure.</td>		</tr>		<tr>			<td valign="top"><i>avail_out</i></td>			<td valign="top">The number of bytes available in the binary object for output. Beware, there is no check that added to next_out,			this is smaller than the size of the binary. This value is directly converted to/from the zstream avail_out field.</td>		</tr>		<tr>			<td valign="top"><i>total_out</i></td>			<td valign="top">The number of output bytes generated. This field is read from the zstream total_out field.</td>		</tr>		<tr>			<td valign="top"><i>msg</i></td>			<td valign="top">The NewtonScript (Unicode) string representation of the zstream msg field. May be NIL or absent if there			is no message (cf the discussion of methods below).</td>		</tr>	</table>	<p>You can access slots of the object as you normally do in NewtonScript and send messages with the	<code>myDeflateStream:Message( parameters ... )</code> syntax.</p>		<p>The messages are the following:</p>	<p><b>DeflateInit</b></p>	<p><i>deflateStream</i>:DeflateInit(<i>level</i>)</p>	<p>Initialize the deflate stream.</p>	<table summary="DeflateInit parameters">		<tr>			<td valign="top"><i>level</i></td>			<td valign="top"><p>The level of compression to use. This can be NIL, a symbol or an integer (between -1 and 9).</p>			<p>Allowed symbols are:</p>			<table>				<tr><td>'default</td><td>(-1)</td></tr>				<tr><td>'bestspeed</td><td>(1)</td></tr>				<tr><td>'bestcompression</td><td>(9)</td></tr>				<tr><td>'nocompression</td><td>(0)</td></tr>			</table>			<p>If it's NIL, 'default is assumed.</p>			<p>If the input value is an integer, it's passed directly without any check to deflateInit function</p>			</td>		</tr>		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if deflateInit returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>If something went wrong in the NS wrapper, an exception is thrown. If deflateInit didn't return Z_OK and if			zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message (as a NewtonScript string).</p>			<p>If the 'zstreamf slot is present, then it's read and values there are set to the zstream structure before being			passed to deflateInit. This means that deflateInit may do some initialization process. Otherwise, the zstreamf slot is			created. Also, the 'zstream slot will be set to the pointer to the zstream structure and the zstreamf frame will			be filled with the output of deflateInit method.</p>			</td>	</table>	<p><b>DeflateInit2</b></p>	<p><i>deflateStream</i>:DeflateInit2(<i>level, method, windowBits, memLevel, strategy</i>)</p>	<p>Initialize the deflate stream with advanced options.</p>	<table summary="DeflateInit2 parameters">		<tr>			<td valign="top"><i>level</i></td>			<td valign="top"><p>The level of compression to use. This is exactly like level parameter of DeflateInit method.</p>			</td>		</tr>		<tr>			<td valign="top"><i>method</i></td>			<td valign="top"><p>The method of compression to use. This must be either 8 (Z_DEFLATE_METHOD constant) or NIL (in which case 8 is assumed).</p>			</td>		</tr>		<tr>			<td valign="top"><i>windowBits</i></td>			<td valign="top"><p>This must be an integer or NIL. If this is NIL, 15 is assumed (just as with deflateInit function).</p>			<p>The value (normally between 8 and 15) is passed directly to the deflateInit2 function. This means that you can pass			a negative value (e.g. -15) to use the ZLib undocumented feature and bypass the ZLib header.</p>			</td>		</tr>		<tr>			<td valign="top"><i>memLevel</i></td>			<td valign="top"><p>This must be an integer or NIL. If this is NIL, 8 is assumed (just as with deflateInit function).</p>			<p>The value (normally between 1 and 9) is passed directly to the deflateInit2 function. Note: Steve's tests showed that you can run out			of memory with 8 on an MP2000. Lower memory level means worst compression, but unlike modifications of the windowWidth, it doesn't			affect the compatibility.</p>			</td>		</tr>		<tr>			<td valign="top"><i>strategy</i></td>			<td valign="top"><p>The strategy of compression to use. This can be NIL, a symbol or an integer.</p>			<p>Allowed symbols are:</p>			<ul>				<li>'default				<li>'filtered				<li>'huffman_only			</ul>			<p>If it's NIL, 'default is assumed.</p>			<p>If the input value is an integer, it's passed directly without any check to the deflateInit2 function</p>			</td>		</tr>		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if deflateInit2 returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>The discussion about deflateInit applies for deflateInit2 as well.</p>			</td>	</table>	<p><b>Deflate</b></p>	<p><i>deflateStream</i>:Deflate(<i>flush</i>)</p>	<p>Compress some bytes.</p>	<table summary="Deflate parameters">		<tr>			<td valign="top"><i>flush</i></td>			<td valign="top"><p>Which flush behavior to have. This can be NIL, a symbol or an integer.</p>			<p>Allowed symbols are:</p>			<ul>				<li>'no				<li>'partial				<li>'sync				<li>'full				<li>'finish			</ul>			<p>If it's NIL, 'no is assumed.</p>			<p>If the input value is an integer, it's passed directly without any check to the deflate function</p>			</td>		</tr>		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if deflate returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>The role of the flush parameter is explained in the			<a href="http://www.gzip.org/zlib/manual.html">ZLib documentation</a>.</p>			<p>The role of the zstreamf frame slots is exactly the same as the role of the zstream structure as mentioned			in the ZLib documentation.</p>			<p>If an error occured in the NS wrapper, an execption is thrown.  If deflate didn't return Z_OK and if			zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message (as a NewtonScript string).</p>			<p>Note: this is the only method of this prototype which can return an integer (here 1) with normal operations.			Please read the ZLib documentation.</p>			</td>		</tr>	</table>	<p><b>DeflateEnd</b></p>	<p><i>deflateStream</i>:DeflateEnd()</p>	<p>Disposes the deflate stream.</p>	<table summary="DeflateEnd parameters">		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if deflate returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>deflateEnd function is called. Additionally, the zstream structure is disposed			and the 'zstream slot is removed.</p>			<p>The zstreamf slot isn't removed, just because you might want to keep it. It will go away with the			DeflateStream object at next garbage collection, but you can remove it as well to save some NS Heap			bytes.</p>			<p>If an error occured in the NS wrapper, an execption is thrown.  If deflateEnd didn't return Z_OK and if			zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message (as a NewtonScript string).</p>			</td>		</tr>	</table>	<p><b>DeflateReset</b></p>	<p><i>deflateStream</i>:DeflateReset()</p>	<p>Resets the deflate stream.</p>	<table summary="DeflateReset parameters">		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if deflate returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>deflateReset function is called. This is equivalent to deflateEnd			followed by deflateInit.</p>			<p>If an error occured in the NS wrapper, an execption is thrown.  If deflateReset didn't return Z_OK and if			zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message (as a NewtonScript string).</p>			</td>		</tr>	</table>	<hr>	<h4><a name="version">ProtoInflateStream</a></h4>		<p><b>ProtoInflateStream</b> is a prototype to inflate (decompress) a stream of data.	You use it with the _proto chain of NewtonOS, i.e.:</p>	<pre><code>	local frame myInflateStream := {		_proto: UR( kZLibSymbol, 'ProtoInflateStream )	};	</code></pre>		<p>The inflate stream frame has two slots, <code>zstream</code> and <code>zstreamf</code> just like	the deflate stream frame.</p>	<p>You can access slots of the object as you normally do in NewtonScript and send messages with the	<code>myInflateStream:Message( parameters ... )</code> syntax.</p>		<p>The messages are the following:</p>	<p><b>InflateInit</b></p>	<p><i>inflateStream</i>:InflateInit()</p>	<p>Initialize the inflate stream.</p>	<table summary="InflateInit parameters">		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if inflateInit returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>If something went wrong in the NS wrapper, an exception is thrown. If			inflateInit didn't return Z_OK and if zstream-&gt;msg isn't nil, then zstreamf.msg is set			to this message (as a NewtonScript string).</p>			<p>If the 'zstreamf slot is present, then it's read and values there are set to the zstream			structure before being passed to inflateInit. This means that inflateInit may do some			initialization process. Otherwise, the zstreamf slot is created. Also, the 'zstream slot			will be set to the pointer to the zstream structure and the zstreamf frame will be filled			with the output of inflateInit method.</p>			</td>	</table>	<p><b>InflateInit2</b></p>	<p><i>inflateStream</i>:InflateInit2(<i>windowBits</i>)</p>	<p>Initialize the inflate stream with advanced options.</p>	<table summary="InflateInit2 parameters">		<tr>			<td valign="top"><i>windowBits</i></td>			<td valign="top"><p>This must be an integer or NIL. If this is NIL, 15 is assumed (just as with inflateInit function).</p>			<p>The value (normally between 8 and 15) is passed directly to the inflateInit2 function. This means that you can pass			a negative value (e.g. -15) to use the ZLib undocumented feature and bypass the ZLib header.</p>			</td>		</tr>		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if inflateInit2 returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>The discussion about inflateInit applies for inflateInit2 as well.</p>			</td>	</table>	<p><b>Inflate</b></p>	<p><i>inflateStream</i>:Inflate(<i>flush</i>)</p>	<p>Compress some bytes.</p>	<table summary="Inflate parameters">		<tr>			<td valign="top"><i>flush</i></td>			<td valign="top"><p>Which flush behavior to have. This can be NIL, a symbol or an integer.</p>			<p>Allowed symbols are:</p>			<ul>				<li>'no				<li>'partial				<li>'sync				<li>'full				<li>'finish			</ul>			<p>If it's NIL, 'no is assumed.</p>			<p>If the input value is an integer, it's passed directly without any check to the inflate function</p>			</td>		</tr>		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if inflate returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>The role of the flush parameter is explained in the			<a href="http://www.gzip.org/zlib/manual.html">ZLib documentation</a>.</p>			<p>The role of the zstreamf frame slots is exactly the same as the role of the zstream			structure as mentioned in the ZLib documentation.</p>			<p>If an error occured in the NS wrapper, an execption is thrown.  If inflate didn't			return Z_OK and if zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message			(as a NewtonScript string).</p>			<p>Note: this is the only method of this prototype which can return an integer (here 1)			with normal operations. Please read the ZLib documentation.</p>			</td>		</tr>	</table>	<p><b>InflateEnd</b></p>	<p><i>inflateStream</i>:InflateEnd()</p>	<p>Disposes the inflate stream.</p>	<table summary="InflateEnd parameters">		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if inflate returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>inflateEnd function is called. Additionally, the zstream structure is disposed			and the 'zstream slot is removed.</p>			<p>The zstreamf slot isn't removed, just because you might want to keep it. It will go away with the			InflateStream object at next garbage collection, but you can remove it as well to save some NS Heap			bytes.</p>			<p>If an error occured in the NS wrapper, an execption is thrown.  If inflateEnd didn't return Z_OK and if			zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message (as a NewtonScript string).</p>			</td>		</tr>	</table>	<p><b>InflateReset</b></p>	<p><i>inflateStream</i>:InflateReset()</p>	<p>Resets the inflate stream.</p>	<table summary="InflateInit parameters">		<tr>			<td valign="top">return value</td>			<td valign="top"><code>NIL</code> if inflate returned Z_OK, an integer otherwise.</td>		</tr>		<tr>			<td valign="top"><b>Discussion</b></td>			<td valign="top"><p>inflateReset function is called. This is equivalent to inflateEnd			followed by inflateInit.</p>			<p>If an error occured in the NS wrapper, an execption is thrown.  If inflateReset didn't return Z_OK and if			zstream-&gt;msg isn't nil, then zstreamf.msg is set to this message (as a NewtonScript string).</p>			</td>		</tr>	</table>	<hr>	<h3><a name="history">Change history</a></h3>	<ul>		<li>2001/11/04: v1 - Initial release	</ul>		<hr>	<small>Copyright 2001 by Paul Guyot. All rights reserved worldwide.</small></body></html>