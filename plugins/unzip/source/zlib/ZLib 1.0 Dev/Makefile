# =========== Header ===========# File:					Makefile# Project:				ZLib for NewtonOS# Written by:			Paul Guyot (pguyot@kallisys.net)## Created on:			09/18/2001# Internal version:		1## Copyright:			© 2001 by Paul Guyot.# 						All rights reserved worldwide.# ===========# =========== Change History ===========# 09/02/2001	v1	[PG]	Creation of the file# ===========# Makefile for the native module of the NewtonOS port of ZLib# (to be used with MPW).# This makefile is based on the one I developped for the ATA Support project.# It doesn't use the Newton C++ Toolbox build system but MPW's built-in build system.# The targets you probably want to play with (from the Build Menu -> BuildÉ) are:#	all			# same as debug & nodebug#	debug		# make dependencies and builds the debug targets#	nodebug		# make dependencies and builds the nodebug targets#	clean		# remove all binaries/objects# Note for MPW beginners: the current directory must be the directory of this makefile.# What we are building with this makefile:# a/ the ZLib NTK native module# ArmCpp options (from the ARM SDT Reference manual):# -fy:# Treats enumerations as signed integers. This option is off by default (no# forced integers).# -zo:# Generates one AOF area for each function. This can result in increased# code size.# Normally the compiler generates one AOF function for each C# compilation unit, and at least one AOF function for each C++# compilation unit.# This option enables the linker to remove unused functions when the# -remove linker option is specified.# -fa:# Checks for certain types of data flow anomalies. The compiler performs# data flow analysis as part of code generation. The checks enabled by this# option indicate when an automatic variable could have been used before# it has been assigned a value. The check is pessimistic and will sometimes# report an anomaly where there is none, especially in code like this:# int initialized = 0, value;# É# if (initialized) { int v = value; É# É value = É; initialized = 1; }# Here, value is read-only if initialized has been set. This is a# semantic deduction, not a data flow implication, so -fa reports an# anomaly. In general, it is useful to check all code using -fa at some stage# during its development.# -fq:# ? Apparently, if I remove this option, the compiler complains "Error: junk at end of #endif line - ignored"# -fc:# ?# Various Options:MAKEFILE			=	Makefile# Directories:ObjectsDir			=	:Objects:ObjectsCommonDir	=	:Objects:Common:ObjectsNoDebugDir	=	:Objects:NoDebug:ObjectsDebugDir		=	:Objects:Debug:BinariesDir			=	:Binaries:BinariesNoDebugDir	=	:Binaries:NoDebug:BinariesDebugDir	=	:Binaries:Debug:# Commands & options:Link				=	ARMLinkLinkOptionsCommon	=	-dupok -remove -aif -bin -relLinkOptionsNoDebug	=LinkOptionsDebug	=	LinkOptionsNTKC		=	-debugLinkOptionsNE2K		=	LinkOptionsRCH		=	Asm					=	ARM6AsmAsmOptionsCommon	=AsmOptionsNoDebug	=AsmOptionsDebug		=	-gCPlus				=	ARMCppCPlusOptionsDefines	=	-d hasPCMCIA -d forARM -d NO_ERRNO_H -d STDCCPlusOptionsCommon	=	-facqy -zo -W -cfront {CPlusOptionsDefines}CPlusOptionsNoDebug	=CPlusOptionsDebug	=	-d forDebugCPlusOptionsNTKC	=	-gfC					=	ARM6CCOptionsDefines		=	{CPlusOptionsDefines}COptionsCommon		=	-facq -zo -W {COptionsDefines}COptionsNoDebug		=COptionsDebug		=	-d forDebugCOptionsNTKC		=	-gfAIFtoNTK			=	AIFtoNTKPacker				=	PackerPackerOptions		=	-packageid 'xxxx'# Source files: (used to build the dependencies)# The impl.h & .h are not there because MakeDepend doesn't handle them.# The .o's are not $OutOfDate because actually they'll be rarely changed if the .impl.h isn't changed.#Sources				=	":NTKModule:ZLib.cp" ¶						":zlib:adler32.c" ¶						":zlib:compress.c" ¶						":zlib:crc32.c" ¶						":zlib:deflate.c" ¶#						":zlib:gzio.c" ¶						":zlib:infblock.c" ¶						":zlib:infcodes.c" ¶						":zlib:inffast.c" ¶						":zlib:inflate.c" ¶						":zlib:inftrees.c" ¶						":zlib:infutil.c" ¶						":zlib:trees.c" ¶						":zlib:uncompr.c" ¶						":zlib:zutil.c"# Include paths:AsmIncludes			=CPlusIncludes		=	-i ":Common:" ¶						-i ":NTKModule:" ¶						-i ":zlib:" ¶						-i "{DDK_Includes-dir}" ¶						-i "{DDK_Includes-dir}Bootstrap:" ¶						-i "{DDK_Includes-dir}CLibrary:" ¶						-i "{DDK_Includes-dir}CommAPI:" ¶						-i "{DDK_Includes-dir}Communications:" ¶						-i "{DDK_Includes-dir}Frames:" ¶						-i "{DDK_Includes-dir}HAL:" ¶						-i "{DDK_Includes-dir}Lantern:" ¶						-i "{DDK_Includes-dir}OS600:" ¶						-i "{DDK_Includes-dir}Packages:" ¶						-i "{DDK_Includes-dir}Power:" ¶						-i "{DDK_Includes-dir}QD:" ¶						-i "{DDK_Includes-dir}Toolbox:" ¶						-i "{DDK_Includes-dir}UtilityClasses:" ¶						-i "{DDK_Includes-dir}PCMCIA:" ¶						-i "{NCT_Includes}" ¶						-i "{NCT_Includes}Frames:" ¶						-i "{NCT_Includes}Utilities:" ¶						-i "{NCT_Includes}:LanternDriver_DDK:Includes:" ¶						-i "{NCT_Includes}:NSandDDK:"CIncludesOptions	=	{CPlusIncludes}# Libraries I'm linking with:LibrariesCommon		=	"{NCT_Libraries}Newton Public APIs.o"LibrariesNTKC		=	# Directory rules (where to find the source files)"{ObjectsCommonDir}"	Ä "{ObjectsCommonDir}" :Common: :NTKModule: :zlib:"{ObjectsNoDebugDir}"	Ä "{ObjectsNoDebugDir}" :Common: :NTKModule: :zlib:"{ObjectsDebugDir}"		Ä "{ObjectsDebugDir}" :Common: :NTKModule: :zlib:# Binaries:# Binaries with the entry points:ObjectsNTKC			=	"{ObjectsCommonDir}ZLib.exp.o"# Common: binaries for which the forDebug flag won't change anything:ObjectsCommon		=	"{ObjectsCommonDir}adler32.c.o" ¶						"{ObjectsCommonDir}compress.c.o" ¶						"{ObjectsCommonDir}crc32.c.o" ¶						"{ObjectsCommonDir}deflate.c.o" ¶#						"{ObjectsCommonDir}gzio.c.o" ¶						"{ObjectsCommonDir}infblock.c.o" ¶						"{ObjectsCommonDir}infcodes.c.o" ¶						"{ObjectsCommonDir}inffast.c.o" ¶						"{ObjectsCommonDir}inflate.c.o" ¶						"{ObjectsCommonDir}inftrees.c.o" ¶						"{ObjectsCommonDir}infutil.c.o" ¶						"{ObjectsCommonDir}trees.c.o" ¶						"{ObjectsCommonDir}uncompr.c.o" ¶						"{ObjectsCommonDir}zutil.c.o"ObjectsNoDebug		=	"{ObjectsNoDebugDir}ZLib.cp.o"ObjectsDebug		=	"{ObjectsDebugDir}ZLib.cp.d.o"# ------ Generic build rules ------# --- Common rules ---.exp.a		Ä		.exp	"{NCTTools}"NCTBuildMain {depDir}{Default}.exp {targDir}{Default}.exp.a.exp.o		Ä		.exp.a	{Asm} {depDir}{Default}.exp.a -o {targDir}{Default}.exp.o# --- No Debug rules ---.cp.o		Ä		.cp	{CPlus}	{depDir}{Default}.cp {CPlusOptionsCommon} {CPlusOptionsNoDebug} {CPlusIncludes} -o {targDir}{Default}.cp.o.c.o		Ä		.c	{C}	{depDir}{Default}.c {COptionsCommon} {COptionsNoDebug} {CIncludesOptions} -o {targDir}{Default}.c.o.a.o		Ä		.a	{Asm} {depDir}{Default}.a {AsmOptionsCommon} {AsmOptionsNoDebug} {AsmIncludes} -o {targDir}{Default}.a.o.h.a		Ä		.h	ProtocolGen -InterfaceGlue {depDir}{Default}.h {CPlusOptionsDefines} {CPlusOptionsNoDebug} {CPlusIncludes} -stdout > {targDir}{Default}.h.a.h.o		Ä		.h.a	{Asm} {depDir}{Default}.h.a -o {targDir}{Default}.h.o.impl.h.a	Ä		.impl.h	ProtocolGen -ImplementationGlue {depDir}{Default}.impl.h {CPlusOptionsDefines} {CPlusOptionsNoDebug} {CPlusIncludes} -stdout > {targDir}{Default}.impl.h.a.impl.h.o	Ä		.impl.h.a	{Asm} {depDir}{Default}.impl.h.a -o {targDir}{Default}.impl.h.o.impl.a	Ä		.impl.h	ProtocolGen -ImplementationGlue {depDir}{Default}.impl.h -package {CPlusOptionsDefines} {CPlusOptionsNoDebug} {CPlusIncludes} -stdout > {targDir}{Default}.impl.a.impl.o	Ä		.impl.a	{Asm} {depDir}{Default}.impl.a -o {targDir}{Default}.impl.o# --- Debug rules ---.cp.d.o		Ä		.cp	{CPlus}	{depDir}{Default}.cp {CPlusOptionsCommon} {CPlusOptionsDebug} {CPlusIncludes} -o {targDir}{Default}.cp.d.o.c.d.o		Ä		.c	{C}	{depDir}{Default}.c {COptionsCommon} {COptionsDebug} {CIncludesOptions} -o {targDir}{Default}.c.d.o.a.d.o		Ä		.a	{Asm} {depDir}{Default}.a {AsmOptionsCommon} {AsmOptionsDebug} {AsmIncludes} -o {targDir}{Default}.a.d.o.h.d.a		Ä		.h	ProtocolGen -InterfaceGlue {depDir}{Default}.h {CPlusOptionsDefines} {CPlusOptionsDebug} {CPlusIncludes} -stdout > {targDir}{Default}.h.d.a.h.d.o		Ä		.h.d.a	{Asm} {depDir}{Default}.h.d.a -o {targDir}{Default}.h.d.o.impl.h.d.a	Ä		.impl.h	ProtocolGen -ImplementationGlue {depDir}{Default}.impl.h {CPlusOptionsDefines} {CPlusOptionsDebug} {CPlusIncludes} -stdout > {targDir}{Default}.impl.h.d.a.impl.h.d.o	Ä		.impl.h.d.a	{Asm} {depDir}{Default}.impl.h.d.a -o {targDir}{Default}.impl.h.d.o.impl.d.a	Ä		.impl.h	ProtocolGen -ImplementationGlue {depDir}{Default}.impl.h -package {CPlusOptionsDefines} {CPlusOptionsDebug} {CPlusIncludes} -stdout > {targDir}{Default}.impl.d.a.impl.d.o	Ä		.impl.d.a	{Asm} {depDir}{Default}.impl.d.a -o {targDir}{Default}.impl.d.o# --- Specific rules ---# I need specific rules for the NTKC entry points. They should be compiled with -gf to make AIFtoNTK happy."{ObjectsNoDebugDir}ZLib.cp.o"	Ä	:NTKModule:ZLib.cp	{CPlus}	:NTKModule:ZLib.cp {CPlusOptionsCommon} {CPlusOptionsNoDebug} {CPlusOptionsNTKC} {CPlusIncludes} -o {Targ}"{ObjectsDebugDir}ZLib.cp.d.o"	Ä	:NTKModule:ZLib.cp	{CPlus}	:NTKModule:ZLib.cp {CPlusOptionsCommon} {CPlusOptionsDebug} {CPlusOptionsNTKC} {CPlusIncludes} -o {Targ}# ------ General rules ------# These are the rules to use (with make foo)clean		Ä	delete -ay -y "{ObjectsDir}"	delete -ay -y "{BinariesDir}"	newfolder "{ObjectsDir}"	newfolder "{ObjectsDebugDir}"	newfolder "{ObjectsNoDebugDir}"	newfolder "{ObjectsCommonDir}"	newfolder "{BinariesDir}"	newfolder "{BinariesDebugDir}"	newfolder "{BinariesNoDebugDir}"all			Ä	nodebug debugnodebug		Ä	DepNoDebug	set echo 0	BuildProgram	nodebugtargets	set echo 1debug		Ä	DepDebug	set echo 0	BuildProgram	debugtargets	set echo 1nodebugtargets	Ä	"{BinariesNoDebugDir}ZLib.ntkc"debugtargets	Ä	"{BinariesDebugDir}ZLib.ntkc"# ------ NTKC modules ------# --- NoDebug rules ---"{ObjectsNoDebugDir}ZLib.ntkc"	Ä	{ObjectsNTKC} {ObjectsNoDebug} {ObjectsCommon} {LibrariesCommon} {LibrariesNTKC}	{Link} {LinkOptionsCommon} {LinkOptionsNoDebug} {LinkOptionsNTKC} -o {Targ} {ObjectsNTKC} {ObjectsNoDebug} {ObjectsCommon} {LibrariesCommon} {LibrariesNTKC}	Rename -y {Targ} "{ObjectsNoDebugDir}ZLib.sym"	{AIFtoNTK} {LocalAIFtoNTKOptions} -via :NTKModule:ZLib.exp -o {Targ} "{ObjectsNoDebugDir}ZLib.sym"	Rez "{NCTTools}NCTIcons.r" -i "{RIncludes}" -append -o {Targ}	setfile -a C {Targ}"{BinariesNoDebugDir}ZLib.ntkc"	Ä	"{ObjectsNoDebugDir}ZLib.ntkc"	duplicate -y "{ObjectsNoDebugDir}ZLib.ntkc" "{BinariesNoDebugDir}"# --- Debug rules ---"{ObjectsDebugDir}ZLib.ntkc"	Ä	{ObjectsNTKC} {ObjectsDebug} {ObjectsCommon} {LibrariesCommon} {LibrariesNTKC}	{Link} {LinkOptionsCommon} {LinkOptionsDebug} {LinkOptionsNTKC} -o {Targ} {ObjectsNTKC} {ObjectsDebug} {ObjectsCommon} {LibrariesCommon} {LibrariesNTKC}	Rename -y {Targ} "{ObjectsDebugDir}ZLib.sym"	{AIFtoNTK} {LocalAIFtoNTKOptions} -via :NTKModule:ZLib.exp -o {Targ} "{ObjectsDebugDir}ZLib.sym" 	Rez "{NCTTools}NCTIcons.r" -i "{RIncludes}" -append -o {Targ}	setfile -a C {Targ}"{BinariesDebugDir}ZLib.ntkc"	Ä	"{ObjectsDebugDir}ZLib.ntkc"	duplicate -y "{ObjectsDebugDir}ZLib.ntkc" "{BinariesDebugDir}"# --- Dependencies ---DepNoDebug  Ä  $OutOfDate	MakeDepend ¶		-append {MAKEFILE} ¶		-ignore "{DDK_Includes-dir}" ¶		-ignore "{NCT_Includes}" ¶		-ignore "{CIncludes}" ¶		-objdir "{ObjectsNoDebugDir}" ¶		-objext .o ¶		{CPlusIncludes} ¶		{Sources}DepDebug  Ä  $OutOfDate	MakeDepend ¶		-append {MAKEFILE} ¶		-ignore "{DDK_Includes-dir}" ¶		-ignore "{NCT_Includes}" ¶		-ignore "{CIncludes}" ¶		-objdir "{ObjectsDebugDir}" ¶		-objext .d.o ¶		{CPlusIncludes} ¶		{Sources}## ======================================================================== #### Ummm, well, OK.  The network's the network, the computer's the computer. #### Sorry for the confusion.                                                 ####                 -- Sun Microsystems                                      #### ======================================================================== ### The dependencies are appended here: