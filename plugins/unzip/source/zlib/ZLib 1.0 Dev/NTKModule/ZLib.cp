// =========== Header ===========// File:				ZLib.cp// Project:				ZLib for NewtonOS// Written by:			Paul Guyot (pguyot@kallisys.net)//// Created on:			09/18/2001// Internal version:	1//// Copyright:			© 2001 by Paul Guyot.// 						All rights reserved worldwide.// ===========// =========== Change History ===========// 09/18/2001	v1	[PG]	Creation of the file// ===========// I need byte defined because of zlib.h#define __byte_defined__ 1#ifndef __NSANDDDKINCLUDES__	#include "NSandDDKIncludes.h"#endif#ifndef __ZLIBDEFINES__	#include "ZLibDefines.h"#endif#ifndef	__NEWTONSCRIPT_H	#include <NewtonScript.h>#endif#ifndef __NAMESERVER_H	#include <NameServer.h>#endif#ifndef __NEWTONEXCEPTIONS_H	#include <NewtonExceptions.h>#endif#ifndef __OSERRORS_H	#include <OSErrors.h>#endif#ifndef __NEWTONERRORS_H	#include <NewtonErrors.h>#endif#include "zlib.h"// ========================================================================	////	Prototypes// ========================================================================	//// extern "C"{	Ref FZlibVersion( RefArg inRcvr );	Ref FDeflateInit( RefArg inRcvr, RefArg inLevel );	Ref FDeflateInit2( RefArg inRcvr, RefArg inLevel, RefArg inMethod, RefArg inWindowBits, RefArg inMemLevel, RefArg inStrategy );	Ref FDeflate( RefArg inRcvr, RefArg inFlush );	Ref FDeflateEnd( RefArg inRcvr );	Ref FDeflateReset( RefArg inRcvr );	Ref FInflateInit( RefArg inRcvr );	Ref FInflateInit2( RefArg inRcvr, RefArg inWindowBits );	Ref FInflate( RefArg inRcvr, RefArg inFlush );	Ref FInflateEnd( RefArg inRcvr );	Ref FInflateReset( RefArg inRcvr );}// ------------------------------------------------------------------------	////	¥ FZlibVersion( RefArg )// ------------------------------------------------------------------------	//// Return the version of the ZLib in a NewtonScript Unicode string.//// The application can compare zlibVersion and ZLIB_VERSION for consistency.// If the first character differs, the library code actually used is// not compatible with the zlib.h header file used by the application.// This check is automatically made by deflateInit and inflateInit.extern "C" Ref FZlibVersion( RefArg inRcvr ){	return ::MakeString( zlibVersion() );}// ------------------------------------------------------------------------	////	¥ FDeflateInit( RefArg, RefArg )// ------------------------------------------------------------------------	//// This function takes one parameter, the level.// This can be NIL, a symbol or an integer (between -1 and 9).// If it's an integer, it's passed directly to the deflateInit function.// Allowed symbols are://  'default			(-1)//	'bestspeed			(1)//	'bestcompression	(9)//	'nocompression		(0)// If it's NIL, default is assumed.// The pointer to the compress stream object is stored in the rcvr's zstream slot.// This method also creates a frame stored in the zstreamf slot of the rcvr,// with various slots for use with FDeflate & FDeflateEnd. Cf FDeflate for how// to use these slots. If the frame already exists, none of these slots is// initialized here (so you have to do it yourself before calling FDeflate/FDeflateEnd).// Anyway, you have to set bin_in, bin_out, avail_in & avail_out before calling// these functions as well.// The function returns NIL if deflateInit returned Z_OK, an integer otherwise// and throws an exception if something went wrong before.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)extern "C" Ref FDeflateInit( RefArg inRcvr, RefArg inLevel ){	return FDeflateInit2( inRcvr, inLevel, NILREF, NILREF, NILREF, NILREF );}// ------------------------------------------------------------------------	////	¥ FDeflateInit2( RefArg, RefArg )// ------------------------------------------------------------------------	//// This is a more advanced way than FDeflateInit to initialize a deflate stream.// Cf FDeflate for more informations.// First argument is the level, and it behaves exactly as in FDeflateInit.// Second argument is the method.//	It must be Z_DEFLATE_METHOD (8)//	If it is NIL, 8 is assumed.// Third argument is the windowBits parameter.//	It must be an integer between 8 and 15 (it's directly passed to the ZLib)//	If it is NIL, 15 is assumed.//		Note: there is an undocumented feature of ZLib which skips the header if this value is negative.// Fourth argument is the memLevel parameter.//	It must be an integer between 1 & 9.//	If it is NIL, 8 is assumed.// Fifth argument is the strategy.//	It can be a symbol ('default, 'filtered, 'huffman_only)//	It can also be an integer, then passed directly to deflateInit2 ZLib function.//	Or it can be NIL, in which case 'default is assumed.extern "C" Ref FDeflateInit2( RefArg inRcvr, RefArg inLevel, RefArg inMethod, RefArg inWindowBits, RefArg inMemLevel, RefArg inStrategy ){	int theLevel;	do {	// Fake loop for the determination of the level.		if (inLevel == NILREF)		{			theLevel = Z_DEFAULT_COMPRESSION;			break;		}		if (ISINT( inLevel ))		{			theLevel = RINT( inLevel );			break;		}		if (::IsSymbol( inLevel ))		{			if (::SymbolCompareLex( inLevel, Intern( "default" ) ) == 0)			{				theLevel = Z_DEFAULT_COMPRESSION;				break;			}			if (::SymbolCompareLex( inLevel, Intern( "bestspeed" ) ) == 0)			{				theLevel = Z_BEST_SPEED;				break;			}			if (::SymbolCompareLex( inLevel, Intern( "bestcompression" ) ) == 0)			{				theLevel = Z_BEST_COMPRESSION;				break;			}			if (::SymbolCompareLex( inLevel, Intern( "nocompression" ) ) == 0)			{				theLevel = Z_NO_COMPRESSION;				break;			}		}				::ThrowBadTypeWithFrameData( inLevel, kNSErrNotAnInteger );	// Closest to what we want to say.	} while (0);		int theMethod;	if (inMethod == NILREF)		theMethod = 8;	else		theMethod = RINT( inMethod );	// Will throw an exception if it's not an integer.			int theWindowBits;	if (inWindowBits == NILREF)		theWindowBits = 15;	else		theWindowBits = RINT( inWindowBits );	// Idem.		int theMemLevel;	if (inMemLevel == NILREF)		theMemLevel = 8;	else		theMemLevel = RINT( inMemLevel );	// Idem.	int theStrategy;	do {	// Fake loop for the determination of the level.		if (inStrategy == NILREF)		{			theStrategy = Z_DEFAULT_STRATEGY;			break;		}		if (ISINT( inStrategy ))		{			theStrategy = RINT( inStrategy );			break;		}		if (::IsSymbol( inStrategy ))		{			if (::SymbolCompareLex( inStrategy, Intern( "default" ) ) == 0)			{				theStrategy = Z_DEFAULT_STRATEGY;				break;			}			if (::SymbolCompareLex( inStrategy, Intern( "filtered" ) ) == 0)			{				theStrategy = Z_FILTERED;				break;			}			if (::SymbolCompareLex( inStrategy, Intern( "huffman_only" ) ) == 0)			{				theStrategy = Z_HUFFMAN_ONLY;				break;			}		}				::ThrowBadTypeWithFrameData( inStrategy, kNSErrNotAnInteger );	// Closest to what we want to say.	} while (0);		// Allocate the zstreamf frame if required.	RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );	if (theZStreamF == NILREF)	{		theZStreamF = ::AllocateFrame();		::SetFrameSlot( theZStreamF, Intern( "bin_in" ), NILREF );		::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( 0 ) );		::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( 0 ) );		::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( 0 ) );		::SetFrameSlot( theZStreamF, Intern( "bin_out" ), NILREF );		::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( 0 ) );		::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( 0 ) );		::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( 0 ) );		// Add it to the frame.		::SetFrameSlot( inRcvr, Intern( "zstreamf" ), theZStreamF );	}	// Create the zstream object.	z_stream* theZStream = new z_stream;		if (theZStream == nil)		::OutOfMemory();		// Basic initialization of it.	theZStream->zalloc = (alloc_func)0;	theZStream->zfree = (free_func)0;	theZStream->opaque = (voidpf)0;	theZStream->next_in = nil;	theZStream->avail_in = 0;	theZStream->total_in = 0;	theZStream->next_out = nil;	theZStream->avail_out = 0;	theZStream->total_out = 0;	// Store it in our frame	// Note: I'm using try catch here to release the pointer.	newton_try	{		::SetFrameSlot( inRcvr, Intern( "zstream" ), (Ref) theZStream );	}	cleanup	{		delete theZStream;	}	end_try;		// Then, call deflateInit2.	int theResult = ::deflateInit2( theZStream, theLevel, theMethod, theWindowBits, theMemLevel, theStrategy );		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}			return theNSResult;}// ------------------------------------------------------------------------	////	¥ FDeflate( RefArg, RefArg )// ------------------------------------------------------------------------	//// The function returns NIL if deflate returned Z_OK, an integer otherwise.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)// Throws various exceptions if things aren't as expected in the rcvr frame.// It uses the zstreamf slot the following way://	bin_in, bin_out: (input) binaries which are locked before the operation is done.//  next_in, next_out: (input/output) indexes in each binaries for the data to be//		read/written. Updated.//	avail_in, avail_out: (intput/output) number of bytes available in each buffer.//		Normally, you want next_in + avail_in = Length( bin_in )//		If it's greater, bad things will happenª©¨//	total_in, total_out: (output) updated to the ztream struct values.//	Correct values for inFlush are a symbol ('no, 'partial, 'sync, 'full, 'finish),//	nil (means no) or an integer (deflate wants something between 0 and 4)extern "C" Ref FDeflate( RefArg inRcvr, RefArg inFlush ){	RefVar theZStreamR = ::GetFrameSlot( inRcvr, Intern( "zstream" ) );		if (!ISINT( theZStreamR ))	{		::ThrowBadTypeWithFrameData( theZStreamR, kNSErrNotAnInteger );	}		z_stream* theZStream = (z_stream*) (Ref) theZStreamR;		int theFlush;	do {	// Fake loop for the determination of the level.		if (inFlush == NILREF)		{			theFlush = Z_NO_FLUSH;			break;		}		if (ISINT( inFlush ))		{			theFlush = RINT( inFlush );			break;		}		if (::IsSymbol( inFlush ))		{			if (::SymbolCompareLex( inFlush, Intern( "no" ) ) == 0)			{				theFlush = Z_NO_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "partial" ) ) == 0)			{				theFlush = Z_PARTIAL_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "sync" ) ) == 0)			{				theFlush = Z_SYNC_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "full" ) ) == 0)			{				theFlush = Z_FULL_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "finish" ) ) == 0)			{				theFlush = Z_FINISH;				break;			}		}				::ThrowBadTypeWithFrameData( inFlush, kNSErrNotAnInteger );	// Closest to what we want to say.	} while (0);		// Then setup the next_in, avail_in, next_out & avail_out accordingly.		RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		int theResult;	RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );	RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );	WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )		WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )			theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );			theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );			theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );			theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );			// Then, call deflate.			theResult = ::deflate( theZStream, theFlush );			// Update all slots in the frame.			::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );			::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );			::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );			::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );			::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );			::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );		END_WITH_LOCKED_BINARY( theBinaryOut );		END_WITH_LOCKED_BINARY( theBinaryIn );		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}			return theNSResult;}// ------------------------------------------------------------------------	////	¥ FDeflateEnd( RefArg )// ------------------------------------------------------------------------	//// The function returns NIL if deflateEnd returned Z_OK, an integer otherwise.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)// It disposes the ZStream and removes the zstream slot.// Throws various exceptions if things aren't as expected in the rcvr frame.// It doesn't remove the zstreamf slot.// It uses the zstreamf slot like FDeflateextern "C" Ref FDeflateEnd( RefArg inRcvr ){	RefVar theZStreamR = ::GetFrameSlot( inRcvr, Intern( "zstream" ) );		if (!ISINT( theZStreamR ))	{		::ThrowBadTypeWithFrameData( theZStreamR, kNSErrNotAnInteger );	}		z_stream* theZStream = (z_stream*) (Ref) theZStreamR;		// Then setup the next_in, avail_in, next_out & avail_out accordingly.		RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		int theResult;	RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );	RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );	// Note: if the binaries aren't set, I'll use 0.		if (::IsBinary( theBinaryIn ) && ::IsBinary( theBinaryOut ))	{		WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )			WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )				theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );				theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );				theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );				theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );				// Then, call deflateEnd.				theResult = ::deflateEnd( theZStream );				// Update all slots in the frame.				::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );				::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );				::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );				::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );			END_WITH_LOCKED_BINARY( theBinaryOut );			END_WITH_LOCKED_BINARY( theBinaryIn );	} else {		// DeflateEnd may be called just after DeflateInit, to dispose the memory.		theZStream->next_in = nil;		theZStream->avail_in = 0;		theZStream->next_out = nil;		theZStream->avail_out = 0;		// Then, call deflateEnd.		theResult = ::deflateEnd( theZStream );		// Update all slots in the frame.		::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );		::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );		::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );		::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );	}		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}		// Dispose the zstream pointer.	delete [] theZStream;		// Remove the zstream slot.	::RemoveSlot( inRcvr, Intern( "zstream" ) );	// I don't remove the zstreamf slot because the caller may want to read availout or totalout.		return theNSResult;}// ------------------------------------------------------------------------	////	¥ FDeflateReset( RefArg )// ------------------------------------------------------------------------	//// The function returns NIL if deflateReset returned Z_OK, an integer otherwise.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)// Throws various exceptions if things aren't as expected in the rcvr frame.// It uses the zstreamf slot like FDeflateextern "C" Ref FDeflateReset( RefArg inRcvr ){	RefVar theZStreamR = ::GetFrameSlot( inRcvr, Intern( "zstream" ) );		if (!ISINT( theZStreamR ))	{		::ThrowBadTypeWithFrameData( theZStreamR, kNSErrNotAnInteger );	}		z_stream* theZStream = (z_stream*) (Ref) theZStreamR;		// Then setup the next_in, avail_in, next_out & avail_out accordingly.		RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		int theResult;	RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );	RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );	// Note: if the binaries aren't set, I'll use 0.		if (::IsBinary( theBinaryIn ) && ::IsBinary( theBinaryOut ))	{		WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )			WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )				theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );				theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );				theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );				theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );				// Then, call deflateReset.				theResult = ::deflateReset( theZStream );				// Update all slots in the frame.				::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );				::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );				::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );				::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );			END_WITH_LOCKED_BINARY( theBinaryOut );			END_WITH_LOCKED_BINARY( theBinaryIn );	} else {		// DeflateEnd may be called just after DeflateInit, to dispose the memory.		theZStream->next_in = nil;		theZStream->avail_in = 0;		theZStream->next_out = nil;		theZStream->avail_out = 0;		// Then, call deflateReset.		theResult = ::deflateReset( theZStream );		// Update all slots in the frame.		::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );		::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );		::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );		::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );	}		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}		return theNSResult;}// ------------------------------------------------------------------------	////	¥ FInflateInit( RefArg )// ------------------------------------------------------------------------	//// The pointer to the compress stream object is stored in the rcvr's zstream slot.// This method also creates a frame stored in the zstreamf slot of the rcvr, if required,// with various slots for use with FInflate & FInflateEnd.// If the frame already exists, not only none of these slots is initialized// but moreover the frame is processed and the whole thing is passed to inflateInit// which will start decompression of the frame (cf inflateInit's doc in zlib.h)// The function returns NIL if inflateInit returned Z_OK, an integer otherwise// and throws an exception if something went wrong before.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)extern "C" Ref FInflateInit( RefArg inRcvr ){	return FInflateInit2( inRcvr, NILREF );}// ------------------------------------------------------------------------	////	¥ FInflateInit2( RefArg, RefArg )// ------------------------------------------------------------------------	//// This is a more advanced way than FInflateInit to initialize a deflate stream.// Cf FInflateInit for more informations.// Argument is the windowBits parameter.//	It must be an integer between 8 and 15 (it's directly passed to the ZLib)//	If it is NIL, 15 is assumed.//		Note: there is an undocumented feature of ZLib which skips the header if this value is negative.extern "C" Ref FInflateInit2( RefArg inRcvr, RefArg inWindowBits ){	int theWindowBits;	if (inWindowBits == NILREF)		theWindowBits = 15;	else		theWindowBits = RINT( inWindowBits );	// Idem.		// Create the zstream object.	z_stream* theZStream = new z_stream;	if (theZStream == nil)		::OutOfMemory();	// Basic initialization of the frame.	theZStream->zalloc = (alloc_func)0;	theZStream->zfree = (free_func)0;	theZStream->opaque = (voidpf)0;		int theResult;	RefVar theZStreamF;		newton_try	{		// Store the pointer of the struct to our frame		::SetFrameSlot( inRcvr, Intern( "zstream" ), (Ref) theZStream );		// Allocate the zstreamf frame if required.		theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		if (theZStreamF == NILREF)		{			theZStreamF = ::AllocateFrame();			::SetFrameSlot( theZStreamF, Intern( "bin_in" ), NILREF );			::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( 0 ) );			::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( 0 ) );			::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( 0 ) );			::SetFrameSlot( theZStreamF, Intern( "bin_out" ), NILREF );			::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( 0 ) );			::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( 0 ) );			::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( 0 ) );			// Add it to the rcvr frame.			::SetFrameSlot( inRcvr, Intern( "zstreamf" ), theZStreamF );			// Setting the corresponding slots in the struct:			theZStream->next_in = nil;			theZStream->avail_in = 0;			theZStream->next_out = nil;			theZStream->avail_out = 0;			// These two are set to 0 anyway.			theZStream->total_in = 0;			theZStream->total_out = 0;			// Then, call inflateInit2			theResult = ::inflateInit2( theZStream, theWindowBits );		} else {			// I read the values from the frame and I set the according fields of the struct.			RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );			RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );						WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )					WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )					theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );					theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );					theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );					theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );					// Then, call inflateInit					theResult = ::inflateInit2( theZStream, theWindowBits );					// Update all slots in the frame.					::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );					::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );					::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );					::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );					::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );					::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );				END_WITH_LOCKED_BINARY( theBinaryOut );				END_WITH_LOCKED_BINARY( theBinaryIn );		}	}	cleanup	{		delete theZStream;	}	end_try;		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}		return theNSResult;}// ------------------------------------------------------------------------	////	¥ FInflate( RefArg, RefArg )// ------------------------------------------------------------------------	//// The function returns NIL if inflate returned Z_OK, an integer otherwise.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)// Throws various exceptions if things aren't as expected in the rcvr frame.// It uses the zstreamf slot the following way://	bin_in, bin_out: (input) binaries which are locked before the operation is done.//  next_in, next_out: (input/output) indexes in each binaries for the data to be//		read/written. Updated.//	avail_in, avail_out: (intput/output) number of bytes available in each buffer.//		Normally, you want next_in + avail_in = Length( bin_in )//		If it's greater, bad things will happenª©¨//	total_in, total_out: (output) updated to the ztream struct values.//	Correct values for inFlush are a symbol ('no, 'partial, 'sync, 'full, 'finish),//	nil (means no) or an integer (deflate wants something between 0 and 4)extern "C" Ref FInflate( RefArg inRcvr, RefArg inFlush ){	RefVar theZStreamR = ::GetFrameSlot( inRcvr, Intern( "zstream" ) );		if (!ISINT( theZStreamR ))	{		::ThrowBadTypeWithFrameData( theZStreamR, kNSErrNotAnInteger );	}		z_stream* theZStream = (z_stream*) (Ref) theZStreamR;		int theFlush;	do {	// Fake loop for the determination of the level.		if (inFlush == NILREF)		{			theFlush = Z_NO_FLUSH;			break;		}		if (ISINT( inFlush ))		{			theFlush = RINT( inFlush );			break;		}		if (::IsSymbol( inFlush ))		{			if (::SymbolCompareLex( inFlush, Intern( "no" ) ) == 0)			{				theFlush = Z_NO_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "partial" ) ) == 0)			{				theFlush = Z_PARTIAL_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "sync" ) ) == 0)			{				theFlush = Z_SYNC_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "full" ) ) == 0)			{				theFlush = Z_FULL_FLUSH;				break;			}			if (::SymbolCompareLex( inFlush, Intern( "finish" ) ) == 0)			{				theFlush = Z_FINISH;				break;			}		}				::ThrowBadTypeWithFrameData( inFlush, kNSErrNotAnInteger );	// Closest to what we want to say.	} while (0);		// Then setup the next_in, avail_in, next_out & avail_out accordingly.		RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		int theResult;	RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );	RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );	WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )		WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )			theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );			theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );			theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );			theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );			// Then, call inflate.			theResult = ::inflate( theZStream, theFlush );			// Update all slots in the frame.			::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );			::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );			::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );			::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );			::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );			::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );		END_WITH_LOCKED_BINARY( theBinaryOut );		END_WITH_LOCKED_BINARY( theBinaryIn );		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}		return theNSResult;}// ------------------------------------------------------------------------	////	¥ FInflateEnd( RefArg )// ------------------------------------------------------------------------	//// The function returns NIL if inflateEnd returned Z_OK, an integer otherwise.// It disposes the ZStream and disposes the zstream slot.// Throws various exceptions if things aren't as expected in the rcvr frame.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)// It doesn't remove the zstreamf slot.// It uses the zstreamf slot like FInflateextern "C" Ref FInflateEnd( RefArg inRcvr ){	RefVar theZStreamR = ::GetFrameSlot( inRcvr, Intern( "zstream" ) );		if (!ISINT( theZStreamR ))	{		::ThrowBadTypeWithFrameData( theZStreamR, kNSErrNotAnInteger );	}		z_stream* theZStream = (z_stream*) (Ref) theZStreamR;		// Then setup the next_in, avail_in, next_out & avail_out accordingly.		RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		int theResult;	RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );	RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );	// Note: if the binaries aren't set, I'll use 0.		if (::IsBinary( theBinaryIn ) && ::IsBinary( theBinaryOut ))	{		WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )			WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )				theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );				theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );				theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );				theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );				// Then, call inflateEnd.				theResult = ::inflateEnd( theZStream );				// Update all slots in the frame.				::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );				::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );				::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );				::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );			END_WITH_LOCKED_BINARY( theBinaryOut );			END_WITH_LOCKED_BINARY( theBinaryIn );	} else {		// InflateEnd may be called just after InflateInit, to dispose the memory.		theZStream->next_in = nil;		theZStream->avail_in = 0;		theZStream->next_out = nil;		theZStream->avail_out = 0;		// Then, call inflateEnd.		theResult = ::inflateEnd( theZStream );		// Update all slots in the frame.		::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );		::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );		::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );		::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );	}		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}		// Dispose the zstream pointer.		delete [] theZStream;		// Remove the zstream slot.	::RemoveSlot( inRcvr, Intern( "zstream" ) );	// I don't remove the zstreamf slot because the caller may want to read availout or totalout.		return theNSResult;}// ------------------------------------------------------------------------	////	¥ FInflateReset( RefArg )// ------------------------------------------------------------------------	//// The function returns NIL if inflateReset returned Z_OK, an integer otherwise.// Throws various exceptions if things aren't as expected in the rcvr frame.// If an error occurred, and if zstream->msg is not nil, sets zstreamf.msg//	to that message (as a Unicode NS string)// It uses the zstreamf slot like FInflateextern "C" Ref FInflateReset( RefArg inRcvr ){	RefVar theZStreamR = ::GetFrameSlot( inRcvr, Intern( "zstream" ) );		if (!ISINT( theZStreamR ))	{		::ThrowBadTypeWithFrameData( theZStreamR, kNSErrNotAnInteger );	}		z_stream* theZStream = (z_stream*) (Ref) theZStreamR;		// Then setup the next_in, avail_in, next_out & avail_out accordingly.		RefVar theZStreamF = ::GetFrameSlot( inRcvr, Intern( "zstreamf" ) );		int theResult;	RefVar theBinaryIn = ::GetFrameSlot( theZStreamF, Intern( "bin_in" ) );	RefVar theBinaryOut = ::GetFrameSlot( theZStreamF, Intern( "bin_out" ) );	// Note: if the binaries aren't set, I'll use 0.		if (::IsBinary( theBinaryIn ) && ::IsBinary( theBinaryOut ))	{		WITH_LOCKED_BINARY( theBinaryIn, theBinaryInPtr )			WITH_LOCKED_BINARY( theBinaryOut, theBinaryOutPtr )				theZStream->next_in = (Bytef*) ((ULong) theBinaryInPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_in" ) ) ) );				theZStream->avail_in = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_in" ) ) );				theZStream->next_out = (Bytef*) ((ULong) theBinaryOutPtr + RINT( ::GetFrameSlot( theZStreamF, Intern( "next_out" ) ) ) );				theZStream->avail_out = RINT( ::GetFrameSlot( theZStreamF, Intern( "avail_out" ) ) );				// Then, call inflateReset.				theResult = ::inflateReset( theZStream );				// Update all slots in the frame.				::SetFrameSlot( theZStreamF, Intern( "next_in" ), MAKEINT( (ULong) theZStream->next_in - (ULong) theBinaryInPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );				::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );				::SetFrameSlot( theZStreamF, Intern( "next_out" ), MAKEINT( (ULong) theZStream->next_out - (ULong) theBinaryOutPtr ) );				::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );				::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );			END_WITH_LOCKED_BINARY( theBinaryOut );			END_WITH_LOCKED_BINARY( theBinaryIn );	} else {		// InflateEnd may be called just after InflateInit, to dispose the memory.		theZStream->next_in = nil;		theZStream->avail_in = 0;		theZStream->next_out = nil;		theZStream->avail_out = 0;		// Then, call inflateReset.		theResult = ::inflateReset( theZStream );		// Update all slots in the frame.		::SetFrameSlot( theZStreamF, Intern( "avail_in" ), MAKEINT( theZStream->avail_in ) );		::SetFrameSlot( theZStreamF, Intern( "total_in" ), MAKEINT( theZStream->total_in ) );		::SetFrameSlot( theZStreamF, Intern( "avail_out" ), MAKEINT( theZStream->avail_out ) );		::SetFrameSlot( theZStreamF, Intern( "total_out" ), MAKEINT( theZStream->total_out ) );	}		// Convert the result to NIL if it's Z_OK, or MAKEINT of it otherwise.	RefVar theNSResult = NILREF;	if (theResult != Z_OK)	{		theNSResult = MAKEINT( theResult );				if (theZStream->msg)			::SetFrameSlot( theZStreamF, Intern( "msg" ), ::MakeString( theZStream->msg ) );	}		return theNSResult;}                        /* Advanced functions *//*    The following functions are needed only in some special applications.*/                            /*ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,                                             const Bytef *dictionary,                                             uInt  dictLength));     Initializes the compression dictionary from the given byte sequence   without producing any compressed output. This function must be called   immediately after deflateInit, deflateInit2 or deflateReset, before any   call of deflate. The compressor and decompressor must use exactly the same   dictionary (see inflateSetDictionary).     The dictionary should consist of strings (byte sequences) that are likely   to be encountered later in the data to be compressed, with the most commonly   used strings preferably put towards the end of the dictionary. Using a   dictionary is most useful when the data to be compressed is short and can be   predicted with good accuracy; the data can then be compressed better than   with the default empty dictionary.     Depending on the size of the compression data structures selected by   deflateInit or deflateInit2, a part of the dictionary may in effect be   discarded, for example if the dictionary is larger than the window size in   deflate or deflate2. Thus the strings most likely to be useful should be   put at the end of the dictionary, not at the front.     Upon return of this function, strm->adler is set to the Adler32 value   of the dictionary; the decompressor may later use this value to determine   which dictionary has been used by the compressor. (The Adler32 value   applies to the whole dictionary even if only a subset of the dictionary is   actually used by the compressor.)     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a   parameter is invalid (such as NULL dictionary) or the stream state is   inconsistent (for example if deflate has already been called for this stream   or if the compression method is bsort). deflateSetDictionary does not   perform any compression: this will be done by deflate().*//*ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,                                    z_streamp source));     Sets the destination stream as a complete copy of the source stream.     This function can be useful when several compression strategies will be   tried, for example when there are several ways of pre-processing the input   data with a filter. The streams that will be discarded should then be freed   by calling deflateEnd.  Note that deflateCopy duplicates the internal   compression state which can be quite large, so this strategy is slow and   can consume lots of memory.     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent   (such as zalloc being NULL). msg is left unchanged in both source and   destination.*//*ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));     This function is equivalent to deflateEnd followed by deflateInit,   but does not free and reallocate all the internal compression state.   The stream will keep the same compression level and any other attributes   that may have been set by deflateInit2.      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source   stream state was inconsistent (such as zalloc or state being NULL).*//*ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,				      int level,				      int strategy));     Dynamically update the compression level and compression strategy.  The   interpretation of level and strategy is as in deflateInit2.  This can be   used to switch between compression and straight copy of the input data, or   to switch to a different kind of input data requiring a different   strategy. If the compression level is changed, the input available so far   is compressed with the old level (and may be flushed); the new level will   take effect only at the next call of deflate().     Before the call of deflateParams, the stream state must be set as for   a call of deflate(), since the currently available input may have to   be compressed and flushed. In particular, strm->avail_out must be non-zero.     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR   if strm->avail_out was zero.*//*ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,                                             const Bytef *dictionary,                                             uInt  dictLength));     Initializes the decompression dictionary from the given uncompressed byte   sequence. This function must be called immediately after a call of inflate   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor   can be determined from the Adler32 value returned by this call of   inflate. The compressor and decompressor must use exactly the same   dictionary (see deflateSetDictionary).     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a   parameter is invalid (such as NULL dictionary) or the stream state is   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the   expected one (incorrect Adler32 value). inflateSetDictionary does not   perform any decompression: this will be done by subsequent calls of   inflate().*//* ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));    Skips invalid compressed data until a full flush point (see above the  description of deflate with Z_FULL_FLUSH) can be found, or until all  available input is skipped. No output is provided.    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR  if no more input was provided, Z_DATA_ERROR if no flush point has been found,  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success  case, the application may save the current current value of total_in which  indicates where valid compressed data was found. In the error case, the  application may repeatedly call inflateSync, providing more input each time,  until success or end of the input data.*//*ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));     This function is equivalent to inflateEnd followed by inflateInit,   but does not free and reallocate all the internal decompression state.   The stream will keep attributes that may have been set by inflateInit2.      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source   stream state was inconsistent (such as zalloc or state being NULL).*/                        /* utility functions *//*     The following utility functions are implemented on top of the   basic stream-oriented functions. To simplify the interface, some   default options are assumed (compression level and memory usage,   standard memory allocation functions). The source code of these   utility functions can easily be modified if you need special options.*//*ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,                                 const Bytef *source, uLong sourceLen));     Compresses the source buffer into the destination buffer.  sourceLen is   the byte length of the source buffer. Upon entry, destLen is the total   size of the destination buffer, which must be at least 0.1% larger than   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the   compressed buffer.     This function can be used to compress a whole file at once if the   input file is mmap'ed.     compress returns Z_OK if success, Z_MEM_ERROR if there was not   enough memory, Z_BUF_ERROR if there was not enough room in the output   buffer.*//*ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,                                  const Bytef *source, uLong sourceLen,                                  int level));     Compresses the source buffer into the destination buffer. The level   parameter has the same meaning as in deflateInit.  sourceLen is the byte   length of the source buffer. Upon entry, destLen is the total size of the   destination buffer, which must be at least 0.1% larger than sourceLen plus   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough   memory, Z_BUF_ERROR if there was not enough room in the output buffer,   Z_STREAM_ERROR if the level parameter is invalid.*//*ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,                                   const Bytef *source, uLong sourceLen));     Decompresses the source buffer into the destination buffer.  sourceLen is   the byte length of the source buffer. Upon entry, destLen is the total   size of the destination buffer, which must be large enough to hold the   entire uncompressed data. (The size of the uncompressed data must have   been saved previously by the compressor and transmitted to the decompressor   by some mechanism outside the scope of this compression library.)   Upon exit, destLen is the actual size of the compressed buffer.     This function can be used to decompress a whole file at once if the   input file is mmap'ed.     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not   enough memory, Z_BUF_ERROR if there was not enough room in the output   buffer, or Z_DATA_ERROR if the input data was corrupted.*/                        /* checksum functions *//*     These functions are not related to compression but are exported   anyway because they might be useful in applications using the   compression library.*//*ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));     Update a running Adler-32 checksum with the bytes buf[0..len-1] and   return the updated checksum. If buf is NULL, this function returns   the required initial value for the checksum.   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed   much faster. Usage example:     uLong adler = adler32(0L, Z_NULL, 0);     while (read_buffer(buffer, length) != EOF) {       adler = adler32(adler, buffer, length);     }     if (adler != original_adler) error();*//*ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));     Update a running crc with the bytes buf[0..len-1] and return the updated   crc. If buf is NULL, this function returns the required initial value   for the crc. Pre- and post-conditioning (one's complement) is performed   within this function so it shouldn't be done by the application.   Usage example:     uLong crc = crc32(0L, Z_NULL, 0);     while (read_buffer(buffer, length) != EOF) {       crc = crc32(crc, buffer, length);     }     if (crc != original_crc) error();*/// ================================	////		¥¥¥¥ From unzip.h ¥¥¥¥		//// ================================	///*extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,												 const char* fileName2,												 int iCaseSensitivity));   Compare two filename (fileName1,fileName2).   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi								or strcasecmp)   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system	(like 1 on Unix, 2 on Windows)extern unzFile ZEXPORT unzOpen OF((const char *path));  Open a Zip file. path contain the full pathname (by example,     on a Windows NT computer "c:\\zlib\\zlib111.zip" or on an Unix computer	 "zlib/zlib111.zip".	 If the zipfile cannot be opened (file don't exist or in not valid), the	   return value is NULL.     Else, the return value is a unzFile Handle, usable with other function	   of this unzip package.extern int ZEXPORT unzClose OF((unzFile file));  Close a ZipFile opened with unzipOpen.  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.  return UNZ_OK if there is no problem.extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,					unz_global_info *pglobal_info));  Write info about the ZipFile in the *pglobal_info structure.  No preparation of the structure is needed  return UNZ_OK if there is no problem.extern int ZEXPORT unzGetGlobalComment OF((unzFile file,										   char *szComment,					   uLong uSizeBuf));  Get the global comment string of the ZipFile, in the szComment buffer.  uSizeBuf is the size of the szComment buffer.  return the number of byte copied or an error code <0 Unzip package allow you browse the directory of the zipfileextern int ZEXPORT unzGoToFirstFile OF((unzFile file));  Set the current file of the zipfile to the first file.  return UNZ_OK if there is no problemextern int ZEXPORT unzGoToNextFile OF((unzFile file));  Set the current file of the zipfile to the next file.  return UNZ_OK if there is no problem  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.extern int ZEXPORT unzLocateFile OF((unzFile file, 				     const char *szFileName,				     int iCaseSensitivity));  Try locate the file szFileName in the zipfile.  For the iCaseSensitivity signification, see unzStringFileNameCompare  return value :  UNZ_OK if the file is found. It becomes the current file.  UNZ_END_OF_LIST_OF_FILE if the file is not foundextern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,					     unz_file_info *pfile_info,					     char *szFileName,					     uLong fileNameBufferSize,					     void *extraField,					     uLong extraFieldBufferSize,					     char *szComment,					     uLong commentBufferSize));  Get Info about the current file  if pfile_info!=NULL, the *pfile_info structure will contain somes info about	    the current file  if szFileName!=NULL, the filemane string will be copied in szFileName			(fileNameBufferSize is the size of the buffer)  if extraField!=NULL, the extra field information will be copied in extraField			(extraFieldBufferSize is the size of the buffer).			This is the Central-header version of the extra field  if szComment!=NULL, the comment string of the file will be copied in szComment			(commentBufferSize is the size of the buffer)   for reading the content of the current zipfile, you can open it, read data   from it, and close it (you can close it before reading all the file)extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));  Open for reading data the current file in the zipfile.  If there is no error, the return value is UNZ_OK.extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));  Close the file in zip opened with unzOpenCurrentFile  Return UNZ_CRCERROR if all the file was read but the CRC is not good												extern int ZEXPORT unzReadCurrentFile OF((unzFile file, 					  voidp buf,					  unsigned len));  Read bytes from the current file (opened by unzOpenCurrentFile)  buf contain buffer where data must be copied  len the size of buf.  return the number of byte copied if somes bytes are copied  return 0 if the end of file was reached  return <0 with error code if there is an error    (UNZ_ERRNO for IO error, or zLib error for uncompress error)extern z_off_t ZEXPORT unztell OF((unzFile file));  Give the current position in uncompressed dataextern int ZEXPORT unzeof OF((unzFile file));  return 1 if the end of file was reached, 0 elsewhere extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,											 voidp buf,											 unsigned len));  Read extra field from the current file (opened by unzOpenCurrentFile)  This is the local-header version of the extra field (sometimes, there is    more info in the local-header version than in the central-header)  if buf==NULL, it return the size of the local extra field  if buf!=NULL, len is the size of the buffer, the extra header is copied in	buf.  the return value is the number of bytes copied in buf, or (if <0) 	the error code*/// ========================================== //// Do not use the blue keys on this terminal. //// ========================================== //