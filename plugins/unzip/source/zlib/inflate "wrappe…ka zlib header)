To: Paul Guyot <pguyot@kallisys.net>Subject: inflate "wrapper" (aka zlib header)I'm not a C guru, but it looks like in InflateReset (Inflate.c)it sets up initial state:    z->state->mode = z->state->nowrap ? BLOCKS : METHOD;currently it's obviously starting at METHOD (checks compression byte, then some flags, then some dicts)but I'm guessing we want it to start directly with BLOCKS (data?) by turning on nowrap  (there's evidence for this in gzio.c (later))---inside inflateInit2_...  /* handle undocumented nowrap option (no zlib header or check) */  z->state->nowrap = 0;  if (w < 0)  {    w = - w;    z->state->nowrap = 1;  }(I'm still thinking we want to get rid of zlib header unless it's same as file header)----that's called by InflateInit_ inflateInit2_(z, DEF_WBITS, version, stream_size);---DEF_WBITS ("window bits") is used _only_ in InflateInit_and defined in zutil.h#ifndef DEF_WBITS#  define DEF_WBITS MAX_WBITS#endifinterestingly, there are some places where -MAX_WBITS is usede.g., gzio.c         err = deflateInit2(&(s->stream), level,                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);        /* windowBits is passed < 0 to suppress zlib header */...        err = inflateInit2(&(s->stream), -MAX_WBITS);        /* windowBits is passed < 0 to tell that there is no zlib header.         * Note that in this case inflate *requires* an extra "dummy" byte         * after the compressed stream in order to complete decompression and         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are         * present after the compressed stream.         */====so, if the zlib header is different from the file header, maybe we need to 1) suppress it -- in which case, this might be as simple as setting DEF_WBITS -MAX-WBITS (and recompiling)?I'm not sure if the extra "dummy" byte mentioned in gzio.c is actually needed if the stream is already at end.Inflate.c BLOCKS: state does check nowrap, so maybe it'll stop successfully?      if (z->state->nowrap)      {        z->state->mode = DONE;        break;      }2) alternatively, we might have to fake a zlib header if it's different from the file header.  then, I'm not sure how to do this without either overwriting part of the .zip, or (safer but slower) creating a new binary with zlib header followed by the copied compressed data.---so if 1) worked for .zip, how about zlib in VNC?the Java version relies on Java java.util.zip.* classesthe VNC source:...            if ( zlibInflater == null ) {              zlibInflater = new Inflater();            }            zlibInflater.setInput( zlibBuf, 0, nBytes );            drawZlibRect( rfb.updateRectX, rfb.updateRectY,                          rfb.updateRectW, rfb.updateRectH );drawZlibRect has a loop containing:        zlibInflater.inflate( pixels, j * rfb.framebufferWidth + x, w );it really looks to me that inflate is getting direct data (pixels) and no zlib header (esp, in front of each row in loop).so, I think I'd vote for 1) also in this case.what do you think???-- Steve