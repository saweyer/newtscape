constant kByteSize :=   256;	// for ExtractRWord, ExtractRLongconstant kWordSize := 65536;// ==========// Newt's Cape helperAppDefineGlobalConstant('kNewtsCapeSymbol, '|NewtsCape:NewtsCape|);DefineGlobalConstant('kNewtsCapeEmptyGlobal, {	cache: [], historyPos: 0,				htmlApps: {}, helperApps: {},	imageExtensions: [".gif"],	protos: {},	}); constant kNotesSym := 'paperroll; // for borrowing Newt's Cape "tiny icon"// ==========// ZIP file/header signaturesDefineGlobalConstant('kJarLocSig, "PK\u00030004");//DefineGlobalConstant('kJarCenSig, "PK\u00010002");DefineGlobalConstant('kJarEndSig, "PK\u00050006");// file offset infoDefineGlobalConstant('kNumRecPos, -12);	// numRec pos (word) within fileDefineGlobalConstant('kRecPos, 	  0);	// 1st rec pos (long)//DefineGlobalConstant('kRecOffset, 30);	// rec size incrementDefineGlobalConstant('kLOCHDR,	  30); // .jar  header lengthDefineGlobalConstant('kUnzipMediaTypes, [	"application/zip",	"application/zip-compressed",	// jar?	"application/x-zip-compressed",	//??other	]);DefineGlobalConstant('kUnzipMediaExt, [".jar", ".zip"]);DefineGlobalConstant('kUnzipHelperFrame, {transferMode: 'binary,extensions:   kUnzipMediaExt,sigBytes:	kJarEndSig,sigPos:		-22,matchFile: /*boolean*/ func(/*string*/ url, /*binary*/ data) // for Inbox testingbegin	local int pos := LSearch(extensions, url, 0, GetGlobalFn('EndsWith), nil);	return if pos and IsBinary(data) and :ByteBeginsWith(data, sigBytes, sigPos) then pos;end,addFile: /*boolean*/ func(/*string*/ contentType, /*string*/ url, /*binary*/ data, /*frame*/ options)beginif (kDEBUG) then Print([contentType,url]);	if not :matchFile(url, data)	then return NIL;	// this shouldn't happen... let Newt's Cape report no helperApp	local errObj := {_proto: self, curFileName: url};	if not options	then options := {};	if not call kMissingImportsFunc with (ObjectPkgRef("Me"))	then begin		options.(EnsureInternal('allowCompressed)) := true;//if kDebug then Print("using" && kZlibName && call UR(kZlibSymbol, 'GetZLibVersion) with ());		end;//if (kDEBUG) then Print(options);	options.(EnsureInternal('DoProgress)) := true;	// for .pkg		// build map of extensions to MIME type (for later dispatch)	// Newt's Cape(built-in)	local /*string*/ array mediaExts  := [".htm",      ".html",     ".gif",      ".txt",       ".pkg",];	local /*string*/ array mediaTypes := ["text/html", "text/html", "image/gif", "text/plain", "application/x-newton-compatible-pkg"];	// check other helperApps;	local /*frame*/ helperApps := GetGlobalVar(kNewtsCapeSymbol).helperApps;	if helperApps.|application/x-pilot-pdb| and helperApps.|application/x-pilot-prc|	then begin // avoid generic */* or text/ for PilotDoc plugin		AddArraySlot(mediaExts, ".pdb"); AddArraySlot(mediaTypes, "application/x-pilot-pdb");		AddArraySlot(mediaExts, ".prc"); AddArraySlot(mediaTypes, "application/x-pilot-prc");		end;	local /*symbol*/ helperSym;	local /*frame*/ helperFrame, helperApp;	local /*string*/ ext;	foreach /*symbol*/ contentType,helperFrame in helperApps	do  foreach helperSym,helperApp in helperFrame		do if IsArray(exts := helperApp.extensions)			then foreach ext in exts				 do if not LSearch(mediaExts,ext,0,'|str=|,nil)					then begin						AddArraySlot(mediaExts, ext);						AddArraySlot(mediaTypes, SPrintObject(contentType));						end;//if (kDEBUG) then Print(mediaExts);//if (kDEBUG) then Print(mediaTypes);	local int i, ulen := StrLen(url), pos := 0;	for i := ulen-1 to 0 by -1	do  if url[i] = $/		then break pos := i+1;	local /*string*/ zipName := Substr(url, pos, ulen), fileName;	local int nameLen, fullLen, fileLen, recPad := 0, zipFormat, dTime1,dTime2, modMins;	local int offset := kRecPos, dlen :=  Length(data);	// technically this could be a long though I doubt it	local int numRec := :ExtractRWord(data, dlen + kNumRecPos); // from endif (kDEBUG) then Print(zipName & ";  bytes:" && dlen & "; items:" && numRec);	local ARRAY fileItems := Array(numRec,nil);	// cache file names, offsets, lens	// offset points to beginning of next record (initially; then fileName, then data)	for i := 0 to numRec-1	do begin		if not :ByteBeginsWith(data, kJarLocSig, offset) // LOC entry		then return errObj:error("problem record:" && i, "offset:", offset, FATAL_ERROR);			//ExtractByte(data,offset) && ExtractByte(data,offset+1) && ExtractByte(data,offset+2) && ExtractByte(data,offset+3));				//LOCVER(4)	version needed to extract		//LOCFLG(6)	general purpose bit flag		zipFormat := :ExtractRWord(data, offset+ 8);	//LOCHOW	compression method (0=stored; 8=deflated)		dTime1    := :ExtractRWord(data, offset+10);	//LOCTIM	modification time(DOS format)		dTime2    := :ExtractRWord(data, offset+12);	// do as 2 words instead of long		fileLen	  := :ExtractRLong(data, offset+18);	//LOCSIZ	compressed size (same as uncomp if no compression)		fullLen   := :ExtractRLong(data, offset+22);	//LOCLEN	uncompressed size		nameLen   := :ExtractRWord(data, offset+26);	//LOCNAM	filename length		recPad	  := :ExtractRWord(data, offset+28);	//LOCEXT	extra field length		offset := offset + kLOCHDR;		fileName  := :UniMunger(nil,0,nil, data, offset, nameLen);		modMins := TotalMinutes({ // convert from DOS to Newton time format(mins since 1/1/1904)			year:	Band((dTime2 >>  9), 0x7F) + 1980,			month:	Band((dTime2 >>  5), 0x0F),			date:	Band( dTime2,        0x1F),			hour:	Band((dTime1 >> 11), 0x1F),			minute: Band((dTime1 >>  5), 0x3F),		  //second: Band((dTime1 <<  1), 0x3E),			});		offset := offset + nameLen + recPad;		pos := LSearch(mediaExts, fileName, 0, GetGlobalFn('EndsWith), nil);		fileItems[i] := {			item: 		fileName,			fileOffset:	offset,		// start of data for kSTORED			fullLength: fullLen,	// uncompressed			fileLength: fileLen,	// less if compressed			compMethod: zipFormat,			contentType: if pos then mediaTypes[pos],			_modTime: 	modMins,			};		offset := offset + fileLen;if (kDEBUG) then Print(fileName & "; len:" && fullLen & "; type:" && fileItems[i].contentType);if (kDEBUG) then Print("modified:" &&				LongDateStr(modMins,ROM_dateTimeStrSpecs.abbrDateStrSpec) &&				TimeStr(modMins, ROM_dateTimeStrSpecs.shortTimeStrSpec));if (kDEBUG and zipFormat <> kSTORED)then Print("compressed:" && fileLen & "; method:" && (if zipFormat=kDEFLATED then kDeflatedName else zipFormat&$?));		end;	local notes := GetRoot().(kNotesSym);	local entry := LFetch(notes:GetRouteScripts(notes:GetTargetInfo('routing)), kNewtsCapeSymbol, 0, '|=|, 'tag);	BuildContext({       	_proto: protoFileOverview,       	icon: if entry then entry.icon,	// for progress       	title: zipName,       	url: url,       	querySpec: fileItems,		callbackObj: errObj,		callbackMeth: 'unzipFile,		data:  data,		options: options,       	}):open();	return TRUE; // this has handled (possibly some callbacks to unzipFile later)end,curFileName: nil,	// for :error. set in an errObj instanceInflater: { // borrowed from VNC	// more compatible with Java API and hides more zlib details	_proto: UR(kZLibSymbol, 'ProtoInflateStream),	obj: nil,	new: func(obj, int zh)	// zh=-15 for no zlib header (e.g., .zip)		begin			local inf :=				{_proto: self,				obj: obj,		// for status, error				closed: nil,				//zstreamf:		// created by InflateInit				};			local int err := if zh then inf:InflateInit2(zh) else inf:InflateInit();			if err			then return obj:?error("InflateInit" && if inf.zstreamf then inf.zstreamf.msg, err, FATAL_ERROR);			return inf;		end,	close: func()		begin			local int err;			if not closed			then try err := :InflateEnd();				onexception |evt.ex|				do err := currentException();			closed := true;			if err			then obj:?error("InflateEnd" && zstreamf.msg, err, IGNORE_ERROR);			nil;		end,	setInput: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_in 	:= data;			zstreamf.next_in 	:= offset;			zstreamf.avail_in 	:= len;		end,	inflate: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_out 	:= data;			zstreamf.next_out 	:= offset;			zstreamf.avail_out 	:= len;			local int err := inherited:Inflate('sync);	// 'finish ???			if err and (err <> Z_STREAM_END or zstreamf.avail_out <> 0)			then return obj:?error("Inflate" && zstreamf.msg && zstreamf.avail_out, err, FATAL_ERROR);			true;		end,},// called via callback by protoFileOverview.extractScriptunzipFile: func(/*frame*/ fileItem, /*binary*/ data, /*frame*/ options, /*frame*/ progressView, /*frame*/ progressOptions)begin	curFileName := fileItem.item;	// reset for each indiv file//Print(curFileName);	local /*string*/ contentType := fileItem.contentType;	if not IsString(contentType)	then return :error("unknown helper", contentType, FATAL_ERROR);	local int offset := fileItem.fileOffset, len := fileItem.fullLength, zipFormat := fileItem.compMethod;	local /*boolean*/ isText := BeginsWith(contentType, "text/"), isCompressed := (zipFormat = kDEFLATED and options.allowCompressed);	if not (isCompressed or zipFormat = kSTORED)	// shouldn't have occurred, but just in case...	then return :error("unrecognized compression", zipFormat, FATAL_ERROR);	if not progressOptions	then progressOptions := {};	local /*string*/ title := (if zipFormat = kDEFLATED then kDeflatedName else kStoredName) & $: && curFileName;	local /*frame*/ inf;	if isCompressed	// Unit is present (checked in addFile)	then begin		inf := Inflater:new(self, -15);		if not inf		then return;	// error already reported		inf:setInput(data, offset, fileItem.fileLength);		end;	local /*binary*/ tmpData, fileData;	local int i, remaining := len, flushInc := kVBOFlush, inc := min(len, 4096); // inc=4K (flushInc should be multiple)	// create final destination (fileData)	if isText	then begin		if isCompressed		then tmpData := MakeBinary(inc, 'bytes);	// create interim buffer		flushInc := kVBOFlush div 2;				// more freq due to expansion		fileData := :makeBigBinary((len*2)+2, 'string);	// unicode + null		end	else fileData:= :makeBigBinary(len, 'bytes);	// inflate or copy -- incrementally	for i := 0 to len-1 by inc	do begin//Print(i);		progressOptions.titleText := title & unicodeCR & i & $/ & len;		progressOptions.gauge := RIntToL(i * 100 / len);		try progressView:?SetStatus('vGauge, progressOptions)		onexception |evt.ex.cancel| do return inf:?close();		if (i mod flushInc) = 0 and i > 0 and IsVBO(fileData)		then ClearVBOCache(fileData);		if isText		then begin			if inf			then if inf:inflate(tmpData, 0, inc)					// kDEFLATED: expand into tmpData				then :UniMunger(fileData, i, inc, tmpData, 0, inc);	// copy as unicode				else return inf:close();							// Inflate already reported error			else :UniMunger(fileData, i, inc, data, offset+i, inc);	// kSTORED: copy as unicode			end		else begin			if inf			then if inf:inflate(fileData, i, inc)					// kDEFLATED: expand directly into fileData				then nil	// ok				else return inf:close();							// Inflate already reported error			else BinaryMunger(fileData,i,inc, data, offset+i, inc);	// kSTORED: copy directly into fileData			end;		remaining := remaining - inc;		if remaining < inc		then inc := remaining;		end;	// cleanup	inf := inf:?close();	progressOptions.gauge := 100;	try progressView:?SetStatus('vGauge, progressOptions)	onexception |evt.ex.cancel| do return;	if IsVBO(fileData)	then ClearVBOCache(fileData);//if (kDEBUG) then Print(fileData);	AddDeferredSend(GetRoot().(kNewtsCapeSymbol), 'dispatchFile, [contentType, EnsureInternal(curFileName), fileData, options]);end,makeBigBinary: func(int len, /*symbol*/ class)if len > 4096then GetDefaultStore():NewCompressedVBO(EnsureInternal(class), len, kTextCompander, nil)else MakeBinary(len, EnsureInternal(class)),// convert packed ascii (8-bit not unicode chars) to unicode -- see NC:copyRawHTML// like ExtractCString except it supports VBOs, offsets and lens (ending null not required)/*string*/ UniMunger: func(/*string*/ str, int strOffset, int strLen, /*byte*/ data, dataOffset, dataLen)begin // strLen unused	if not str	then str := MakeBinary((2*dataLen)+2, 'string);	// :makeBigBinary???	local int i, byte;	for i := 0 to dataLen-1	do	if (byte := ExtractByte(data,dataOffset+i)) = 0		then break StrMunger(str,strOffset+i,nil, nil,0,nil)		else str[strOffset+i] := if byte = chLF then unicodeCR else Chr(byte);	str;end,error: func(/*string*/ msg, earg, /*boolean*/ fatal)	// earg: string, int, nil or frame=currentException()begin	local eval := earg;	if IsFrame(earg) 	then if not (eval := earg.error)		then if IsFrame(earg.data)			then eval := earg.data.errorCode;	msg := curFileName && msg & $: && eval;//Print(msg);	if fatal	then GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), msg);	NIL;end,// BMP,JAR seems to use little-endian rather than big-endian for header fieldsExtractRWord: /*int*/ func(/*byte[]*/ data, int offset)begin	local int byte1 := ExtractByte(data, offset+1), byte2 := ExtractByte(data, offset);	if byte1=0	then byte2	else (byte1*kByteSize) + byte2;end,ExtractRLong: /*long*/ func(/*byte[]*/ data, int offset)begin	local int word1 := :ExtractRWord(data, offset+2);	local int word2 := :ExtractRWord(data, offset);	if word1=0	then word2	else (word1*kWordSize) + word2;end,ByteBeginsWith: /*boolean*/ func(/*byte[]*/ bytes, /*string*/ str, int offset)begin	local int i, slen := StrLen(str), blen := Length(bytes);	if offset < 0	then offset := blen+offset;	if offset < 0 or offset+slen > blen	then return NIL;	for i := 0 to slen-1	do if ExtractChar(bytes, offset+i) <> str[i]		then return NIL;	TRUE;end,protoFileOverview: GetLayout("protoFileOverview"),});// ==========DefineGlobalConstant('kBMPMediaTypes, [	"image/bmp",	//??other	]);DefineGlobalConstant('kBMPMediaExt,   [".bmp", ".wbm"]);// 1.x compat for booksconstant kHeadlen1x := 16;//constant kHeadlen2x := 28;DefineGlobalConstant('kBMPSig, "BM");DefineGlobalConstant('kBMPHelperFrame, {transferMode: 'binary,extensions:   kBMPMediaExt,sigBytes:	"BM",sigPos:		0,matchFile:	kUnzipHelperFrame.matchFile,	// *** sharecurFileName: nil,	// for :error. set in an errObj instance// borrowed from WabaTester.convertBitmap, wababin.pkg.BitmapaddFile: /*boolean*/ func(/*string*/ contentType, /*string*/ url, /*binary*/ data, /*frame*/ options)beginif (kDEBUG) then Print([contentType,url]);	if not :matchFile(url, data)	then return NIL;	// this shouldn't happen... let Newt's Cape report no helperApp	local errObj := {_proto: self, curFileName: url};    local int offset := 0, len := Length(data);		//+0 = "BM"  (sigBytes)		//+2L = len		//+6L = 0 reserved	local int doffset  	:= :ExtractRLong(data, offset+10);		//+14L infoSize=40	local int width  	:= :ExtractRLong(data, offset+18);	local int height 	:= :ExtractRLong(data, offset+22);		//+26W = 0 planes 	local int depth    	:= :ExtractRWord(data, offset+28);    if depth > 4    then return return errObj:error("depth", depth, FATAL_ERROR); 	local int comp		:= :ExtractRLong(data, offset+30);    if comp <> 0    then return return errObj:error("compression", comp, FATAL_ERROR);	local int dlen 		:= :ExtractRLong(data, offset+34);		//+38L  x pixelspermeter		//+42L	y pixelspermeter		//+46L colorsUsed=2		//+50L colorImportant?		//+54L col1		//+58L col2 (blue,green,red,reserved) 255,255,255,0 	local /*boolean*/ invert :=            	not (:ExtractRLong(data, offset+54) <> 0 and            		 :ExtractRLong(data, offset+58) = 0);	if dlen=0	then dlen := ((len-doffset) div 4) * 4;//Print([len, doffset,dlen, width,height,depth, invert]);	local int rowBytes  := 4*(((width*depth) + 31) div 32);	local /*byte[]*/ bits := :makeBigBinary(kHeadlen1x + (rowBytes*height), if depth=1 then 'bits else 'cbits);	StuffWord(bits,  4, rowBytes);	StuffWord(bits, 12, height);	//8=top(0),10=left(0)	StuffWord(bits, 14, width);	local /*bitmap*/ bitmap := {		bounds: RelBounds(0, 0, width, height),		};	if depth=1	then bitmap.bits := bits	else bitmap.colordata := {		cbits: bits,		bitdepth: depth,		};	local int x, y, btop := kHeadLen1x; // wbytes := (width-1) div (8 div depth);	local int dtop := offset + doffset + dlen - rowBytes, byte, flushBytes := if IsVBO(bits) then 0;//Print([btop, dtop, rowBytes, bitmap]);	for y := 0 to dlen-1 by rowBytes	do  begin		for x := 0 to rowBytes-1		do begin			byte := ExtractByte(data, dtop-y+x); 			StuffByte(bits, btop+y+x, if invert then Bxor(0xFF, byte) else byte);			end;		if flushBytes and (flushBytes := flushBytes + rowBytes) >= kVBOFlush		then begin			flushBytes := 0;			ClearVBOCache(bits);			end;		end;	if flushBytes	then ClearVBOCache(bits);	// this handles single BMP. alternatively, generate full URL and cache??	GetRoot().(kNewtsCapeSymbol):?addFile(contentType, url, bitmap, options);end,// *** sharemakeBigBinary: 	kUnzipHelperFrame.makeBigBinary,error:			kUnzipHelperFrame.error,ExtractRWord:	kUnzipHelperFrame.ExtractRWord,ExtractRLong:	kUnzipHelperFrame.ExtractRLong,ByteBeginsWith: kUnzipHelperFrame.ByteBeginsWith,});// =====DefineGlobalConstant('kInstallHelperApp, /*void*/ func(/*string*/ contentType, /*symbol*/ helperSym, /*frame*/ helperApp)if GetRoot().(kNewtsCapeSymbol)	// use built-in installHelperApp if therethen GetRoot().(kNewtsCapeSymbol):installHelperApp(contentType, helperSym, helperApp)else begin	local /*frame*/ gData := GetGlobalVar(kNewtsCapeSymbol);	if not gData	then DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal(kNewtsCapeEmptyGlobal)); 	local /*frame*/ helperApps := gData.helperApps;	local /*symbol*/ icontentType := Intern(contentType);	local /*frame*/ helperFrame := helperApps.(icontentType); 	if isFrame(helperApp)	then begin // install		if not helperFrame then		helperApps.(EnsureInternal(icontentType)) := helperFrame := EnsureInternal({});		// assume in this version that helperApp has 'addFile		helperFrame.(EnsureInternal(helperSym)) := helperApp; // add/replace		end	else if helperFrame and Length(RemoveSlot(helperFrame,helperSym))=0	then RemoveSlot(helperApps, icontentType); // un-install	end;);InstallScript := func(/*frame*/ partFrame, /*frame*/ removeFrame)begin	local /*frame*/ data := partFrame.partData;	local /*string*/ contentType;	foreach contentType in kUnzipMediaTypes	do data:InstallHelperApp(contentType, kPkgSymbol, data.UnzipHelperFrame);	foreach contentType in kBMPMediaTypes	do data:InstallHelperApp(contentType, kPkgSymbol, data.BMPHelperFrame);	local /*string*/ ext;	foreach ext in kBMPMediaExt	do AddArraySlot(GetGlobalVar(kNewtsCapeSymbol).imageExtensions, EnsureInternal(ext));end;RemoveScript :=	func(/*frame*/ removeFrame)begin	local /*string*/ contentType;	foreach contentType in kUnzipMediaTypes	do call kInstallHelperApp with (contentType, kPkgSymbol, nil);	foreach contentType in kBMPMediaTypes	do call kInstallHelperApp with (contentType, kPkgSymbol, nil);	local /*string*/ ext;	local array exts := GetGlobalVar(kNewtsCapeSymbol).imageExtensions;	local int pos;	foreach ext in kBMPMediaExt	do if (pos := LSearch(exts,ext,0,'|str=|,nil))		then ArrayRemoveCount(exts,pos,1);end;SetPartFrameSlot('RemovalApproval, func(/*symbol*/ unitName, int major, int minor)if unitName = kZlibSymbolthen return	"If you remove" && kZlibName & $, &&	kAppName && "will disable Deflate for .zip files";);/*SetPartFrameSlot('ImportDisabled, func(unitName, int major, int minor)if unitName = kZlibSymbol// don't care -- addFile will check next time used);*/SetPartFrameSlot('text, kAppName);	// nicer than symbol, plus allows tapActionSetPartFrameSlot('tapAction, func()	GetRoot():Notify(0,		kAppName && kVersionNum & kBetaVersion,		"a Newt's Cape helperApp\nfor .zip and .bmp files.\n\n©2001. Steve Weyer\nwww.kagi.com/weyer/#Unzip"));partData := {	// avoids some ensure-internaling at install time?installHelperApp:	kInstallHelperApp,UnzipHelperFrame: 	kUnzipHelperFrame,BMPHelperFrame: 	kBMPHelperFrame,};/*getglobals().|newtscape:newtscape|.helperapps.|application/zip|.|UnzipBMP:NewtsCape|http://www.unna.org/unna/books/Newton/NewtNews117.txt.ziphttp://www.unna.org/unna/books/Newton/NN049.pkg.zip*/