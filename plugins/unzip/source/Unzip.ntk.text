// Text of project Unzip.ntk written on 11/8/01 at 9:49 AM// Beginning of text file ZLib.unit/*	File:		ZLib.unit	Project:	ZLib - Public NewtonScript Interface*/DefConst( 'kZLibVersionStr, "1.1.3" );DefConst( 'kZLibSymbol, '|ZLib:Kallisys| );DefConst( 'kZLibMajor, 1 );DefConst( 'kZLibMinor, 0 );DeclareUnit( kZLibSymbol, kZLibMajor, kZLibMinor,{// GetZLibVersion: func ()// You may want to compare the result of this function with kZLibVersion	GetZLibVersion:	0,// ProtoDeflateStream: frame with four slots//	DeflateInit: func( inLevel ),//	DeflateInit2: func( inLevel, inMethod, inWindowBits, inMemLevel, inStrategy ),//	Deflate: func( inFlush ),//	DeflateEnd: func()// Doc to be written (there are the comments in :NTKModule:ZLib.cp in the meanwhile)	ProtoDeflateStream: 1,// ProtoInflateStream: frame with four slots//	InflateInit: func(),//	InflateInit2: func( inWindowBits ),//	Inflate: func( inFlush ),//	InflateEnd: func()// Idem for doc.	ProtoInflateStream: 2} );// End of text file ZLib.unit// Beginning of text file ProjectData.txt// Unzip/BMP helperApp (parts copied from WabaTester)// defined together due to shared codeconstant kUnzip 		:= "Unzip";constant kBMP 			:= "BMP";constant kFileName 		:= "uzpbm";constant kVersionNum 	:= "1.0";constant kVersionInt	:= "10";constant kBetaVersion 	:= "b";constant kDebug 		:= NIL;constant kZlibName		:= "zlib";//constant kInstalled	:= "installed";//constant kNotInstalled:= "not installed";Print(kFileName & kVersionInt & kBetaVersion & ".pkg" && DateNTime(Time()));DefineGlobalConstant('kPkgSymbol, Intern(kPackageName)); // kAppSymbol='auto ?Print([kAppName, kAppSymbol, kPackageName, kPkgSymbol]);constant kSTORED 		:= 0;constant kDEFLATED  	:= 8;constant Z_STREAM_END 	:= 1;constant kDeflatedName 	:= "Deflated";constant kStoredName 	:= "Stored";//??other// for Inflaterconstant FATAL_ERROR	:= true;constant IGNORE_ERROR	:= nil;DefineGlobalConstant('kVBOFlush, 32*1024);		// 32K per Q&ADeclareGlobalFn('ClearVBOCache,1);DeclareGlobalFn('InetGetIPAddress,1);// End of text file ProjectData.txt// Beginning of file protoFileOverviewprotoFileOverview :=    {viewFlags: 68,     viewBounds: {left: 3, top: 3, right: -3, bottom: -3},     viewScrollDownScript:       func()       overview:viewScrollDownScript()       //overview:scroller(20)       ,     viewJustify: 240,     viewScrollUpScript:       func()       overview:viewScrollUpScript()       //overview:scroller(-20)       ,     querySpec: nil,     viewSetupFormScript:       func()       begin       	soupCount := Length(querySpec);       	SetKeyView(self, 0);       	// kludge: avoid NOS 2.1 window glitch (by making window smaller) if NIE is  connected       	if GlobalFnExists('PackRGB) and GlobalFnExists('InetGetIPAddress) and InetGetIPAddress('localAddress)       	then viewBounds := SetBounds(40,0, -40,-80);       	inherited:?viewSetupFormScript();       end,     soupCount: 0,     viewFormat: 67109713,     ReorientToScreen: ROM_DefRotateFunc,     extractScript:       func()       begin       	local array items := overview.selected;       	base:close();              	local /*frame*/ item, progressOptions := {       		closeBox: nil,       		icon: icon,        		statusText: kUnzip && kVersionNum & kBetaVersion,       		gauge: 0,			// 0-100 in unzipFile       		//titleText: "",	// fileName in unzipFile       		};       	DoProgress('vGauge, progressOptions, func(progressView)       		foreach item in items       		do Perform(callbackObj, callbackMeth, [item, data, options, progressView, progressOptions]);       		);       /*       	AddDeferredCall(GetGlobalFn('DoProgress),       		['vGauge, progressOptions,       		func(progressView)       			foreach item in items       			do Perform(callbackObj, callbackMeth, [item, data, options, progressView, progressOptions])       		]);       */end,     _proto: @179 /* protoFloater */    };titleStr :=    {viewBounds: {left: 0, top: 0, right: 120, bottom: 16},     viewSetupFormScript:       func()       begin       	titleIcon := icon;       	inherited:?viewSetupFormScript();       end,     _proto: @229 /* protoTitle */    };AddStepForm(protoFileOverview, titleStr);StepDeclare(protoFileOverview, titleStr, 'titleStr);// After Script for titleStrthisView := titleStr;//thisView.titleIcon := ROM_routeDuplicateIconoverview :=    {cachedLine: nil,     SelectItem:       func(int index)       begin       	local /*frame*/ entry := cursor:GetIndexEntry(index + cursPos - 1);       	local int pos;              	if selected and pos := SetContains(selected, entry) 	// = ok       	then ArrayRemoveCount(selected,pos,1)       	else if selected       	then AddArraySlot(selected, entry)       	else selected := [entry];       	// RedoChildren called in HitItem              	:updateTitle(nil);       end,     Reset:       func()       begin       	cursPos := 1;       	cursor:reset();       	cursor;       end,     viewDrawScript:       DefineGlobalConstant('kSepLineStyle, {penPattern: vfNone, fillPattern: vfFillGray});              func()       begin       	inherited:?viewDrawScript();       	if cachedLine       	then :DrawShape(cachedLine, kSepLineStyle);       end,     CheckState:       func(/*frame*/ entry)       begin       	local int zipFormat := entry.compMethod;       	if entry.contentType and (zipFormat = kSTORED or (zipFormat = kDEFLATED and options.allowCompressed))       	then nil			// have unchecked checkbox       	else 'notCheckable;	// no checkbox at all. either no contentType, or Deflated (w/o zlib) or unknown type       end,     stylep: nil,     updateTitle:       func(/*boolean*/ redo)       begin       	if redo       	then :RedoChildren();              	local int len := Length(selected);       	local /*string*/ txt := title, /*string*/ suffix :=       		(if numLines > 0 then $( & cursPos & $- & cursPos+numLines-1 & $))	 // none for empty folder       		&& (if len > 0 then $\uFC0B & len);              	if titleStr	// closed?       	then begin       		titleStr:close();       		titleStr.title := txt & $: && soupCount && suffix;       		titleStr:open();       		end;       end,     Abstract:       func(/*frame*/ item, /*frame:rect*/ bbox)       begin       	local /*string*/ contentType := item.contentType;       	local /*string*/ line1 := item.item & "; length:" && item.fullLength & "; type:" && (if contentType then contentType else $?);       	local /*string*/ line2 :=       		LongDateStr(item._modTime, ROM_dateTimeStrSpecs.abbrDateStrSpec) &&       			TimeStr(item._modTime, ROM_dateTimeStrSpecs.shortTimeStrSpec);              	local int zipFormat := item.compMethod;       	if (zipFormat <> kSTORED)       	then line2 := line2 &       		$; && (if (zipFormat = kDEFLATED) then kDeflatedName else zipFormat & $?) &       		$: && item.fileLength;              	local int left := bbox.left, top := bbox.top, right := bbox.right, bottom := top+13; //bbox.bottom       	return [       		MakeText(line1, left, top, right, bottom),       		styleB,       		MakeText(line2, left, bottom, right, bottom+13),	       		styleP,       		];       end,     viewBounds: {left: 3, top: 18, right: -1, bottom: -15},     _proto: @460 /* clView */,     cursor: nil,     Scroller:       func(INT numItems)	// !!!f       begin       	inherited:?Scroller(numItems);       	cursPos := max(1, min(cursCount, cursPos + numItems));       	:updateTitle(nil);	// !!!g       end,     cursPos: nil,     lineHeight: 28,     viewJustify: 240,     selected: nil,     resetCursor:       func(/*boolean*/ newCursor, /*boolean*/ redo)       begin       	selected := [];       	if newCursor       	then begin       		cursor := nil;       		cursPos := 1;       		cursor := {       			_proto: fakeCursor,       			items: querySpec,       			itemLen: cursCount := Length(querySpec),       			};       		end              	else if not (cursor:entry())       	then :reset();              	if redo       	then :RedoChildren();              	AddDeferredSend(self, 'updateTitle, '[nil]);	// allow time for numLines to be set       end,     styleb: nil,     viewSetupFormScript:       func()       begin       	:resetCursor(true, nil);              	styleP := {font: viewFont};       	styleB := {font: SetFontFace(viewFont, kFaceBold)}; // for titles       	cachedLine := MakeRect(selectIndent-4, 0, selectIndent-3, :LocalBox().bottom);              	local /*frame*/ entry;       	foreach entry in querySpec       	do  if not :CheckState(entry)       		then return;       	nothingCheckable := true;       	cachedLine := nil;       	//inherited:?viewSetupFormScript();       end,     HitItem:       func(int index, int x, int y)       if nothingCheckable or :CheckState(cursor:GetIndexEntry(index + cursPos - 1))	// ignore invalid entries       then TRUE       else if x < selectIndent+5       then inherited:HitItem(index,x,y)       else begin       	local int oldLen := if selected then Length(selected) else 0; // none before       	:SelectItem(index);       	if oldLen=0       	then base:extractScript()       	else :RedoChildren();	// checkmarks       	TRUE;       	end,     cursCount: nil,     fakeCursor:       // for pseudo-soup        {items: nil,              itemLen: nil,              index: 0,              Entry: func()       	if index < itemLen       	then items[index],              Next: func()       	if index < itemLen-1       	then items[index := index + 1],              Move: func(INT delta)       	items[index := Min(Max(index + delta, 0), itemLen-1)],              Reset: func()       	index := 0,              Clone: func()       	{_proto: self,       	index: index,},	// !!!k. reset index?              GetIndexEntry: func(INT theIndex)       	items[theIndex],       	       /*       countEntries: func()       	itemLen,       */       },     viewFont: ROM_fontSystem9,     autoDeselect: true    };AddStepForm(protoFileOverview, overview);StepDeclare(protoFileOverview, overview, 'overview);// After Script for overviewthisView := overview;begin	thisView._proto := protoSoupOverview;	// @460endallButton :=    {     buttonClickScript:       func()       begin       	local array sel := overview.selected;       	overview.selected := [];              	if not isArray(sel) or Length(sel) < overview.cursCount       	then begin       		sel := overview.selected;       		local /*frame*/ cursor := overview:reset();       		local /*frame*/ entry := cursor:entry();              		while entry       		do begin       			AddArraySlot(sel, entry);       			entry := cursor:next();       			end;       		cursor:Reset();       		end;              	overview:updateTitle(true);       end,     viewBounds: {left: 3, top: -15, right: 38, bottom: -3},     viewJustify: 8388742,     text: $\uFC0B & "All",     _proto: @226 /* protoTextButton */    };AddStepForm(protoFileOverview, allButton);extractButton :=    {buttonClickScript: func() base:extractScript(),     viewBounds: {left: 48, top: -15, right: 118, bottom: -3},     viewJustify: 8388742,     text: "Extract files",     _proto: @226 /* protoTextButton */    };AddStepForm(protoFileOverview, extractButton);saveInboxButton :=    {     buttonClickScript:       func()       try GetUnionSoup(ROM_inboxsoupname):AddFlushedXmit({       	class: 			'ioItem,        	xlabels: 		'[_unfiled, _new],       	category: 		'|beam:newton|,       //	appSymbol: 		kExtrasSym,       	title: 			title,					       	body:  			{data: data, title: url},       	timestamp: 		Time(),       	labels: 		NIL,       	state: 			'Received,        	}, 'entryAdded)       onexception |evt.ex|       do :Notify(kNotifyAlert, "Inbox Error", currentException().error),     viewBounds: {left: 128, top: -15, right: 218, bottom: -3},     viewJustify: 8388742,     text: "Save .zip to Inbox",     _proto: @226 /* protoTextButton */    };AddStepForm(protoFileOverview, saveInboxButton);protoFileOverview_v166_0 := {_proto: @166 /* protoCloseBox */};AddStepForm(protoFileOverview, protoFileOverview_v166_0);constant |layout_protoFileOverview| := protoFileOverview;// End of file protoFileOverview// Beginning of text file Unzip.txtconstant kByteSize :=   256;	// for ExtractRWord, ExtractRLongconstant kWordSize := 65536;// ==========// Newt's Cape helperAppDefineGlobalConstant('kNewtsCapeSymbol, '|NewtsCape:NewtsCape|);DefineGlobalConstant('kNewtsCapeEmptyGlobal, {	cache: [], historyPos: 0,				htmlApps: {}, helperApps: {},	imageExtensions: [".gif"],	protos: {},	}); constant kNotesSym := 'paperroll; // for borrowing Newt's Cape "tiny icon"// ==========// ZIP file/header signaturesDefineGlobalConstant('kJarLocSig, "PK\u00030004");//DefineGlobalConstant('kJarCenSig, "PK\u00010002");DefineGlobalConstant('kJarEndSig, "PK\u00050006");// file offset infoDefineGlobalConstant('kNumRecPos, -12);	// numRec pos (word) within fileDefineGlobalConstant('kRecPos, 	  0);	// 1st rec pos (long)//DefineGlobalConstant('kRecOffset, 30);	// rec size incrementDefineGlobalConstant('kLOCHDR,	  30); // .jar  header lengthDefineGlobalConstant('kUnzipMediaTypes, [	"application/zip",	"application/zip-compressed",	// jar?	"application/x-zip-compressed",	//??other	]);DefineGlobalConstant('kUnzipMediaExt, [".jar", ".zip"]);DefineGlobalConstant('kUnzipHelperFrame, {transferMode: 'binary,extensions:   kUnzipMediaExt,sigBytes:	kJarEndSig,sigPos:		-22,matchFile: /*boolean*/ func(/*string*/ url, /*binary*/ data) // for Inbox testingbegin	local int pos := LSearch(extensions, url, 0, GetGlobalFn('EndsWith), nil);	return if pos and IsBinary(data) and :ByteBeginsWith(data, sigBytes, sigPos) then pos;end,addFile: /*boolean*/ func(/*string*/ contentType, /*string*/ url, /*binary*/ data, /*frame*/ options)beginif (kDEBUG) then Print([contentType,url]);	if not :matchFile(url, data)	then return NIL;	// this shouldn't happen... let Newt's Cape report no helperApp	local errObj := {_proto: self, curFileName: url};	if not options	then options := {};	if not call kMissingImportsFunc with (ObjectPkgRef("Me"))	then begin		options.(EnsureInternal('allowCompressed)) := true;//if kDebug then Print("using" && kZlibName && call UR(kZlibSymbol, 'GetZLibVersion) with ());		end;//if (kDEBUG) then Print(options);	// build map of extensions to MIME type (for later dispatch)	// Newt's Cape(built-in)	local /*string*/ array mediaExts  := [".htm",      ".html",     ".gif",      ".txt",       ".pkg",];	local /*string*/ array mediaTypes := ["text/html", "text/html", "image/gif", "text/plain", "application/x-newton-compatible-pkg"];	// check other helperApps;	local /*frame*/ helperApps := GetGlobalVar(kNewtsCapeSymbol).helperApps;	if helperApps.|application/x-pilot-pdb| and helperApps.|application/x-pilot-prc|	then begin // avoid generic */* or text/ for PilotDoc plugin		AddArraySlot(mediaExts, ".pdb"); AddArraySlot(mediaTypes, "application/x-pilot-pdb");		AddArraySlot(mediaExts, ".prc"); AddArraySlot(mediaTypes, "application/x-pilot-prc");		end;	local /*symbol*/ helperSym;	local /*frame*/ helperFrame, helperApp;	local /*string*/ ext;	foreach /*symbol*/ contentType,helperFrame in helperApps	do  foreach helperSym,helperApp in helperFrame		do if IsArray(exts := helperApp.extensions)			then foreach ext in exts				 do if not LSearch(mediaExts,ext,0,'|str=|,nil)					then begin						AddArraySlot(mediaExts, ext);						AddArraySlot(mediaTypes, SPrintObject(contentType));						end;//if (kDEBUG) then Print(mediaExts);//if (kDEBUG) then Print(mediaTypes);	local int i, ulen := StrLen(url), pos := 0;	for i := ulen-1 to 0 by -1	do  if url[i] = $/		then break pos := i+1;	local /*string*/ zipName := Substr(url, pos, ulen), fileName;	local int nameLen, fullLen, fileLen, recPad := 0, zipFormat, dTime1,dTime2, modMins;	local int offset := kRecPos, dlen :=  Length(data);	// technically this could be a long though I doubt it	local int numRec := :ExtractRWord(data, dlen + kNumRecPos); // from endif (kDEBUG) then Print(zipName & ";  bytes:" && dlen & "; items:" && numRec);	local ARRAY fileItems := Array(numRec,nil);	// cache file names, offsets, lens	// offset points to beginning of next record (initially; then fileName, then data)	for i := 0 to numRec-1	do begin		if not :ByteBeginsWith(data, kJarLocSig, offset) // LOC entry		then return errObj:error("problem record:" && i, "offset:", offset, FATAL_ERROR);			//ExtractByte(data,offset) && ExtractByte(data,offset+1) && ExtractByte(data,offset+2) && ExtractByte(data,offset+3));				//LOCVER(4)	version needed to extract		//LOCFLG(6)	general purpose bit flag		zipFormat := :ExtractRWord(data, offset+ 8);	//LOCHOW	compression method (0=stored; 8=deflated)		dTime1    := :ExtractRWord(data, offset+10);	//LOCTIM	modification time(DOS format)		dTime2    := :ExtractRWord(data, offset+12);	// do as 2 words instead of long		fileLen	  := :ExtractRLong(data, offset+18);	//LOCSIZ	compressed size (same as uncomp if no compression)		fullLen   := :ExtractRLong(data, offset+22);	//LOCLEN	uncompressed size		nameLen   := :ExtractRWord(data, offset+26);	//LOCNAM	filename length		recPad	  := :ExtractRWord(data, offset+28);	//LOCEXT	extra field length		offset := offset + kLOCHDR;		fileName  := :UniMunger(nil,0,nil, data, offset, nameLen);		modMins := TotalMinutes({ // convert from DOS to Newton time format(mins since 1/1/1904)			year:	Band((dTime2 >>  9), 0x7F) + 1980,			month:	Band((dTime2 >>  5), 0x0F),			date:	Band( dTime2,        0x1F),			hour:	Band((dTime1 >> 11), 0x1F),			minute: Band((dTime1 >>  5), 0x3F),		  //second: Band((dTime1 <<  1), 0x3E),			});		offset := offset + nameLen + recPad;		pos := LSearch(mediaExts, fileName, 0, GetGlobalFn('EndsWith), nil);		fileItems[i] := {			item: 		fileName,			fileOffset:	offset,		// start of data for kSTORED			fullLength: fullLen,	// uncompressed			fileLength: fileLen,	// less if compressed			compMethod: zipFormat,			contentType: if pos then mediaTypes[pos],			_modTime: 	modMins,			};		offset := offset + fileLen;if (kDEBUG) then Print(fileName & "; len:" && fullLen & "; type:" && fileItems[i].contentType);if (kDEBUG) then Print("modified:" &&				LongDateStr(modMins,ROM_dateTimeStrSpecs.abbrDateStrSpec) &&				TimeStr(modMins, ROM_dateTimeStrSpecs.shortTimeStrSpec));if (kDEBUG and zipFormat <> kSTORED)then Print("compressed:" && fileLen & "; method:" && (if zipFormat=kDEFLATED then kDeflatedName else zipFormat&$?));		end;	local notes := GetRoot().(kNotesSym);	local entry := LFetch(notes:GetRouteScripts(notes:GetTargetInfo('routing)), kNewtsCapeSymbol, 0, '|=|, 'tag);	BuildContext({       	_proto: protoFileOverview,       	icon: if entry then entry.icon,	// for progress       	title: zipName,       	url: url,       	querySpec: fileItems,		callbackObj: errObj,		callbackMeth: 'unzipFile,		data:  data,		options: options,       	}):open();	return TRUE; // this has handled (possibly some callbacks to unzipFile later)end,curFileName: nil,	// for :error. set in an errObj instanceInflater: { // borrowed from VNC	// more compatible with Java API and hides more zlib details	_proto: UR(kZLibSymbol, 'ProtoInflateStream),	obj: nil,	new: func(obj, int zh)	// zh=-15 for no zlib header (e.g., .zip)		begin			local inf :=				{_proto: self,				obj: obj,		// for status, error				closed: nil,				//zstreamf:		// created by InflateInit				};			local int err := if zh then inf:InflateInit2(zh) else inf:InflateInit();			if err			then return obj:?error("InflateInit" && if inf.zstreamf then inf.zstreamf.msg, err, FATAL_ERROR);			return inf;		end,	close: func()		begin			local int err;			if not closed			then try err := :InflateEnd();				onexception |evt.ex|				do err := currentException();			closed := true;			if err			then obj:?error("InflateEnd" && zstreamf.msg, err, IGNORE_ERROR);			nil;		end,	setInput: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_in 	:= data;			zstreamf.next_in 	:= offset;			zstreamf.avail_in 	:= len;		end,	inflate: func(/*byte[]*/ data, int offset, int len)		begin			zstreamf.bin_out 	:= data;			zstreamf.next_out 	:= offset;			zstreamf.avail_out 	:= len;			local int err := inherited:Inflate('sync);	// 'finish ???			if err and (err <> Z_STREAM_END or zstreamf.avail_out <> 0)			then return obj:?error("Inflate" && zstreamf.msg && zstreamf.avail_out, err, FATAL_ERROR);			true;		end,},// called via callback by protoFileOverview.extractScriptunzipFile: func(/*frame*/ fileItem, /*binary*/ data, /*frame*/ options, /*frame*/ progressView, /*frame*/ progressOptions)begin	curFileName := fileItem.item;	// reset for each indiv file//Print(curFileName);	local /*string*/ contentType := fileItem.contentType;	if not IsString(contentType)	then return :error("unknown helper", contentType, FATAL_ERROR);	local int offset := fileItem.fileOffset, len := fileItem.fullLength, zipFormat := fileItem.compMethod;	local /*boolean*/ isText := BeginsWith(contentType, "text/"), isCompressed := (zipFormat = kDEFLATED and options.allowCompressed);	if not (isCompressed or zipFormat = kSTORED)	// shouldn't have occurred, but just in case...	then return :error("unrecognized compression", zipFormat, FATAL_ERROR);	if not progressOptions	then progressOptions := {};	local /*string*/ title := (if zipFormat = kDEFLATED then kDeflatedName else kStoredName) & $: && curFileName;	local /*frame*/ inf;	if isCompressed	// Unit is present (checked in addFile)	then begin		inf := Inflater:new(self, -15);		if not inf		then return;	// error already reported		inf:setInput(data, offset, fileItem.fileLength);		end;	local /*binary*/ tmpData, fileData;	local int i, remaining := len, flushInc := kVBOFlush, inc := min(len, 4096); // inc=4K (flushInc should be multiple)	// create final destination (fileData)	if isText	then begin		if isCompressed		then tmpData := MakeBinary(inc, 'bytes);	// create interim buffer		flushInc := kVBOFlush div 2;				// more freq due to expansion		fileData := :makeBigBinary((len*2)+2, 'string);	// unicode + null		end	else fileData:= :makeBigBinary(len, 'bytes);	// inflate or copy -- incrementally	for i := 0 to len-1 by inc	do begin//Print(i);		progressOptions.titleText := title & unicodeCR & i & $/ & len;		progressOptions.gauge := RIntToL(i * 100 / len);		try progressView:?SetStatus('vGauge, progressOptions)		onexception |evt.ex.cancel| do return inf:?close();		if (i mod flushInc) = 0 and i > 0 and IsVBO(fileData)		then ClearVBOCache(fileData);		if isText		then begin			if inf			then if inf:inflate(tmpData, 0, inc)					// kDEFLATED: expand into tmpData				then :UniMunger(fileData, i, inc, tmpData, 0, inc);	// copy as unicode				else return inf:close();							// Inflate already reported error			else :UniMunger(fileData, i, inc, data, offset+i, inc);	// kSTORED: copy as unicode			end		else begin			if inf			then if inf:inflate(fileData, i, inc)					// kDEFLATED: expand directly into fileData				then nil	// ok				else return inf:close();							// Inflate already reported error			else BinaryMunger(fileData,i,inc, data, offset+i, inc);	// kSTORED: copy directly into fileData			end;		remaining := remaining - inc;		if remaining < inc		then inc := remaining;		end;	// cleanup	inf := inf:?close();	progressOptions.gauge := 100;	try progressView:?SetStatus('vGauge, progressOptions)	onexception |evt.ex.cancel| do return;	if IsVBO(fileData)	then ClearVBOCache(fileData);//if (kDEBUG) then Print(fileData);	AddDeferredSend(GetRoot().(kNewtsCapeSymbol), 'dispatchFile, [contentType, EnsureInternal(curFileName), fileData, options]);end,makeBigBinary: func(int len, /*symbol*/ class)if len > 4096then GetDefaultStore():NewCompressedVBO(EnsureInternal(class), len, kTextCompander, nil)else MakeBinary(len, EnsureInternal(class)),// convert packed ascii (8-bit not unicode chars) to unicode -- see NC:copyRawHTML// like ExtractCString except it supports VBOs, offsets and lens (ending null not required)/*string*/ UniMunger: func(/*string*/ str, int strOffset, int strLen, /*byte*/ data, dataOffset, dataLen)begin // strLen unused	if not str	then str := MakeBinary((2*dataLen)+2, 'string);	// :makeBigBinary???	local int i, byte;	for i := 0 to dataLen-1	do	if (byte := ExtractByte(data,dataOffset+i)) = 0		then break StrMunger(str,strOffset+i,nil, nil,0,nil)		else str[strOffset+i] := if byte = chLF then unicodeCR else Chr(byte);	str;end,error: func(/*string*/ msg, earg, /*boolean*/ fatal)	// earg: string, int, nil or frame=currentException()begin	local eval := earg;	if IsFrame(earg) 	then if not (eval := earg.error)		then if IsFrame(earg.data)			then eval := earg.data.errorCode;	msg := curFileName && msg & $: && eval;//Print(msg);	if fatal	then GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), msg);	NIL;end,// BMP,JAR seems to use little-endian rather than big-endian for header fieldsExtractRWord: /*int*/ func(/*byte[]*/ data, int offset)begin	local int byte1 := ExtractByte(data, offset+1), byte2 := ExtractByte(data, offset);	if byte1=0	then byte2	else (byte1*kByteSize) + byte2;end,ExtractRLong: /*long*/ func(/*byte[]*/ data, int offset)begin	local int word1 := :ExtractRWord(data, offset+2);	local int word2 := :ExtractRWord(data, offset);	if word1=0	then word2	else (word1*kWordSize) + word2;end,ByteBeginsWith: /*boolean*/ func(/*byte[]*/ bytes, /*string*/ str, int offset)begin	local int i, slen := StrLen(str), blen := Length(bytes);	if offset < 0	then offset := blen+offset;	if offset < 0 or offset+slen > blen	then return NIL;	for i := 0 to slen-1	do if ExtractChar(bytes, offset+i) <> str[i]		then return NIL;	TRUE;end,protoFileOverview: GetLayout("protoFileOverview"),});// ==========DefineGlobalConstant('kBMPMediaTypes, [	"image/bmp",	//??other	]);DefineGlobalConstant('kBMPMediaExt,   [".bmp", ".wbm"]);// 1.x compat for booksconstant kHeadlen1x := 16;//constant kHeadlen2x := 28;DefineGlobalConstant('kBMPSig, "BM");DefineGlobalConstant('kBMPHelperFrame, {transferMode: 'binary,extensions:   kBMPMediaExt,sigBytes:	"BM",sigPos:		0,matchFile:	kUnzipHelperFrame.matchFile,	// *** sharecurFileName: nil,	// for :error. set in an errObj instance// borrowed from WabaTester.convertBitmap, wababin.pkg.BitmapaddFile: /*boolean*/ func(/*string*/ contentType, /*string*/ url, /*binary*/ data, /*frame*/ options)beginif (kDEBUG) then Print([contentType,url]);	if not :matchFile(url, data)	then return NIL;	// this shouldn't happen... let Newt's Cape report no helperApp	local errObj := {_proto: self, curFileName: url};    local int offset := 0, len := Length(data);		//+0 = "BM"  (sigBytes)		//+2L = len		//+6L = 0 reserved	local int doffset  	:= :ExtractRLong(data, offset+10);		//+14L infoSize=40	local int width  	:= :ExtractRLong(data, offset+18);	local int height 	:= :ExtractRLong(data, offset+22);		//+26W = 0 planes 	local int depth    	:= :ExtractRWord(data, offset+28);    if depth > 4    then return return errObj:error("depth", depth, FATAL_ERROR); 	local int comp		:= :ExtractRLong(data, offset+30);    if comp <> 0    then return return errObj:error("compression", comp, FATAL_ERROR);	local int dlen 		:= :ExtractRLong(data, offset+34);		//+38L  x pixelspermeter		//+42L	y pixelspermeter		//+46L colorsUsed=2		//+50L colorImportant?		//+54L col1		//+58L col2 (blue,green,red,reserved) 255,255,255,0 	local /*boolean*/ invert :=            	not (:ExtractRLong(data, offset+54) <> 0 and            		 :ExtractRLong(data, offset+58) = 0);	if dlen=0	then dlen := ((len-doffset) div 4) * 4;//Print([len, doffset,dlen, width,height,depth, invert]);	local int rowBytes  := 4*(((width*depth) + 31) div 32);	local /*byte[]*/ bits := :makeBigBinary(kHeadlen1x + (rowBytes*height), if depth=1 then 'bits else 'cbits);	StuffWord(bits,  4, rowBytes);	StuffWord(bits, 12, height);	//8=top(0),10=left(0)	StuffWord(bits, 14, width);	local /*bitmap*/ bitmap := {		bounds: RelBounds(0, 0, width, height),		};	if depth=1	then bitmap.bits := bits	else bitmap.colordata := {		cbits: bits,		bitdepth: depth,		};	local int x, y, btop := kHeadLen1x; // wbytes := (width-1) div (8 div depth);	local int dtop := offset + doffset + dlen - rowBytes, byte, flushBytes := if IsVBO(bits) then 0;//Print([btop, dtop, rowBytes, bitmap]);	for y := 0 to dlen-1 by rowBytes	do  begin		for x := 0 to rowBytes-1		do begin			byte := ExtractByte(data, dtop-y+x); 			StuffByte(bits, btop+y+x, if invert then Bxor(0xFF, byte) else byte);			end;		if flushBytes and (flushBytes := flushBytes + rowBytes) >= kVBOFlush		then begin			flushBytes := 0;			ClearVBOCache(bits);			end;		end;	if flushBytes	then ClearVBOCache(bits);	// this handles single BMP. alternatively, generate full URL and cache??	GetRoot().(kNewtsCapeSymbol):?addFile(contentType, url, bitmap, options);end,// *** sharemakeBigBinary: 	kUnzipHelperFrame.makeBigBinary,error:			kUnzipHelperFrame.error,ExtractRWord:	kUnzipHelperFrame.ExtractRWord,ExtractRLong:	kUnzipHelperFrame.ExtractRLong,ByteBeginsWith: kUnzipHelperFrame.ByteBeginsWith,});// =====DefineGlobalConstant('kInstallHelperApp, /*void*/ func(/*string*/ contentType, /*symbol*/ helperSym, /*frame*/ helperApp)if GetRoot().(kNewtsCapeSymbol)	// use built-in installHelperApp if therethen GetRoot().(kNewtsCapeSymbol):installHelperApp(contentType, helperSym, helperApp)else begin	local /*frame*/ gData := GetGlobalVar(kNewtsCapeSymbol);	if not gData	then DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal(kNewtsCapeEmptyGlobal)); 	local /*frame*/ helperApps := gData.helperApps;	local /*symbol*/ icontentType := Intern(contentType);	local /*frame*/ helperFrame := helperApps.(icontentType); 	if isFrame(helperApp)	then begin // install		if not helperFrame then		helperApps.(EnsureInternal(icontentType)) := helperFrame := EnsureInternal({});		// assume in this version that helperApp has 'addFile		helperFrame.(EnsureInternal(helperSym)) := helperApp; // add/replace		end	else if helperFrame and Length(RemoveSlot(helperFrame,helperSym))=0	then RemoveSlot(helperApps, icontentType); // un-install	end;);InstallScript := func(/*frame*/ partFrame, /*frame*/ removeFrame)begin	local /*frame*/ data := partFrame.partData;	local /*string*/ contentType;	foreach contentType in kUnzipMediaTypes	do data:InstallHelperApp(contentType, kPkgSymbol, data.UnzipHelperFrame);	foreach contentType in kBMPMediaTypes	do data:InstallHelperApp(contentType, kPkgSymbol, data.BMPHelperFrame);	local /*string*/ ext;	foreach ext in kBMPMediaExt	do AddArraySlot(GetGlobalVar(kNewtsCapeSymbol).imageExtensions, EnsureInternal(ext));end;RemoveScript :=	func(/*frame*/ removeFrame)begin	local /*string*/ contentType;	foreach contentType in kUnzipMediaTypes	do call kInstallHelperApp with (contentType, kPkgSymbol, nil);	foreach contentType in kBMPMediaTypes	do call kInstallHelperApp with (contentType, kPkgSymbol, nil);	local /*string*/ ext;	local array exts := GetGlobalVar(kNewtsCapeSymbol).imageExtensions;	local int pos;	foreach ext in kBMPMediaExt	do if (pos := LSearch(exts,ext,0,'|str=|,nil))		then ArrayRemoveCount(exts,pos,1);end;SetPartFrameSlot('RemovalApproval, func(/*symbol*/ unitName, int major, int minor)if unitName = kZlibSymbolthen return	"If you remove" && kZlibName & $, &&	kAppName && "will disable Deflate for .zip files";);/*SetPartFrameSlot('ImportDisabled, func(unitName, int major, int minor)if unitName = kZlibSymbol// don't care -- addFile will check next time used);*/SetPartFrameSlot('text, kAppName);	// nicer than symbol, plus allows tapActionSetPartFrameSlot('tapAction, func()	GetRoot():Notify(0,		kAppName && kVersionNum & kBetaVersion,		"a Newt's Cape helperApp\nfor .zip and .bmp files.\n\n©2001. Steve Weyer\nwww.kagi.com/weyer/#Unzip"));partData := {	// avoids some ensure-internaling at install time?installHelperApp:	kInstallHelperApp,UnzipHelperFrame: 	kUnzipHelperFrame,BMPHelperFrame: 	kBMPHelperFrame,};/*getglobals().|newtscape:newtscape|.helperapps.|application/zip|.|UnzipBMP:NewtsCape|http://www.unna.org/unna/books/Newton/NewtNews117.txt.ziphttp://www.unna.org/unna/books/Newton/NN049.pkg.zip*/// End of text file Unzip.txt