// HTMList 1.0// Copyright 1997-2000. S. Weyer. All Rights Reserved Worldwideconstant kHTMList 		:= "HTMList";constant kVersionNum 	:= "1.0";constant kVersionInt	:= 10;constant kBetaVersion 	:= "k";// avoid some compiler warningsDeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalConstant('kExpiringVersion, kBuild20 and NIL);	// !!!eDefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if not kIgnoreNativeKeyword then $N) &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if kExpiringVersion then $X) &	(if kBuild20 then "-2"));DefineGlobalConstant('kVersion, kHTMList && kVersionString);Print("hlst" & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then $N	else if language='English	then $2	else Upcase(SPrintObject(language))[0])	& ".pkg");Print(kVersion && DateNTime(time()));DefineGlobalConstant('kPkgSymbol, Intern(kPackageName)); // kAppSymbol='autoPrint(kPkgSymbol);//Print(kAppSymbol);	// same/*Notes	Save as HTML	Newt's Cape:Add Bookmarks [2.x]NewtWorks	Save as HTML [2.1]	Newt's Cape:Add Bookmarks [2.1]Books [Help 2.1]	Page Range	Save to NewtWorks [2.1]	Save as HTML to NewtWorks [2.1]	Save as HTML to Notes	Save as HTML to Desktop	Mail,Speak,... [2.1]Inbox	Newt's Cape:Add Bookmarks [2.x]merge RouteBook?save FONT FACE info?for font info, one strategy for saving to HTML would be to save the name of the font,e.g., <FONT FACE=Geneva>.  another would be to try to map from user prefs(this assumes that user had installed Newt's Cape, and that the Appearance mappingswere relatively unique)recognition of tabs?(except unless using PRE, there wouldn't be any tabs in a book (createdfrom HTML); and going from NewtWorks, not sure how tabs would beinterpreted?  or, if you identify 18 bold Casual as H1 inNewt's Cape, then if there's an 18 bold Casual line in Newtworks,perhaps HTMList could tag it as <H1> from- higher-level tags. e.g., from patterns as in the list items. or headings based onentire paragraph being bold, with largest one H1. -perhaps lists based on - or bullet and tabs and maybe HREFs using patterns like in lists- look for a way to share some code. currently, Newt's Cape, NewtDevEnv,Sloup and HTMList all each to define functions their own copies of functions forgetting text from/saving text to NewtWorks docs. slight size and maintenance advantages,but some rewriting necessary and not large amounts of code saved, so low priority. - of course, as it moves beyond a simple demo of just Notes list items, might need tobe renamed to better reflect what it does. (and as I add features/provide support,might want to charge $10 for it separately, or offer it as a further incentivefor Newt's Cape registration).NAMEHREFs (instead of U)H1 (if non-B)char entities*/DeclareGlobalFn('ClearVBOCache, 1);DeclareGlobalFn('GetAppPrefs, 2);constant kExportHTML	:= "Save as HTML";constant kAddBookmarks	:= "Newt's Cape:Add Bookmarks";constant kHTTP			:= "http:";constant kNotesSym 		:= 'paperroll;constant kNewtsCapeSym 	:= '|Newtscape:Newtscape|;constant kSloupSym 		:= '|Sloup:TKnollSys|;constant kNewtWorksSym	:= 'NewtWorks;constant kBookReaderSym	:= 'Copperfield;constant kHelpReaderSym	:= 'TinyTim;constant kInboxSym		:= 'ioBox;constant kNCViewDefSym	:= '|ViewText:Copperfield:NewtsCape|;constant kNCDataDefSym	:= '|DataText:Copperfield:NewtsCape|;constant kPageRange		:= "Page Range";constant kParaTag		:= "<P>";constant tabs 			:= "\t\t\t\t\t\t\t\t\t\t";constant cr 			:= "\n";DefineGlobalConstant('crlf, unicodeCR & unicodeLF);constant kEndPara		:= cr;	// end of paragraph?DefineGlobalConstant('kDefaultPrefs,	if kBuild20 then {} else {tag: kPackageName});DefineGlobalConstant ('kContentsPath,	'contents);DefineGlobalConstant ('kTOCPath,		'[pathExpr: browsers,0,list]);DefineGlobalConstant ('kPagePath,		'[pathExpr: rendering,0,pages]);DefineGlobalConstant ('kMetaFields, '["ISBN", "Author", "Copyright"]);DefineGlobalConstant ('kISBNField, [kMetaFields[0]]);	// shareconstant kAlign := '["Left", "Right", "Center", "Justify"];constant kUntitled := "untitled";// =====DefineGlobalConstant('kVBOFlush, 10*1024);	// !!!j(16),i(20)DefineGlobalConstant('kBigStringObj, {new: func(str)	{_proto: self,	bigStr:		if kBuild20		then begin	// !!!e. inline kNewVBO			gc();			local vbo :=				GetDefaultStore():NewCompressedVBO('string, if str then Length(str) else 0, kTextCompander, nil);			BinaryMunger(vbo,0,nil, if str then str else "",0,nil);			end		else Clone(if str then str else ""),	// !!!j	nextFlush: if kBuild20 then kVBOFlush,	},append: func(str,start,count)	begin		StrMunger(bigStr,StrLen(bigStr),0, str,start,count);		if kBuild20 and (StrLen(bigStr)*2) >= nextFlush		then begin			ClearVBOCache(bigStr);			nextFlush := nextFlush + kVBOFlush;			end;	end,save: func(title, labels, show) // !!!e. ignore args	begin		if kBuild20		then ClearVBOCache(bigStr);		bigStr;	end,});DefineGlobalConstant('kNotesObj, { // !!!g_proto: kBigStringObj,save: func(title, labels, show)	// use show?	begin		local notes, note;		if kBuild20		then begin			ClearVBOCache(bigStr);			notes := GetRoot().(kNotesSym);			note := notes:makeTextNote(bigStr, nil);			end		else begin			constant noteFont	:= userFont10;			constant noteWidth	:= 226;			//constant noteHeight := 265;			constant noteLeft	:= 10;			constant noteTop	:= 2;			local INT ht := 2*FontHeight(noteFont) + // add two lines				call kSimpleTextHeightFunc with (bigStr, noteWidth, noteFont);			note := {				viewStationery: kNotesSym,				height: ht,				data: [{					viewStationery: 'para,					viewBounds: RelBounds(noteLeft,noteTop,noteWidth,ht),					text: bigStr,					viewFont: noteFont,					}],				timeStamp: Time(),				};			end;				note.title := title;		note.labels := labels;		if kBuild20		then notes:newNote(note, true, nil)		// display it; store on default store		else begin			GetUnionSoup(ROM_paperRollSoupName):AddToDefaultStore(note);			BroadcastSoupChange(ROM_paperRollSoupName);			end;	end,});// =====DefineGlobalConstant('kFaceStrings, [	[kFaceBold, 		"B"],	[kFaceItalic, 		"I"],	[kFaceUnderline, 	"U"],	[kFaceOutline,		"O"],	[kFaceSuperScript,	"SUP"],	[kFaceSubScript,	"SUB"],	]);DefineGlobalConstant('kMakeTag, func(tag, stop, attrib)	// !!!d	$< & stop & tag & (if attrib then $  & attrib) & $>);DefineGlobalConstant('kGetFontFace, func(font) // !!!f. 1.xif isFrame(font)then font.faceelse Band(font,tsFaceMask) >> tsFaceShift);DefineGlobalConstant('kTagFunc, func(font,text,start,count, hx,attrib) // !!!dbegin//Print(["kTagFunc",font,text,start,count,hx,attrib]);	local INT face :=		if kBuild20		then GetFontFace(font)		else call kGetFontFace with (font);	local ARRAY fbit;	local s1, s2, ptag;	if face=0 and hx	then begin		s1 := call kMakeTag with (hx, nil, attrib);		s2 := call kMakeTag with (hx, $/,  nil);		end	else foreach fbit in kFaceStrings // in case there are combinations		 do if BAND(face,fbit[0]) <> 0			then begin				ptag := if hx then hx else fbit[1];				s1 := s1 & call kMakeTag with (ptag, nil, attrib);				s2 := call kMakeTag with (ptag, $/,  nil) & s2;				end;	text := SubStr(text,start,count);	StrReplace(text, "&", "&amp;", nil);	StrReplace(text, "<", "&lt;", nil);	StrReplace(text, ">", "&gt;", nil);	s1 & text & s2;end);//justification	Optional. One of the symbols: 'left, 'right, 'center or 'full.DefineGlobalConstant('kAppendPara, func(bigStr, entry) // !!!c. from Notes or NewtWorksbegin	local text, styles, ptag := $P, attrib, align, rulers, font;	local INT i, pos, len;	if (text := entry.text) and		(if kBuild20		then IsString(text) and not IsRichString(text)		else isInstance(text, 'string)) and		StrFilled(text)	then begin		if kBuild20 and IsArray(rulers := entry.rulers) and Length(rulers) > 0 and			(align := rulers[1].justification) and align <> 'left		then attrib := "ALIGN=" & if align='full then "justify" else align; // NW only. !!!f		if isArray(styles := entry.styles)		then begin			if Length(styles)=2			then begin // treat like viewFont				if not (kBuild20 and styles[0]=1 and text[0] = $\u2206)				then font := styles[1];				end			else begin				bigStr:append(call kMakeTag with (ptag,nil,attrib), pos := 0, nil); // !!!f				for i:=0 to Length(styles)-1 by 2				do begin					len := styles[i];					if not (kBuild20 and len = 1 and text[pos] = $\u2206) // elim NW graphics					then bigStr:append(call kTagFunc with (styles[i+1],text,pos,len, nil,nil), 0,nil);					pos := pos + len;     				end;     			bigStr:append(cr,0,nil);     			end;     		end     	else font := entry.viewFont;     	if font	// all same font. check for heading     	then begin     		bigStr:append(     			if Band(if kBuild20					then GetFontFace(font)					else call kGetFontFace with (font), kFaceBold) <> 0				then call kTagFunc with (0,text,0,nil, "H1",attrib) & unicodeCR				else call kMakeTag with (ptag,nil,attrib) & call kTagFunc with (font,text,0,nil, nil,nil) & unicodeCR,				0,nil);			end;		end;end);DefineGlobalConstant('kStartDoc, func(book, metaFields)	// !!!e,cbegin	local str := "<HTML><HEAD><TITLE>" & book.title & "</TITLE>\n", obj, val;	if book.data and book.data.base_href	// !!!f	then str := str & "<BASE HREF=\"" & book.data.base_href & "\">\n";	foreach obj in metaFields	do  if val := book.(Intern(obj))		then str := str & "<META NAME=\"" & obj & "\" CONTENT=\"" & val & "\">\n";	str & "</HEAD><BODY>\n";end);DefineGlobalConstant('kEndDoc, "</BODY></HTML>\n");		// !!!cDefineGlobalConstant('kMakeFileName, func(title)if kBuild20then SubstituteChars(title, " ", "_") & ".htm"else begin	// !!!d. 1.x	StrReplace(title := Clone(title), " ", "_", nil);	title & ".htm";	end);DefineGlobalConstant('kNotesExportTitle, func(target)// for GetTitle slot of routeframeif target //and (target.class='list or target.class='checkList)		// !!!cthen kExportHTML);DefineGlobalConstant('kNotesExportScript, func(target, targetView)begin // for RouteScript slot of routeframe	local topic, text, indent, title := target.title, groupTag, listTag, pos, url, entry, styles;	if not title	then title := kUntitled;	local filename := call kMakeFileName with (title);	local INT lastLevel := 0, level, i;	local ARRAY endings := [];	local noteStr := kNotesObj:new(call kStartDoc with ({title: title, ISBN: filename}, kISBNField)); // !!!e//Print(noteStr);	if kBuild20 and (target.class='list or target.class='checkList)	// !!!c	then begin		foreach topic in target.topics		do  if IsString(text := topic.text) and not IsRichString(text) and StrFilled(text)			then begin				//text := Clone(text);	// !!!c				level := topic.level;				indent := SubStr(tabs, 0, level-1);				if level < lastLevel := Length(endings)		// end list (>=1 levels)				then begin					for i := 0 to lastLevel-level-1					do noteStr:append(endings[i], 0,nil);	// !!!c					ArrayRemoveCount(endings, 0, lastLevel-level);					end				else if level > lastLevel					// begin list				then for i := lastLevel to level-1					do begin						groupTag := // check first item for 'type'   nnn.   ddd: 							if $0 <= text[0] and text[0] <= $9 and CharPos(text,$.,0) and StringToNumber(text)							then "<OL>\n"							else if text[0] <> $< and CharPos(text, $:, 0)							then "<DL>\n"							else "<UL>\n";						noteStr:append(indent & groupTag, 0,nil);	// !!!c						ArrayInsert(endings, indent & StrMunger(Clone(groupTag),1,0, "/",0,1), 0);						end;				pos := nil;				listTag := "<LI>";				groupTag := endings[0][StrLen(endings[0])-4];	// char: U, O, D  "\t..</xL>\n"				if groupTag = $O and text[0] <> $<				then pos := CharPos(text, $., 0)				else if groupTag = $D				then begin					listTag := "<DT>";					if text[0] <> $< and pos := CharPos(text, $:, 0)					then begin						noteStr:append(indent & listTag & TrimString(SubStr(text,0,pos)) & unicodeCR, 0,nil);	// !!!c						listTag := "<DD>";						end;					end;				if pos				then text := TrimString(SubStr(text, pos+1, nil));				if StrFilled(text) and text[0] = $< and pos := CharPos(text, $>, 1)		// !!!c				then begin					url := SubStr(text,1,pos-1);					text :=						if pos+1 < StrLen(text)						then TrimString(SubStr(text,pos+1,nil))						else url;					text := "<A HREF=\"" & url & "\">" & text & "</A>";					end;				noteStr:append(indent & listTag & text & unicodeCR, 0,nil); // !!!c				end;		noteStr:append(Stringer(endings), 0,nil); // !!!c		end	else if isArray(target.data)	// !!!e	then foreach entry in target.data		 do call kAppendPara with (noteStr, entry);	// !!!c. regular note	noteStr:append(kEndDoc,0,nil);	// !!!c	noteStr:save(title, target.labels, true);	// same folderend);if kBuild20 thenDefineGlobalConstant('kNotesGetHighlightedText, func(target)	// !!!i. borrowed from NC. used only by kNotesBookmarkScriptif HiliteOwner() and GetHiliteOffsets()	and (target = GetVariable(HiliteOwner(), 'target) or		// Notes		 target = GetVariable(HiliteOwner(), 'parentTarget))	// Inboxthen begin	local ARRAY offset;	local start, str, sep, txt, stop;	foreach offset in GetHiliteOffsets()	do begin		if (start := offset[1]) and 			(IsString(txt := offset[0].text) or IsString(txt := offset[0].realData.text))	// !!!k		then str := str & sep & TrimString(Substr(txt, start, if stop := offset[2] then stop-start));		sep := unicodeCR;	// if multiple selections		end;	str;	end);if kBuild20 thenDefineGlobalConstant('kAddBookmark, func(ARRAY bookmarks, text)	// !!!iif StrFilled(TrimString(text))then if BeginsWith(text, kHTTP)	then AddArraySlot(bookmarks, {name: text, URL: text})	else begin		local pos, url;		if text[0] = $< and (pos := CharPos(text, $>, 1))			and (not BeginsWith(url := SubStr(text,1,pos-1), "URL:") or StrMunger(url,0,4,nil,0,nil))			and BeginsWith(url, kHTTP)		then AddArraySlot(bookmarks, {			name: if pos+1 < StrLen(text)				then TrimString(SubStr(text,pos+1,nil))				else url,				URL: url});		// newtscape:?addBookmark(text,url);		end);if kBuild20 thenDefineGlobalConstant('kNotesBookmarkTitle, func(target)	// !!!bif kBuild20 and target and GetRoot().(kNewtsCapeSym)	and (HiliteOwner() or target.class='list or target.class='checkList) 	// !!!ithen kAddBookmarks);// add label info?if kBuild20 thenDefineGlobalConstant('kNotesBookmarkScript, func(target, targetView) 	// !!!bbegin	local topic, text;	//newtscape:init(nil);	// !!!i,d.	newtscape:open();	local ARRAY bookmarks := [];	if StrFilled(topic := call kNotesGetHighlightedText with (target))	// !!!i	then begin		local fn := StrTokenize(topic, unicodeCR);		while text := call fn with ()		do call kAddBookmark with (bookmarks, text);		end	else if target.class='list or target.class='checkList	// !!!i	then foreach topic in target.topics		 do if IsString(text := topic.text) and not IsRichString(text)			then call kAddBookmark with (bookmarks, Clone(text));	// !!!i	GetRoot().(kNewtsCapeSym):?addBookmark(bookmarks,nil); // !!!iend);DefineGlobalConstant('kNotesExportItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kNotesExportTitle,icon:				if kBuild20 then ROM_routeAddSender, //ROM_routeForward,	// !!!dtag:				kAppSymbol,routeScript:		kNotesExportScript,});if kBuild20 then RemoveSlot(kNotesExportItem, 'tag);if kBuild20 thenDefineGlobalConstant('kNotesBookmarkItem, { // !!!bGetTitle: 			kNotesBookmarkTitle,icon:				ROM_bookmarkBitmap,//tag:				kAppSymbol,routeScript:		kNotesBookmarkScript,});DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chainHTMListItems: if kBuild20			// override for kInboxProtoItem		then [kNotesExportItem, kNotesBookmarkItem]		else [kNotesExportItem],GetRouteScripts: if kBuild20 then func(targetInfo)	begin		local routes := Clone(HTMListItems), oldRoutes; // !!!d,b		if oldRoutes := inherited:?GetRouteScripts(targetInfo)		then routes  := SetUnion(routes, oldRoutes, true);		SetUnion(routes, routeScripts, true);	end,});if kBuild20 thenDefineGlobalConstant('kInboxGetTitle, func(target)	// !!!iif target and GetRoot().(kNewtsCapeSym) and HiliteOwner()then kAddBookmarks);if kBuild20 thenDefineGlobalConstant('kInboxBookmarkItem, { // !!!i. for routeScript array (GetRouteScripts)GetTitle: 			kInboxGetTitle,icon:				ROM_bookmarkBitmap,//tag:				kAppSymbol,routeScript:		kNotesBookmarkScript,});if kBuild20 thenDefineGlobalConstant('kInboxProtoItem, { //  !!!i. for Inbox _proto chainHTMListItems:		[kInboxBookmarkItem],GetRouteScripts:	kNotesProtoItem.GetRouteScripts,	// share});// ----------DefineGlobalConstant('kFixedFont, 	{family: 'Courier, face: kFaceNormal, size: 10, });DefineGlobalConstant('kDefaultFont, {family: 'espy,    face: kFaceNormal, size: 10, });DefineGlobalConstant('kMargin32,	SetBounds(32, 32, 32, 32));constant kRejectChars := "\u2206\u"; // graphic indicatorif kBuild20 then DefineGlobalConstant('kNewtWorksObj, {	_proto: protoTxView,	viewBounds: SetBounds(0,0,0,0),	viewFlags: 0,	ReorientToScreen: ROM_DefRotateFunc,	viewSetupFormScript: func()	begin		inherited:?viewSetupFormScript();		:SetGeometry(nil, 0, 0, kMargin32); // how to wrap long lines?		:SetStore(GetDefaultStore());	end,	new: func(str) // !!!e	begin		local dest := BuildContext(self);		dest:Open();		if str		then dest:append(str,0,nil);		dest;	end,	append: func(obj, INT start, count)	// !!!e,d	begin		local INT dlen := :GetCountCharacters(), i, slen, tlen, slast;		local txt, newObj, oldStyles, styles, justify;		newObj :=			if IsString(obj)	// text w/ default font (e.g., HTML source)			then {				text: if start > 0 or count then SubStr(obj,start,count) else obj,				styles: [if count then count else StrLen(obj), kFixedFont]				}			else if isFrame(obj) and IsString(txt := obj.data)	// book text object			then begin				if start > 0 or count				then txt := SubStr(txt, start, count); 	// just part on this page				tlen := StrLen(txt);				if oldStyles := obj.styles				then begin // check since some books might be wrong!					slen := 0;/*					for i:=0 to (slast := Length(oldStyles)-2) by 2 // add run lengths					do slen := slen + oldStyles[i];					if (i := slen-tlen) <> 0					then beginPrint("styles off by:" && pos);						styles := Clone(oldStyles);						if (styles[slast] := oldStyles[slast] - i) < 0						then return Print("really off!");						end;*/					styles := [];					for i:=0 to Length(oldStyles)-1 by 2					do  if tlen <= 0						then break // none left						else if start < (slen := slen+oldStyles[i])						then begin							AddArraySlot(styles, count := min(tlen, slen-start));							AddArraySlot(styles, oldStyles[i+1]);							tlen := tlen - count;							start := slen;							end;					end				else styles := [tlen, if obj.viewFont then obj.viewFont else kDefaultFont];				{text: txt,				styles: styles,				};				end			else if isFrame(obj) or isBinary(obj) // graphic (bitmap, PICT)			then {				class: 'graphics,				shape: MakeShape(obj),				};	if newObj	then begin		:Replace({first: dlen, last: dlen}, newObj, nil);		if tlen and IsInteger(justify := obj.viewJustify) and justify <= 3	// left,right,center,full		then :ChangeRangeRulers({first: dlen, last: dlen+tlen}, {justification: if justify < 3 then Intern(kAlign[justify]) else 'full}, true);		end;	end,	save: func(title, labels, show)	begin		gc();	// !!!i.		local saveData := :Externalize();			ClearVBOCache(saveData);	// !!!i		local summary := SubstituteChars(	// !!!h			StringFilter(				:GetRangeData({first: 0, last: min(:GetCountCharacters(), 80)}, 'text), // !!!g				kRejectChars, 'rejectAll),			cr, " ");		:Close(); 		local app := GetRoot().(kNewtworksSym);		local entry := app:AdoptEntryFromStationery({	// add the data to Works			title: title,			labels: labels,			saveData: saveData,			hiliteRange: {first: 0, last: 0},			margins: kMargin32,			summary: summary,	// !!!g			},			'paper,			GetDefaultStore());		if show		then begin	// !!!e			app:open();			// DANGER undocumented! open to this doc and titlebox			try app:showFoundItem(entry, {findWords: [""]}) // {setStatus: kNilFunc1})			onexception |evt.ex.outofmem| do begin app:close(); Rethrow(); end			onexception |evt.ex| do nil;			AddDelayedSend(app, '_titleKeyScript, '[nil], 100);			end;	end,});if kBuild20 thenDefineGlobalConstant('kNewtWorksExportFunc, func(viewDefView, newtAppBase)	// newtAppBase is unusedbegin	//range := viewDefView:GetHiliteRange();	// just do entire doc	local INT last := viewDefView:GetCountCharacters();	local entry := viewDefView.realData, pos := 0, epos, title := entry.title;	if not title	then title := kUntitled;	local filename := call kMakeFileName with (title);	local nwStr := kBigStringObj:new(call kStartDoc with ({title: title, ISBN: filename}, kISBNField));	while pos	do begin		epos := viewDefView:FindString(kEndPara, pos, nil);		if epos and epos > last		then epos := nil;		call kAppendPara with (nwStr, viewDefView:GetRangeData({first: pos, last: if epos then epos else last}, 'all));		pos := if epos then epos + StrLen(kEndPara);		end;	nwStr:append(kEndDoc,0,nil);	nwStr := nwStr:save(nil,nil,nil);	local textView := kNewtWorksObj:new(nwStr);		// !!!e	textView:save(filename, entry.labels, nil);	// same folderend);if kBuild20 thenDefineGlobalConstant('kNewtWorksBookmarkFunc, func(viewDefView, newtAppBase)	// !!!ibegin	local range := viewDefView:GetHiliteRange(), text;	local str := StringFilter(					viewDefView:GetRangeData({first: range.first, last: range.last}, 'text),					kRejectChars, 'rejectAll);	if StrFilled(str)	then begin		local ARRAY bookmarks := [];		local fn := StrTokenize(str, unicodeCR);		while text := call fn with ()		do call kAddBookmark with (bookmarks, text);		GetRoot().(kNewtsCapeSym):?addBookmark(bookmarks,nil);		end;end);constant kNewtWorksExportTag	:= '|HTMList:Export|;constant kNewtWorksBookmarkTag	:= '|HTMList:Bookmark|;if kBuild20 thenDefineGlobalConstant('kNewtWorksExportItem,	{dataTypeSymbol: 'paper,			// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)item: 			kExportHTML,	// REQUIRED: appears in popup in tool picker.cmdFunc:		kNewtWorksExportFunc,});if kBuild20 thenDefineGlobalConstant('kNewtWorksBookmarkItem,	{dataTypeSymbol: 'paper,item: 			kAddBookmarks,cmdFunc:		kNewtWorksBookmarkFunc,});// -------DefineGlobalConstant('kGetAppPrefs, func(sym, default)			// !!!jif kBuild20then GetAppPrefs(sym,default)else begin	local sysSoup := GetStores()[0]:GetSoup(ROM_systemsoupname);	local entry := Query(sysSoup, {type: 'index, indexPath: 'tag, startKey: kPackageName}):entry();	if entry and StrEqual(entry.tag, kPackageName)	then entry	else sysSoup:Add(Clone(default));	end);DefineGlobalConstant('kGetPageRangeFunc, func(target, targetView, obj, allFr)		// !!!jbegin//Print("kGetPageRangeFunc: "); xtargetView := targetView;	if obj = '_range	then obj := call kGetAppPrefs with (kAppSymbol, kDefaultPrefs).range;	// get/resolve pref value	// otherwise, '_curMax ?	local curPage, maxPage := targetView:countPages();	if obj = '_all	then return if allFr then {fromPage: 1, toPage: maxPage};	if kBuild20 and isFrame(obj)	then return {fromPage: obj.fromPage, toPage: min(obj.toPage, maxPage)};	// _current, _curMax(kBookPageRangeFunc)	if kBuild20		and (target.help or			(target.bookTarget and target.bookTarget.help and target := target.bookTarget))	then begin		curPage := LSearch(			target.(kPagePath),			targetView.contentArea:childViewFrames()[0].item,	// kludge: 1st item on visible page (e.g., heading)			0,			'|=|,			'[pathExpr: blocks,0,item]		// works for empty arrays!			);		curPage :=			if curPage			then curPage+1			else 1;		end	else curPage := targetView:currentPage();	{fromPage: curPage,	toPage: if obj = '_curMax then maxPage else curPage,	};end);// ----------if kBuild20 thenDefineGlobalConstant('kMungeContentScript, func(content) // !!!d. see Newt's Capeif IsEntryAlias(content.data)then begin	content := Clone(content);	content.data := ResolveEntryAlias(content.data).data;	if IsEntryAlias(content.hrefs)	then content.hrefs := ResolveEntryAlias(content.hrefs).data;	content;	endelse content);if kBuild20 thenDefineGlobalConstant('kBookNWExportDoc, func(target, targetView, destClass)	// !!!j,dbegin // save book as formatted NewtWorks doc	local curBook := targetView:?GetBook(target);	//GetRoot().(kBookReaderSym)	if not curBook	then return;	// use a txView to properly create the SaveData info	local dest := destClass:new(nil), obj, val;	local range := call kGetPageRangeFunc with (target, targetView, '_range, nil);	// !!!j. nil if _all	if range	then dest:append("pages:" && range.fromPage & $- & range.toPage & unicodeCR, 0,nil)	else foreach obj in kMetaFields		do  if val := curBook.(Intern(obj))			then dest:append(obj & $: && val & unicodeCR, 0,nil);		//dest:append(cr,0,nil);	local items, pages, dlen, block;	local INT itemNum := -1, itemLen := 0, pageNum, pageLast, doff := 0; 	if range 	then begin 		pages := curBook.(kPagePath); 		pageNum := range.fromPage-1;	// for init 		pageLast := range.toPage; 		end	else begin		items := curBook.(kContentsPath);		itemLen := Length(items);		end;	loop begin		itemNum := itemNum+1;		block := obj := nil;		if range		then begin			if itemNum >= itemLen			then if (pageNum := pageNum+1) > pageLast	// next page				then break				else begin				 	items := pages[pageNum-1].blocks;				 	itemLen := Length(items);				 	itemNum := 0;				 	end;			if itemNum < itemLen			then begin				block := items[itemNum];				obj   := block.item;				end;			end		else if itemNum >= itemLen	// "all" (done)		then break		else obj := items[itemNum];		if obj		then begin			obj := call kMungeContentScript with (obj); // resolve any aliases			doff := if block and block.dataOffset then block.dataOffset else 0;			dlen := if block and block.dataLen then block.dataLen;			if obj.type <> 'form	// text and graphics only			then begin					dest:append(if IsString(obj.data) then obj else obj.data, doff,dlen);				dest:append(cr,0,nil);		// some spacing between paras				end;			end;		end;	dest:save(Clone(curBook.title), nil, nil);end);DefineGlobalConstant('kDesktopObj, {new: func(str)begin	if str	then :append(str,0,nil);	self;end,append: func(str,start,count)begin	str :=		if start > 0 or count		then SubStr(str,start,count)		else Clone(str);	// if readonly	local app, ep, root := GetRoot();	if  ((app  := root.(kNewtsCapeSym)) and ep := app.commEndPt) or		((app  := root.(kSloupSym)) 	and ep := app.commEndPt)	then begin					// via Newt's Cape/Sloup		StrReplace(str,cr,crlf,nil);		ep:Output(str,nil);		end		else Write(str);			// Inspectorend,// save: func(title,labels, show)});DefineGlobalConstant('kBookExportHTML, func(target, targetView, destClass, textOnly)	// !!!jbegin	// save book as HTML to Newtworks/Desktop (shared by kBookNWExportFunc, kBookDesktopExportFunc)	local curBook, obj;	if kBuild20	then curBook := targetView:?GetBook(target)	//GetRoot().(kBookReaderSym)	else if target and (obj := GetRoot().(kBookReaderSym):WhereIsBook(target.isbn)) and obj and obj.bookSoup	then curBook := obj.bookSoup.book;	if not curBook	then return;	local dest := destClass:new(nil);	// !!!e	local range := call kGetPageRangeFunc with (target, targetView, '_range, nil);	// !!!j nil if _all	if textOnly	then dest:append(textOnly & unicodeCR, 0, nil)	else begin		if range		then dest:append("<!--pages:" && range.fromPage & $- & range.toPage & "-->\n", 0,nil);		dest:append(call kStartDoc with (curBook, kMetaFields), 0,nil);		// !!!e		end;	local block, data, level, justify, attrib, btag, styles; //, hrefs, name; 	local INT doff, dlen, slen, i, count, itemNum := -1, itemLen := 0, pageLast, pageNum; 	local items, toc, pages; 	if range 	then begin 		pages := curBook.(kPagePath); 		pageNum := range.fromPage-1;	// for init 		pageLast := range.toPage; 		end	else begin		toc := curBook.(kTOCPath);		items := curBook.(kContentsPath);		itemLen := Length(items);		end;	loop begin		itemNum := itemNum+1;		block := obj := level := nil;		if range		then begin			if itemNum >= itemLen			then if (pageNum := pageNum+1) > pageLast	// next page				then break				else begin				 	items := pages[pageNum-1].blocks;				 	itemLen := Length(items);				 	itemNum := 0;				 	end;			if itemNum < itemLen			then begin				block := items[itemNum];				level := block.level;				obj   := block.item;				end;			end		else if itemNum >= itemLen	// "all" (done)		then break		else begin // next item (in contents)			obj := items[itemNum];			if kBuild20			then block := LFetch(toc, obj, 0, '|=|, 'item)			else foreach data in toc	// 1.x				 do if data.item = obj					then break block := data;			if block			then begin				level := block.level;				if not level				then level := 1;				end;			end;		if not obj then break;		//hrefs := obj.hrefs;		//name := obj.name;		if kBuild20		then obj := call kMungeContentScript with (obj); // resolve any aliases		data := obj.data;		 		if (if kBuild20 then IsString(data) else isInstance(data, 'string)) // text only.  obj.type <> 'form		then begin				doff := if block and block.dataOffset then block.dataOffset else 0;			dlen := if block and block.dataLen then block.dataLen else StrLen(data);  			if textOnly 			then begin 				dest:append(data,doff,dlen); 				dest:append(cr,0,nil); 				end 			else begin				btag := if level then $H & level else $P;				attrib :=					if (justify := obj.viewJustify) and justify > 0	// since left is default					then "ALIGN=\"" & kAlign[justify] & "\"";				if styles := obj.styles				then begin					dest:append(call kMakeTag with (btag, nil, attrib), 0,nil);					slen := 0;					for i := 0 to Length(styles)-1 by 2					do  if dlen <= 0						then break // none left						else if doff < (slen := slen+styles[i])						then begin							count := min(dlen, slen-doff);							dest:append(call kTagFunc with (styles[i+1], data, doff, count, nil,nil), 0,nil);							dlen := dlen - count;							doff := slen;							end;       				dest:append((if level then call kMakeTag with (btag, $/, nil)) & unicodeCR, 0,nil);					end				else dest:append(					if level	// heading (1 font; assume bold)					then call kTagFunc with (obj.viewFont,data,doff,dlen, btag,attrib) & unicodeCR					else call kMakeTag with (btag, nil, attrib) &						call kTagFunc with (obj.viewFont,data,doff,dlen, nil,nil) & unicodeCR,					0,nil					);				end;			end;  		end;	if not textOnly	then dest:append(kEndDoc, 0,nil);	dest:?save(Clone(curBook.title), nil, nil);	end);if kBuild20 thenDefineGlobalConstant('kRangeRadio, {	_proto: protoRadioCluster,	viewBounds: RelBounds(145,5,80,60),	// 2-input fields (0,0,120,64)	prefsEntry: nil,	viewSetupFormScript: func()	begin		prefsEntry := GetAppPrefs(kAppSymbol, kDefaultPrefs);		local range := prefsEntry.range;		clusterValue :=			if range = '_all			then '_all			else if isFrame(range)			then '_range			else '_current;		:ClusterChanged();	// update fromField,toField		inherited:?viewSetupFormScript();		end,	ClusterChanged: func()	begin		local fromPage := 1, toPage := fields.body.nPages, range; // '_all (or no range yet)		if clusterValue = '_current		then fromPage := toPage := fields.body.curPage		else if clusterValue = '_range and isFrame(range := prefsEntry.range)		then begin			fromPage := range.fromPage;			toPage := range.toPage;			end;//Print("ClusterChanged:"  && clusterValue && fromPage && toPage);		// save only in quit		SetValue(fromField.entryLine, 'text, SPrintObject(fromPage));		SetValue(toField.entryLine,   'text, SPrintObject(toPage));	end,	viewQuitScript: func()	begin		local toPage;		prefsEntry.range :=			if clusterValue = '_range			then {				fromPage: fields.body.fromPage,				toPage: if (toPage := fields.body.toPage) then toPage else fields.toPage, // set at init(max), but not changed?				}			else clusterValue;//Write("viewQuitScript: "); Print(prefsEntry.range);		EntryFlushXmit(prefsEntry,nil);		inherited:?viewQuitScript();	end,	stepChildren: [stepChildren:		{_proto: protoRadioButton,		viewBounds: RelBounds(0,10,80,14),		text: "Current Page",		buttonValue: '_current,		},		{_proto: protoRadioButton,		viewBounds: RelBounds(0,30,80,14),		text: "All Pages",		buttonValue: '_all,		},		{_proto: protoRadioButton,		viewBounds: RelBounds(0,50,80,14),		text: "Page Range",		buttonValue: '_range,		},		],});if kBuild20 thenDefineGlobalConstant('kRangeTitle, {	_proto: protoStaticText,	viewBounds: RelBounds(0,-14,150, 12),	text: kHTMList && "Preference",	viewJustify: vjParentCenterH+vjParentBottomV + vjCenterH+vjCenterV,});if kBuild1x thenDefineGlobalConstant('kBookGetPagesPickFunc, func(INT i)	// !!!j,ebegin	prefsEntry.range := myItems[i].value;	EntryChange(prefsEntry);end);DefineGlobalConstant('kBookPageRangeFunc, func(target, targetView)	// !!!jif kBuild20then begin	local range := call kGetPageRangeFunc with (target, targetView, '_curMax, nil);	local protoRange := GetViewDefs(kBookReaderSym).bookScreenFormat.auxForm, rangeFields := Clone(protoRange.viewChildren);	rangeFields[1] := {_proto: rangeFields[1], preallocatedContext: 'fromField};	rangeFields[2] := {_proto: rangeFields[2], preallocatedContext: 'toField};	BuildContext({		_proto: protoRange,		viewBounds: RelBounds(0,120,230,95),	// +90 width, +15 height. 0,120,140,80		allocateContext: [			'fromField, rangeFields[1],			'toField, 	rangeFields[2],			],		viewChildren: ArrayMunger(						rangeFields, Length(rangeFields), 0,						[kRangeRadio, kRangeTitle], 0, nil),		fields: 	{			body: {				curPage:	range.fromPage,				nPages: 	range.toPage,				//fromPage: fromPage,	// ignored on init anyway (always set to 1)				//toPage:				// toField changed?						},			//toPage:					// toField initially?			},		}):open();	endelse begin	local prefsEntry := call kGetAppPrefs with (kAppSymbol, kDefaultPrefs);	local ARRAY items := [		{item: "All Pages", 	value: '_all},		{item: "Current Page", 	value: '_current}		];	items[if prefsEntry.range = '_all then 0 else 1].mark := kCheckMarkChar;		DoPopup(items, 220, 300, {		//_proto: self,		pickActionScript: kBookGetPagesPickFunc,		myItems: items,		prefsEntry: prefsEntry,		});	end);if kBuild20 thenDefineGlobalConstant('kBookNWExportDocFunc, func(target, targetView)	// save formatted book to NewtWorks	call kBookNWExportDoc with (target, targetView, kNewtWorksObj)	//call kBookGetPagesFunc with (target, kNewtWorksObj, kBookNWExportDoc));if kBuild20 thenDefineGlobalConstant('kBookNWExportFunc, func(target, targetView)	// save book as HTML to NewtWorks	call kBookExportHTML with (target, targetView, kNewtWorksObj, nil)	//call kBookGetPagesFunc with (target, kNewtWorksObj, kBookExportHTML));DefineGlobalConstant('kBookNotesExportFunc, func(target, targetView)	// save book as HTML to Notes	call kBookExportHTML with (target, targetView, kNotesObj, nil)	//call kBookGetPagesFunc with (target, kNotesObj, kBookExportHTML));DefineGlobalConstant('kBookDesktopExportFunc, func(target, targetView)	// save book as HTML to Desktop	call kBookExportHTML with (target, targetView, kDesktopObj, nil)	//call kBookGetPagesFunc with (target, kDesktopObj, kBookExportHTML));if kBuild20 thenDefineGlobalConstant('kBookNWExportDocItem, { // !!!d for routeScript array (GetRouteScripts)GetTitle:	func(target)	if target then "Save to NewtWorks",icon:				@717,	//GetDataDefs('paper).icon,//tag:				kAppSymbol,routeScript:		kBookNWExportDocFunc,});if kBuild20 thenDefineGlobalConstant('kBookNWExportItem, { 	// !!!dGetTitle:	func(target)	if target then kExportHTML && "to NewtWorks",icon:				ROM_routeAddSender, //ROM_routeForward, ROM_pasteText//tag:				kAppSymbol,routeScript:		kBookNWExportFunc,});constant kBookNotesExportTag 	:= '|HTMList:Notes|;constant kBookDesktopExportTag 	:= '|HTMList:Desktop|;constant kBookPageRangeTag		:= '|HTMList:PageRange|;DefineGlobalConstant('kBookNotesExportItem, {	// !!!gGetTitle:	func(target)	if target then kExportHTML && "to Notes",//icon: if kBuild20 then GetRoot().Connection.stepChildren[0].titleIcon,tag:				kBookNotesExportTag,	// !!!jrouteScript:		kBookNotesExportFunc,});if kBuild20 then RemoveSlot(kBookNotesExportItem, 'tag);DefineGlobalConstant('kBookDesktopExportItem, {	// !!!dGetTitle:	func(target)	if target then kExportHTML && "to Desktop",//icon: if kBuild20 then GetRoot().Connection.stepChildren[0].titleIcon,tag:				kBookDesktopExportTag,		// !!!jrouteScript:		kBookDesktopExportFunc,});if kBuild20 then RemoveSlot(kBookDesktopExportItem, 'tag);DefineGlobalConstant('kBookPageRangeItem, {	// !!!jGetTitle:	func(target)	if target	then begin		local range := call kGetAppPrefs with (kAppSymbol, kDefaultPrefs).range;		//local rangeFr := call kGetPageRangeFunc with (target, targetView, '_range, true); // unk: targetView		kPageRange & $: &&			if range = '_all			then "All"			else if kBuild20 and isFrame(range)			then range.fromPage & $- & range.toPage			else "Current"			/*if range = '_all			then "All(" & rangeFr.toPage & $)			else if kBuild20 and isFrame(range)		// rangeFr may have different toPage			then rangeFr.fromPage & $- & rangeFr.toPage			else "Current(" & rangeFr.fromPage & $)*/		end,//icon: if kBuild20 then GetRoot().Connection.stepChildren[0].titleIcon,tag:				kBookPageRangeTag,routeScript:		kBookPageRangeFunc,});if kBuild20 then RemoveSlot(kBookPageRangeItem, 'tag);DefineGlobalConstant('kBookProtoItem, {	// !!!dGetBook: if kBuild20 thenfunc(target)if targetthen begin	local bookTarget;	if target.contents and target.rendering	// !!!j	then target	else if (bookTarget := target.bookTarget) and bookTarget.contents and bookTarget.rendering	then bookTarget	else begin	//Write("GetBook: "); Print(xtarget := target);		local libook, isbn := if target.isbn then target.isbn else bookTarget.isbn;	// regular/help		if isbn and (libook := :WhereIsBook(isbn)) and libook and libook.bookSoup		then libook.bookSoup.book;		end;	end,HTMListItems:	if kBuild20	then [kBookPageRangeItem, kBookNWExportDocItem, kBookNWExportItem, kBookNotesExportItem, kBookDesktopExportItem] // !!!j	else [kBookPageRangeItem, kBookNotesExportItem, kBookDesktopExportItem],	// !!!jGetRouteScripts: if kBuild20 thenfunc(targetInfo)begin	constant kItemNote := 3;	constant kItemDesk := 4;	local oldRoutes, routes, root := GetRoot();	local itemNote := Clone(HTMListItems[kItemNote]);			//kBookNotesExportItem. !!!j,g	local itemDesk := Clone(HTMListItems[kItemDesk]);			//kBookDesktopExportItem. !!!j,g	itemNote.icon := ROM_routeAddSender;	itemDesk.icon := root.Connection.stepChildren[0].titleIcon;	if root.(kNewtWorksSym)	then begin		routes := Clone(HTMListItems);		routes[kItemNote] := itemNote;		routes[kItemDesk] := itemDesk;		//routes[0] := item := Clone(routes[0]);	// kBookNWExportDocItem		//item.icon := GetDataDefs('paper).icon;		end	else routes := [HTMListItems[0], itemNote, itemDesk];	// omit NW items	if oldRoutes := inherited:?GetRouteScripts(targetInfo)	then routes  := SetUnion(routes, oldRoutes, true);	if oldRoutes := GetVariable(self, 'routeScripts)	then SetUnion(routes, oldRoutes, true)	else routes;end,toggleRoute: nil,	// !!!jgetTargetInfo: if kBuild20 then func(targetType)	// !!!jbegin	local fr := inherited:getTargetInfo(targetType);	if targetType = 'routing and not (self.(EnsureInternal('toggleRoute)) := not toggleRoute)	then fr.target := {class: kNCDataDefSym, bookTarget: fr.target};	fr;end,});DefineGlobalConstant('kHelpProtoItem, {	// !!!jGetBook: kBookProtoItem.GetBook,HTMListItems: kBookProtoItem.HTMListItems,GetRouteScripts: kBookProtoItem.GetRouteScripts,getTargetInfo: func(targetType)	// Print,Fax don't workbegin	local fr := GetRoot():getTargetInfo(targetType); //inherited doesn't work in help!	if targetType = 'routing and Visible(_defaultButton)	// topicsButton 2.0?	then begin		fr.target := {class: kNCDataDefSym, bookTarget: bookRef};		fr.targetView := self:parent();		end;	fr;end,	viewChildren: [viewChildren:	// or add via viewSetupChildrenScript? wrong position for 2.0	{_proto: protoActionButton,	viewBounds: RelBounds(-43,-18, 17,13),	viewJustify: vjParentRightH + vjParentBottomV + vjCenterH + vjCenterV, //166	}],});if kBuild20 thenDefineGlobalConstant ('kBookRouteFormat, {	// !!!j_proto: protoFrameFormat,dataTypes: '[text],name: "Book(Newt's Cape) Text Format",symbol: kNCViewDefSym,TextScript: func(item, target)begin	local body := item.body;	if isFrame(body) and isString(body.text)	then body.text	else if isString(body)	then body	else item.text;end,SetupItem: func(item, targetInfo)begin	// set up the routing item if necessary	inherited:?SetupItem(item, targetInfo);	local bookTarget := item.body.bookTarget;	local range := GetAppPrefs(kAppSymbol, kDefaultPrefs).range;	local targetView := targetInfo.targetView;//Write("SetupItem: "); Print(xtargetInfo := targetInfo);	local rangeFr := call kGetPageRangeFunc with (bookTarget, targetView, range, nil);	item.title :=			bookTarget.title &&		// see kBookPageRangeItem			if range = '_all			then "by" && bookTarget.author			else if isFrame(range)			then "(pages:" && rangeFr.fromPage & $- & rangeFr.toPage & $)			else "(page" && rangeFr.fromPage & $);//Print(item.title);	item.text := item.body := call kBookExportHTML with (bookTarget, targetView, kBigStringObj, item.title);//Print(item.text);	item.appSymbol := kNotesSym;	item;end,});// ----------DefineGlobalConstant ('kAddPatchFunc, func(target, template, gsym)	// !!!dif targetthen if kBuild20then begin	// init the patch	target:close();	// !!!j	local patch := EnsureInternal({}), sym, val;	// copy all of the patched slots (including tag)	foreach sym, val in template	do patch.(EnsureInternal(sym)) :=		if sym = 'viewChildren	// e.g., kHelpProtoItem		then ArrayMunger(Clone(target.(sym)), Length(target.(sym)), 0, val,0,nil)		else val;	patch.(EnsureInternal('tag)) := EnsureInternal(kAppSymbol);	// link into the target's proto chain	patch.(EnsureInternal('_proto)) := target._proto;	target._proto := patch; // returns patch	endelse begin	local rf := EnsureInternal(		{GetTitle: nil, tag: template.tag, routeScript: template.tag});	// !!!j	local rs, grouting := GetGlobals().Routing;	if isFrame(rs := grouting.(gsym))	then begin		rf.GetTitle := template.GetTitle;		target.(rf.routeScript) := template.routeScript;		if isReadonly(rs)		then rs := grouting.(gsym) := Clone(rs);		rs.(rf.tag) := rf;		end;	end);DefineGlobalConstant('kRemovePatchFunc, func(target, tagSym, gsym)	// !!!dif targetthen if kBuild20then begin	target:close();	// !!!j	local nextProto;	while nextProto := target._proto	do  if nextProto.tag = kAppSymbol		then break target._proto := nextProto._proto		else target := nextProto;	endelse begin	local rs;	if isFrame(rs := GetGlobals().Routing.(gsym))	then begin		RemoveSlot(rs, tagSym);		RemoveSlot(target, tagSym);		end;	end);partData := {	AddPatch: 		kAddPatchFunc,	NotesPatchItem:	kNotesProtoItem,	BookPatchItem:  kBookProtoItem,						// !!!d	InboxPatchItem: if kBuild20 then kInboxProtoItem,	// !!!i	nwTools: 		[ // for DeferRegNewtWorksTools		// !!!j				kNewtWorksExportTag,	kNewtWorksExportItem,				kNewtWorksBookmarkTag,	kNewtWorksBookmarkItem,				],	DeferRegNewtWorksTools: if kBuild20 then func(ARRAY symitem)	// !!!j		begin			local i, newtWorks := GetRoot().(kNewtWorksSym);			if newtWorks			then for i:=0 to Length(symitem)-1 by 2				 do newtWorks:?RegNewtWorksTool(EnsureInternal(symitem[i]), symitem[i+1]);		end,	HelpPatchItem:	if kBuild20 then kHelpProtoItem,	// !!!j	routeFormat:	if kBuild20 then kBookRouteFormat,	// !!!j	};/*export for Newt's Cape via protos:kNewtWorksObj, kBookGetPagesFunc, kBookNWExportDoc ?*/// =====// !!!e. code borrowed/modified from Newt's CapeDefineGlobalConstant('kDayMin, 24*60);DefineGlobalConstant('kRegExpDays, 45);						// number of days to expireDefineGlobalConstant('kRegExpMin, kRegExpDays * kDayMin);	// number of mins to expireDefineGlobalConstant('kRegExpSym, Intern($X & kNewtsCapeSym));// this is the app-specific ID for this "lock" DefineGlobalConstant('kRegExpired, func()	// nag=0begin	// return true if "expired"	local entry := GetAppPrefs(kRegExpSym, kDefaultPrefs), now, start;	not entry.version or									// no Newt's Cape public beta (yet)	(now := Time()) < (start := EntryModTime(entry)) or		// user set clock back?	now >= start + kRegExpMin;								// expiredend);if kExpiringVersionthen SetPartFrameSlot('DoNotInstall, kRegExpired);// =====InstallScript := func(partFrame, removeFrame) // !!!jbegin	local data := partFrame.partData, root := GetRoot(), notes := root.(kNotesSym), reader := root.(kBookReaderSym);	if kBuild20	then begin		data:AddPatch(notes,  data.NotesPatchItem,	kNotesSym);		data:AddPatch(reader, data.BookPatchItem,	kBookReaderSym);		reader.(EnsureInternal('toggleRoute)) := NIL;			// toplevel		data:AddPatch(root.(kInboxSym), data.InboxPatchItem,	kInboxSym);		if GlobalFnExists('PackRGB)	// !!!e. NOS 2.1?		then begin			data:AddPatch(root.(kHelpReaderSym), data.HelpPatchItem, kHelpReaderSym);			RegisterViewDef(data.routeFormat, EnsureInternal(kNCDataDefSym));			// defer in case NewtWorks installed later, e.g., on MP2K			AddDeferredSend(data, 'DeferRegNewtWorksTools, [data.nwTools]); // delay? assume NW internal?			end;		end	else begin		data:AddPatch(notes,  data.NotesPatchItem.HTMListItems[0],	kNotesSym);		data:AddPatch(reader, data.BookPatchItem.HTMListItems[0],	kBookReaderSym);		data:AddPatch(reader, data.BookPatchItem.HTMListItems[1],	kBookReaderSym);		data:AddPatch(reader, data.BookPatchItem.HTMListItems[2],	kBookReaderSym);		end;end;RemoveScript := func(removeFrame) // !!!jbegin	local root := GetRoot(), reader := root.(kBookReaderSym);	call kRemovePatchFunc with (root.(kNotesSym), kAppSymbol, kNotesSym);	if kBuild20	then begin		call kRemovePatchFunc with (reader,	nil, kBookReaderSym);		call kRemovePatchFunc with (root.(kInboxSym), nil, kInboxSym);		if GlobalFnExists('PackRGB)	// !!!e. NOS 2.1?		then begin			call kRemovePatchFunc with (root.(kHelpReaderSym), nil, kHelpReaderSym);			UnRegisterViewDef(kNCViewDefSym, kNCDataDefSym);			root.(kNewtWorksSym):?UnRegNewtWorksTool(kNewtWorksExportTag);			root.(kNewtWorksSym):?UnRegNewtWorksTool(kNewtWorksBookmarkTag);			end;		end	else begin		call kRemovePatchFunc with (reader, kBookNotesExportTag,	kBookReaderSym);		call kRemovePatchFunc with (reader, kBookDesktopExportTag,	kBookReaderSym);		call kRemovePatchFunc with (reader, kBookPageRangeTag,		kBookReaderSym);		end;end;